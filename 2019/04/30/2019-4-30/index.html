<!DOCTYPE html>
<html lang="z">
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>麻省理工 MapReduce 实验 | 米琴香光</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="RSS">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="麻省理工 MapReduce 实验 | 米琴香光">
    <meta name="twitter:description" content="RSS">

    <meta property="og:type" content="article">
    <meta property="og:title" content="麻省理工 MapReduce 实验 | 米琴香光">
    <meta property="og:description" content="RSS">

    
    <meta name="author" content="Jiang-Tao He">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/icon.jpg">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="米琴香光" href="/atom.xml">
    

    <link rel="canonical" href="https://hejtao.netlify.com/2019/04/30/2019-4-30/"/><!-- hexo-inject:begin --><!-- hexo-inject:end -->

              
</head>

<body class="home-template no-js">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>
    <header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/"><img src="/images/avatar.jpg" width="80" alt="米琴香光 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="返回封面">米琴香光</a></h1>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">夫君子之行，静以修身，俭以养德。非淡泊无以明志，非宁静无以致远。夫学须静也，才须学也，非学无以广才，非志无以成学。淫慢则不能励精，险躁则不能治性。年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及！</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" class="blog-button">笔记</a></li>
            
              <li class="navigation__item"><a href="/archives">归档</a></li>
            
              <li class="navigation__item"><a href="/videos">视频</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="https://weibo.com/hjt1993" title="我的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li>


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/jiangtaohe" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  <li class="navigation__item">
    <a href="https://facebook.com/chiangtaoho" title="上Facebook找我" target="_blank">
      <i class='social fa fa-facebook'></i>
      <span class="label">Facebook</span>
    </a>
  </li>


<!-- Twitter -->



  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class='social fa fa-rss'></i>
      <span class="label">RSS</span>
    </a>
  </li>



  <li class="navigation__item">
    <a href="mailto:hejtao@outlook.com" title="邮件联系我" target="_blank">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>


  </ul>
</nav>

          </div>
          <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=250 height=86 src="//music.163.com/outchain/player?type=2&id=27538415&auto=0&height=66"></iframe>
        </div>
    </div>
    </div>
    <div class="panel-cover--overlay cover-blue"></div>
  </div>
</header>


    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2019-04-29T16:00:00.000Z" class="post-list__meta--date date">2019-04-30</time> &#8226; <span class="post-meta__tags tags"> 
  <a class="tag-link" href="/tags/Golang/">Golang</a>, <a class="tag-link" href="/tags/MapReduce/">MapReduce</a>
 </span>
    

    </div>
    <h1 class="post-title">麻省理工 MapReduce 实验</h1>
  </header>

  <section class="post">
    <p><meta name="referrer" content="no-referrer"></p>
<div class="toc">

<!-- toc -->
<ul>
<li><a href="#mapreduce-zhi-xing-gai-shu">MapReduce执行概述</a></li>
<li><a href="#xu-yan-shou-xi-yuan-dai-ma">序言：熟悉源代码</a></li>
<li><a href="#part-i-map-reduce-shu-ru-he-shu-chu">Part I: Map/Reduce 输入和输出</a></li>
<li><a href="#part-ii-single-worker-dan-ci-tong-ji">Part II: Single-worker单词统计</a></li>
<li><a href="#part-iii-fen-bu-shi-mapreduce-ren-wu">Part III: 分布式 MapReduce 任务</a></li>
<li><a href="#part-iv-worker-cuo-wu-chu-li">Part IV: worker错误处理</a></li>
</ul>
<!-- tocstop -->
</div>

<p><a href="http://nil.csail.mit.edu/6.824/2018/labs/lab-1.html" target="_blank" rel="noopener">原文链接</a></p>
<h3><span id="mapreduce-zhi-xing-gai-shu">MapReduce执行概述</span><a href="#mapreduce-zhi-xing-gai-shu" class="header-anchor">#</a></h3><p><a href="http://nil.csail.mit.edu/6.824/2018/papers/mapreduce.pdf" target="_blank" rel="noopener">论文地址</a><br><img src="https://upload-images.jianshu.io/upload_images/1863961-e3049b9f4645a329.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/840" alt=""></p>
<p>通过自动将输入数据划分为$M$个片段，Map调用分布在多台机器上。 不同片段的输入数据可以由不同的机器并行处理。 Reduce调用的分布式则通过使用分区函数(即 $hash(key)$  $mod$  $R$)将键空间划分为$R$个部分来实现，$R$的大小和分区函数由用户指定。上图显示了MapReduce操作的总体流程。 当用户程序调用MapReduce函数时，会发生以下操作序列(图中的编号标签对应于下面的数字)：</p>
<ol>
<li>用户程序中的MapReduce库首先将输入文件拆分为16MB到64MB(用户可通过参数设置)的$M$个片段。 然后，它会在一组计算机上启动该程序的许多副本；</li>
<li>master为副本之一，其余的是由master分配工作的workers。 有$M$个Map任务和$R$个Reduce任务需要分配。master为每个空闲的worker分配一个Map任务或Reduce任务；</li>
<li>被分配Map任务的worker读取相应输入片段。 它从输入片段中解析键/值对，并将键/值对传递给用户定义的Map函数。 Map函数生成的中间键/值对缓存在内存中；</li>
<li>内存中的键\值对被周期性地写入到本地磁盘，并通过分区函数划分为$R$个分区。 键\值对在本地磁盘的位置将被传回到master，master再将位置信息转发给Reduce worker；</li>
<li>当Reduce worker收到来自master的位置信息后，它使用远程过程调用(RPC)从Map worker的本地磁盘读取缓冲数据。 当Reduce worker读取了所有中间数据时，它会根据中间键进行排序，以便将所有相同的中间键组合在一起。 之所以需要排序是因为通常有许多不同的键映射到同一个reduce任务。 如果中间数据量太大而无法容纳在内存中，则使用外部排序；</li>
<li>Reduce worker对排好序的中间数据进行遍历。对遇到的每个唯一中间键，它将键和相应的一组中间值传递给用户的Reduce函数。 Reduce函数的输出附加到此Reduce分区的最终输出文件。</li>
<li>完成所有Map任务和Reduce任务后，master会唤醒用户程序。 此时，用户程序中的MapReduce()将返回用户代码。</li>
</ol>
<h3><span id="xu-yan-shou-xi-yuan-dai-ma">序言：熟悉源代码</span><a href="#xu-yan-shou-xi-yuan-dai-ma" class="header-anchor">#</a></h3><p>提供的Map/Reduce代码支持两种操作模式，即串行和分布式。 在前者中，map和reduce任务每次执行一个：首先是第一个map任务执行完成，然后是第二个，然后是第三个，等等。当所有map任务完成后，执行第一个reduce任务，然后是第二个，等等。这种模式虽然不快，但方便调试。 分布式模式运行着许多worker线程，这些线程先并行执行map任务，然后reduce任务。 这要快得多，但也难以调试。mapreduce包提供了一个简单的Map/Reduce库。 应用程序通常调用<code>master.go</code>中的<code>Distributed()</code>来启动分布式模式，而调用<code>master.go</code>中的<code>Sequential()</code>来获取调试的串行执行。</p>
<p>代码如下执行：</p>
<ol>
<li>该应用程序提供了许多输入文件、一个<strong>map函数</strong>、一个<strong>reduce函数</strong>和<strong>reduce任务的数量</strong>（$nReduce$）；</li>
<li>创建master。 master启动一个RPC服务器(参见<code>master_rpc.go</code>)，并等待worker注册(使用RPC调用<code>Register()</code>，在<code>master.go</code>中定义)。 当任务变得可用时(在步骤4和5中)，<code>schedule()</code>(位于schedule.go)决定如何将这些任务分配给workers以及如何处理worker故障；</li>
<li>master将每个输入文件视为一个  Map任务，并为每个Map任务至少调用一次(at-least-once)<code>doMap()</code>(<code>common_map.go</code>)，可以通过直接使用<code>Sequential()</code>或通过向worker (<code>worker.go</code>)发出DoTask RPC来实现。每次调用<code>doMap()</code>都会读取适当的文件，调用该文件中的map函数，并将生成的键/值对写入$nReduce$个中间文件。doMap() 对每个键哈希化以便挑选中间文件和 将会处理键的reduce任务。 完成所有map任务后，将会有$nMap \times nReduce$个文件。 每个文件名都包含一个前缀，map任务编号和reduce任务编号。 如果有两个map任务和三个reduce任务，map任务将创建如下六个中间文件：<br><code>mrtmp.xxx-0-0</code><br><code>mrtmp.xxx-0-1</code><br><code>mrtmp.xxx-0-2</code><br><code>mrtmp.xxx-1-0</code><br><code>mrtmp.xxx-1-1</code><br><code>mrtmp.xxx-1-2</code><br>每个worker必须能够读取由任何其他worker写入的文件以及输入文件。 现实部署利用分布式存储系统(如GFS)来允许此读取，即使workers在不同的计算机上运行。 在本实验中，您将在同一台计算机上运行所有workers，并使用本地文件系统；</li>
<li>接下来master为每个reduce任务至少调用一次(at-least-once) <code>doReduce()</code>(<code>common_reduce.go</code>)。 与<code>doMap()</code>一样，可以直接或通过worker来完成。 用于reduce任务r的`doReduce()从每个map任务中收集第$r$个中间文件，并为这些文件中出现的每个键调用reduce函数。 reduce任务生成$nReduce$个结果文件；</li>
<li>master调用<code>mr.merge()</code>(<code>master_splitmerge.go</code>)，将上一步生成的所有$nReduce$个文件合并为单个输出；</li>
<li>master向每个woker发送Shutdown RPC，然后关闭自己的RPC服务器。<blockquote>
<p>说明：在后续的练习中，您必须编写/修改<code>doMap()</code>，<code>doReduce()</code>和<code>schedule()</code>，它们分别位于<code>common_map.go</code>、<code>common_reduce.go</code>和<code>schedule.go</code>中。 您还必须在<code>../main/wc.go</code>中编写map函数和reduce函数。</p>
</blockquote>
</li>
</ol>
<h3><span id="part-i-map-reduce-shu-ru-he-shu-chu">Part I: Map/Reduce 输入和输出</span><a href="#part-i-map-reduce-shu-ru-he-shu-chu" class="header-anchor">#</a></h3><p>提供的Map/Reduce实现缺少部分代码。 在编写第一个Map/Reduce函数对之前，您需要修改sequential的实现代码。 特别是，提供的代码缺少两个关键部分：分配一个map任务输出的函数，以及收集一个reduce任务所有输入的函数。 这些任务分别由<code>common_map.go</code>中的<code>doMap()</code>函数和<code>common_reduce.go</code>中的<code>doReduce()</code>函数执行。 </p>
<p>为了帮助您确定是否正确实现了<code>doMap()</code>和<code>doReduce()</code>，我们为您提供了一个Go测试套件(<code>test_test.go</code>)用于检查文件中实现。 例如测试修改后的sequence实现代码，请运行：<br><code>go test -run Sequential</code><br>or<br><code>go test -v -run Sequential</code></p>
<p><strong>解答：</strong><br>该部分任务只需要补全<code>common_map.go</code>中的<code>doMap()</code>和<code>common_reduce.go</code>中的<code>doReduce()</code>的代码，补全的结果如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mapreduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"hash/fnv"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doMap</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">	jobName <span class="keyword">string</span>, // the name of the MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">	mapTask <span class="keyword">int</span>, // which <span class="keyword">map</span> task this is</span></span></span><br><span class="line"><span class="function"><span class="params">	inFile <span class="keyword">string</span>,</span></span></span><br><span class="line">	nReduce int, // the number of reduce task that will be run ("R" in the paper)</span><br><span class="line">	mapF <span class="function"><span class="keyword">func</span>(<span class="params">filename <span class="keyword">string</span>, content <span class="keyword">string</span></span>) []<span class="title">KeyValue</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// doMap manages one map task: it should read one of the input files</span></span><br><span class="line">	<span class="comment">// (inFile), call the user-defined map function (mapF) for that file's</span></span><br><span class="line">	<span class="comment">// content, and partition mapF's output into nReduce intermediate files.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// There is one intermediate file per reduce task. The file name</span></span><br><span class="line">	<span class="comment">// includes both the map task number and the reduce task number. Use</span></span><br><span class="line">	<span class="comment">// the filename generated by reduceName(jobName, mapTask, r)</span></span><br><span class="line">	<span class="comment">// as the intermediate file for reduce task r. Call ihash() (see</span></span><br><span class="line">	<span class="comment">// below) on each key, mod nReduce, to pick r for a key/value pair.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// mapF() is the map function provided by the application. The first</span></span><br><span class="line">	<span class="comment">// argument should be the input file name, though the map function</span></span><br><span class="line">	<span class="comment">// typically ignores it. The second argument should be the entire</span></span><br><span class="line">	<span class="comment">// input file content. mapF() returns a slice containing the</span></span><br><span class="line">	<span class="comment">// key/value pairs for reduce; see common.go for the definition of</span></span><br><span class="line">	<span class="comment">// KeyValue.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Look at Go's ioutil and os packages for functions to read</span></span><br><span class="line">	<span class="comment">// and write files.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Coming up with a scheme for how to format the key/value pairs on</span></span><br><span class="line">	<span class="comment">// disk can be tricky, especially when taking into account that both</span></span><br><span class="line">	<span class="comment">// keys and values could contain newlines, quotes, and any other</span></span><br><span class="line">	<span class="comment">// character you can think of.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// One format often used for serializing data to a byte stream that the</span></span><br><span class="line">	<span class="comment">// other end can correctly reconstruct is JSON. You are not required to</span></span><br><span class="line">	<span class="comment">// use JSON, but as the output of the reduce tasks *must* be JSON,</span></span><br><span class="line">	<span class="comment">// familiarizing yourself with it here may prove useful. You can write</span></span><br><span class="line">	<span class="comment">// out a data structure as a JSON string to a file using the commented</span></span><br><span class="line">	<span class="comment">// code below. The corresponding decoding functions can be found in</span></span><br><span class="line">	<span class="comment">// common_reduce.go.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//   enc := json.NewEncoder(file)</span></span><br><span class="line">	<span class="comment">//   for _, kv := ... &#123;</span></span><br><span class="line">	<span class="comment">//     err := enc.Encode(&amp;kv)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Remember to close the file after you have written all the values!</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here (Part I).</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取输入文件</span></span><br><span class="line">	content, err := ioutil.ReadFile(inFile)  </span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">"doMap读取输入文件错误"</span>,err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//map操作</span></span><br><span class="line">	kvPairs := mapF(inFile, <span class="keyword">string</span>(content))  <span class="comment">//调用mapF，返回键值对</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//将键值对写入到中间文件</span></span><br><span class="line">	tmpFiles := <span class="built_in">make</span>([] *os.File, nReduce)  <span class="comment">//R个中间文件</span></span><br><span class="line">	encoders := <span class="built_in">make</span>([] *json.Encoder, nReduce)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nReduce; i++ &#123;</span><br><span class="line">		tmpFileName := reduceName(jobName, mapTask, i)  <span class="comment">//中间文件名,mrtmp.test-mapTask-i</span></span><br><span class="line"></span><br><span class="line">		tmpFiles[i], err = os.Create(tmpFileName)  <span class="comment">//创建中间文件mrtmp.test-mapTask-i</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">"doMap生成中间文件错误"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">defer</span> tmpFiles[i].Close()</span><br><span class="line"></span><br><span class="line">		encoders[i] = json.NewEncoder(tmpFiles[i])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">"doMap编码错误"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _ , kv := <span class="keyword">range</span> kvPairs &#123;</span><br><span class="line">		hashKey := ihash(kv.Key) % nReduce  <span class="comment">//根据键将键值对分成R组</span></span><br><span class="line"></span><br><span class="line">		err := encoders[hashKey].Encode(&amp;kv)  <span class="comment">//将R个键值对写入R个中间文件</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">"doMap编码错误"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ihash</span>(<span class="params">s <span class="keyword">string</span></span>) <span class="title">int</span></span> &#123;</span><br><span class="line">	h := fnv.New32a()</span><br><span class="line">	h.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">int</span>(h.Sum32() &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mapreduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doReduce</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">	jobName <span class="keyword">string</span>, // the name of the whole MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">	reduceTask <span class="keyword">int</span>, // which reduce task this is</span></span></span><br><span class="line"><span class="function"><span class="params">	outFile <span class="keyword">string</span>, // write the output here</span></span></span><br><span class="line">	nMap int, // the number of map tasks that were run ("M" in the paper)</span><br><span class="line">	reduceF <span class="function"><span class="keyword">func</span>(<span class="params">key <span class="keyword">string</span>, values []<span class="keyword">string</span></span>) <span class="title">string</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// doReduce manages one reduce task: it should read the intermediate</span></span><br><span class="line">	<span class="comment">// files for the task, sort the intermediate key/value pairs by key,</span></span><br><span class="line">	<span class="comment">// call the user-defined reduce function (reduceF) for each key, and</span></span><br><span class="line">	<span class="comment">// write reduceF's output to disk.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// You'll need to read one intermediate file from each map task;</span></span><br><span class="line">	<span class="comment">// reduceName(jobName, m, reduceTask) yields the file</span></span><br><span class="line">	<span class="comment">// name from map task m.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your doMap() encoded the key/value pairs in the intermediate</span></span><br><span class="line">	<span class="comment">// files, so you will need to decode them. If you used JSON, you can</span></span><br><span class="line">	<span class="comment">// read and decode by creating a decoder and repeatedly calling</span></span><br><span class="line">	<span class="comment">// .Decode(&amp;kv) on it until it returns an error.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// You may find the first example in the golang sort package</span></span><br><span class="line">	<span class="comment">// documentation useful.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// reduceF() is the application's reduce function. You should</span></span><br><span class="line">	<span class="comment">// call it once per distinct key, with a slice of all the values</span></span><br><span class="line">	<span class="comment">// for that key. reduceF() returns the reduced value for that key.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// You should write the reduce output as JSON encoded KeyValue</span></span><br><span class="line">	<span class="comment">// objects to the file named outFile. We require you to use JSON</span></span><br><span class="line">	<span class="comment">// because that is what the merger than combines the output</span></span><br><span class="line">	<span class="comment">// from all the reduce tasks expects. There is nothing special about</span></span><br><span class="line">	<span class="comment">// JSON -- it is just the marshalling format we chose to use. Your</span></span><br><span class="line">	<span class="comment">// output code will look something like this:</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// enc := json.NewEncoder(file)</span></span><br><span class="line">	<span class="comment">// for key := ... &#123;</span></span><br><span class="line">	<span class="comment">// 	enc.Encode(KeyValue&#123;key, reduceF(...)&#125;)</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">// file.Close()</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here (Part I).</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历属于自己的中间文件，将键值对合并到kvs中</span></span><br><span class="line">	kvs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nMap; i++ &#123;</span><br><span class="line">		fileName := reduceName(jobName, i, reduceTask)</span><br><span class="line"></span><br><span class="line">		file, err := os.Open(fileName)  <span class="comment">//打开中间文件mrtmp.test-i-reduceTask</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">"doReduce打开文件错误"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		dec := json.NewDecoder(file)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> &#123;  <span class="comment">//每个中间文件可能包含多个键值对</span></span><br><span class="line">			<span class="keyword">var</span> kv KeyValue</span><br><span class="line">			err = dec.Decode(&amp;kv)  <span class="comment">//解码一个键值对</span></span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			_, ok := kvs[kv.Key]</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;  <span class="comment">//出现新的键则初始化kvs</span></span><br><span class="line">				kvs[kv.Key] = []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			kvs[kv.Key] = <span class="built_in">append</span>(kvs[kv.Key], kv.Value)  <span class="comment">//加入与键对应的值</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		file.Close()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将键集合到一起并排序</span></span><br><span class="line">	<span class="keyword">var</span> keys []<span class="keyword">string</span>  </span><br><span class="line">	<span class="keyword">for</span> k := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">		keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Strings(keys)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建输出文件</span></span><br><span class="line">	out := mergeName(jobName, reduceTask)  </span><br><span class="line">	file, err := os.Create(out)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">"doReduce创建输出文件错误"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	enc := json.NewEncoder(file)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//reduce操作</span></span><br><span class="line">	<span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">		res := reduceF(k, kvs[k])  <span class="comment">//调用客户端的reduceF，进行reduce</span></span><br><span class="line">		enc.Encode(KeyValue&#123;k, res&#125;)  <span class="comment">//reduce后的键值对写入到输出文件</span></span><br><span class="line">	&#125;</span><br><span class="line">	file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>go test -run Sequential</code>，结果如下：<br>&nbsp;<br><img src="https://upload-images.jianshu.io/upload_images/1863961-b5960850942d11a2.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p>
<h3><span id="part-ii-single-worker-dan-ci-tong-ji">Part II: Single-worker单词统计</span><a href="#part-ii-single-worker-dan-ci-tong-ji" class="header-anchor">#</a></h3><p>在该部分，您将要实现一个简单的Map/Reduce示例——单词统计。 具体是需要实现<code>main/wc.go</code>中的<code>mapF()</code>和<code>reduceF()</code>函数。 您的工作是插入代码，以便<code>wc.go</code>返回输入文件中每个单词出现的次数。 一个单词是任意连续的字母序列，其中字母可用Golang的<a href="https://golang.org/pkg/unicode/#IsLetter" target="_blank" rel="noopener">unicode.IsLetter</a>函数来判断。</p>
<p>在<code>~/6.824/src/main</code>目录中提供了一些路径名为<code>pg-*.txt</code>形式的输入文件， 可用如下命令给<code>wc.go</code>使用输入文件运行：<br><code>go run wc.go master sequential pg-*.txt</code></p>
<p>查看MapReduce论文的第2部分。<code>mapF()</code>和<code>reduceF()</code>函数与论文第2.1节中的函数略有不同。<code>mapF()</code>将接收一个文件名和该文件的内容，并将内容分成单词最终输出一个<code>mapreduce.KeyValue</code>型切片。 对于单词统计可将单词作为键。对输出中的每个键都将调用一次<code>reduceF()</code>，其中包含<code>mapF()</code>为该键生成的所有值的切片。 <code>reduceF()</code>返回一个包含键出现总数的字符串。</p>
<blockquote>
<p>提示1：关于Go的字符串处理，可以参读 <a href="http://blog.golang.org/strings" target="_blank" rel="noopener">Go Blog on strings</a><br>提示2：可以使用<a href="https://golang.org/pkg/strings/#FieldsFunc" target="_blank" rel="noopener">strings.FieldsFunc</a>函数将字符串拆分成单词<br>提示3： 利用Go的<a href="https://golang.org/pkg/strconv/" target="_blank" rel="noopener">strconv</a>包可以很方便地将字符串转换成整型</p>
</blockquote>
<p>使用如下命令来验证答案：<br><code>go run wc.go master sequential pg-*.txt</code></p>
<p><strong>答案：</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"mapreduce"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">	<span class="string">"unicode"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The map function is called once for each file of input. The first</span></span><br><span class="line"><span class="comment">// argument is the name of the input file, and the second is the</span></span><br><span class="line"><span class="comment">// file's complete contents. You should ignore the input file name,</span></span><br><span class="line"><span class="comment">// and look only at the contents argument. The return value is a slice</span></span><br><span class="line"><span class="comment">// of key/value pairs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span>(<span class="params">filename <span class="keyword">string</span>, contents <span class="keyword">string</span></span>) []<span class="title">mapreduce</span>.<span class="title">KeyValue</span></span> &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part II).</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> res []mapreduce.KeyValue</span><br><span class="line"></span><br><span class="line">	f := <span class="function"><span class="keyword">func</span>(<span class="params">c <span class="keyword">rune</span></span>) <span class="title">bool</span></span> &#123; <span class="comment">//不是字母</span></span><br><span class="line">		<span class="keyword">return</span> !unicode.IsLetter(c)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	words := strings.FieldsFunc(contents, f) <span class="comment">//在不是字母地方拆分字符串contents</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, key := <span class="keyword">range</span> words &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, mapreduce.KeyValue&#123;key, <span class="string">"1"</span>&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The reduce function is called once for each key generated by the</span></span><br><span class="line"><span class="comment">// map tasks, with a list of all the values created for that key by</span></span><br><span class="line"><span class="comment">// any map task.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span>(<span class="params">key <span class="keyword">string</span>, values []<span class="keyword">string</span></span>) <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="comment">// Your code here (Part II).</span></span><br><span class="line"></span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line">		num, _ := strconv.ParseInt(value, <span class="number">10</span>, <span class="number">64</span>) <span class="comment">// 将字符串value（例如："157"）按照十进制转换成整型</span></span><br><span class="line">		count = count + <span class="keyword">int</span>(num)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strconv.Itoa(count) <span class="comment">//整型转换成字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Can be run in 3 ways:</span></span><br><span class="line"><span class="comment">// 1) Sequential (e.g., go run wc.go master sequential x1.txt .. xN.txt)</span></span><br><span class="line"><span class="comment">// 2) Master (e.g., go run wc.go master localhost:7777 x1.txt .. xN.txt)</span></span><br><span class="line"><span class="comment">// 3) Worker (e.g., go run wc.go worker localhost:7777 localhost:7778 &amp;)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &lt; <span class="number">4</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%s: see usage comments in file\n"</span>, os.Args[<span class="number">0</span>])</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> os.Args[<span class="number">1</span>] == <span class="string">"master"</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> mr *mapreduce.Master</span><br><span class="line">		<span class="keyword">if</span> os.Args[<span class="number">2</span>] == <span class="string">"sequential"</span> &#123;</span><br><span class="line">			mr = mapreduce.Sequential(<span class="string">"wcseq"</span>, os.Args[<span class="number">3</span>:], <span class="number">3</span>, mapF, reduceF)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			mr = mapreduce.Distributed(<span class="string">"wcseq"</span>, os.Args[<span class="number">3</span>:], <span class="number">3</span>, os.Args[<span class="number">2</span>])</span><br><span class="line">		&#125;</span><br><span class="line">		mr.Wait()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mapreduce.RunWorker(os.Args[<span class="number">2</span>], os.Args[<span class="number">3</span>], mapF, reduceF, <span class="number">100</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行<code>go run wc.go master sequential pg-sherlock_holmes.txt</code>和<code>sort -n -k2 mrtmp.wcseq | tail -10</code>的结果：<br>&nbsp;<br><img src="https://upload-images.jianshu.io/upload_images/1863961-2d925a0b957652b7.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p>
<h3><span id="part-iii-fen-bu-shi-mapreduce-ren-wu">Part III: 分布式 MapReduce 任务</span><a href="#part-iii-fen-bu-shi-mapreduce-ren-wu" class="header-anchor">#</a></h3><p>在当前的实现中，是通过串行的方式来执行Map任务和Reduce任务。 Map/Reduce最大的卖点之一是它可以自动地并行执行原始的串行代码而无需开发人员的任何额外工作。 在这一部分中，您将完成一个分布式MapReduce版本，即将工作拆分为在多核上运行的一组worker线程。 尽管不像真实的Map/Reduce部署被分布在多台机器上那样，但你本部分的实现中将使用RPC来模拟分布式计算。</p>
<p><code>mapreduce/master.go</code>中的代码完成了管理MapReduce的大部分工作。 我们还为您提供了<code>mapreduce/worker.go</code>中worker线程的完整代码以及在<code>mapreduce/common_rpc.go</code>中处理RPC的一些代码。</p>
<p><strong>你的任务是实现<code>mapreduce/schedule.go</code>中的<code>schedule()</code>函数</strong>。 master在MapReduce期间将两次调用<code>schedule()</code>，一次用于Map阶段，一次用于Reduce阶段。 <code>schedule()</code>的功能是将任务分发给可用的worker。 任务的数量通常比worker线程多，因此<code>schedule()</code>必须为每个worker分配一系列任务，一次一个。 <code>schedule()</code>应该等到所有任务都完成后再返回。</p>
<p><code>schedule()</code>通过读取<code>registerChan</code>参数来了解一组worker。 该channel为每个worker生成一个包含worker的RPC地址的字符串。所有的worker都会出现在registerChan，其中一些worker可能在调用<code>schedule()</code>之前就存在，而另一些worker可能在<code>schedule()</code>运行时才启动。<code>schedule()</code>应该充分利用所有的worker，包括启动后出现的worker。</p>
<p><code>schedule()</code>通过向worker发送<code>Worker.DoTask</code>RPC来通知worker执行任务。 此RPC的参数由<code>mapreduce/common_rpc.go</code>中的<code>DoTaskArgs</code>定义。<code>File</code>元素仅由Map任务使用，代表要读取的文件的名称；<code>schedule()</code>可以在<code>mapFiles</code>中找到这些文件名。</p>
<p>使用<code>mapreduce/common_rpc.go</code>中的<code>call()</code>函数将RPC发送给worker。 第一个参数是worker的地址，从<code>registerChan</code>读取，第二个参数是<code>Worker.DoTask</code>， 第三个参数是<code>DoTaskArgs</code>结构，最后一个参数是<code>nil</code>。</p>
<p>您对在第III部分的解答仅涉及对<code>schedule.go</code>的修改；如果您在调试过程中修改了其他文件，请恢复其原始内容。请先测试再提交。</p>
<p>使用<code>go test -run TestParallel</code>来测试您的答案。 该命令将执行两个测试，<code>TestParallelBasic</code>和<code>TestParallelCheck</code>，后者验证您的<code>schedule()</code>是否使worker并行执行任务。</p>
<blockquote>
<p>提示1：<code>schedule()</code>应该并行地向worker发送RPC，以便worker可以并发执行任务。 你会发现go语句对此很有用，参见<a href="http://golang.org/doc/effective_go.html#concurrency" target="_blank" rel="noopener">Concurrency in Go</a>。<br>提示2：<code>schedule()</code>必须等待worker完成一个任务后才能给它另下一个任务，Go的channel对此很有用。<br>提示3： <a href="https://golang.org/pkg/sync/#WaitGroup" target="_blank" rel="noopener">sync.WaitGroup</a><br>提示4：追踪错误的最简单的方法是插入print语句（在common.go中可能是调用<code>debug()</code>），使用<code>go test -run TestParallel &gt; out</code>将输出收集到一个文件中，然后分析输出是否与你对代码的预期相符。 最后一步是最重要的。<br>提示5：检查您的代码是否有竞争的情况可在测试中运行<a href="https://golang.org/doc/articles/race_detector.html" target="_blank" rel="noopener">race detector</a>。</p>
<p>注意：我们提供的代码是在单个UNIX进程中将worker作为线程运行，并且可以在单台机器上使用多核。 要想在使用网络进行通信的多台机器上运行worker必须进行一些修改：RPC必须使用TCP而不是UNIX-domain套接字；需要有一种方法来启动所有机器上的worker进程；所有的机器都必须通过某种网络文件系统共享存储。</p>
</blockquote>
<p><strong>答案</strong>见Part IV。</p>
<h3><span id="part-iv-worker-cuo-wu-chu-li">Part IV: worker错误处理</span><a href="#part-iv-worker-cuo-wu-chu-li" class="header-anchor">#</a></h3><p>在这部分中，您将实现master处理失败的worker的功能。由于worker的状态不是持久的，该功能在MapReduce中相对容易实现。 如果worker在处理来自master的RPC时发生错误，master的<code>call()</code>最终会因超时而返回<code>false</code>。在这种情况下，master会将该任务重新分配给另一个worker。</p>
<p>RPC故障并不一定意味着worker没有执行任务；worker可能已执行任务但是返回结果丢失，或者worker可能仍在执行但master的RPC超时。因此，可能会发生两个worker接收相同任务、计算并产生输出的情况。 需要对map或reduce函数进行两次调用才能为给定输入生成相同的输出，因此如果后续处理读取一个输出或者读取另一个输出，则不会出现不一致。 此外，MapReduce框架确保map和reduce函数输出以原子方式出现：输出文件要么不存在，要么包含单个map或单个reduce函数执行的整个输出（提供的代码不涉及这部分）。</p>
<p>您的实现必须通过<code>test_test.go</code>中剩下的两个测试用例。 第一个用例测试一个worker的失败，而第二个测试用例测试对多个worker的失败的处理。 测试用例会定期启动新的worker，master可以使用这些worker来推进程序过程，但这些worker在处理完一些任务后会失败。 使用下面的命令来运行测试：<br><code>go test -run Failure</code></p>
<p>在第IV部分，只涉及对<code>schedule.go</code>的修改。 如果您在调试过程中修改了其他文件，请恢复其原始内容，然后再进行测试、提交。</p>
<p>Part III、Part IV<strong>答案：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mapreduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// schedule() starts and waits for all tasks in the given phase (mapPhase</span></span><br><span class="line"><span class="comment">// or reducePhase). the mapFiles argument holds the names of the files that</span></span><br><span class="line"><span class="comment">// are the inputs to the map phase, one per map task. nReduce is the</span></span><br><span class="line"><span class="comment">// number of reduce tasks. the registerChan argument yields a stream</span></span><br><span class="line"><span class="comment">// of registered workers; each item is the worker's RPC address,</span></span><br><span class="line"><span class="comment">// suitable for passing to call(). registerChan will yield all</span></span><br><span class="line"><span class="comment">// existing registered workers (if any) and new ones as they register.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span>(<span class="params">jobName <span class="keyword">string</span>, mapFiles []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>, phase jobPhase, registerChan <span class="keyword">chan</span> <span class="keyword">string</span></span>)</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ntasks <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> n_other <span class="keyword">int</span> <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line">	<span class="keyword">switch</span> phase &#123;</span><br><span class="line">	<span class="keyword">case</span> mapPhase:</span><br><span class="line">		ntasks = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">		n_other = nReduce</span><br><span class="line">	<span class="keyword">case</span> reducePhase:</span><br><span class="line">		ntasks = nReduce</span><br><span class="line">		n_other = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"Schedule: %v %v tasks (%d I/Os)\n"</span>, ntasks, phase, n_other)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// All ntasks tasks have to be scheduled on workers. Once all tasks</span></span><br><span class="line">	<span class="comment">// have completed successfully, schedule() should return.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here (Part III, Part IV).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ntasks; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params">num <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">			args := DoTaskArgs&#123;jobName, mapFiles[num], phase, num, n_other&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">var</span> worker <span class="keyword">string</span></span><br><span class="line">			reply := <span class="built_in">new</span>(<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">			ok := <span class="literal">false</span></span><br><span class="line">			<span class="keyword">for</span> ok != <span class="literal">true</span> &#123;</span><br><span class="line">				worker = &lt;-registerChan</span><br><span class="line">				ok = call(worker, <span class="string">"Worker.DoTask"</span>, args, reply)</span><br><span class="line">			&#125;</span><br><span class="line">			done &lt;- <span class="literal">true</span>           <span class="comment">//任务完成</span></span><br><span class="line">			registerChan &lt;- worker <span class="comment">//该worker工作完毕，处于空闲，加入channel中以分配给其它任务</span></span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ntasks; i++ &#123; <span class="comment">//等待所有任务完成</span></span><br><span class="line">		&lt;-done</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"Schedule: %v done\n"</span>, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>go test -run TestParallel</code>的结果：<br>&nbsp;<br><img src="https://upload-images.jianshu.io/upload_images/1863961-da345dba91fc382f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p>

  </section>

</article>

<section class="read-more">
     

        
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h3 class="post-list__post-title post-title"><a href="/2019/09/05/2019-9-5/" title="SQL Notes">SQL Notes</a></h3>
                <p class="excerpt">
                
                




联表查询
字符替换
正则查询
导入SQL文件
排序




联表查询#12345678SELECT library.id, library.name, r.reader_sum, b.book_sum FROM library INNER JOIN( SELECT library_id, 
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2019-09-04T16:00:00.000Z" class="post-list__meta--date date">2019-09-05</time> &#8226; <span class="post-list__meta--tags tags">
  <a class="tag-link" href="/tags/SQL/">SQL</a>
</span><a class="btn-border-small" href="/2019/09/05/2019-9-5/">阅读全文</a></div>

            </div>
        

        
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h3 class="post-list__post-title post-title"><a href="/2019/03/25/2019-3-25/" title="远程过程调用和线程(RPC and Thread)">远程过程调用和线程(RPC and Thread)</a></h3>
                <p class="excerpt">
                
                

MIT Distributed System Course: Lecture 2Remote Procedure Call (RPC)
目标：建立编程友好的客户端/服务器通信
RPC消息图：   客户端 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 服务器    请求—-&amp;gt;      
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2019-03-24T16:00:00.000Z" class="post-list__meta--date date">2019-03-25</time> &#8226; <span class="post-list__meta--tags tags">
  <a class="tag-link" href="/tags/Golang/">Golang</a>, <a class="tag-link" href="/tags/RPC/">RPC</a>, <a class="tag-link" href="/tags/并发/">并发</a>
</span><a class="btn-border-small" href="/2019/03/25/2019-3-25/">阅读全文</a></div>

            </div>
        

   


</section>


  


            <footer class="footer">
    <span class="footer__copyright">
        2019 &copy; Jiang-Tao He - Powered by <a href="https://hexo.io">Hexo</a> with <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> theme originated from <a href="https://github.com/onevcat/vno" target="_blank">onevcat</a>. Hosted by Netlify.

    </span>
    <span class="footer__copyright">
            
         </span>


  
         <script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    }); 
    
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
 
</footer>


<div id="totop" style="position:fixed;bottom:150px;right:20px;cursor: pointer;">
<a title="返回顶部"><img src="/images/scrollup.png"/></a>
</div>
<script src="/js/totop.js"></script>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-119463453-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?cbff5c9c1c024f714d2c51527df12893";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":140,"height":280,"hOffset":-28,"vOffset":-63},"mobile":{"show":true,"motion":true},"log":false,"tagMode":false});</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end --></body>
</html>
