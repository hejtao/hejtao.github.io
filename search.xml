<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQLæ˜¯æ€Žæ ·è¿è¡Œçš„ï¼šä»Žæ ¹å„¿ä¸Šç†è§£ MySQL]]></title>
    <url>%2F2019%2F09%2F20%2F2019-9-20%2F</url>
    <content type="text"><![CDATA[é‡æ–°è®¤è¯†MySQL å®¢æˆ·ç«¯ + æœåŠ¡å™¨ å¯åŠ¨æœåŠ¡å™¨ç¨‹åº UNIX Windows å¯åŠ¨å®¢æˆ·ç«¯ç¨‹åº å®¢æˆ·ç«¯ä¸ŽæœåŠ¡å™¨çš„é€šä¿¡ TCP/IP å‘½åç®¡é“å’Œå…±äº«å†…å­˜ UNIXåŸŸå¥—æŽ¥å­—æ–‡ä»¶ æœåŠ¡å™¨å¤„ç†å®¢æˆ·ç«¯è¯·æ±‚ å­˜å‚¨å¼•æ“Ž å¯åŠ¨é€‰é¡¹å’Œç³»ç»Ÿå˜é‡ åœ¨å‘½ä»¤è¡Œä¸Šä½¿ç”¨é€‰é¡¹ é…ç½®æ–‡ä»¶ä¸­ä½¿ç”¨é€‰é¡¹ Windows UNIX ç³»ç»Ÿå˜é‡ æŸ¥çœ‹ç³»ç»Ÿå˜é‡ è®¾ç½®ç³»ç»Ÿå˜é‡ çŠ¶æ€å˜é‡ å­—ç¬¦é›†å’Œæ¯”è¾ƒè§„åˆ™ å­—ç¬¦é›†çš„è½¬æ¢ InnoDBè®°å½•å­˜ InnoDBé¡µ InnoDBè¡Œæ ¼å¼ Compactè¡Œæ ¼å¼ è¡Œæ•°æ®æº¢å‡º è¡Œæº¢å‡ºçš„ä¸´ç•Œç‚¹ InnoDBæ•°æ®é¡µ æ•°æ®é¡µç»“æž„ è®°å½•åœ¨é¡µä¸­çš„å­˜å‚¨ è®°å½•å¤´ä¿¡æ¯ Page Directory Page Header File Header File Trailer B+æ ‘ç´¢å¼• æ— ç´¢å¼•æŸ¥æ‰¾ åœ¨é¡µå†…æŸ¥æ‰¾ åœ¨å¤šé¡µä¸­æŸ¥æ‰¾ ç´¢å¼• ç›®å½•é¡¹ ç”¨é¡µå­˜æ”¾ç›®å½•é¡¹ èšç°‡ç´¢å¼• äºŒçº§ç´¢å¼• B+æ ‘ç´¢å¼•çš„ä½¿ç”¨ åˆç†ä½¿ç”¨ç´¢å¼• å…¨å€¼åŒ¹é… åŒ¹é…å·¦è¾¹çš„åˆ— åŒ¹é…åˆ—å‰ç¼€ å›žè¡¨çš„ä»£ä»· äºŒçº§ç´¢å¼• + å›žè¡¨ or å…¨è¡¨æ‰«ç  è¦†ç›–ç´¢å¼• åˆç†åœ°å»ºç«‹ç´¢å¼• MySQLçš„æ•°æ®ç›®å½• æ•°æ®åº“å’Œæ–‡ä»¶ç³»ç»Ÿçš„å…³ç³» æ•°æ®ç›®å½• æ•°æ®ç›®å½•å’Œå®‰è£…ç›®å½•çš„åŒºåˆ« æŸ¥æ‰¾æ•°æ®ç›®å½• æ•°æ®ç›®å½•çš„ç»“æž„ æ•°æ®åº“åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­çš„è¡¨ç¤º è¡¨åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­çš„è¡¨ç¤º æ–‡ä»¶ç³»ç»Ÿå¯¹æ•°æ®åº“çš„å½±å“ MySQLç³»ç»Ÿæ•°æ®åº“ç®€ä»‹ æœ¬æ–‡ä¸ºæ•äººçš„å­¦ä¹ è®°å½•ï¼Œæ„Ÿå…´è¶£çš„è¯·åœ¨æŽ˜é‡‘å°å†Œè´­ä¹°åŒååŽŸè‘— ðŸ˜Ž é‡æ–°è®¤è¯†MySQL# å®¢æˆ·ç«¯ + æœåŠ¡å™¨# MySQLæœåŠ¡å™¨è¿›ç¨‹(ä¹Ÿå«æ•°æ®åº“å®žä¾‹) MySQLå®¢æˆ·ç«¯è¿›ç¨‹ è¿›ç¨‹ï¼šè¿›ç¨‹å·(PIDï¼Œç”±æ“ä½œç³»ç»Ÿéšæœºåˆ†é…)ã€è¿›ç¨‹åç§° MySQLæœåŠ¡å™¨è¿›ç¨‹çš„é»˜è®¤åç§°ä¸ºmysqldï¼Œ MySQLå®¢æˆ·ç«¯è¿›ç¨‹çš„é»˜è®¤åç§°ä¸ºmysql å¯åŠ¨æœåŠ¡å™¨ç¨‹åº# UNIX# ä½¿ç”¨å®‰è£…ç›®å½•ä¸‹(æ¯”å¦‚ /usr/local/mysql/bin/): 1mysqld 1mysqld_safe mysqld_safeæ˜¯ä¸€ä¸ªå¯åŠ¨è„šæœ¬çš„å‘½ä»¤ï¼Œè°ƒç”¨äº†mysqldï¼Œå¹¶å¯åŠ¨ä¸€ä¸ªç›‘æŽ§è¿›ç¨‹(é‡å¯ï¼Œæ—¥å¿—) 12mysql.server startysql.server stop mysql.serveræ˜¯ä¸€ä¸ªé“¾æŽ¥æ–‡ä»¶ï¼Œ ä¼šè°ƒç”¨mysqld_safe Windows# ä½¿ç”¨å®‰è£…ç›®å½•ä¸‹(æ¯”å¦‚ D:\Program Files\mysql-5.7.26-winx64\bin\) mysqld.exe å¯æ‰§è¡Œæ–‡ä»¶ ä½¿ç”¨ WindowsæœåŠ¡ã€‚æŠŠæŸä¸ªç¨‹åºæ³¨å†Œä¸ºWindowsæœåŠ¡çš„æ ¼å¼ï¼š &quot;å¯æ‰§è¡Œæ–‡ä»¶è·¯å¾„&quot; --install [-manual] [æœåŠ¡åç§°] 123D:\Program Files\mysql-5.7.26-winx64\bin\mysqld --install [MySQL_Service]net start MySQL_Servicenet stop MySQL_Service å¯åŠ¨å®¢æˆ·ç«¯ç¨‹åº# mysql -hä¸»æœºå -uç”¨æˆ·å -på¯†ç  123mysql -hlocalhost -uroot -p123abcmysql -u root -pmysql --host=localhost --user=root --password=123abc é€€å‡ºå®¢æˆ·ç«¯ 123quitexit\q å®¢æˆ·ç«¯ä¸ŽæœåŠ¡å™¨çš„é€šä¿¡# æœ¬è´¨æ˜¯ä¸¤ä¸ªè¿›ç¨‹é—´çš„é€šä¿¡ TCP/IP# æ¯å°è®¡ç®—æœºéƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„IPåœ°å€ æ¯ä¸ªè¿›ç¨‹å‘æ“ä½œç³»ç»Ÿç”³è¯·ä¸€ä¸ªç«¯å£å·(0~65535) é€šè¿‡IPåœ°å€ + ç«¯å£å·æ¥ä¸ŽæŸä¸ªè¿›ç¨‹é€šä¿¡ MySQLæœåŠ¡å™¨è¿›ç¨‹çš„é»˜è®¤ç«¯å£å·ä¸º3306ï¼Œè‡ªå®šä¹‰MySQLæœåŠ¡å™¨è¿›ç¨‹çš„ç«¯å£å·å¦‚ä¸‹ 1mysqld -P3307 å‘½åç®¡é“å’Œå…±äº«å†…å­˜# Windowsç³»ç»Ÿä¸­çš„è¿›ç¨‹é—´é€šä¿¡æ–¹å¼ å‘½åç®¡é“ 12345mysqld --enable-named-pipemysql --pipeormysql --protocol=pipe å…±äº«å†…å­˜ 123mysqld --shared-memorymysql --protocol=memory UNIXåŸŸå¥—æŽ¥å­—æ–‡ä»¶# 1mysql --protocol=socket æœåŠ¡å™¨ç¨‹åºé»˜è®¤ç›‘å¬çš„å¥—æŽ¥å­—æ–‡ä»¶è·¯å¾„ä¸º/tmp/mysql.sockï¼ŒæŒ‡å®šå¥—æŽ¥å­—æ–‡ä»¶è·¯å¾„ï¼š 12mysqld --socket=/tmp/a.txtmysql -hlocalhost -uroot --socket=/tmp/a.txt -p æœåŠ¡å™¨å¤„ç†å®¢æˆ·ç«¯è¯·æ±‚# å­˜å‚¨å¼•æ“Ž# XAåˆ—ä»£è¡¨æ˜¯å¦æ”¯æŒåˆ†å¸ƒå¼äº‹åŠ¡ Savepointsä»£è¡¨æ˜¯å¦æ”¯æŒéƒ¨åˆ†äº‹åŠ¡å›žæ»š å¯åŠ¨é€‰é¡¹å’Œç³»ç»Ÿå˜é‡# åœ¨å‘½ä»¤è¡Œä¸Šä½¿ç”¨é€‰é¡¹# 12mysqld --skip-networkingmysqld --default-storage-engine=MyISAM \\ ç­‰å·ä¸¤è¾¹ä¸èƒ½æœ‰ç©ºæ ¼ ä½¿ç”¨mysql --helpå¯ä»¥çœ‹åˆ°mysqlç¨‹åºæ”¯æŒçš„å¯åŠ¨é€‰é¡¹ ä½¿ç”¨mysqld --verbose --helpæŸ¥çœ‹mysqldæ”¯æŒçš„å¯åŠ¨é€‰é¡¹ é…ç½®æ–‡ä»¶ä¸­ä½¿ç”¨é€‰é¡¹# Windows# 12345678910111213%WINDIR%\my.ini%WINDIR%\my.cnf C:\my.iniC:\my.cnfBASEDIR\my.ini \\ MySQLå®‰è£…è·¯å¾„BASEDIR\my.cnf defaults-extra-file å‘½ä»¤è¡ŒæŒ‡å®šçš„é¢å¤–é…ç½®æ–‡ä»¶è·¯å¾„ï¼Œå¦‚mysqld --defaults-extra-file=C:\Users\chiangtao ho\my_extra_file.txt%APPDATA%\MySQL\.mylogin.cnf ç™»å½•è·¯å¾„é€‰é¡¹ï¼ˆä»…é™å®¢æˆ·ç«¯ï¼‰ UNIX# 12345678910/etc/my.cnf /etc/mysql/my.cnf SYSCONFDIR/my.cnf $MYSQL_HOME/my.cnf ç‰¹å®šäºŽæœåŠ¡å™¨çš„é€‰é¡¹ï¼ˆä»…é™æœåŠ¡å™¨ï¼‰defaults-extra-file ~/.my.cnf ç”¨æˆ·ç‰¹å®šé€‰é¡¹~/.mylogin.cnf ç”¨æˆ·ç‰¹å®šçš„ç™»å½•è·¯å¾„é€‰é¡¹ï¼ˆä»…é™å®¢æˆ·ç«¯ï¼‰ ç³»ç»Ÿå˜é‡# æŸ¥çœ‹ç³»ç»Ÿå˜é‡# 12SHOW VARIABLES like 'max_connections';SHOW VARIABLES LIKE 'default%'; ç³»ç»Ÿå˜é‡çš„å•è¯ä¹‹é—´å¿…é¡»ä½¿ç”¨ä¸‹åˆ’çº¿_è¿žæŽ¥ è®¾ç½®ç³»ç»Ÿå˜é‡# å˜é‡çš„ä½œç”¨èŒƒå›´ GLOBALï¼šå…¨å±€å˜é‡ï¼Œå½±å“æœåŠ¡å™¨çš„æ•´ä½“æ“ä½œ SESSION (LOCAL)ï¼šä¼šè¯å˜é‡ï¼Œå½±å“æŸä¸ªå®¢æˆ·ç«¯è¿žæŽ¥çš„æ“ä½œ 123456SET GLOBAL default_storage_engine = MyISAM;SET @@GLOBAL.default_storage_engine = MyISAM;SET SESSION default_storage_engine = MyISAM;SET @@SESSION.default_storage_engine = MyISAM;SET default_storage_engine = MyISAM; \\ é»˜è®¤ä½œç”¨èŒƒå›´æ˜¯LOCAL é‚£æˆ‘ä»¬çš„SHOW VARIABLESè¯­å¥é»˜è®¤æŸ¥çœ‹çš„æ˜¯SESSIONä½œç”¨èŒƒå›´çš„ç³»ç»Ÿå˜é‡ å¹¶ä¸æ˜¯æ‰€æœ‰ç³»ç»Ÿå˜é‡éƒ½å…·æœ‰GLOBALå’ŒSESSIONçš„ä½œç”¨èŒƒå›´ çŠ¶æ€å˜é‡# ä¸Žç³»ç»Ÿå˜é‡ç±»ä¼¼ï¼ŒçŠ¶æ€å˜é‡ä¹Ÿæœ‰GLOBALå’ŒSESSIONä¸¤ä¸ªä½œç”¨èŒƒå›´çš„ 1SHOW STATUS LIKE 'thread%'; å­—ç¬¦é›†å’Œæ¯”è¾ƒè§„åˆ™# æŸ¥çœ‹å­—ç¬¦é›† 12SHOW CHARSET;SHOW CHARACTER SET; Default collationè¡¨ç¤ºå­—ç¬¦é›†é»˜è®¤çš„æ¯”è¾ƒè§„åˆ™ Maxlenä»£è¡¨è¯¥å­—ç¬¦é›†è¡¨ç¤ºä¸€ä¸ªå­—ç¬¦æœ€å¤šéœ€è¦å‡ ä¸ªå­—èŠ‚ æŸ¥çœ‹æ¯”è¾ƒè§„åˆ™ MySQLä¸­utf8æ˜¯utf8mb3çš„åˆ«åï¼Œæ‰€ä»¥åœ¨MySQLä¸­utf8å°±æ„å‘³ç€ä½¿ç”¨1~3ä¸ªå­—èŠ‚æ¥è¡¨ç¤ºä¸€ä¸ªå­—ç¬¦ï¼Œå¦‚æžœå¤§å®¶æœ‰ä½¿ç”¨4å­—èŠ‚ç¼–ç ä¸€ä¸ªå­—ç¬¦çš„æƒ…å†µï¼Œæ¯”å¦‚å­˜å‚¨ä¸€äº›emojiè¡¨æƒ…ï¼Œä½¿ç”¨utf8mb4 MySQLæœ‰4ä¸ªçº§åˆ«çš„å­—ç¬¦é›†å’Œæ¯”è¾ƒè§„åˆ™ï¼Œåˆ†åˆ«æ˜¯ï¼š æœåŠ¡å™¨çº§åˆ« character_set_server, collation_server æ•°æ®åº“çº§åˆ« character_set_database, collation_database è¡¨çº§åˆ« åˆ—çº§åˆ« ç¼–ç å’Œè§£ç ä½¿ç”¨çš„å­—ç¬¦é›†ä¸ä¸€è‡´å°†å¯¼è‡´ä¹±ç  å­—ç¬¦é›†çš„è½¬æ¢# character_set_client æœåŠ¡å™¨è§£ç è¯·æ±‚è¯­å¥æ—¶ä½¿ç”¨çš„å­—ç¬¦é›† character_set_connection æœåŠ¡å™¨å¤„ç†è¯·æ±‚æ—¶ä¼šæŠŠè¯·æ±‚å­—ç¬¦ä¸²ä»Žcharacter_set_clientè½¬ä¸ºcharacter_set_connection character_set_results æœåŠ¡å™¨å‘å®¢æˆ·ç«¯è¿”å›žæ•°æ®æ—¶ä½¿ç”¨çš„å­—ç¬¦é›† é€šå¸¸æŠŠ character_set_client ã€character_set_connectionã€character_set_results è¿™ä¸‰ä¸ªç³»ç»Ÿå˜é‡è®¾ç½®æˆå’Œå®¢æˆ·ç«¯ä½¿ç”¨çš„ç›¸åŒçš„å­—ç¬¦é›† 12345SET NAMES å­—ç¬¦é›†å;SET character_set_client = å­—ç¬¦é›†å;SET character_set_connection = å­—ç¬¦é›†å;SET character_set_results = å­—ç¬¦é›†å; InnoDBè®°å½•å­˜# InnoDBé¡µ# InnoDBæ˜¯ä¸€ä¸ªå°†è¡¨ä¸­çš„æ•°æ®å­˜å‚¨åˆ°ç£ç›˜ä¸Šçš„å­˜å‚¨å¼•æ“Žã€‚ç£ç›˜è¯»å†™çš„é€Ÿåº¦æ¯”å†…å­˜çš„è¯»å†™é€Ÿåº¦å·®äº†å‡ ä¸ªæ•°é‡çº§ï¼Œå› æ­¤è®¾è®¡InnoDBæ—¶å°†æ•°æ®åˆ’åˆ†ä¸ºè‹¥å¹²ä¸ªé¡µå¹¶ä»¥é¡µä½œä¸ºç£ç›˜å’Œå†…å­˜ä¹‹é—´äº¤äº’çš„åŸºæœ¬å•ä½ï¼Œé¡µçš„å¤§å°ä¸€èˆ¬ä¸º 16 KBã€‚ InnoDBè¡Œæ ¼å¼# 4ç§è¡Œæ ¼å¼: Compact Redundant Dynamic Compressed 1CREATE TABLE è¡¨å ROW_FORMAT=è¡Œæ ¼å¼åç§° Compactè¡Œæ ¼å¼# æ‰€æœ‰å˜é•¿å­—æ®µçš„çœŸå®žæ•°æ®å ç”¨çš„å­—èŠ‚é•¿åº¦éƒ½è¢«å­˜æ”¾åœ¨å˜é•¿å­—æ®µé•¿åº¦åˆ—è¡¨ æŠŠå€¼ä¸ºNULLçš„åˆ—ç»Ÿä¸€å­˜å‚¨åˆ°NULLå€¼åˆ—è¡¨ä¸­ è®°å½•å¤´ä¿¡æ¯æ˜¯ç”±å›ºå®šçš„5ä¸ªå­—èŠ‚ç»„æˆ MySQLä¼šä¸ºæ¯ä¸ªè®°å½•é»˜è®¤çš„æ·»åŠ ä¸€äº›åˆ—ï¼ˆéšè—åˆ—ï¼‰ï¼ŒåŒ…æ‹¬ï¼šrow_idï¼ˆDB_ROW_IDï¼‰ã€transaction_idï¼ˆDB_TRX_IDï¼‰ã€roll_pointerï¼ˆDB_ROLL_PTRï¼‰ã€‚ è¡Œæ•°æ®æº¢å‡º# å¯¹äºŽMySQLçš„æ¯æ¡è®°å½•ï¼Œé™¤äº†BLOBæˆ–è€…TEXTç±»åž‹çš„åˆ—ä¹‹å¤–ï¼Œå…¶ä»–æ‰€æœ‰çš„åˆ—ï¼ˆä¸åŒ…æ‹¬éšè—åˆ—å’Œè®°å½•å¤´ä¿¡æ¯ï¼‰å ç”¨çš„å­—èŠ‚é•¿åº¦åŠ èµ·æ¥ä¸èƒ½è¶…è¿‡65535ä¸ªå­—èŠ‚ã€‚è¿™ä¸ª65535ä¸ªå­—èŠ‚é™¤äº†åˆ—æœ¬èº«çš„æ•°æ®ä¹‹å¤–ï¼Œè¿˜åŒ…æ‹¬ä¸€äº›å…¶ä»–çš„æ•°æ®ï¼Œå³ çœŸå®žæ•°æ®æœ¬èº« çœŸå®žæ•°æ®å ç”¨å­—èŠ‚çš„é•¿åº¦æ ‡è¯†ï¼ˆ&lt;= 2 bytesï¼‰ NULLå€¼æ ‡è¯†ï¼ˆ&lt;= 1 byteï¼‰ï¼Œå½“åˆ—éƒ½æœ‰NOT NULLå±žæ€§æ—¶ä¸º0 å› æ­¤ï¼Œä¸Šå›¾ä¸­è®¾ç½®å˜é•¿ç±»åž‹VARCHAR(M)ï¼ˆMè¡¨ç¤ºå…è®¸çš„å­—ç¬¦æ•°é‡ï¼‰M=65535æ—¶å¯¼è‡´äº†æº¢å‡ºã€‚ çœŸå®žæ•°æ®ï¼š65533 = 65529(c1)+ 4(c2) é•¿åº¦æ ‡è¯†ï¼š2 NULLå€¼æ ‡è¯†ï¼š1 å…±65536 &gt; 65535æº¢å‡ºã€‚ æ›´æ¢å­—ç¬¦é›†åŽæº¢å‡ºã€‚ VARCHAR(M)ç±»åž‹çš„åˆ—å°±æœ€å¤šå¯ä»¥å­˜å‚¨65533ä¸ªå­—èŠ‚ï¼Œè€Œä¸€ä¸ªé¡µçš„å¤§å°ä¸€èˆ¬æ˜¯16KBï¼Œä¹Ÿå°±æ˜¯16384å­—èŠ‚ï¼Œå› æ­¤åœ¨Compactå’ŒReduntantè¡Œæ ¼å¼ä¸­ï¼Œåœ¨æœ¬è®°å½•åªä¼šå­˜å‚¨è¯¥åˆ—çš„å‰768ä¸ªå­—èŠ‚çš„æ•°æ®å’Œä¸€ä¸ªæŒ‡å‘å…¶ä»–é¡µçš„åœ°å€ï¼Œç„¶åŽæŠŠå‰©ä¸‹çš„æ•°æ®å­˜æ”¾åˆ°å…¶ä»–é¡µä¸­ï¼›è€Œåœ¨Dynamicå’ŒCompressedè¡Œæ ¼å¼ä¸­ï¼Œè®°å½•ä¸­åªå­˜å‚¨å…¶ä»–é¡µçš„åœ°å€ã€‚ è¡Œæº¢å‡ºçš„ä¸´ç•Œç‚¹# MySQLä¸­è§„å®šä¸€ä¸ªé¡µä¸­è‡³å°‘è¦å­˜æ”¾ä¸¤è¡Œè®°å½• æ¯ä¸ªé¡µé™¤äº†å­˜æ”¾è®°å½•å¤–ï¼Œä¹Ÿéœ€è¦å­˜å‚¨ä¸€äº›é¢å¤–çš„ä¿¡æ¯ï¼Œè¿™äº›é¢å¤–ä¿¡æ¯åŠ èµ·æ¥éœ€è¦132ä¸ªå­—èŠ‚ æ¯ä¸ªè®°å½•çš„é¢å¤–ä¿¡æ¯éœ€è¦27å­—èŠ‚ çœŸå®žæ•°æ®çš„é•¿åº¦æ ‡è¯† 1B NULLå€¼æ ‡è¯† 1B è®°å½•å¤´ä¿¡æ¯ 5B row_id 6B transaction_id 6B roll_pointer 7B ä¸æº¢å‡ºçš„ä¸´ç•Œæ¡ä»¶ï¼š132 + 2Ã—(27 + n) &lt; 16384 InnoDBæ•°æ®é¡µ# æ•°æ®é¡µç»“æž„# è®°å½•åœ¨é¡µä¸­çš„å­˜å‚¨# è®°å½•å¤´ä¿¡æ¯# ä»¥ page_demo è¡¨ä¸ºä¾‹ 123456CREATE TABLE page_demo( c1 INT, c2 INT, c3 VARCHAR(10000), PRIMARY KEY (c1)) CHARSET=ascii ROW_FORMAT=Compact; ç”±äºŽæŒ‡å®š c1 ä¸ºä¸»é”®ï¼Œæ‰€ä»¥åœ¨è¡Œæ ¼å¼ä¸­å°±æ²¡æœ‰éšè—åˆ— row_idã€‚ æ’å…¥æ•°æ®4æ¡è®°å½• 1234INSERT INTO page_demo VALUES(1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'), (4, 400, 'dddd'); delete_mask æ ‡è®°å½“å‰è®°å½•æ˜¯å¦è¢«åˆ é™¤ï¼Œå€¼ä¸º0çš„æ—¶å€™ä»£è¡¨è®°å½•æ²¡æœ‰è¢«åˆ é™¤ï¼Œ1åˆ™è¢«åˆ é™¤äº†ï¼› æ‰€æœ‰è¢«åˆ çš„è®°å½•ä¼šç»„æˆä¸€ä¸ªåžƒåœ¾é“¾è¡¨ï¼Œæ–°è®°å½•æ’å…¥åˆ°è¡¨æ—¶å¯ä»¥è¦†ç›–è¿™äº›è¢«åˆ é™¤çš„è®°å½•å ç”¨çš„å­˜å‚¨ç©ºé—´ã€‚ n_owned è§Page Directory heap_no è¡¨ç¤ºå½“å‰è®°å½•åœ¨æœ¬é¡µä¸­çš„ä½ç½®ï¼Œä»Žä¸Šå›¾ä¸­å¯ä»¥çœ‹å‡ºï¼Œæ’å…¥çš„4æ¡è®°å½•åœ¨æœ¬é¡µä¸­çš„ä½ç½®åˆ†åˆ«æ˜¯ï¼š2ã€3ã€4ã€5ã€‚æœ€å°è®°å½•å’Œæœ€å¤§è®°å½•åˆ†åˆ«ä¸º0ã€1ã€‚ record_type è®°å½•ç±»åž‹ï¼Œå…±4ç§ï¼š 0ï¼šæ™®é€šè®°å½• 1ï¼šB+æ ‘éžå¶èŠ‚ç‚¹è®°å½• ï¼ˆæˆ–ç›®å½•é¡¹è®°å½•ï¼Œè§ç›®å½•é¡¹ï¼‰ 2ï¼šæœ€å°è®°å½• 3ï¼šæœ€å¤§è®°å½• min_rec_mask ä»£è¡¨B+æ ‘çš„æ¯å±‚éžå¶èŠ‚ç‚¹ä¸­çš„æœ€å°è®°å½• ï¼ˆæˆ–è€…ä¸»é”®å€¼æœ€å°çš„ç›®å½•é¡¹è®°å½•çš„min_rec_maskå€¼ä¸º1ï¼‰ next_record è¡¨ç¤ºä»Žå½“å‰è®°å½•çš„çœŸå®žæ•°æ®åˆ°ä¸‹ä¸€æ¡è®°å½•çš„çœŸå®žæ•°æ®çš„åœ°å€åç§»é‡ã€‚ä¾‹å¦‚ç¬¬ä¸€æ¡è®°å½•çš„next_recordå€¼ä¸º32ï¼Œæ„å‘³ç€ä»Žç¬¬ä¸€æ¡è®°å½•çš„çœŸå®žæ•°æ®çš„åœ°å€å¤„å‘åŽæ‰¾32ä¸ªå­—èŠ‚ä¾¿æ˜¯ä¸‹ä¸€æ¡è®°å½•çš„çœŸå®žæ•°æ®ã€‚è®°å½•æŒ‰ç…§ä¸»é”®ä»Žå°åˆ°å¤§çš„é¡ºåºå½¢æˆäº†ä¸€ä¸ªå•é“¾è¡¨ å¦‚æžœåˆ é™¤ç¬¬äºŒæ¡è®°å½• 1DELETE FROM page_demo WHERE c1 = 2; åˆ é™¤ç¬¬2æ¡è®°å½•å‰åŽçš„ä¸»è¦å˜åŒ–ï¼š ç¬¬2æ¡è®°å½•çš„delete_maskå€¼è®¾ç½®ä¸º1ï¼› ç¬¬2æ¡è®°å½•çš„next_recordå€¼å˜ä¸ºäº†0ï¼Œæ„å‘³ç€è¯¥è®°å½•æ²¡æœ‰ä¸‹ä¸€æ¡è®°å½•äº†ï¼› ç¬¬1æ¡è®°å½•çš„next_recordæŒ‡å‘äº†ç¬¬3æ¡è®°å½•ï¼› æœ€å¤§è®°å½•çš„n_ownedå€¼ä»Ž5å˜æˆäº†4ã€‚ Page Directory# è®¾è®¡é¡µç›®å½•æ˜¯ä¸ºäº†æ–¹ä¾¿å¿«é€ŸæŸ¥æ‰¾è®°å½•ï¼Œå°±åƒä¹¦çš„ç›®å½•é‚£æ ·ï¼Œåˆ›å»º page directory çš„æ­¥éª¤ï¼š å°†æ‰€æœ‰æ­£å¸¸çš„è®°å½•ï¼ˆåŒ…æ‹¬æœ€å¤§å’Œæœ€å°è®°å½•ï¼Œä¸åŒ…æ‹¬æ ‡è®°ä¸ºå·²åˆ é™¤çš„è®°å½•ï¼‰åˆ’åˆ†ä¸ºå‡ ä¸ªç»„ï¼› æ¯ä¸ªç»„å†…æœ€å¤§çš„é‚£æ¡è®°å½•çš„å¤´ä¿¡æ¯çš„ n_owned è¡¨ç¤ºç»„å†…è®°å½•çš„æ•°é‡ï¼› å°†æ¯ä¸ªç»„çš„æœ€å¤§çš„é‚£æ¡è®°å½•çš„åœ°å€åç§»é‡ï¼ˆä¹Ÿç§°æ§½ï¼Œslotï¼‰é›†ä¸­èµ·æ¥å­˜æ”¾ï¼Œæž„æˆ Page Directoryï¼› InnoDBè§„å®šæœ€å°è®°å½•æ‰€åœ¨çš„åˆ†ç»„åªèƒ½æœ‰ 1 æ¡è®°å½•ï¼Œæœ€å¤§è®°å½•æ‰€åœ¨çš„åˆ†ç»„çš„è®°å½•æ¡æ•°åœ¨ 1~8 æ¡ä¹‹é—´ï¼Œå…¶å®ƒåˆ†ç»„ä¸­è®°å½•çš„æ¡æ•°åˆ™åœ¨æ˜¯ 4~8 æ¡ä¹‹é—´ã€‚ åˆ©ç”¨é¡µç›®å½•æŸ¥æ‰¾æŒ‡å®šä¸»é”®çš„è®°å½•çš„è¿‡ç¨‹åˆ†ä¸ºä¸¤æ­¥ï¼š é€šè¿‡äºŒåˆ†æ³•ç¡®å®šè¯¥è®°å½•æ‰€åœ¨çš„æ§½ï¼Œå¹¶æ‰¾åˆ°è¯¥æ§½ä¸­ä¸»é”®å€¼æœ€å°çš„é‚£æ¡è®°å½•ï¼› é€šè¿‡è®°å½•çš„ next_record å±žæ€§éåŽ†ç»„ä¸­çš„å„ä¸ªè®°å½•ã€‚ Page Header# å­˜å‚¨æ•°æ®çš„çŠ¶æ€ä¿¡æ¯ï¼Œæ¯”å¦‚æœ¬é¡µä¸­å·²ç»å­˜å‚¨äº†å¤šå°‘æ¡è®°å½•ï¼Œç¬¬ä¸€æ¡è®°å½•çš„åœ°å€æ˜¯ä»€ä¹ˆï¼Œé¡µç›®å½•ä¸­å­˜å‚¨äº†å¤šå°‘ä¸ªæ§½ç­‰ç­‰ã€‚ File Header# ä¸åŒç±»åž‹çš„é¡µéƒ½ä¼šä»¥File Headerä½œä¸ºç¬¬ä¸€ä¸ªç»„æˆéƒ¨åˆ†ï¼Œå®ƒè®°å½•äº†é’ˆå¯¹å„ç§é¡µéƒ½é€šç”¨çš„ä¸€äº›ä¿¡æ¯ã€‚ ç´¢å¼•é¡µï¼ˆæ•°æ®é¡µï¼‰é€šè¿‡ file header æž„æˆåŒå‘é“¾è¡¨ File Trailer# ä¸Žfile headerä¸€æ ·å¯¹ä¸åŒç±»åž‹çš„é¡µé€šç”¨ï¼Œä¸»è¦ç”¨äºŽæ ¡éªŒé¡µæ•°æ®çš„å®Œæ•´æ€§ã€‚ B+æ ‘ç´¢å¼•# æ— ç´¢å¼•æŸ¥æ‰¾# åœ¨é¡µå†…æŸ¥æ‰¾# ä»¥ä¸»é”®æŸ¥æ‰¾ ä¾æ®é¡µç›®å½•ï¼ˆæ§½ï¼‰é‡‡ç”¨äºŒåˆ†æŸ¥æ‰¾å®šä½åˆ†ç»„ï¼Œå†éåŽ†åˆ†ç»„ ä»¥ä¸»é”®ä»¥å¤–çš„åˆ—æŸ¥æ‰¾ éåŽ†é¡µå†…çš„è®°å½•é“¾è¡¨ åœ¨å¤šé¡µä¸­æŸ¥æ‰¾# å®šä½è®°å½•æ‰€åœ¨çš„é¡µ é¡µå†…æŸ¥æ‰¾ ç´¢å¼•# å»ºç«‹ç´¢å¼•æ˜¯ä¸ºäº†å¿«é€Ÿå®šä½è®°å½•æ‰€åœ¨çš„æ•°æ®é¡µã€‚ å¯¹æ•°æ®é¡µè¿›è¡ŒæŽ’åºã€‚å³è®©ä¸‹ä¸€ä¸ªæ•°æ®é¡µçš„è®°å½•çš„ä¸»é”®å€¼å¤§äºŽä¸Šä¸€ä¸ªé¡µçš„è®°å½•çš„ä¸»é”®å€¼ï¼Œå› æ­¤åœ¨æ’å…¥æ–°çš„è®°å½•æ—¶æ¶‰åŠæ•°æ®é¡µé—´çš„è®°å½•çš„è°ƒæ•´ å¯¹é¡µè¿›è¡ŒæŽ’åºåŽï¼Œå…¨éƒ¨è®°å½•çš„ä¸»é”®å€¼å°±æž„æˆäº†ä¸€ä¸ªé€’å¢žçš„åºåˆ—ï¼Œä»Žè€Œå¯ä»¥åˆ©ç”¨äºŒåˆ†æ³•å®žçŽ°å¿«é€ŸæŸ¥æ‰¾ã€‚ å¯¹æ¯ä¸ªé¡µè®¾ç½®ç›®å½•é¡¹ ç›®å½•é¡¹# ç›®å½•é¡¹åŒ…æ‹¬ æ•°æ®é¡µä¸­çš„è®°å½•çš„æœ€å°ä¸»é”®å€¼ï¼Œç”¨keyæ¥è¡¨ç¤ºï¼› é¡µå·ï¼Œç”¨page_noè¡¨ç¤ºã€‚ ç”¨é¡µå­˜æ”¾ç›®å½•é¡¹# ç”¨æˆ·è®°å½•éƒ½å­˜æ”¾åœ¨B+æ ‘çš„å¶èŠ‚ç‚¹ä¸Šï¼Œè€Œç›®å½•é¡¹éƒ½å­˜æ”¾åœ¨éžé¡µèŠ‚ç‚¹ä¸Šã€‚ èšç°‡ç´¢å¼•# ç‰¹æ€§åŒ…æ‹¬ï¼š ä¾æ®è®°å½•çš„ä¸»é”®å€¼æŽ’åº é¡µå†…çš„è®°å½•æ˜¯æŒ‰ç…§ä¸»é”®çš„å¤§å°é¡ºåºæŽ’æˆä¸€ä¸ªå•å‘é“¾è¡¨ æ•°æ®é¡µæ ¹æ®ä¸»é”®å¤§å°é¡ºåºæŽ’æˆä¸€ä¸ªåŒå‘é“¾è¡¨ å­˜æ”¾ç›®å½•é¡¹è®°å½•çš„é¡µæ ¹æ®ä¸»é”®å¤§å°åˆ†ä¸ºä¸åŒçš„å±‚æ¬¡ B+æ ‘çš„å¶èŠ‚ç‚¹å­˜å‚¨çš„æ˜¯å®Œæ•´çš„è®°å½•ï¼Œå³è®°å½•çš„æ‰€æœ‰åˆ—çš„å€¼ï¼ˆåŒ…æ‹¬éšè—åˆ—ï¼‰ äºŒçº§ç´¢å¼•# ä¾æ®è®°å½•çš„å…¶å®ƒåˆ—ï¼ˆæ¯”å¦‚c1ï¼‰çš„å€¼æŽ’åºå½¢æˆçš„B+æ ‘ã€‚å°†èšç°‡ç´¢å¼•çš„ä¸»é”®å€¼æ¢ä¸ºc1çš„å€¼ï¼Œæ­¤å¤–ï¼Œå¶èŠ‚ç‚¹å­˜å‚¨çš„ä¸æ˜¯å®Œæ•´çš„è®°å½•è€Œåªæœ‰ä¸»é”®å’Œc1ã€‚ é€šè¿‡äºŒçº§ç´¢å¼•æ¥æŸ¥æ‰¾å®Œæ•´è®°å½•ï¼šé€šè¿‡äºŒçº§ç´¢å¼•æ‰¾åˆ°ä¸»é”®å€¼ä¹‹åŽå†é€šè¿‡èšç°‡ç´¢å¼•æŸ¥æ‰¾å®Œæ•´è®°å½•ã€‚ B+æ ‘ç´¢å¼•çš„ä½¿ç”¨# åˆç†ä½¿ç”¨ç´¢å¼•# è€ƒè™‘è¡¨ person_info 123456789CREATE TABLE person_info( id INT NOT NULL auto_increment, name VARCHAR(100) NOT NULL, birthday DATE NOT NULL, phone CHAR(11) NOT NULL, country varchar(100) NOT NULL, PRIMARY KEY (id), KEY idx_name_birthday_phone (name, birthday, phone)); idx_name_birthday_phone ä¸ºäºŒçº§ç´¢å¼• å…¨å€¼åŒ¹é…# 1SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone = '15123983239'; ç”±äºŽæŸ¥è¯¢ä¼˜åŒ–å™¨çš„å­˜åœ¨ï¼Œè°ƒæ¢nameã€birthdayã€phoneè¿™å‡ ä¸ªæœç´¢åˆ—çš„é¡ºåºä¸å½±å“æŸ¥è¯¢çš„æ‰§è¡Œè¿‡ç¨‹ã€‚ åŒ¹é…å·¦è¾¹çš„åˆ—# 1SELECT * FROM person_info WHERE name = 'Ashburn'; å¯ä»¥ä½¿ç”¨ç´¢å¼•idx_name_birthday_phoneï¼Œè€Œ 1SELECT * FROM person_info WHERE birthday = '1990-09-27'; ä¸èƒ½ä½¿ç”¨ç´¢å¼•idx_name_birthday_phoneã€‚ åŒ¹é…åˆ—å‰ç¼€# æ¯”å¦‚æŸ¥è¯¢åå­—ä»¥ As å¼€å¤´çš„è®°å½• 1SELECT * FROM person_info WHERE name LIKE 'As%'; å›žè¡¨çš„ä»£ä»·# 1SELECT * FROM person_info WHERE name &gt; 'Asa' AND name &lt; 'Barlow'; äºŒçº§ç´¢å¼•æœç´¢åˆ°çš„ç»“æžœï¼ˆå³å€¼åœ¨Asaï½žBarlowä¹‹é—´çš„è®°å½•ï¼‰åœ¨ç£ç›˜ä¸­çš„å­˜å‚¨æ˜¯ç›¸è¿žçš„ï¼Œé›†ä¸­åˆ†å¸ƒåœ¨ä¸€ä¸ªæˆ–å‡ ä¸ªæ•°æ®é¡µä¸­ï¼Œå› æ­¤å¯ä»¥å¾ˆå¿«ä»Žç£ç›˜ä¸­è¯»å‡ºï¼Œè¿™ç§è¯»å–æ–¹å¼å¯ä»¥ç§°ä¸ºé¡ºåºI/Oã€‚è€Œå›žè¡¨æ˜¯æ ¹æ®ä¸è¿žç»­çš„idå€¼åˆ°èšç°‡ç´¢å¼•ä¸­è¯»å‡ºå®Œæ•´çš„ç”¨æˆ·è®°å½•ï¼ˆå¯èƒ½åˆ†å¸ƒåœ¨ä¸åŒçš„æ•°æ®é¡µä¸­ï¼‰ï¼Œè¿™ç§è¯»å–æ–¹å¼å¯ä»¥ç§°ä¸ºéšæœºI/Oã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œé¡ºåºI/Oæ¯”éšæœºI/Oçš„æ€§èƒ½é«˜å¾ˆå¤šã€‚ äºŒçº§ç´¢å¼• + å›žè¡¨ or å…¨è¡¨æ‰«ç # éœ€è¦å›žè¡¨çš„è®°å½•è¶Šå¤šï¼Œä½¿ç”¨äºŒçº§ç´¢å¼•çš„æ€§èƒ½å°±è¶Šä½Žï¼Œç”šè‡³ä¸å¦‚ä½¿ç”¨èšç°‡ç´¢å¼•å…¨è¡¨æ‰«ç ï¼› ä½¿ç”¨LIMITé™åˆ¶å›žè¡¨æ¬¡æ•°ï¼Œä½¿ä¼˜åŒ–å™¨å€¾å‘äºŽä½¿ç”¨äºŒçº§ç´¢å¼• + å›žè¡¨çš„æ–¹å¼æ‰§è¡ŒæŸ¥è¯¢ã€‚ è¦†ç›–ç´¢å¼•# å¦‚æžœéœ€è¦æŸ¥è¯¢çš„åˆ—åŒ…å«åœ¨äºŒçº§ç´¢å¼•ä¸­ï¼Œå°±å¯ä»¥é¿å…å›žè¡¨æŸ¥è¯¢ï¼Œè¿™ç§åªéœ€è¦ç”¨åˆ°ç´¢å¼•çš„æŸ¥è¯¢æ–¹å¼ç§°ä¸ºç´¢å¼•è¦†ç›–ã€‚ä¾‹å¦‚å¯¹äºŽç´¢å¼•idx_name_birthday_phone 1SELECT name, birthday, phone FROM person_info WHERE name &gt; 'Asa' AND name &lt; 'Barlow' åˆç†åœ°å»ºç«‹ç´¢å¼•# åªç»™æœç´¢ã€æŽ’åºã€åˆ†ç»„çš„åˆ—åˆ›å»ºç´¢å¼• å³åªç»™å‡ºçŽ°åœ¨ WHEREã€ORDER BYã€GROUP BY å­å¥ä¸­çš„åˆ—åˆ›å»ºç´¢å¼•ï¼› åˆ—çš„æ–¹å·®è¶Šå¤§è¶Šé€‚åˆå»ºç«‹ç´¢å¼• åˆ—çš„æ•°æ®è¶Šåˆ†æ•£ï¼Œè¶Šé€‚åˆç´¢å¼•æŸ¥è¯¢ã€‚ä¸¾ä¸ªæžç«¯çš„ä¾‹å­ï¼Œæ•°æ®éƒ½ç›¸åŒçš„åˆ—ï¼Œå¯¹è¿™æ ·çš„åˆ—å»ºç«‹ç´¢å¼•æ¯«æ— æ„ä¹‰ï¼› åˆ—çš„æ•°æ®ç±»åž‹è¶Šå°è¶Šé€‚åˆå»ºç«‹ç´¢å¼• æ¯”è¾ƒæ•°æ®å¤§å°æ›´å¿«ï¼Œå ç”¨çš„å­˜å‚¨ç©ºé—´æ›´å°ï¼› ç´¢å¼•å­—ç¬¦ä¸²çš„å‰ç¼€ 1234567CREATE TABLE person_info( name VARCHAR(100) NOT NULL, birthday DATE NOT NULL, phone CHAR(11) NOT NULL, country varchar(100) NOT NULL, KEY idx_name_birthday_phone (name(10), birthday, phone)); å…¶ä¸­ name(10) è¡¨ç¤ºåœ¨å»ºç«‹çš„B+æ ‘ç´¢å¼•ä¸­åªä¿ç•™è®°å½•çš„å‰10ä¸ªå­—ç¬¦çš„ç¼–ç ï¼Œä½†æ˜¯è¯¥ç´¢å¼•ä¸æ”¯æŒ name æŽ’åº 1SELECT * FROM person_info ORDER BY name LIMIT 10; è®©ç´¢å¼•åˆ—åœ¨æ¯”è¾ƒè¡¨è¾¾å¼ä¸­å•ç‹¬å‡ºçŽ° 12WHERE my_col * 2 &lt; 4WHERE my_col &lt; 4/2 å¦‚æžœåˆ—æ˜¯ä»¥æŸä¸ªè¡¨è¾¾å¼æˆ–è€…å‡½æ•°è°ƒç”¨å½¢å¼å‡ºçŽ°æ˜¯ç”¨ä¸åˆ°ç´¢å¼•çš„ï¼Œæ¯”å¦‚ä¸Šé¢çš„my_col * 2ï¼› å¼€å¯ä¸»é”®AUTO_INCREMENTå±žæ€§ å¯å‡å°‘é¡µåˆ†è£‚å’Œè®°å½•ç§»ä½çš„æ¬¡æ•°ã€‚ MySQLçš„æ•°æ®ç›®å½•# æ•°æ®åº“å’Œæ–‡ä»¶ç³»ç»Ÿçš„å…³ç³»# InnoDBã€MyISAMç­‰å­˜å‚¨å¼•æ“Žéƒ½æ˜¯æŠŠè¡¨å­˜å‚¨åœ¨ç£ç›˜ä¸Šã€‚æ“ä½œç³»ç»Ÿé€šè¿‡æ–‡ä»¶ç³»ç»Ÿç®¡ç†ç£ç›˜ã€‚ InnoDBã€MyISAMç­‰å­˜å‚¨å¼•æ“Ž $ \Leftrightarrow $ æ–‡ä»¶ç³»ç»Ÿ $ \Leftrightarrow $ ç£ç›˜ æ•°æ®ç›®å½•# æ•°æ®ç›®å½•å’Œå®‰è£…ç›®å½•çš„åŒºåˆ«# æ•°æ®ç›®å½•æ˜¯ç”¨æ¥å­˜å‚¨MySQLåœ¨è¿è¡Œè¿‡ç¨‹ä¸­äº§ç”Ÿçš„æ•°æ®ï¼Œè¦ä¸ŽMySQLçš„å®‰è£…ç›®å½•åŒºåˆ«å¼€æ¥ã€‚ æŸ¥æ‰¾æ•°æ®ç›®å½•# æ•°æ®ç›®å½•çš„ç»“æž„# æ•°æ®åº“åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­çš„è¡¨ç¤º# æ¯æ–°å»ºä¸€ä¸ªæ•°æ®åº“ï¼ŒMySQLæ‰§è¡Œäº†ï¼š åœ¨æ•°æ®ç›®å½•ä¸‹åˆ›å»ºä¸€ä¸ªå’Œæ•°æ®åº“ååŒåçš„å­ç›®å½•ï¼› å¹¶åœ¨è¯¥å­ç›®å½•ä¸‹åˆ›å»ºä¸€ä¸ªdb.optæ–‡ä»¶ï¼Œè¿™ä¸ªæ–‡ä»¶ä¸­åŒ…å«äº†è¯¥æ•°æ®åº“çš„å„ç§å±žæ€§ï¼Œæ¯”æ–¹è¯´è¯¥æ•°æ®åº“çš„å­—ç¬¦é›†å’Œæ¯”è¾ƒè§„åˆ™ç­‰ã€‚ æŸ¥çœ‹æ•°æ®åº“ æŸ¥çœ‹æ•°æ®ç›®å½• é™¤äº†information_schemaè¿™ä¸ªç³»ç»Ÿæ•°æ®åº“å¤–ï¼Œå…¶ä»–çš„æ•°æ®åº“åœ¨æ•°æ®ç›®å½•ä¸‹éƒ½æœ‰å¯¹åº”çš„å­ç›®å½•ã€‚ è¡¨åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­çš„è¡¨ç¤º# æ¯ä¸ªè¡¨åŒ…å«ä¸¤éƒ¨åˆ†ä¿¡æ¯ï¼š è¡¨ç»“æž„çš„å®šä¹‰ ç”¨è¡¨å.frmæ–‡ä»¶æ¥æè¿°è¡¨ç»“æž„ è¡¨ä¸­çš„æ•°æ® InnoDB: æ•°æ®å­˜åœ¨ç‹¬ç«‹è¡¨ç©ºé—´(file-per-table tablespace)ä¸­ï¼Œå³ test.ibd æ–‡ä»¶ MyISAM: è¡¨å.MYDè¡¨ç¤ºè¡¨çš„æ•°æ®æ–‡ä»¶ã€è¡¨å.MYIè¡¨ç¤ºè¡¨çš„ç´¢å¼•æ–‡ä»¶ æ–‡ä»¶ç³»ç»Ÿå¯¹æ•°æ®åº“çš„å½±å“# æ•°æ®åº“åå’Œè¡¨åä¸å¾—è¶…è¿‡æ–‡ä»¶ç³»ç»Ÿæ‰€å…è®¸çš„æœ€å¤§é•¿åº¦ ç‰¹æ®Šå­—ç¬¦ MySQLä¼šæŠŠæ•°æ®åº“åå’Œè¡¨åä¸­é™¤æ•°å­—å’Œæ‹‰ä¸å­—æ¯å¤–çš„æ‰€æœ‰å­—ç¬¦åœ¨æ–‡ä»¶åé‡Œéƒ½æ˜ å°„æˆ @+ç¼–ç å€¼çš„å½¢å¼ï¼Œå¦‚test?.frm $ \rightarrow $ test@003f.frm æ–‡ä»¶å¤§å°å—æ–‡ä»¶ç³»ç»Ÿé™åˆ¶ MySQLç³»ç»Ÿæ•°æ®åº“ç®€ä»‹# mysql å­˜å‚¨äº†MySQLçš„è´¦æˆ·å’Œæƒé™ä¿¡æ¯ï¼Œä¸€äº›å­˜å‚¨è¿‡ç¨‹ã€äº‹ä»¶çš„å®šä¹‰ä¿¡æ¯ï¼Œä¸€äº›è¿è¡Œè¿‡ç¨‹ä¸­äº§ç”Ÿçš„æ—¥å¿—ä¿¡æ¯ã€ä»¥åŠæ—¶åŒºä¿¡æ¯ç­‰ information_schema è¿™ä¸ªæ•°æ®åº“ä¿å­˜ç€MySQLæœåŠ¡å™¨ç»´æŠ¤çš„æ‰€æœ‰å…¶ä»–æ•°æ®åº“çš„ä¿¡æ¯ï¼Œæ¯”å¦‚è¡¨ã€è§†å›¾ã€è§¦å‘å™¨ã€åˆ—ã€ç´¢å¼•ç­‰ performance_schema è¿™ä¸ªæ•°æ®åº“é‡Œä¸»è¦ä¿å­˜MySQLæœåŠ¡å™¨è¿è¡Œè¿‡ç¨‹ä¸­çš„ä¸€äº›çŠ¶æ€ä¿¡æ¯ï¼ŒåŒ…æ‹¬ç»Ÿè®¡æœ€è¿‘æ‰§è¡Œçš„è¯­å¥ï¼Œæ‰§è¡Œæ—¶é—´ï¼Œå†…å­˜ä½¿ç”¨æƒ…å†µç­‰ sys è¿™ä¸ªæ•°æ®åº“ä¸»è¦æ˜¯é€šè¿‡è§†å›¾çš„å½¢å¼æŠŠinformation_schemaå’Œperformance_schemaç»“åˆèµ·æ¥]]></content>
      <tags>
        <tag>MySQL, é•¿æ–‡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL Notes]]></title>
    <url>%2F2019%2F09%2F05%2F2019-9-5%2F</url>
    <content type="text"><![CDATA[è”è¡¨æŸ¥è¯¢ å­—ç¬¦æ›¿æ¢ æ­£åˆ™æŸ¥è¯¢ å¯¼å…¥SQLæ–‡ä»¶ æŽ’åº è”è¡¨æŸ¥è¯¢# 12345678SELECT library.id, library.name, r.reader_sum, b.book_sum FROM library INNER JOIN( SELECT library_id, count(*) AS reader_sum FROM reader WHERE library_group_id = 10 GROUP BY library_id ) AS rON r.library_id = library.id INNER JOIN( SELECT library_id, count( * ) AS book_sum FROM book WHERE library_group_id = 10 GROUP BY library_id ) AS bON b.library_id = library.id; å­—ç¬¦æ›¿æ¢# 1UPDATE account SET grade = replace(grade,'ç´š','çº§'); æ­£åˆ™æŸ¥è¯¢# 12SELECT * FROM account WHERE grade REGEXP 'ç´š'; -- æŸ¥è¯¢åŒ…å«SELECT name FROM person WHERE name REGEXP '^[aeiou]|ok$'; -- aeiouå¼€å¤´ï¼Œæˆ–okç»“å°¾ å¯¼å…¥SQLæ–‡ä»¶# 1234SET @@global.max_allowed_packet = 1024*1024*1024;SET @@global.sql_mode ='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';SET @@sql_mode ='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'; æŽ’åº# 1SELECT * FROM book WHERE library_id = 257 AND (title REGEXP "æˆ‘" OR author REGEXP "æˆ‘") ORDER BY LOCATE("æˆ‘", CONCAT(title, author)), LENGTH(title), LENGTH(author);]]></content>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[éº»çœç†å·¥ MapReduce å®žéªŒ]]></title>
    <url>%2F2019%2F04%2F30%2F2019-4-30%2F</url>
    <content type="text"><![CDATA[MapReduceæ‰§è¡Œæ¦‚è¿° åºè¨€ï¼šç†Ÿæ‚‰æºä»£ç  Part I: Map/Reduce è¾“å…¥å’Œè¾“å‡º Part II: Single-workerå•è¯ç»Ÿè®¡ Part III: åˆ†å¸ƒå¼ MapReduce ä»»åŠ¡ Part IV: workeré”™è¯¯å¤„ç† åŽŸæ–‡é“¾æŽ¥ MapReduceæ‰§è¡Œæ¦‚è¿°# è®ºæ–‡åœ°å€ é€šè¿‡è‡ªåŠ¨å°†è¾“å…¥æ•°æ®åˆ’åˆ†ä¸º$M$ä¸ªç‰‡æ®µï¼ŒMapè°ƒç”¨åˆ†å¸ƒåœ¨å¤šå°æœºå™¨ä¸Šã€‚ ä¸åŒç‰‡æ®µçš„è¾“å…¥æ•°æ®å¯ä»¥ç”±ä¸åŒçš„æœºå™¨å¹¶è¡Œå¤„ç†ã€‚ Reduceè°ƒç”¨çš„åˆ†å¸ƒå¼åˆ™é€šè¿‡ä½¿ç”¨åˆ†åŒºå‡½æ•°(å³ $hash(key)$ $mod$ $R$)å°†é”®ç©ºé—´åˆ’åˆ†ä¸º$R$ä¸ªéƒ¨åˆ†æ¥å®žçŽ°ï¼Œ$R$çš„å¤§å°å’Œåˆ†åŒºå‡½æ•°ç”±ç”¨æˆ·æŒ‡å®šã€‚ä¸Šå›¾æ˜¾ç¤ºäº†MapReduceæ“ä½œçš„æ€»ä½“æµç¨‹ã€‚ å½“ç”¨æˆ·ç¨‹åºè°ƒç”¨MapReduceå‡½æ•°æ—¶ï¼Œä¼šå‘ç”Ÿä»¥ä¸‹æ“ä½œåºåˆ—(å›¾ä¸­çš„ç¼–å·æ ‡ç­¾å¯¹åº”äºŽä¸‹é¢çš„æ•°å­—)ï¼š ç”¨æˆ·ç¨‹åºä¸­çš„MapReduceåº“é¦–å…ˆå°†è¾“å…¥æ–‡ä»¶æ‹†åˆ†ä¸º16MBåˆ°64MB(ç”¨æˆ·å¯é€šè¿‡å‚æ•°è®¾ç½®)çš„$M$ä¸ªç‰‡æ®µã€‚ ç„¶åŽï¼Œå®ƒä¼šåœ¨ä¸€ç»„è®¡ç®—æœºä¸Šå¯åŠ¨è¯¥ç¨‹åºçš„è®¸å¤šå‰¯æœ¬ï¼› masterä¸ºå‰¯æœ¬ä¹‹ä¸€ï¼Œå…¶ä½™çš„æ˜¯ç”±masteråˆ†é…å·¥ä½œçš„workersã€‚ æœ‰$M$ä¸ªMapä»»åŠ¡å’Œ$R$ä¸ªReduceä»»åŠ¡éœ€è¦åˆ†é…ã€‚masterä¸ºæ¯ä¸ªç©ºé—²çš„workeråˆ†é…ä¸€ä¸ªMapä»»åŠ¡æˆ–Reduceä»»åŠ¡ï¼› è¢«åˆ†é…Mapä»»åŠ¡çš„workerè¯»å–ç›¸åº”è¾“å…¥ç‰‡æ®µã€‚ å®ƒä»Žè¾“å…¥ç‰‡æ®µä¸­è§£æžé”®/å€¼å¯¹ï¼Œå¹¶å°†é”®/å€¼å¯¹ä¼ é€’ç»™ç”¨æˆ·å®šä¹‰çš„Mapå‡½æ•°ã€‚ Mapå‡½æ•°ç”Ÿæˆçš„ä¸­é—´é”®/å€¼å¯¹ç¼“å­˜åœ¨å†…å­˜ä¸­ï¼› å†…å­˜ä¸­çš„é”®\å€¼å¯¹è¢«å‘¨æœŸæ€§åœ°å†™å…¥åˆ°æœ¬åœ°ç£ç›˜ï¼Œå¹¶é€šè¿‡åˆ†åŒºå‡½æ•°åˆ’åˆ†ä¸º$R$ä¸ªåˆ†åŒºã€‚ é”®\å€¼å¯¹åœ¨æœ¬åœ°ç£ç›˜çš„ä½ç½®å°†è¢«ä¼ å›žåˆ°masterï¼Œmasterå†å°†ä½ç½®ä¿¡æ¯è½¬å‘ç»™Reduce workerï¼› å½“Reduce workeræ”¶åˆ°æ¥è‡ªmasterçš„ä½ç½®ä¿¡æ¯åŽï¼Œå®ƒä½¿ç”¨è¿œç¨‹è¿‡ç¨‹è°ƒç”¨(RPC)ä»ŽMap workerçš„æœ¬åœ°ç£ç›˜è¯»å–ç¼“å†²æ•°æ®ã€‚ å½“Reduce workerè¯»å–äº†æ‰€æœ‰ä¸­é—´æ•°æ®æ—¶ï¼Œå®ƒä¼šæ ¹æ®ä¸­é—´é”®è¿›è¡ŒæŽ’åºï¼Œä»¥ä¾¿å°†æ‰€æœ‰ç›¸åŒçš„ä¸­é—´é”®ç»„åˆåœ¨ä¸€èµ·ã€‚ ä¹‹æ‰€ä»¥éœ€è¦æŽ’åºæ˜¯å› ä¸ºé€šå¸¸æœ‰è®¸å¤šä¸åŒçš„é”®æ˜ å°„åˆ°åŒä¸€ä¸ªreduceä»»åŠ¡ã€‚ å¦‚æžœä¸­é—´æ•°æ®é‡å¤ªå¤§è€Œæ— æ³•å®¹çº³åœ¨å†…å­˜ä¸­ï¼Œåˆ™ä½¿ç”¨å¤–éƒ¨æŽ’åºï¼› Reduce workerå¯¹æŽ’å¥½åºçš„ä¸­é—´æ•°æ®è¿›è¡ŒéåŽ†ã€‚å¯¹é‡åˆ°çš„æ¯ä¸ªå”¯ä¸€ä¸­é—´é”®ï¼Œå®ƒå°†é”®å’Œç›¸åº”çš„ä¸€ç»„ä¸­é—´å€¼ä¼ é€’ç»™ç”¨æˆ·çš„Reduceå‡½æ•°ã€‚ Reduceå‡½æ•°çš„è¾“å‡ºé™„åŠ åˆ°æ­¤Reduceåˆ†åŒºçš„æœ€ç»ˆè¾“å‡ºæ–‡ä»¶ã€‚ å®Œæˆæ‰€æœ‰Mapä»»åŠ¡å’ŒReduceä»»åŠ¡åŽï¼Œmasterä¼šå”¤é†’ç”¨æˆ·ç¨‹åºã€‚ æ­¤æ—¶ï¼Œç”¨æˆ·ç¨‹åºä¸­çš„MapReduce()å°†è¿”å›žç”¨æˆ·ä»£ç ã€‚ åºè¨€ï¼šç†Ÿæ‚‰æºä»£ç # æä¾›çš„Map/Reduceä»£ç æ”¯æŒä¸¤ç§æ“ä½œæ¨¡å¼ï¼Œå³ä¸²è¡Œå’Œåˆ†å¸ƒå¼ã€‚ åœ¨å‰è€…ä¸­ï¼Œmapå’Œreduceä»»åŠ¡æ¯æ¬¡æ‰§è¡Œä¸€ä¸ªï¼šé¦–å…ˆæ˜¯ç¬¬ä¸€ä¸ªmapä»»åŠ¡æ‰§è¡Œå®Œæˆï¼Œç„¶åŽæ˜¯ç¬¬äºŒä¸ªï¼Œç„¶åŽæ˜¯ç¬¬ä¸‰ä¸ªï¼Œç­‰ç­‰ã€‚å½“æ‰€æœ‰mapä»»åŠ¡å®ŒæˆåŽï¼Œæ‰§è¡Œç¬¬ä¸€ä¸ªreduceä»»åŠ¡ï¼Œç„¶åŽæ˜¯ç¬¬äºŒä¸ªï¼Œç­‰ç­‰ã€‚è¿™ç§æ¨¡å¼è™½ç„¶ä¸å¿«ï¼Œä½†æ–¹ä¾¿è°ƒè¯•ã€‚ åˆ†å¸ƒå¼æ¨¡å¼è¿è¡Œç€è®¸å¤šworkerçº¿ç¨‹ï¼Œè¿™äº›çº¿ç¨‹å…ˆå¹¶è¡Œæ‰§è¡Œmapä»»åŠ¡ï¼Œç„¶åŽreduceä»»åŠ¡ã€‚ è¿™è¦å¿«å¾—å¤šï¼Œä½†ä¹Ÿéš¾ä»¥è°ƒè¯•ã€‚mapreduceåŒ…æä¾›äº†ä¸€ä¸ªç®€å•çš„Map/Reduceåº“ã€‚ åº”ç”¨ç¨‹åºé€šå¸¸è°ƒç”¨master.goä¸­çš„Distributed()æ¥å¯åŠ¨åˆ†å¸ƒå¼æ¨¡å¼ï¼Œè€Œè°ƒç”¨master.goä¸­çš„Sequential()æ¥èŽ·å–è°ƒè¯•çš„ä¸²è¡Œæ‰§è¡Œã€‚ ä»£ç å¦‚ä¸‹æ‰§è¡Œï¼š è¯¥åº”ç”¨ç¨‹åºæä¾›äº†è®¸å¤šè¾“å…¥æ–‡ä»¶ã€ä¸€ä¸ªmapå‡½æ•°ã€ä¸€ä¸ªreduceå‡½æ•°å’Œreduceä»»åŠ¡çš„æ•°é‡ï¼ˆ$nReduce$ï¼‰ï¼› åˆ›å»ºmasterã€‚ masterå¯åŠ¨ä¸€ä¸ªRPCæœåŠ¡å™¨(å‚è§master_rpc.go)ï¼Œå¹¶ç­‰å¾…workeræ³¨å†Œ(ä½¿ç”¨RPCè°ƒç”¨Register()ï¼Œåœ¨master.goä¸­å®šä¹‰)ã€‚ å½“ä»»åŠ¡å˜å¾—å¯ç”¨æ—¶(åœ¨æ­¥éª¤4å’Œ5ä¸­)ï¼Œschedule()(ä½äºŽschedule.go)å†³å®šå¦‚ä½•å°†è¿™äº›ä»»åŠ¡åˆ†é…ç»™workersä»¥åŠå¦‚ä½•å¤„ç†workeræ•…éšœï¼› masterå°†æ¯ä¸ªè¾“å…¥æ–‡ä»¶è§†ä¸ºä¸€ä¸ª Mapä»»åŠ¡ï¼Œå¹¶ä¸ºæ¯ä¸ªMapä»»åŠ¡è‡³å°‘è°ƒç”¨ä¸€æ¬¡(at-least-once)doMap()(common_map.go)ï¼Œå¯ä»¥é€šè¿‡ç›´æŽ¥ä½¿ç”¨Sequential()æˆ–é€šè¿‡å‘worker (worker.go)å‘å‡ºDoTask RPCæ¥å®žçŽ°ã€‚æ¯æ¬¡è°ƒç”¨doMap()éƒ½ä¼šè¯»å–é€‚å½“çš„æ–‡ä»¶ï¼Œè°ƒç”¨è¯¥æ–‡ä»¶ä¸­çš„mapå‡½æ•°ï¼Œå¹¶å°†ç”Ÿæˆçš„é”®/å€¼å¯¹å†™å…¥$nReduce$ä¸ªä¸­é—´æ–‡ä»¶ã€‚doMap() å¯¹æ¯ä¸ªé”®å“ˆå¸ŒåŒ–ä»¥ä¾¿æŒ‘é€‰ä¸­é—´æ–‡ä»¶å’Œ å°†ä¼šå¤„ç†é”®çš„reduceä»»åŠ¡ã€‚ å®Œæˆæ‰€æœ‰mapä»»åŠ¡åŽï¼Œå°†ä¼šæœ‰$nMap \times nReduce$ä¸ªæ–‡ä»¶ã€‚ æ¯ä¸ªæ–‡ä»¶åéƒ½åŒ…å«ä¸€ä¸ªå‰ç¼€ï¼Œmapä»»åŠ¡ç¼–å·å’Œreduceä»»åŠ¡ç¼–å·ã€‚ å¦‚æžœæœ‰ä¸¤ä¸ªmapä»»åŠ¡å’Œä¸‰ä¸ªreduceä»»åŠ¡ï¼Œmapä»»åŠ¡å°†åˆ›å»ºå¦‚ä¸‹å…­ä¸ªä¸­é—´æ–‡ä»¶ï¼š mrtmp.xxx-0-0 mrtmp.xxx-0-1 mrtmp.xxx-0-2 mrtmp.xxx-1-0 mrtmp.xxx-1-1 mrtmp.xxx-1-2 æ¯ä¸ªworkerå¿…é¡»èƒ½å¤Ÿè¯»å–ç”±ä»»ä½•å…¶ä»–workerå†™å…¥çš„æ–‡ä»¶ä»¥åŠè¾“å…¥æ–‡ä»¶ã€‚ çŽ°å®žéƒ¨ç½²åˆ©ç”¨åˆ†å¸ƒå¼å­˜å‚¨ç³»ç»Ÿ(å¦‚GFS)æ¥å…è®¸æ­¤è¯»å–ï¼Œå³ä½¿workersåœ¨ä¸åŒçš„è®¡ç®—æœºä¸Šè¿è¡Œã€‚ åœ¨æœ¬å®žéªŒä¸­ï¼Œæ‚¨å°†åœ¨åŒä¸€å°è®¡ç®—æœºä¸Šè¿è¡Œæ‰€æœ‰workersï¼Œå¹¶ä½¿ç”¨æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿï¼› æŽ¥ä¸‹æ¥masterä¸ºæ¯ä¸ªreduceä»»åŠ¡è‡³å°‘è°ƒç”¨ä¸€æ¬¡(at-least-once) doReduce()(common_reduce.go)ã€‚ ä¸ŽdoMap()ä¸€æ ·ï¼Œå¯ä»¥ç›´æŽ¥æˆ–é€šè¿‡workeræ¥å®Œæˆã€‚ ç”¨äºŽreduceä»»åŠ¡rçš„`doReduce()ä»Žæ¯ä¸ªmapä»»åŠ¡ä¸­æ”¶é›†ç¬¬$r$ä¸ªä¸­é—´æ–‡ä»¶ï¼Œå¹¶ä¸ºè¿™äº›æ–‡ä»¶ä¸­å‡ºçŽ°çš„æ¯ä¸ªé”®è°ƒç”¨reduceå‡½æ•°ã€‚ reduceä»»åŠ¡ç”Ÿæˆ$nReduce$ä¸ªç»“æžœæ–‡ä»¶ï¼› masterè°ƒç”¨mr.merge()(master_splitmerge.go)ï¼Œå°†ä¸Šä¸€æ­¥ç”Ÿæˆçš„æ‰€æœ‰$nReduce$ä¸ªæ–‡ä»¶åˆå¹¶ä¸ºå•ä¸ªè¾“å‡ºï¼› masterå‘æ¯ä¸ªwokerå‘é€Shutdown RPCï¼Œç„¶åŽå…³é—­è‡ªå·±çš„RPCæœåŠ¡å™¨ã€‚ è¯´æ˜Žï¼šåœ¨åŽç»­çš„ç»ƒä¹ ä¸­ï¼Œæ‚¨å¿…é¡»ç¼–å†™/ä¿®æ”¹doMap()ï¼ŒdoReduce()å’Œschedule()ï¼Œå®ƒä»¬åˆ†åˆ«ä½äºŽcommon_map.goã€common_reduce.goå’Œschedule.goä¸­ã€‚ æ‚¨è¿˜å¿…é¡»åœ¨../main/wc.goä¸­ç¼–å†™mapå‡½æ•°å’Œreduceå‡½æ•°ã€‚ Part I: Map/Reduce è¾“å…¥å’Œè¾“å‡º# æä¾›çš„Map/Reduceå®žçŽ°ç¼ºå°‘éƒ¨åˆ†ä»£ç ã€‚ åœ¨ç¼–å†™ç¬¬ä¸€ä¸ªMap/Reduceå‡½æ•°å¯¹ä¹‹å‰ï¼Œæ‚¨éœ€è¦ä¿®æ”¹sequentialçš„å®žçŽ°ä»£ç ã€‚ ç‰¹åˆ«æ˜¯ï¼Œæä¾›çš„ä»£ç ç¼ºå°‘ä¸¤ä¸ªå…³é”®éƒ¨åˆ†ï¼šåˆ†é…ä¸€ä¸ªmapä»»åŠ¡è¾“å‡ºçš„å‡½æ•°ï¼Œä»¥åŠæ”¶é›†ä¸€ä¸ªreduceä»»åŠ¡æ‰€æœ‰è¾“å…¥çš„å‡½æ•°ã€‚ è¿™äº›ä»»åŠ¡åˆ†åˆ«ç”±common_map.goä¸­çš„doMap()å‡½æ•°å’Œcommon_reduce.goä¸­çš„doReduce()å‡½æ•°æ‰§è¡Œã€‚ ä¸ºäº†å¸®åŠ©æ‚¨ç¡®å®šæ˜¯å¦æ­£ç¡®å®žçŽ°äº†doMap()å’ŒdoReduce()ï¼Œæˆ‘ä»¬ä¸ºæ‚¨æä¾›äº†ä¸€ä¸ªGoæµ‹è¯•å¥—ä»¶(test_test.go)ç”¨äºŽæ£€æŸ¥æ–‡ä»¶ä¸­å®žçŽ°ã€‚ ä¾‹å¦‚æµ‹è¯•ä¿®æ”¹åŽçš„sequenceå®žçŽ°ä»£ç ï¼Œè¯·è¿è¡Œï¼š go test -run Sequential or go test -v -run Sequential è§£ç­”ï¼š è¯¥éƒ¨åˆ†ä»»åŠ¡åªéœ€è¦è¡¥å…¨common_map.goä¸­çš„doMap()å’Œcommon_reduce.goä¸­çš„doReduce()çš„ä»£ç ï¼Œè¡¥å…¨çš„ç»“æžœå¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package mapreduceimport ( "hash/fnv" "io/ioutil" "encoding/json" "log" "os")func doMap( jobName string, // the name of the MapReduce job mapTask int, // which map task this is inFile string, nReduce int, // the number of reduce task that will be run ("R" in the paper) mapF func(filename string, content string) []KeyValue,) &#123; // // doMap manages one map task: it should read one of the input files // (inFile), call the user-defined map function (mapF) for that file's // content, and partition mapF's output into nReduce intermediate files. // // There is one intermediate file per reduce task. The file name // includes both the map task number and the reduce task number. Use // the filename generated by reduceName(jobName, mapTask, r) // as the intermediate file for reduce task r. Call ihash() (see // below) on each key, mod nReduce, to pick r for a key/value pair. // // mapF() is the map function provided by the application. The first // argument should be the input file name, though the map function // typically ignores it. The second argument should be the entire // input file content. mapF() returns a slice containing the // key/value pairs for reduce; see common.go for the definition of // KeyValue. // // Look at Go's ioutil and os packages for functions to read // and write files. // // Coming up with a scheme for how to format the key/value pairs on // disk can be tricky, especially when taking into account that both // keys and values could contain newlines, quotes, and any other // character you can think of. // // One format often used for serializing data to a byte stream that the // other end can correctly reconstruct is JSON. You are not required to // use JSON, but as the output of the reduce tasks *must* be JSON, // familiarizing yourself with it here may prove useful. You can write // out a data structure as a JSON string to a file using the commented // code below. The corresponding decoding functions can be found in // common_reduce.go. // // enc := json.NewEncoder(file) // for _, kv := ... &#123; // err := enc.Encode(&amp;kv) // // Remember to close the file after you have written all the values! // // Your code here (Part I). //è¯»å–è¾“å…¥æ–‡ä»¶ content, err := ioutil.ReadFile(inFile) if err != nil &#123; log.Fatal("doMapè¯»å–è¾“å…¥æ–‡ä»¶é”™è¯¯",err) &#125; //mapæ“ä½œ kvPairs := mapF(inFile, string(content)) //è°ƒç”¨mapFï¼Œè¿”å›žé”®å€¼å¯¹ //å°†é”®å€¼å¯¹å†™å…¥åˆ°ä¸­é—´æ–‡ä»¶ tmpFiles := make([] *os.File, nReduce) //Rä¸ªä¸­é—´æ–‡ä»¶ encoders := make([] *json.Encoder, nReduce) for i := 0; i &lt; nReduce; i++ &#123; tmpFileName := reduceName(jobName, mapTask, i) //ä¸­é—´æ–‡ä»¶å,mrtmp.test-mapTask-i tmpFiles[i], err = os.Create(tmpFileName) //åˆ›å»ºä¸­é—´æ–‡ä»¶mrtmp.test-mapTask-i if err != nil &#123; log.Fatal("doMapç”Ÿæˆä¸­é—´æ–‡ä»¶é”™è¯¯", err) &#125; defer tmpFiles[i].Close() encoders[i] = json.NewEncoder(tmpFiles[i]) if err != nil &#123; log.Fatal("doMapç¼–ç é”™è¯¯", err) &#125; &#125; for _ , kv := range kvPairs &#123; hashKey := ihash(kv.Key) % nReduce //æ ¹æ®é”®å°†é”®å€¼å¯¹åˆ†æˆRç»„ err := encoders[hashKey].Encode(&amp;kv) //å°†Rä¸ªé”®å€¼å¯¹å†™å…¥Rä¸ªä¸­é—´æ–‡ä»¶ if err != nil &#123; log.Fatal("doMapç¼–ç é”™è¯¯", err) &#125; &#125;&#125;func ihash(s string) int &#123; h := fnv.New32a() h.Write([]byte(s)) return int(h.Sum32() &amp; 0x7fffffff)&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package mapreduceimport ( "encoding/json" "log" "os" "sort")func doReduce( jobName string, // the name of the whole MapReduce job reduceTask int, // which reduce task this is outFile string, // write the output here nMap int, // the number of map tasks that were run ("M" in the paper) reduceF func(key string, values []string) string,) &#123; // // doReduce manages one reduce task: it should read the intermediate // files for the task, sort the intermediate key/value pairs by key, // call the user-defined reduce function (reduceF) for each key, and // write reduceF's output to disk. // // You'll need to read one intermediate file from each map task; // reduceName(jobName, m, reduceTask) yields the file // name from map task m. // // Your doMap() encoded the key/value pairs in the intermediate // files, so you will need to decode them. If you used JSON, you can // read and decode by creating a decoder and repeatedly calling // .Decode(&amp;kv) on it until it returns an error. // // You may find the first example in the golang sort package // documentation useful. // // reduceF() is the application's reduce function. You should // call it once per distinct key, with a slice of all the values // for that key. reduceF() returns the reduced value for that key. // // You should write the reduce output as JSON encoded KeyValue // objects to the file named outFile. We require you to use JSON // because that is what the merger than combines the output // from all the reduce tasks expects. There is nothing special about // JSON -- it is just the marshalling format we chose to use. Your // output code will look something like this: // // enc := json.NewEncoder(file) // for key := ... &#123; // enc.Encode(KeyValue&#123;key, reduceF(...)&#125;) // &#125; // file.Close() // // Your code here (Part I). //éåŽ†å±žäºŽè‡ªå·±çš„ä¸­é—´æ–‡ä»¶ï¼Œå°†é”®å€¼å¯¹åˆå¹¶åˆ°kvsä¸­ kvs := make(map[string][]string) for i := 0; i &lt; nMap; i++ &#123; fileName := reduceName(jobName, i, reduceTask) file, err := os.Open(fileName) //æ‰“å¼€ä¸­é—´æ–‡ä»¶mrtmp.test-i-reduceTask if err != nil &#123; log.Fatal("doReduceæ‰“å¼€æ–‡ä»¶é”™è¯¯", err) &#125; dec := json.NewDecoder(file) for &#123; //æ¯ä¸ªä¸­é—´æ–‡ä»¶å¯èƒ½åŒ…å«å¤šä¸ªé”®å€¼å¯¹ var kv KeyValue err = dec.Decode(&amp;kv) //è§£ç ä¸€ä¸ªé”®å€¼å¯¹ if err != nil &#123; break &#125; _, ok := kvs[kv.Key] if !ok &#123; //å‡ºçŽ°æ–°çš„é”®åˆ™åˆå§‹åŒ–kvs kvs[kv.Key] = []string&#123;&#125; &#125; kvs[kv.Key] = append(kvs[kv.Key], kv.Value) //åŠ å…¥ä¸Žé”®å¯¹åº”çš„å€¼ &#125; file.Close() &#125; //å°†é”®é›†åˆåˆ°ä¸€èµ·å¹¶æŽ’åº var keys []string for k := range kvs &#123; keys = append(keys, k) &#125; sort.Strings(keys) //åˆ›å»ºè¾“å‡ºæ–‡ä»¶ out := mergeName(jobName, reduceTask) file, err := os.Create(out) if err != nil &#123; log.Fatal("doReduceåˆ›å»ºè¾“å‡ºæ–‡ä»¶é”™è¯¯", err) &#125; enc := json.NewEncoder(file) //reduceæ“ä½œ for _, k := range keys &#123; res := reduceF(k, kvs[k]) //è°ƒç”¨å®¢æˆ·ç«¯çš„reduceFï¼Œè¿›è¡Œreduce enc.Encode(KeyValue&#123;k, res&#125;) //reduceåŽçš„é”®å€¼å¯¹å†™å…¥åˆ°è¾“å‡ºæ–‡ä»¶ &#125; file.Close()&#125; è¿è¡Œgo test -run Sequentialï¼Œç»“æžœå¦‚ä¸‹ï¼š Part II: Single-workerå•è¯ç»Ÿè®¡# åœ¨è¯¥éƒ¨åˆ†ï¼Œæ‚¨å°†è¦å®žçŽ°ä¸€ä¸ªç®€å•çš„Map/Reduceç¤ºä¾‹â€”â€”å•è¯ç»Ÿè®¡ã€‚ å…·ä½“æ˜¯éœ€è¦å®žçŽ°main/wc.goä¸­çš„mapF()å’ŒreduceF()å‡½æ•°ã€‚ æ‚¨çš„å·¥ä½œæ˜¯æ’å…¥ä»£ç ï¼Œä»¥ä¾¿wc.goè¿”å›žè¾“å…¥æ–‡ä»¶ä¸­æ¯ä¸ªå•è¯å‡ºçŽ°çš„æ¬¡æ•°ã€‚ ä¸€ä¸ªå•è¯æ˜¯ä»»æ„è¿žç»­çš„å­—æ¯åºåˆ—ï¼Œå…¶ä¸­å­—æ¯å¯ç”¨Golangçš„unicode.IsLetterå‡½æ•°æ¥åˆ¤æ–­ã€‚ åœ¨~/6.824/src/mainç›®å½•ä¸­æä¾›äº†ä¸€äº›è·¯å¾„åä¸ºpg-*.txtå½¢å¼çš„è¾“å…¥æ–‡ä»¶ï¼Œ å¯ç”¨å¦‚ä¸‹å‘½ä»¤ç»™wc.goä½¿ç”¨è¾“å…¥æ–‡ä»¶è¿è¡Œï¼š go run wc.go master sequential pg-*.txt æŸ¥çœ‹MapReduceè®ºæ–‡çš„ç¬¬2éƒ¨åˆ†ã€‚mapF()å’ŒreduceF()å‡½æ•°ä¸Žè®ºæ–‡ç¬¬2.1èŠ‚ä¸­çš„å‡½æ•°ç•¥æœ‰ä¸åŒã€‚mapF()å°†æŽ¥æ”¶ä¸€ä¸ªæ–‡ä»¶åå’Œè¯¥æ–‡ä»¶çš„å†…å®¹ï¼Œå¹¶å°†å†…å®¹åˆ†æˆå•è¯æœ€ç»ˆè¾“å‡ºä¸€ä¸ªmapreduce.KeyValueåž‹åˆ‡ç‰‡ã€‚ å¯¹äºŽå•è¯ç»Ÿè®¡å¯å°†å•è¯ä½œä¸ºé”®ã€‚å¯¹è¾“å‡ºä¸­çš„æ¯ä¸ªé”®éƒ½å°†è°ƒç”¨ä¸€æ¬¡reduceF()ï¼Œå…¶ä¸­åŒ…å«mapF()ä¸ºè¯¥é”®ç”Ÿæˆçš„æ‰€æœ‰å€¼çš„åˆ‡ç‰‡ã€‚ reduceF()è¿”å›žä¸€ä¸ªåŒ…å«é”®å‡ºçŽ°æ€»æ•°çš„å­—ç¬¦ä¸²ã€‚ æç¤º1ï¼šå…³äºŽGoçš„å­—ç¬¦ä¸²å¤„ç†ï¼Œå¯ä»¥å‚è¯» Go Blog on strings æç¤º2ï¼šå¯ä»¥ä½¿ç”¨strings.FieldsFuncå‡½æ•°å°†å­—ç¬¦ä¸²æ‹†åˆ†æˆå•è¯ æç¤º3ï¼š åˆ©ç”¨Goçš„strconvåŒ…å¯ä»¥å¾ˆæ–¹ä¾¿åœ°å°†å­—ç¬¦ä¸²è½¬æ¢æˆæ•´åž‹ ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤æ¥éªŒè¯ç­”æ¡ˆï¼š go run wc.go master sequential pg-*.txt ç­”æ¡ˆï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package mainimport ( "fmt" "mapreduce" "os" "strconv" "strings" "unicode")//// The map function is called once for each file of input. The first// argument is the name of the input file, and the second is the// file's complete contents. You should ignore the input file name,// and look only at the contents argument. The return value is a slice// of key/value pairs.//func mapF(filename string, contents string) []mapreduce.KeyValue &#123; // Your code here (Part II). var res []mapreduce.KeyValue f := func(c rune) bool &#123; //ä¸æ˜¯å­—æ¯ return !unicode.IsLetter(c) &#125; words := strings.FieldsFunc(contents, f) //åœ¨ä¸æ˜¯å­—æ¯åœ°æ–¹æ‹†åˆ†å­—ç¬¦ä¸²contents for _, key := range words &#123; res = append(res, mapreduce.KeyValue&#123;key, "1"&#125;) &#125; return res&#125;//// The reduce function is called once for each key generated by the// map tasks, with a list of all the values created for that key by// any map task.//func reduceF(key string, values []string) string &#123; // Your code here (Part II). count := 0 for _, value := range values &#123; num, _ := strconv.ParseInt(value, 10, 64) // å°†å­—ç¬¦ä¸²valueï¼ˆä¾‹å¦‚ï¼š"157"ï¼‰æŒ‰ç…§åè¿›åˆ¶è½¬æ¢æˆæ•´åž‹ count = count + int(num) &#125; return strconv.Itoa(count) //æ•´åž‹è½¬æ¢æˆå­—ç¬¦ä¸²&#125;// Can be run in 3 ways:// 1) Sequential (e.g., go run wc.go master sequential x1.txt .. xN.txt)// 2) Master (e.g., go run wc.go master localhost:7777 x1.txt .. xN.txt)// 3) Worker (e.g., go run wc.go worker localhost:7777 localhost:7778 &amp;)func main() &#123; if len(os.Args) &lt; 4 &#123; fmt.Printf("%s: see usage comments in file\n", os.Args[0]) &#125; else if os.Args[1] == "master" &#123; var mr *mapreduce.Master if os.Args[2] == "sequential" &#123; mr = mapreduce.Sequential("wcseq", os.Args[3:], 3, mapF, reduceF) &#125; else &#123; mr = mapreduce.Distributed("wcseq", os.Args[3:], 3, os.Args[2]) &#125; mr.Wait() &#125; else &#123; mapreduce.RunWorker(os.Args[2], os.Args[3], mapF, reduceF, 100, nil) &#125;&#125; è¿è¡Œgo run wc.go master sequential pg-sherlock_holmes.txtå’Œsort -n -k2 mrtmp.wcseq | tail -10çš„ç»“æžœï¼š Part III: åˆ†å¸ƒå¼ MapReduce ä»»åŠ¡# åœ¨å½“å‰çš„å®žçŽ°ä¸­ï¼Œæ˜¯é€šè¿‡ä¸²è¡Œçš„æ–¹å¼æ¥æ‰§è¡ŒMapä»»åŠ¡å’ŒReduceä»»åŠ¡ã€‚ Map/Reduceæœ€å¤§çš„å–ç‚¹ä¹‹ä¸€æ˜¯å®ƒå¯ä»¥è‡ªåŠ¨åœ°å¹¶è¡Œæ‰§è¡ŒåŽŸå§‹çš„ä¸²è¡Œä»£ç è€Œæ— éœ€å¼€å‘äººå‘˜çš„ä»»ä½•é¢å¤–å·¥ä½œã€‚ åœ¨è¿™ä¸€éƒ¨åˆ†ä¸­ï¼Œæ‚¨å°†å®Œæˆä¸€ä¸ªåˆ†å¸ƒå¼MapReduceç‰ˆæœ¬ï¼Œå³å°†å·¥ä½œæ‹†åˆ†ä¸ºåœ¨å¤šæ ¸ä¸Šè¿è¡Œçš„ä¸€ç»„workerçº¿ç¨‹ã€‚ å°½ç®¡ä¸åƒçœŸå®žçš„Map/Reduceéƒ¨ç½²è¢«åˆ†å¸ƒåœ¨å¤šå°æœºå™¨ä¸Šé‚£æ ·ï¼Œä½†ä½ æœ¬éƒ¨åˆ†çš„å®žçŽ°ä¸­å°†ä½¿ç”¨RPCæ¥æ¨¡æ‹Ÿåˆ†å¸ƒå¼è®¡ç®—ã€‚ mapreduce/master.goä¸­çš„ä»£ç å®Œæˆäº†ç®¡ç†MapReduceçš„å¤§éƒ¨åˆ†å·¥ä½œã€‚ æˆ‘ä»¬è¿˜ä¸ºæ‚¨æä¾›äº†mapreduce/worker.goä¸­workerçº¿ç¨‹çš„å®Œæ•´ä»£ç ä»¥åŠåœ¨mapreduce/common_rpc.goä¸­å¤„ç†RPCçš„ä¸€äº›ä»£ç ã€‚ ä½ çš„ä»»åŠ¡æ˜¯å®žçŽ°mapreduce/schedule.goä¸­çš„schedule()å‡½æ•°ã€‚ masteråœ¨MapReduceæœŸé—´å°†ä¸¤æ¬¡è°ƒç”¨schedule()ï¼Œä¸€æ¬¡ç”¨äºŽMapé˜¶æ®µï¼Œä¸€æ¬¡ç”¨äºŽReduceé˜¶æ®µã€‚ schedule()çš„åŠŸèƒ½æ˜¯å°†ä»»åŠ¡åˆ†å‘ç»™å¯ç”¨çš„workerã€‚ ä»»åŠ¡çš„æ•°é‡é€šå¸¸æ¯”workerçº¿ç¨‹å¤šï¼Œå› æ­¤schedule()å¿…é¡»ä¸ºæ¯ä¸ªworkeråˆ†é…ä¸€ç³»åˆ—ä»»åŠ¡ï¼Œä¸€æ¬¡ä¸€ä¸ªã€‚ schedule()åº”è¯¥ç­‰åˆ°æ‰€æœ‰ä»»åŠ¡éƒ½å®ŒæˆåŽå†è¿”å›žã€‚ schedule()é€šè¿‡è¯»å–registerChanå‚æ•°æ¥äº†è§£ä¸€ç»„workerã€‚ è¯¥channelä¸ºæ¯ä¸ªworkerç”Ÿæˆä¸€ä¸ªåŒ…å«workerçš„RPCåœ°å€çš„å­—ç¬¦ä¸²ã€‚æ‰€æœ‰çš„workeréƒ½ä¼šå‡ºçŽ°åœ¨registerChanï¼Œå…¶ä¸­ä¸€äº›workerå¯èƒ½åœ¨è°ƒç”¨schedule()ä¹‹å‰å°±å­˜åœ¨ï¼Œè€Œå¦ä¸€äº›workerå¯èƒ½åœ¨schedule()è¿è¡Œæ—¶æ‰å¯åŠ¨ã€‚schedule()åº”è¯¥å……åˆ†åˆ©ç”¨æ‰€æœ‰çš„workerï¼ŒåŒ…æ‹¬å¯åŠ¨åŽå‡ºçŽ°çš„workerã€‚ schedule()é€šè¿‡å‘workerå‘é€Worker.DoTaskRPCæ¥é€šçŸ¥workeræ‰§è¡Œä»»åŠ¡ã€‚ æ­¤RPCçš„å‚æ•°ç”±mapreduce/common_rpc.goä¸­çš„DoTaskArgså®šä¹‰ã€‚Fileå…ƒç´ ä»…ç”±Mapä»»åŠ¡ä½¿ç”¨ï¼Œä»£è¡¨è¦è¯»å–çš„æ–‡ä»¶çš„åç§°ï¼›schedule()å¯ä»¥åœ¨mapFilesä¸­æ‰¾åˆ°è¿™äº›æ–‡ä»¶åã€‚ ä½¿ç”¨mapreduce/common_rpc.goä¸­çš„call()å‡½æ•°å°†RPCå‘é€ç»™workerã€‚ ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯workerçš„åœ°å€ï¼Œä»ŽregisterChanè¯»å–ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯Worker.DoTaskï¼Œ ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯DoTaskArgsç»“æž„ï¼Œæœ€åŽä¸€ä¸ªå‚æ•°æ˜¯nilã€‚ æ‚¨å¯¹åœ¨ç¬¬IIIéƒ¨åˆ†çš„è§£ç­”ä»…æ¶‰åŠå¯¹schedule.goçš„ä¿®æ”¹ï¼›å¦‚æžœæ‚¨åœ¨è°ƒè¯•è¿‡ç¨‹ä¸­ä¿®æ”¹äº†å…¶ä»–æ–‡ä»¶ï¼Œè¯·æ¢å¤å…¶åŽŸå§‹å†…å®¹ã€‚è¯·å…ˆæµ‹è¯•å†æäº¤ã€‚ ä½¿ç”¨go test -run TestParallelæ¥æµ‹è¯•æ‚¨çš„ç­”æ¡ˆã€‚ è¯¥å‘½ä»¤å°†æ‰§è¡Œä¸¤ä¸ªæµ‹è¯•ï¼ŒTestParallelBasicå’ŒTestParallelCheckï¼ŒåŽè€…éªŒè¯æ‚¨çš„schedule()æ˜¯å¦ä½¿workerå¹¶è¡Œæ‰§è¡Œä»»åŠ¡ã€‚ æç¤º1ï¼šschedule()åº”è¯¥å¹¶è¡Œåœ°å‘workerå‘é€RPCï¼Œä»¥ä¾¿workerå¯ä»¥å¹¶å‘æ‰§è¡Œä»»åŠ¡ã€‚ ä½ ä¼šå‘çŽ°goè¯­å¥å¯¹æ­¤å¾ˆæœ‰ç”¨ï¼Œå‚è§Concurrency in Goã€‚ æç¤º2ï¼šschedule()å¿…é¡»ç­‰å¾…workerå®Œæˆä¸€ä¸ªä»»åŠ¡åŽæ‰èƒ½ç»™å®ƒå¦ä¸‹ä¸€ä¸ªä»»åŠ¡ï¼ŒGoçš„channelå¯¹æ­¤å¾ˆæœ‰ç”¨ã€‚ æç¤º3ï¼š sync.WaitGroup æç¤º4ï¼šè¿½è¸ªé”™è¯¯çš„æœ€ç®€å•çš„æ–¹æ³•æ˜¯æ’å…¥printè¯­å¥ï¼ˆåœ¨common.goä¸­å¯èƒ½æ˜¯è°ƒç”¨debug()ï¼‰ï¼Œä½¿ç”¨go test -run TestParallel &gt; outå°†è¾“å‡ºæ”¶é›†åˆ°ä¸€ä¸ªæ–‡ä»¶ä¸­ï¼Œç„¶åŽåˆ†æžè¾“å‡ºæ˜¯å¦ä¸Žä½ å¯¹ä»£ç çš„é¢„æœŸç›¸ç¬¦ã€‚ æœ€åŽä¸€æ­¥æ˜¯æœ€é‡è¦çš„ã€‚ æç¤º5ï¼šæ£€æŸ¥æ‚¨çš„ä»£ç æ˜¯å¦æœ‰ç«žäº‰çš„æƒ…å†µå¯åœ¨æµ‹è¯•ä¸­è¿è¡Œrace detectorã€‚ æ³¨æ„ï¼šæˆ‘ä»¬æä¾›çš„ä»£ç æ˜¯åœ¨å•ä¸ªUNIXè¿›ç¨‹ä¸­å°†workerä½œä¸ºçº¿ç¨‹è¿è¡Œï¼Œå¹¶ä¸”å¯ä»¥åœ¨å•å°æœºå™¨ä¸Šä½¿ç”¨å¤šæ ¸ã€‚ è¦æƒ³åœ¨ä½¿ç”¨ç½‘ç»œè¿›è¡Œé€šä¿¡çš„å¤šå°æœºå™¨ä¸Šè¿è¡Œworkerå¿…é¡»è¿›è¡Œä¸€äº›ä¿®æ”¹ï¼šRPCå¿…é¡»ä½¿ç”¨TCPè€Œä¸æ˜¯UNIX-domainå¥—æŽ¥å­—ï¼›éœ€è¦æœ‰ä¸€ç§æ–¹æ³•æ¥å¯åŠ¨æ‰€æœ‰æœºå™¨ä¸Šçš„workerè¿›ç¨‹ï¼›æ‰€æœ‰çš„æœºå™¨éƒ½å¿…é¡»é€šè¿‡æŸç§ç½‘ç»œæ–‡ä»¶ç³»ç»Ÿå…±äº«å­˜å‚¨ã€‚ ç­”æ¡ˆè§Part IVã€‚ Part IV: workeré”™è¯¯å¤„ç†# åœ¨è¿™éƒ¨åˆ†ä¸­ï¼Œæ‚¨å°†å®žçŽ°masterå¤„ç†å¤±è´¥çš„workerçš„åŠŸèƒ½ã€‚ç”±äºŽworkerçš„çŠ¶æ€ä¸æ˜¯æŒä¹…çš„ï¼Œè¯¥åŠŸèƒ½åœ¨MapReduceä¸­ç›¸å¯¹å®¹æ˜“å®žçŽ°ã€‚ å¦‚æžœworkeråœ¨å¤„ç†æ¥è‡ªmasterçš„RPCæ—¶å‘ç”Ÿé”™è¯¯ï¼Œmasterçš„call()æœ€ç»ˆä¼šå› è¶…æ—¶è€Œè¿”å›žfalseã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œmasterä¼šå°†è¯¥ä»»åŠ¡é‡æ–°åˆ†é…ç»™å¦ä¸€ä¸ªworkerã€‚ RPCæ•…éšœå¹¶ä¸ä¸€å®šæ„å‘³ç€workeræ²¡æœ‰æ‰§è¡Œä»»åŠ¡ï¼›workerå¯èƒ½å·²æ‰§è¡Œä»»åŠ¡ä½†æ˜¯è¿”å›žç»“æžœä¸¢å¤±ï¼Œæˆ–è€…workerå¯èƒ½ä»åœ¨æ‰§è¡Œä½†masterçš„RPCè¶…æ—¶ã€‚å› æ­¤ï¼Œå¯èƒ½ä¼šå‘ç”Ÿä¸¤ä¸ªworkeræŽ¥æ”¶ç›¸åŒä»»åŠ¡ã€è®¡ç®—å¹¶äº§ç”Ÿè¾“å‡ºçš„æƒ…å†µã€‚ éœ€è¦å¯¹mapæˆ–reduceå‡½æ•°è¿›è¡Œä¸¤æ¬¡è°ƒç”¨æ‰èƒ½ä¸ºç»™å®šè¾“å…¥ç”Ÿæˆç›¸åŒçš„è¾“å‡ºï¼Œå› æ­¤å¦‚æžœåŽç»­å¤„ç†è¯»å–ä¸€ä¸ªè¾“å‡ºæˆ–è€…è¯»å–å¦ä¸€ä¸ªè¾“å‡ºï¼Œåˆ™ä¸ä¼šå‡ºçŽ°ä¸ä¸€è‡´ã€‚ æ­¤å¤–ï¼ŒMapReduceæ¡†æž¶ç¡®ä¿mapå’Œreduceå‡½æ•°è¾“å‡ºä»¥åŽŸå­æ–¹å¼å‡ºçŽ°ï¼šè¾“å‡ºæ–‡ä»¶è¦ä¹ˆä¸å­˜åœ¨ï¼Œè¦ä¹ˆåŒ…å«å•ä¸ªmapæˆ–å•ä¸ªreduceå‡½æ•°æ‰§è¡Œçš„æ•´ä¸ªè¾“å‡ºï¼ˆæä¾›çš„ä»£ç ä¸æ¶‰åŠè¿™éƒ¨åˆ†ï¼‰ã€‚ æ‚¨çš„å®žçŽ°å¿…é¡»é€šè¿‡test_test.goä¸­å‰©ä¸‹çš„ä¸¤ä¸ªæµ‹è¯•ç”¨ä¾‹ã€‚ ç¬¬ä¸€ä¸ªç”¨ä¾‹æµ‹è¯•ä¸€ä¸ªworkerçš„å¤±è´¥ï¼Œè€Œç¬¬äºŒä¸ªæµ‹è¯•ç”¨ä¾‹æµ‹è¯•å¯¹å¤šä¸ªworkerçš„å¤±è´¥çš„å¤„ç†ã€‚ æµ‹è¯•ç”¨ä¾‹ä¼šå®šæœŸå¯åŠ¨æ–°çš„workerï¼Œmasterå¯ä»¥ä½¿ç”¨è¿™äº›workeræ¥æŽ¨è¿›ç¨‹åºè¿‡ç¨‹ï¼Œä½†è¿™äº›workeråœ¨å¤„ç†å®Œä¸€äº›ä»»åŠ¡åŽä¼šå¤±è´¥ã€‚ ä½¿ç”¨ä¸‹é¢çš„å‘½ä»¤æ¥è¿è¡Œæµ‹è¯•ï¼š go test -run Failure åœ¨ç¬¬IVéƒ¨åˆ†ï¼Œåªæ¶‰åŠå¯¹schedule.goçš„ä¿®æ”¹ã€‚ å¦‚æžœæ‚¨åœ¨è°ƒè¯•è¿‡ç¨‹ä¸­ä¿®æ”¹äº†å…¶ä»–æ–‡ä»¶ï¼Œè¯·æ¢å¤å…¶åŽŸå§‹å†…å®¹ï¼Œç„¶åŽå†è¿›è¡Œæµ‹è¯•ã€æäº¤ã€‚ Part IIIã€Part IVç­”æ¡ˆï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package mapreduceimport "fmt"//// schedule() starts and waits for all tasks in the given phase (mapPhase// or reducePhase). the mapFiles argument holds the names of the files that// are the inputs to the map phase, one per map task. nReduce is the// number of reduce tasks. the registerChan argument yields a stream// of registered workers; each item is the worker's RPC address,// suitable for passing to call(). registerChan will yield all// existing registered workers (if any) and new ones as they register.//func schedule(jobName string, mapFiles []string, nReduce int, phase jobPhase, registerChan chan string) &#123; var ntasks int var n_other int // number of inputs (for reduce) or outputs (for map) switch phase &#123; case mapPhase: ntasks = len(mapFiles) n_other = nReduce case reducePhase: ntasks = nReduce n_other = len(mapFiles) &#125; fmt.Printf("Schedule: %v %v tasks (%d I/Os)\n", ntasks, phase, n_other) // All ntasks tasks have to be scheduled on workers. Once all tasks // have completed successfully, schedule() should return. // // Your code here (Part III, Part IV). // done := make(chan bool) for i := 0; i &lt; ntasks; i++ &#123; go func(num int) &#123; args := DoTaskArgs&#123;jobName, mapFiles[num], phase, num, n_other&#125; var worker string reply := new(struct&#123;&#125;) ok := false for ok != true &#123; worker = &lt;-registerChan ok = call(worker, "Worker.DoTask", args, reply) &#125; done &lt;- true //ä»»åŠ¡å®Œæˆ registerChan &lt;- worker //è¯¥workerå·¥ä½œå®Œæ¯•ï¼Œå¤„äºŽç©ºé—²ï¼ŒåŠ å…¥channelä¸­ä»¥åˆ†é…ç»™å…¶å®ƒä»»åŠ¡ &#125;(i) &#125; for i := 0; i &lt; ntasks; i++ &#123; //ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ &lt;-done &#125; fmt.Printf("Schedule: %v done\n", phase)&#125; è¿è¡Œgo test -run TestParallelçš„ç»“æžœï¼š]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>MapReduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è¿œç¨‹è¿‡ç¨‹è°ƒç”¨å’Œçº¿ç¨‹(RPC and Thread)]]></title>
    <url>%2F2019%2F03%2F25%2F2019-3-25%2F</url>
    <content type="text"><![CDATA[MIT Distributed System Course: Lecture 2 Remote Procedure Call (RPC) ç›®æ ‡ï¼š å»ºç«‹ç¼–ç¨‹å‹å¥½çš„å®¢æˆ·ç«¯/æœåŠ¡å™¨é€šä¿¡ RPCæ¶ˆæ¯å›¾ï¼š å®¢æˆ·ç«¯ æœåŠ¡å™¨ è¯·æ±‚---&gt; &lt;---å“åº” è½¯ä»¶ç»“æž„ï¼š client app handlers stubs dispatcher RPC lib RPC lib net ------------ net Go rpcåŒ…ï¼š å®˜æ–¹æ–‡æ¡£ import &quot;net/rpc rpcåŒ…æä¾›å¯¹é€šè¿‡ç½‘ç»œæˆ–å…¶ä»–I / Oè¿žæŽ¥çš„å¯¹è±¡çš„å¯¼å‡ºæ–¹æ³•çš„è®¿é—®ã€‚ æœåŠ¡å™¨æ³¨å†Œä¸€ä¸ªå¯¹è±¡ï¼Œå¹¶ä½œä¸ºä¸€ç§æœåŠ¡å¯è§ã€‚ æ³¨å†Œçš„å¯¹è±¡å…¶å¯¼å‡ºæ–¹æ³•å¯ä»¥è¢«è¿œç¨‹è®¿é—®ã€‚ æœåŠ¡å™¨å¯ä»¥æ³¨å†Œä¸åŒç±»åž‹çš„å¤šä¸ªå¯¹è±¡ï¼ˆæœåŠ¡ï¼‰ï¼Œä½†æ˜¯æ³¨å†Œç›¸åŒç±»åž‹çš„å¤šä¸ªå¯¹è±¡æ˜¯é”™è¯¯çš„ã€‚ åªæœ‰æ»¡è¶³ä¸‹åˆ—æ ‡å‡†çš„æ–¹æ³•ï¼ˆmethodï¼‰æ‰èƒ½è¢«è¿œç¨‹è®¿é—®ï¼š the method's type is exported. the method is exported. the method has two arguments, both exported (or builtin) types. the method's second argument is a pointer. the method has return type error. å®žé™…ä¸Šï¼Œè¯¥æ–¹æ³•å¿…é¡»çœ‹èµ·æ¥åƒ 1func (t *T) MethodName(argType T1, replyType *T2) error å…¶ä¸­T1å’ŒT2å¯ä»¥é€šè¿‡ encoding/gobåŒ…æ¥ç¼–ç ã€‚å³ä¾¿ä½¿ç”¨ä¸åŒçš„ç¼–è§£ç å™¨ï¼Œä¸Šè¿°æ ‡å‡†ä»ç„¶é€‚ç”¨ã€‚ ç¬¬ä¸€ä¸ªå‚æ•°T1è¡¨ç¤ºè°ƒç”¨è€…æä¾›çš„å‚æ•°;ç¬¬äºŒä¸ªå‚æ•°T2è¡¨ç¤ºè¦è¿”å›žç»™è°ƒç”¨è€…çš„ç»“æžœå‚æ•°ã€‚æœåŠ¡å™¨å¯ä»¥é€šè¿‡è°ƒç”¨ServeConnæ¥å¤„ç†å•ä¸ªè¿žæŽ¥ä¸Šçš„è¯·æ±‚ã€‚æ›´å…¸åž‹çš„ä¾‹å­æœ‰åˆ›å»ºç½‘ç»œä¾¦å¬å™¨å¹¶è°ƒç”¨Acceptï¼Œåˆ›å»ºHTTPä¾¦å¬å™¨å¹¶è°ƒç”¨HandleHTTPå’Œhttp.Serveã€‚ å¸Œæœ›ä½¿ç”¨è¯¥æœåŠ¡çš„å®¢æˆ·ç«¯é¦–å…ˆå’ŒæœåŠ¡å™¨å»ºç«‹è¿žæŽ¥ï¼Œç„¶åŽåœ¨è¿žæŽ¥çš„åŸºç¡€ä¸Šè°ƒç”¨NewClientã€‚å¯ä»¥ä½¿ç”¨Dialå‡½æ•°ï¼ˆDialHTTPï¼‰æ–¹ä¾¿åœ°æ‰§è¡ŒåŽŸå§‹ç½‘ç»œè¿žæŽ¥ï¼ˆHTTPè¿žæŽ¥ï¼‰çš„ä¸¤ä¸ªæ­¥éª¤ã€‚æ–°å»ºçš„å®¢æˆ·ç«¯å¯¹è±¡å…·å¤‡Callæ–¹æ³•å’ŒGoæ–¹æ³•ã€‚ Callæ–¹æ³•ç­‰å¾…è¿œç¨‹è°ƒç”¨å®Œæˆï¼Œè€ŒGoæ–¹æ³•ä½¿ç”¨Callç»“æž„çš„Doneé€šé“å¯åŠ¨å¼‚æ­¥è°ƒç”¨å’Œå‘å‡ºå®Œæˆä¿¡å·ã€‚ é™¤éžè®¾ç½®äº†æ˜¾å¼ç¼–è§£ç å™¨ï¼Œå¦åˆ™ä¸€èˆ¬ä½¿ç”¨encoding/gobåŒ…æ¥ä¼ è¾“æ•°æ®ã€‚ ä¸€ä¸ªæœåŠ¡å™¨å¯¼å‡ºArithç±»åž‹çš„å¯¹è±¡çš„ä¾‹å­ï¼š 123456789101112131415161718192021222324252627package serverimport "errors"type Args struct &#123; A, B int&#125;type Quotient struct &#123; Quo, Rem int&#125;type Arith intfunc (t *Arith) Multiply(args *Args, reply *int) error &#123; *reply = args.A * args.B return nil&#125;func (t *Arith) Divide(args *Args, quo *Quotient) error &#123; if args.B == 0 &#123; return errors.New("divide by zero") &#125; quo.Quo = args.A / args.B quo.Rem = args.A % args.B return nil&#125; æœåŠ¡å™¨ç«¯è°ƒç”¨ HTTP serviceï¼š 12345678arith := new(Arith)rpc.Register(arith)rpc.HandleHTTP()l, e := net.Listen("tcp", ":1234")if e != nil &#123; log.Fatal("listen error:", e)&#125;go http.Serve(l, nil) çŽ°åœ¨ï¼Œå®¢æˆ·ç«¯æ‹¥æœ‰äº†ä¸€é¡¹æœåŠ¡Arithï¼Œè¯¥æœåŠ¡æä¾›äº†Arith.Multiplyå’ŒArith.Divideæ–¹æ³•ã€‚è¦è°ƒç”¨è¿™äº›æ–¹æ³•ï¼Œå®¢æˆ·ç«¯å¾—å…ˆæ‹¨é€šæœåŠ¡å™¨ï¼š 1234client, err := rpc.DialHTTP("tcp", serverAddress + ":1234")if err != nil &#123; log.Fatal("dialing:", err)&#125; ç„¶åŽè¿›è¡Œè¿œç¨‹è°ƒç”¨ï¼š 12345678// Synchronous callargs := &amp;server.Args&#123;7,8&#125;var reply interr = client.Call("Arith.Multiply", args, &amp;reply)if err != nil &#123; log.Fatal("arith error:", err)&#125;fmt.Printf("Arith: %d*%d=%d", args.A, args.B, reply) æˆ–è€… 12345// Asynchronous callquotient := new(Quotient)divCall := client.Go("Arith.Divide", args, quotient, nil)replyCall := &lt;-divCall.Done // will be equal to divCall// check errors, print, etc. æœåŠ¡å™¨é€šå¸¸ä¼šä¸ºå®¢æˆ·ç«¯æä¾›ä¸€ä¸ªç®€å•çš„ã€ç±»åž‹å®‰å…¨çš„å°è£…ã€‚ net/rpcåŒ…å·²å†»ç»“ï¼Œä¸ä¼šå¢žåŠ æ–°çš„åŠŸèƒ½å±žæ€§ã€‚ Goä¸¾ä¾‹ï¼š ä¸€ä¸ªç®€å•çš„key/valueå­˜å‚¨æœåŠ¡å™¨â€”â€”Put(key,value), Get(key)-&gt;value 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package mainimport ( "fmt" "log" "net" "net/rpc" "sync")//// RPC request/reply definitions//const ( OK = "OK" ErrNoKey = "ErrNoKey")type Err stringtype PutArgs struct &#123; Key string Value string&#125;type PutReply struct &#123; Err Err&#125;type GetArgs struct &#123; Key string&#125;type GetReply struct &#123; Err Err Value string&#125;//// Client//func connect() *rpc.Client &#123; client, err := rpc.Dial("tcp", ":1234") if err != nil &#123; log.Fatal("dialing:", err) &#125; return client&#125;func get(key string) string &#123; client := connect() args := GetArgs&#123;Key: key&#125; reply := GetReply&#123;&#125; err := client.Call("KV.Get", &amp;args, &amp;reply) //è¿œç¨‹è°ƒç”¨KV.Getï¼Œç­‰å¾…å®ƒå®Œæˆï¼Œå¹¶è¿”å›žå…¶é”™è¯¯çŠ¶æ€ã€‚ if err != nil &#123; log.Fatal("error:", err) &#125; client.Close() log.Println(reply.Err) return reply.Value&#125;func put(key string, val string) &#123; client := connect() args := PutArgs&#123;Key: key, Value: val&#125; reply := PutReply&#123;&#125; err := client.Call("KV.Put", &amp;args, &amp;reply) //è¿œç¨‹è°ƒç”¨KV.Put if err != nil &#123; log.Fatal("error:", err) &#125; client.Close()&#125;//// Server//type KV struct &#123; mu sync.Mutex data map[string]string&#125;func server() &#123; kv := new(KV) kv.data = map[string]string&#123;&#125; rpcs := rpc.NewServer() rpcs.Register(kv) l, e := net.Listen("tcp", ":1234") if e != nil &#123; log.Fatal("listen error:", e) &#125; go func() &#123; for &#123; conn, err := l.Accept() if err == nil &#123; go rpcs.ServeConn(conn) &#125; else &#123; break &#125; &#125; l.Close() &#125;()&#125;func (kv *KV) Get(args *GetArgs, reply *GetReply) error &#123; kv.mu.Lock() defer kv.mu.Unlock() val, ok := kv.data[args.Key] if ok &#123; reply.Err = OK reply.Value = val &#125; else &#123; reply.Err = ErrNoKey reply.Value = "" &#125; return nil&#125;func (kv *KV) Put(args *PutArgs, reply *PutReply) error &#123; kv.mu.Lock() defer kv.mu.Unlock() kv.data[args.Key] = args.Value reply.Err = OK return nil&#125;//// main//func main() &#123; server() put("passwd", "2w6C*kcXWWmzK$Jg") //å®¢æˆ·ç«¯å­˜å‚¨å¯†ç  fmt.Println(get("passwd")) //å®¢æˆ·ç«¯èŽ·å–å¯†ç &#125;command-line-arguments2019/04/02 18:34:11 OK2w6C*kcXWWmzK$Jg å…±åŒï¼šå¿…é¡»ä¸ºæ¯ç§RPCç±»åž‹å£°æ˜ŽArgså’ŒReplyç»“æž„ Client: connect()çš„Dial()åˆ›å»ºä¸ŽæœåŠ¡å™¨çš„TCPè¿žæŽ¥ Call()è¦æ±‚RPCåº“æ‰§è¡Œè¿œç¨‹è°ƒç”¨ æŒ‡å®šserver function name, args,reply library marshalls args, sends request, waits, unmarshally reply Call()çš„è¿”å›žå€¼è¡¨ç¤ºæ˜¯å¦æ”¶åˆ°å›žå¤ usually you'll also have a reply.Err indicating service-level failure serverï¼š Goè¦æ±‚æ‚¨å£°æ˜Žä¸€ä¸ªå¸¦æœ‰æ–¹æ³•çš„å¯¹è±¡ä½œä¸ºRPCå¤„ç†ç¨‹åº(RPC handler) ç„¶åŽï¼Œæ‚¨ä½¿ç”¨RPCåº“æ³¨å†Œè¯¥å¯¹è±¡ æ‚¨æŽ¥å—TCPè¿žæŽ¥ï¼Œå¹¶ç»™å®ƒä»¬æä¾›RPCåº“ RPCåº“ è¯»å–æ¯ä¸ªè¯·æ±‚ ä¸ºæ­¤è¯·æ±‚åˆ›å»ºä¸€ä¸ªæ–°çš„goroutine unmarshalls request è°ƒç”¨å‘½åæ–¹æ³•ï¼ˆè°ƒåº¦ï¼‰ marshalls reply åœ¨TCPè¿žæŽ¥ä¸Šå†™å›žå¤ æœåŠ¡å™¨çš„Get()å’ŒPut()å¤„ç†ç¨‹åº å¿…é¡»é”å®šï¼Œå› ä¸ºRPCåº“ç»™æ¯ä¸ªè¯·æ±‚åˆ›å»ºgoroutines è§£è¯»args; ä¿®æ”¹reply çº¿ç¨‹: çº¿ç¨‹æ˜¯ä¸€ç§æœ‰ç”¨çš„ç»“æž„åŒ–å·¥å…· Goç§°ä»–ä»¬ä¸ºgoroutines;å…¶ä»–äººç§°ä»–ä»¬ä¸ºçº¿ç¨‹ ä»–ä»¬å¯èƒ½å¾ˆæ£˜æ‰‹ Why threads? ç”¨å®ƒä»¬å®žçŽ°å¹¶å‘ï¼Œåœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­è‡ªç„¶åœ°å‡ºçŽ° I / Oå¹¶å‘ï¼š åœ¨ç­‰å¾…æ¥è‡ªå…¶ä»–æœåŠ¡å™¨çš„å“åº”æ—¶ï¼Œå¤„ç†ä¸‹ä¸€ä¸ªè¯·æ±‚ å¤šæ ¸ï¼š çº¿ç¨‹åœ¨å¤šä¸ªæ ¸å¿ƒä¸Šå¹¶è¡Œè¿è¡Œ Thread =â€œæ‰§è¡Œçº¿ç¨‹â€ çº¿ç¨‹å…è®¸ä¸€ä¸ªç¨‹åºï¼ˆé€»è¾‘ä¸Šï¼‰ä¸€æ¬¡æ‰§è¡Œè®¸å¤šäº‹æƒ… çº¿ç¨‹å…±äº«å†…å­˜ each thread includes some per-thread stateï¼ŒåŒ…æ‹¬ï¼šç¨‹åºè®¡æ•°å™¨ï¼Œå¯„å­˜å™¨ï¼Œå †æ ˆ ç¨‹åºä¸­æœ‰å¤šå°‘ä¸ªçº¿ç¨‹ï¼Ÿ ç”±ç»“æž„é©±åŠ¨ ä¾‹å¦‚æ¯ä¸ªå®¢æˆ·ç«¯ä¸€ä¸ªçº¿ç¨‹ï¼Œä¸€ä¸ªç”¨äºŽåŽå°ä»»åŠ¡ å¤šæ ¸å¹¶è¡Œ one active thread per coreã€‚Goçš„ runtime è‡ªåŠ¨åœ°åœ¨å¯ç”¨å†…æ ¸ä¸Šè°ƒåº¦å¯è¿è¡Œçš„goroutine I / Oå¹¶å‘ æ•°é‡ç”±å»¶è¿Ÿå’Œå®¹é‡å†³å®š ç»§ç»­å¢žåŠ ç›´åˆ°åžåé‡åœæ­¢å¢žé•¿ Go threads are pretty cheap 100æˆ–1000æ˜¯å¥½çš„ï¼Œä½†å¯èƒ½è¾¾ä¸åˆ°æ•°ç™¾ä¸‡çš„é‡çº§ åˆ›å»ºçº¿ç¨‹æ¯”æ–¹æ³•è°ƒç”¨æ›´æ˜‚è´µ Threading challengesï¼š å…±äº«æ•°æ® ä¸€ä¸ªçº¿ç¨‹è¯»å–å¦ä¸€ä¸ªçº¿ç¨‹æ­£åœ¨æ”¹å˜çš„æ•°æ®ï¼Ÿä¾‹å¦‚å½“ä¸¤ä¸ªçº¿ç¨‹æ‰§è¡Œcount = count + 1æ—¶ï¼Œthis is a &quot;race&quot; -- and is usually a bug â€”â€”ä½¿ç”¨äº’æ–¥é”ï¼ˆæˆ–å…¶ä»–åŒæ­¥ï¼‰ â€”â€”æˆ–é¿å…å…±äº« çº¿ç¨‹ä¹‹é—´çš„åè°ƒ å¦‚ä½•ç­‰å¾…æ‰€æœ‰Mapçº¿ç¨‹å®Œæˆï¼Ÿ â€”â€”ä½¿ç”¨Go channelæˆ–WaitGroup å¹¶å‘çš„ç²’åº¦ ç²—ç²’åº¦(coarse-grained) â€”â€” ç®€å•ï¼Œä½†å¹¶å‘/å¹¶è¡Œå¾ˆå°‘ ç»†ç²’åº¦ â€”â€” æ›´å¤šçš„å¹¶å‘ã€ç«žäº‰(race)å’Œæ­»é” ä»€ä¹ˆæ˜¯çˆ¬è™«ï¼Ÿ ç›®æ ‡æ˜¯èŽ·å–æ‰€æœ‰ç½‘é¡µï¼Œä¾‹å¦‚æä¾›ç»™ç´¢å¼•å™¨(indexer) ç½‘é¡µå½¢æˆä¸€ä¸ªå›¾(graph) æ¯ä¸ªé¡µé¢çš„å¤šä¸ªé“¾æŽ¥ graph has cycles Crawler challenges å®‰æŽ’I / Oå¹¶å‘ åŒæ—¶èŽ·å–å¤šä¸ªURL å¢žåŠ æ¯ç§’èŽ·å–çš„URL ç”±äºŽç½‘ç»œå»¶è¿Ÿè¿œè¿œè¶…è¿‡ç½‘ç»œå®¹é‡ Fetch each URL only once é¿å…æµªè´¹ç½‘ç»œå¸¦å®½ å¯¹è¿œç¨‹æœåŠ¡å™¨å¾ˆå¥½ éœ€è¦è®°ä½è®¿é—®è¿‡çš„URL çŸ¥é“ä»€ä¹ˆæ—¶å€™å®Œæˆ Crawler solutionsï¼š ä¸²è¡Œçˆ¬è™«ï¼š fetched map é¿å…é‡å¤ã€è¿›å…¥æ­»å¾ªçŽ¯ å®ƒæ˜¯ä¸€ä¸ªå•ä¸€çš„æ˜ å°„ï¼Œé€šè¿‡é€’å½’è°ƒç”¨ä¼ é€’ ä¸€æ¬¡åªèƒ½çˆ¬å–ä¸€é¡µ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package mainimport ( "fmt")type Fetcher interface &#123; Fetch(url string) (urls []string, err error) //ç”±ä¸€ä¸ªURLè¿”å›žå¤šä¸ªURL&#125;type fakeResult struct &#123; body string urls []string&#125;type fakeFetcher map[string]*fakeResultfunc (f fakeFetcher) Fetch(url string) ([]string, error) &#123; if res, ok := f[url]; ok &#123; fmt.Printf("found: %s\n", url) return res.urls, nil &#125; fmt.Printf("missing: %s\n", url) return nil, fmt.Errorf("not found: %s", url) //æ‰“å°å­—ç¬¦ä¸²é”™è¯¯&#125;var fetcher = fakeFetcher&#123; "http://golang.org/": &amp;fakeResult&#123; "The Go Programming Language", []string&#123; "http://golang.org/pkg/", "http://golang.org/cmd/", &#125;, &#125;, "http://golang.org/pkg/": &amp;fakeResult&#123; "Packages", []string&#123; "http://golang.org/", "http://golang.org/cmd/", "http://golang.org/pkg/fmt/", "http://golang.org/pkg/os/", &#125;, &#125;, "http://golang.org/pkg/fmt/": &amp;fakeResult&#123; "Package fmt", []string&#123; "http://golang.org/", "http://golang.org/pkg/", &#125;, &#125;, "http://golang.org/pkg/os/": &amp;fakeResult&#123; "Package os", []string&#123; "http://golang.org/", "http://golang.org/pkg/", &#125;, &#125;,&#125;// ä¸²è¡Œçˆ¬è™«func Serial(url string, fetcher Fetcher, fetched map[string]bool) &#123; if fetched[url] &#123; // å·²ç»çˆ¬å– return &#125; fetched[url] = true urls, err := fetcher.Fetch(url) if err != nil &#123; return &#125; for _, u := range urls &#123; Serial(u, fetcher, fetched) &#125; return&#125;func main() &#123; Serial("http://golang.org/", fetcher, make(map[string]bool))&#125; ConcurrentMutexçˆ¬è™«ï¼š ä¸ºæ¯ä¸ªé¡µé¢çš„çˆ¬å–åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œå› æ­¤å¯ä»¥å¹¶å‘çˆ¬å–ï¼Œçˆ¬å–çŽ‡æ›´é«˜ çº¿ç¨‹å…±äº« fetched map Why the Mutex (== lock)? æ²¡æœ‰é”ï¼š ä¸¤ä¸ªç½‘é¡µåŒ…å«æŒ‡å‘åŒä¸€URLçš„é“¾æŽ¥ï¼Œå¯¼è‡´ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶èŽ·å–è¿™è¿™ä¸ªé¡µé¢ T1ã€T2æ£€æŸ¥èŽ·å–[url]ï¼Œå½“ä¸¤è€…éƒ½çœ‹åˆ°urlå°šæœªèŽ·å–ï¼Œä¸¤è€…éƒ½å–ï¼Œå¯¼è‡´é”™è¯¯ åŒæ—¶è¯»å†™ï¼ˆæˆ–å†™å…¥+å†™å…¥ï¼‰æ˜¯ç«žäº‰ å¦‚æžœæˆ‘æ³¨é‡ŠæŽ‰Lock()/Unlock()è°ƒç”¨ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ go run crawler.go go run -race crawler.go The lock causes the check and update to be atomic How does it decide it is done? sync.WaitGroup implicitly waits for children to finish recursive fetches 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package mainimport ( "fmt" "sync")type Fetcher interface &#123; Fetch(url string) (urls []string, err error) //ç”±ä¸€ä¸ªURLè¿”å›žå¤šä¸ªURL&#125;type fakeResult struct &#123; body string urls []string&#125;type fakeFetcher map[string]*fakeResultfunc (f fakeFetcher) Fetch(url string) ([]string, error) &#123; if res, ok := f[url]; ok &#123; fmt.Printf("found: %s\n", url) return res.urls, nil &#125; fmt.Printf("missing: %s\n", url) return nil, fmt.Errorf("not found: %s", url) //æ‰“å°å­—ç¬¦ä¸²é”™è¯¯&#125;var fetcher = fakeFetcher&#123; "http://golang.org/": &amp;fakeResult&#123; "The Go Programming Language", []string&#123; "http://golang.org/pkg/", "http://golang.org/cmd/", &#125;, &#125;, "http://golang.org/pkg/": &amp;fakeResult&#123; "Packages", []string&#123; "http://golang.org/", "http://golang.org/cmd/", "http://golang.org/pkg/fmt/", "http://golang.org/pkg/os/", &#125;, &#125;, "http://golang.org/pkg/fmt/": &amp;fakeResult&#123; "Package fmt", []string&#123; "http://golang.org/", "http://golang.org/pkg/", &#125;, &#125;, "http://golang.org/pkg/os/": &amp;fakeResult&#123; "Package os", []string&#123; "http://golang.org/", "http://golang.org/pkg/", &#125;, &#125;,&#125;// Concurrent crawler with shared state and Mutextype fetchState struct &#123; mu sync.Mutex fetched map[string]bool&#125;func makeState() *fetchState &#123; f := &amp;fetchState&#123;&#125; f.fetched = make(map[string]bool) return f&#125;func ConcurrentMutex(url string, fetcher Fetcher, f *fetchState) &#123; f.mu.Lock() if f.fetched[url] &#123; // å·²ç»çˆ¬å– f.mu.Unlock() return &#125; f.fetched[url] = true f.mu.Unlock() urls, err := fetcher.Fetch(url) if err != nil &#123; return &#125; var done sync.WaitGroup for _, u := range urls &#123; done.Add(1) go func(u string) &#123; defer done.Done() //ç­‰ä»·äºŽdefer done.Add(-1) ConcurrentMutex(u, fetcher, f) &#125;(u) &#125; done.Wait() //ç­‰å¾…æ‰€æœ‰çš„goroutineå®Œæˆ return&#125;func main() &#123; ConcurrentMutex("http://golang.org/", fetcher, makeState())&#125; ConcurrentChannelçˆ¬è™« Go channelï¼š channelæ˜¯ä¸€ä¸ªå¯¹è±¡,å¯èƒ½æœ‰å¾ˆå¤šä¸ª, chï¼š= makeï¼ˆchan intï¼‰ channelå…è®¸ä¸€ä¸ªçº¿ç¨‹å°†å¯¹è±¡å‘é€åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ï¼š ch &lt; - xï¼Œsenderç­‰å¾…goroutineæŽ¥æ”¶ yï¼š= &lt; - ch; for y := range chï¼Œreceiverç­‰å¾…goroutineå‘é€ å¯ä»¥ç”¨channelæ¥è¿›è¡Œé€šä¿¡å’ŒåŒæ­¥ å¤šä¸ªçº¿ç¨‹å¯ä»¥åœ¨ä¸€ä¸ªchannelä¸Šå‘é€å’ŒæŽ¥æ”¶ åœ¨å‘é€æ—¶æ¡ä½é”å¯èƒ½å¾ˆå±é™©... ConcurrentChannel masterï¼ˆï¼‰ master()åˆ›å»ºä¸€ä¸ªworker goroutineæ¥èŽ·å–æ¯ä¸ªé¡µé¢ worker()åœ¨channelä¸Šå‘é€URL å¤šä¸ªworkeråœ¨ä¸€ä¸ªchannelä¸Šå‘é€ master()ä»Žchannelä¸­è¯»å–URL [å›¾ï¼šä¸»äººï¼Œé€šé“ï¼Œå·¥äºº] æ— éœ€é”å®š fetched mapï¼Œå› ä¸ºå®ƒä¸æ˜¯å…±äº«çš„ï¼ æœ‰å…±äº«æ•°æ®å—ï¼Ÿ channel é€šé“ä¸Šå‘é€çš„åˆ‡ç‰‡å’Œå­—ç¬¦ä¸² master()ä¼ é€’ç»™worker()çš„å‚æ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package mainimport ( "fmt")type Fetcher interface &#123; Fetch(url string) (urls []string, err error) //ç”±ä¸€ä¸ªURLè¿”å›žå¤šä¸ªURL&#125;type fakeResult struct &#123; body string urls []string&#125;type fakeFetcher map[string]*fakeResultfunc (f fakeFetcher) Fetch(url string) ([]string, error) &#123; if res, ok := f[url]; ok &#123; fmt.Printf("found: %s\n", url) return res.urls, nil &#125; fmt.Printf("missing: %s\n", url) return nil, fmt.Errorf("not found: %s", url) //æ‰“å°å­—ç¬¦ä¸²é”™è¯¯&#125;var fetcher = fakeFetcher&#123; "http://golang.org/": &amp;fakeResult&#123; "The Go Programming Language", []string&#123; "http://golang.org/pkg/", "http://golang.org/cmd/", &#125;, &#125;, "http://golang.org/pkg/": &amp;fakeResult&#123; "Packages", []string&#123; "http://golang.org/", "http://golang.org/cmd/", "http://golang.org/pkg/fmt/", "http://golang.org/pkg/os/", &#125;, &#125;, "http://golang.org/pkg/fmt/": &amp;fakeResult&#123; "Package fmt", []string&#123; "http://golang.org/", "http://golang.org/pkg/", &#125;, &#125;, "http://golang.org/pkg/os/": &amp;fakeResult&#123; "Package os", []string&#123; "http://golang.org/", "http://golang.org/pkg/", &#125;, &#125;,&#125;// Concurrent crawler with channelsfunc worker(url string, ch chan []string, fetcher Fetcher) &#123; urls, err := fetcher.Fetch(url) if err != nil &#123; ch &lt;- []string&#123;&#125; &#125; else &#123; ch &lt;- urls &#125;&#125;func master(ch chan []string, fetcher Fetcher) &#123; n := 1 fetched := make(map[string]bool) for urls := range ch &#123; for _, u := range urls &#123; if fetched[u] == false &#123; fetched[u] = true n += 1 go worker(u, ch, fetcher) &#125; &#125; n -= 1 if n == 0 &#123; break &#125; &#125;&#125;func ConcurrentChannel(url string, fetcher Fetcher) &#123; ch := make(chan []string) go func() &#123; ch &lt;- []string&#123;url&#125; &#125;() master(ch, fetcher)&#125;func main() &#123; ConcurrentChannel("http://golang.org/", fetcher)&#125; **ä»€ä¹ˆæ—¶å€™ä½¿ç”¨sharingå’Œlocksï¼Œè€Œä¸æ˜¯channelsï¼Ÿ** - å¤§å¤šæ•°é—®é¢˜éƒ½å¯ä»¥ç”¨ä»»ä½•ä¸€ç§æ–¹å¼è§£å†³ - æœ€æœ‰æ„ä¹‰çš„å–å†³äºŽç¨‹åºå‘˜çš„æƒ³æ³• state(çŠ¶æ€) -- sharing and locks communication -- channels waiting for events -- channels - ä½¿ç”¨Goçš„ç«žäº‰æ£€æµ‹å™¨ï¼š [Data Race Detector](https://golang.org/doc/articles/race_detector.html) go test -race]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>RPC</tag>
        <tag>å¹¶å‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Goå¹¶å‘æ¨¡å¼ (Cocurrency Pattern)]]></title>
    <url>%2F2019%2F02%2F10%2F2019-2-10%2F</url>
    <content type="text"><![CDATA[è¿™ç¯‡åšå®¢çš„åŽŸåˆ›æ¥è‡ªGoçš„å®˜æ–¹åšå®¢ï¼Œå…¶ä¸­æä¾›äº†ä¸°å¯Œçš„å…³äºŽGoçš„å¹¶å‘çš„ç›¸å…³èµ„æ–™ã€‚æœ¬æ–‡ä»…ä»…æ˜¯å¯¹ Rob Pike çš„æ¼”è®² Go Concurrency Patterns å’Œ Sameer Ajmani çš„ç»­é›† Advanced Go Concurrency Patterns çš„å­¦ä¹ ï¼Œç›¸å…³å†…å®¹çš„è§†é¢‘å’Œpptåœ¨ç½‘ä¸Šéƒ½å¯ä»¥æ‰¾åˆ°ã€‚ 1. å‡½æ•°è¿”å›ž channel# 12345678910111213141516171819202122232425262728293031323334package mainimport ( "fmt" "math/rand" "time")func boring(msg string) &lt;-chan string &#123; // è¿”å›žå­—ç¬¦ä¸²é€šé“ï¼Œä»…æŽ¥æ”¶ c := make(chan string) go func() &#123; for i := 0; ; i++ &#123; c &lt;- fmt.Sprintf("%s %d", msg, i) time.Sleep(time.Duration(rand.Intn(3e3)) * time.Millisecond) &#125; &#125;() return c&#125;func main() &#123; c := boring("boring!") // é€šé“ä½œä¸ºè¿”å›žçš„å‡½æ•° for i := 0; i &lt; 5; i++ &#123; fmt.Printf("You say: %q\n", &lt;-c) &#125; fmt.Println("You're boring; I'm leaving.")&#125;è¾“å‡ºï¼šYou say: "boring! 0"You say: "boring! 1"You say: "boring! 2"You say: "boring! 3"You say: "boring! 4"You're boring; I'm leaving. 2. é€šé“ä½œä¸ºæœåŠ¡# 12345678910111213141516171819202122func main() &#123; joe := boring("Joe") ann := boring("Ann") for i := 0; i &lt; 5; i++ &#123; fmt.Println(&lt;-joe) fmt.Println(&lt;-ann) &#125; fmt.Println("You're both boring; I'm leaving.")&#125;è¾“å‡ºï¼šJoe 0Ann 0Joe 1Ann 1Joe 2Ann 2Joe 3Ann 3Joe 4Ann 4You're both boring; I'm leaving. 3.å¤šé‡é€šé“(æ‰‡å…¥å‡½æ•°ï¼Œfan-in function)# 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( "fmt" "math/rand" "time")func boring(msg string) &lt;-chan string &#123; // è¿”å›žå­—ç¬¦ä¸²é€šé“ï¼Œä»…æŽ¥æ”¶ c := make(chan string) go func() &#123; for i := 0; ; i++ &#123; c &lt;- fmt.Sprintf("%s %d", msg, i) time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond) &#125; &#125;() return c&#125;func fanIn(input1, input2 &lt;-chan string) &lt;-chan string &#123; c := make(chan string) go func() &#123; for &#123; c &lt;- &lt;-input1 &#125; &#125;() go func() &#123; for &#123; c &lt;- &lt;-input2 &#125; &#125;() return c&#125;func main() &#123; c := fanIn(boring("Joe"), boring("Ann")) for i := 0; i &lt; 10; i++ &#123; fmt.Println(&lt;-c) &#125; fmt.Println("You're both boring; I'm leaving.")&#125; 4. é€šé“å‘é€é€šé“ï¼Œä½¿ goroutine æœ‰åº# 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package mainimport ( "fmt" "math/rand" "time")type Message struct &#123; str string wait chan bool&#125;func boring(msg string) chan Message &#123; c := make(chan Message) waitForIt := make(chan bool) // è¢«æ‰€æœ‰ Message å…±äº« go func() &#123; for i := 0; ; i++ &#123; c &lt;- Message&#123;fmt.Sprintf("%s: %d", msg, i), waitForIt&#125; time.Sleep(time.Duration(rand.Intn(1e3)) * time.Millisecond) &lt;-waitForIt // è¿›å…¥ç­‰å¾… &#125; &#125;() return c&#125;func fanIn(input1, input2 chan Message) chan Message &#123; c := make(chan Message) go func() &#123; for &#123; c &lt;- &lt;-input1 &#125; &#125;() go func() &#123; for &#123; c &lt;- &lt;-input2 &#125; &#125;() return c&#125;func main() &#123; c := fanIn(boring("Joe"), boring("Ann")) for i := 0; i &lt; 5; i++ &#123; msg1 := &lt;-c fmt.Println(msg1.str) msg2 := &lt;-c fmt.Println(msg2.str) // å½“ Joe å’Œ Ann çš„ä¿¡æ¯éƒ½æ”¶åˆ°åŽï¼Œæ‰å¼€æ”¾ä¸‹ä¸€æ¬¡æ¶ˆæ¯æŽ¥æ”¶ msg1.wait &lt;- true msg2.wait &lt;- true &#125;&#125; 5. select è¯­å¥# ä½¿ç”¨ select æ¥å†™æ‰‡å…¥å‡½æ•°ï¼Œå‡å°‘ goroutine æ•°é‡ 123456789101112func fanIn(input1, input2 &lt;-chan string) &lt;-chan string &#123; c := make(chan string) go func() &#123; for &#123; select &#123; case s := &lt;-input1: c &lt;- s case s := &lt;-input2: c &lt;- s &#125; &#125; &#125;() return c&#125; selectè®¾ç½®è¶…æ—¶ 123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( "fmt" "math/rand" "time")func boring(msg string) &lt;-chan string &#123; // è¿”å›žå­—ç¬¦ä¸²é€šé“ï¼Œä»…æŽ¥æ”¶ c := make(chan string) go func() &#123; for i := 0; ; i++ &#123; c &lt;- fmt.Sprintf("%s %d", msg, i) time.Sleep(time.Duration(rand.Intn(1500)) * time.Millisecond) &#125; &#125;() return c&#125;func main() &#123; c := boring("Joe") for &#123; select &#123; case s := &lt;-c: fmt.Println(s) case &lt;-time.After(1 * time.Second): fmt.Println("You're too slow.") return &#125; &#125;&#125;è¾“å‡ºï¼šJoe 0Joe 1Joe 2Joe 3Joe 4You're too slow.]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQLé©±åŠ¨]]></title>
    <url>%2F2018%2F12%2F31%2F2018-12-31%2F</url>
    <content type="text"><![CDATA[MySQLåŸºç¡€è§èœé¸Ÿæ•™ç¨‹; æœ¬æ–‡å‚è€ƒäº†astaxie/build-web-application-with-golang. å¯åŠ¨ã€ä»¥å¯†ç ç™»å…¥å’Œåˆ›å»ºæ•°æ®åº“# windows: åœ¨binç›®å½•ä¸‹ï¼Œè¿è¡Œ(git-bashä»¥ç®¡ç†å‘˜è¿è¡Œï¼ŒåŠ winpty) mysqld --remove åˆ é™¤ä¹‹å‰çš„mysqlæœåŠ¡ mysqld -install mysql å®‰è£…windowsæœåŠ¡ï¼ŒæœåŠ¡åç§°ä¸ºmysql(ä»»æ„å–) mysqld --initialize-insecure å¯æ— å¯†ç ç™»é™†root net start mysql å¯åŠ¨æœåŠ¡(å…³é—­çš„å‘½ä»¤æ˜¯ net stop mysql) ubuntu: service mysql start å¯åŠ¨æœåŠ¡ service mysql stop å…³é—­æœåŠ¡ service restart stop é‡å¯æœåŠ¡ ps -ef | grep mysqld æŸ¥çœ‹mysqlè¿›ç¨‹åˆ—è¡¨ æ‰§è¡Œå¦‚ä¸‹SQLè¯­å¥ä»¥å¯†ç ç™»å…¥ ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456'; æˆ–è€…ç¼–å†™ test.sql åˆ›å»º source test.sql æ–‡ä»¶ ç¼–å†™Goæ–‡ä»¶# test.go å†…å®¹å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package mainimport ( "database/sql" "fmt" _ "github.com/go-sql-driver/mysql")func main() &#123; db, err := sql.Open("mysql", "root:123456@/test") //Linuxç”¨æˆ·å:MySQLå¯†ç @/æ•°æ®åº“åtest checkErr(err) stm, err := db.Prepare("DROP TABLE IF EXISTS userinfo;") //å‡†å¤‡SQLè¯­å¥ï¼Œåˆ é™¤æ•°æ®è¡¨ checkErr(err) _, err = stm.Exec() //Excute, æ‰§è¡Œè¯­å¥ checkErr(err) stm, err = db.Prepare(`CREATE TABLE userinfo ( uid INT(10) NOT NULL AUTO_INCREMENT, name VARCHAR(64) NOT NULL DEFAULT 'åŒ¿å', city VARCHAR(64) NULL DEFAULT 'ä¸è¯¦', moment DATE NOT NULL DEFAULT '1949-10-10', PRIMARY KEY (uid) ) DEFAULT CHARSET=utf8;`) //åˆ›å»ºæ•°æ®è¡¨ï¼Œè®¾ç½®utf8ä»¥æ”¯æŒä¸­æ–‡å­—ç¬¦ checkErr(err) _, err = stm.Exec() checkErr(err) //å¢žåŠ æ•°æ® stm, err = db.Prepare("INSERT userinfo SET name=?, city=?, moment=?") //å‡†å¤‡SQLè¯­å¥ checkErr(err) _, err = stm.Exec("è¯¸è‘›äº®", "å±±ä¸œä¸´æ²‚", "234-10-8") //Excute, ä¼ å…¥å‚æ•°å¹¶æ‰§è¡Œ checkErr(err) _, err = stm.Exec("å…³ç¾½", "å±±è¥¿è¿åŸŽ", "220-1-1") checkErr(err) _, err = stm.Exec("è€å½§", "æ²³å—è®¸æ˜Œ", "212-1-1") checkErr(err) stm, err = db.Prepare("INSERT userinfo SET city=?") checkErr(err) res, err := stm.Exec("æ²³å—ç¦¹å·ž") id, err := res.LastInsertId() checkErr(err) fmt.Println("æœ€åŽæ’å…¥çš„ç”¨æˆ·åºå·ä¸º:", id) //æŸ¥è¯¢æ•°æ® rows, err := db.Query("SELECT * FROM userinfo") checkErr(err) fmt.Println("æ‰“å°æ•°æ®è¡¨çš„æ¯è¡Œä¿¡æ¯:") fmt.Println("---------------------") for rows.Next() &#123; var uid int var name string var city string var moment string err = rows.Scan(&amp;uid, &amp;name, &amp;city, &amp;moment) checkErr(err) fmt.Print(uid, " ") fmt.Print(name, " ") fmt.Print(city, " ") fmt.Println(moment) &#125; //åˆ é™¤æ•°æ® stm, err = db.Prepare("DELETE FROM userinfo WHERE uid=?") checkErr(err) res, err = stm.Exec(2) checkErr(err) fmt.Println("åˆ é™¤äº†ç¬¬2è¡Œ") //æ›´æ”¹æ•°æ® stm, err = db.Prepare("UPDATE userinfo SET name=? WHERE uid=? OR uid=?") checkErr(err) res, err = stm.Exec("éƒ­å˜‰", id-1, id) checkErr(err) affect, err := res.RowsAffected() checkErr(err) fmt.Println("æ€»å…±æœ‰", affect, "è¡Œçš„ä¿¡æ¯å‘ç”Ÿäº†æ›´æ”¹") //æŸ¥è¯¢æ•°æ® rows, err = db.Query("SELECT * FROM userinfo") checkErr(err) fmt.Println("æ‰“å°æ•°æ®è¡¨çš„æ¯è¡Œä¿¡æ¯:") fmt.Println("---------------------") for rows.Next() &#123; var uid int var name string var city string var moment string err = rows.Scan(&amp;uid, &amp;name, &amp;city, &amp;moment) checkErr(err) fmt.Print(uid, " ") fmt.Print(name, " ") fmt.Print(city, " ") fmt.Println(moment) &#125; db.Close()&#125;func checkErr(err error) &#123; if err != nil &#123; panic(err) &#125;&#125; è¿è¡Œç»“æžœï¼š è¿›å…¥MySQLæŸ¥çœ‹æ•°æ®è¡¨ï¼š]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¤§è¯æ•°æ®ç»“æž„]]></title>
    <url>%2F2018%2F12%2F20%2F2018-12-20%2F</url>
    <content type="text"><![CDATA[3.4 é¡ºåºå­˜å‚¨ç»“æž„ 3.6 é“¾å¼å­˜å‚¨ç»“æž„ 3.11 å•é“¾è¡¨ç»“æž„ä¸Žé¡ºåºå­˜å‚¨ç»“æž„ 3.12 é™æ€é“¾è¡¨ 3.13 å¾ªçŽ¯é“¾è¡¨ 3.14 åŒå‘é“¾è¡¨ 4.2 æ ˆ 4.10 é˜Ÿåˆ— 4.12 å¾ªçŽ¯é˜Ÿåˆ— 6.4 æ ‘çš„å­˜å‚¨ç»“æž„ 6.5.2 ç‰¹æ®ŠäºŒå‰æ ‘ 6.6 äºŒå‰æ ‘æ€§è´¨ 6.8 éåŽ†äºŒå‰æ ‘ 6.8.6 æŽ¨å¯¼éåŽ†ç»“æžœ 6.10 çº¿ç´¢äºŒå‰æ ‘ 6.11.1 æ ‘è½¬æ¢ä¸ºäºŒå‰æ ‘ 6.12 èµ«å¤«æ›¼æ ‘ 7.4.1 é‚»æŽ¥çŸ©é˜µ(adjacency matrix) 7.4.2 é‚»æŽ¥è¡¨ 7.5.1 æ·±åº¦ä¼˜å…ˆéåŽ†(Depth First Search) 7.5.2 å¹¿åº¦ä¼˜å…ˆéåŽ†(Breadth First Search) 8.4.1 äºŒåˆ†æŸ¥æ‰¾ 8.6 äºŒå‰æŸ¥æ‰¾æ ‘(Binary Sort Tree) 8.6.2 äºŒå‰æŸ¥æ‰¾æ ‘æ’å…¥ 8.6.3 äºŒå‰æŸ¥æ‰¾æ ‘åˆ é™¤ 8.7 å¹³è¡¡äºŒå‰æ ‘(AVLæ ‘) 9.2.1 æŽ’åºçš„ç¨³å®šæ€§ 9.2.2 å†…æŽ’åºå’Œå¤–æŽ’åº 9.3.2 å†’æ³¡æŽ’åºç®—æ³•(Bubble Sort) 9.3.3 å†’æ³¡æŽ’åºä¼˜åŒ– 9.4.1 ç®€å•é€‰æ‹©æŽ’åº(Simple Selection Sort) 9.5.1 ç›´æŽ¥æ’å…¥æŽ’åº(Straight Insertion Sort) 9.6 å¸Œå°”æŽ’åº(Shell Sort) 9.7 å †æŽ’åº 9.8 å½’å¹¶æŽ’åº 9.9 å¿«é€ŸæŽ’åº 3.4 é¡ºåºå­˜å‚¨ç»“æž„# æ•°å€¼data(èµ·å§‹ä½ç½®)ï¼›æ•°ç»„é•¿åº¦MaxSizeï¼›çº¿æ€§è¡¨é•¿åº¦length LOC($a_{i}$)=LOC($a_{1}$)+(i-1)c 3.6 é“¾å¼å­˜å‚¨ç»“æž„# å•é“¾è¡¨ï¼Œæ¯ä¸ªèŠ‚ç‚¹åªåŒ…å«ä¸€ä¸ªæŒ‡é’ˆåŸŸ å¤´æŒ‡é’ˆï¼Œå¤´èŠ‚ç‚¹ï¼Œç¬¬ä¸€ä¸ªèŠ‚ç‚¹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package mainimport ( "fmt")type Node struct &#123; data string next *Node&#125;type LinkList struct &#123; length int head *Node rear *Node&#125;func NewLinkList(head *Node) *LinkList &#123; return &amp;LinkList&#123;0, head, head&#125;&#125;func (this *LinkList) Append(data string) &#123; if this.rear == nil &#123; return &#125; node := &amp;Node&#123;data: data&#125; this.rear.next = node this.rear = node this.length++&#125;func (this *LinkList) Reverse() *LinkList &#123; head := this.head if head == nil || head.next == nil &#123; return this &#125; var pre *Node = nil cur := head.next //headä¸ä¸ºç©ºæ—¶ï¼Œå½“å‰ä¸ºç¬¬1èŠ‚ç‚¹ this.rear = head.next //ç¬¬1èŠ‚ç‚¹ä¸ä¸ºç©ºæ—¶ï¼Œä½œä¸ºæœ€åŽèŠ‚ç‚¹ for cur != nil &#123; cur.next, pre, cur = pre, cur, cur.next //buf := cur.next //cur.next = pre //pre = cur //cur = buf &#125; head.next = pre //æŒ‡å‘ç¬¬æœ€åŽä¸€ä¸ªèŠ‚ç‚¹ return this&#125;func main() &#123; head := &amp;Node&#123;&#125; bl := NewLinkList(head) bl.Append("1") bl.Append("2") bl.Append("3") bl.Append("4") bl.Reverse() for node := bl.head; node != nil; node = node.next &#123; fmt.Print(node.data, " ") &#125;&#125;&gt; Output:command-line-arguments 4 3 2 1 3.11 å•é“¾è¡¨ç»“æž„ä¸Žé¡ºåºå­˜å‚¨ç»“æž„# å†…å­˜åˆ†é…ï¼›æ—¶é—´å¤æ‚åº¦(æŸ¥æ‰¾ï¼Œæ’å…¥å’Œåˆ é™¤)ï¼›ç©ºé—´å¤æ‚åº¦ 3.12 é™æ€é“¾è¡¨# 3.13 å¾ªçŽ¯é“¾è¡¨# å°¾æŒ‡é’ˆrear å¤´èŠ‚ç‚¹rear-&gt;next ç¬¬ä¸€ä¸ªèŠ‚ç‚¹rear-&gt;next-&gt;next åˆå¹¶ï¼š p=rearA-&gt;next q=rearB-&gt;next rearA-&gt;next=rearB-&gt;next-&gt;next rearB-&gt;next=p free(q) 3.14 åŒå‘é“¾è¡¨# 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package mainimport ( "fmt")type Node struct &#123; data string pre *Node next *Node&#125;type BiLinkList struct &#123; length int head *Node rear *Node&#125;func NewBiLinkList(head *Node) *BiLinkList &#123; return &amp;BiLinkList&#123;0, head, head&#125;&#125;func (this *BiLinkList) Append(data string) &#123; node := &amp;Node&#123;data: data&#125; this.rear.next = node node.pre = this.rear this.rear = node this.length++&#125;func (this *BiLinkList) InsertNext(p *Node, e string) &#123; //çœç•¥åˆ¤æ–­ nd ä¸ä¸ºç©ºä¸”å±žäºŽé“¾è¡¨ if p.next == nil &#123; this.Append(e) &#125; else &#123; s := &amp;Node&#123;data: e&#125; s.pre = p s.next = p.next p.next.pre = s p.next = s &#125; this.length++&#125;func main() &#123; head := &amp;Node&#123;&#125; bl := NewBiLinkList(head) bl.Append("1") bl.Append("2") bl.Append("3") bl.InsertNext(head.next.next, "2.5") //for i := 0; i &lt; bl.length; i++ &#123; // fmt.Print(head.next.data, " ") // head = head.next //&#125; for node := bl.head; node.next != nil; node = node.next &#123; fmt.Print(node.data, " ") &#125; fmt.Print(bl.rear.data) //æ‰“å°æœ«èŠ‚ç‚¹&#125;&gt; Output:command-line-arguments 1 2 2.5 3 ä½¿ç”¨æ ‡å‡†åº“ 1234567891011121314151617181920212223package mainimport ( "container/list" "fmt")func main() &#123; bl := list.New() for i := 1; i &lt; 4; i++ &#123; bl.PushBack(i) &#125; head := bl.Front() rear := bl.Back() for p := head; p != rear; p = p.Next() &#123; fmt.Print(p.Value, " ") &#125; fmt.Print(rear.Value)&#125;&gt; Output:command-line-arguments1 2 3 4.2 æ ˆ# 123ä¾æ¬¡è¿›æ ˆï¼Œå‡ºæ ˆæ¬¡åºä¸å¯èƒ½æœ‰312(12åŒæ—¶åœ¨æ ˆä¸­,2ä¸€å®šå…ˆå‡º) s-&gt;top æ ˆé¡¶æŒ‡é’ˆ æ ˆé¡¶æŒ‡é’ˆä¸º-1è¡¨ç¤ºæŽ§æ ˆ s-&gt;data[s-&gt;top]æ ˆé¡¶å…ƒç´  12345678910111213type Stack struct &#123; //ç”¨äºŽå­˜æ”¾ int çš„æ ˆ nums []int&#125;func (this *Stack) Push(n int) &#123; this.nums = append(this.nums, n)&#125;func (this *Stack) Pop() int &#123; res := this.nums[len(this.nums)-1] this.nums = this.nums[:len(this.nums)-1] return res&#125; 4.10 é˜Ÿåˆ—# 12345678910111213type Queue struct &#123; //Queue æ˜¯ç”¨äºŽå­˜æ”¾ int çš„é˜Ÿåˆ— nums []int&#125;func (this *Queue) Push(n int) &#123; this.nums = append(this.nums, n)&#125;func (this *Queue) Pop() int &#123; res := this.nums[0] this.nums = this.nums[1:] return res&#125; 4.12 å¾ªçŽ¯é˜Ÿåˆ—# é˜Ÿåˆ—æ»¡çš„æ¡ä»¶: (rear+1)%QueueSize == front é˜Ÿåˆ—é•¿åº¦:(rear-front+QueueSize)%QueueSize 6.4 æ ‘çš„å­˜å‚¨ç»“æž„# åŒäº²è¡¨ç¤º(æ•°ç»„)ï¼Œå­©å­å…„å¼Ÿè¡¨ç¤º(æ•°ç»„)ï¼Œå­©å­è¡¨ç¤º(æ•°ç»„+é“¾è¡¨) 6.5.2 ç‰¹æ®ŠäºŒå‰æ ‘# æ–œæ ‘ï¼Œæ»¡äºŒå‰æ ‘ï¼Œå®Œå…¨äºŒå‰æ ‘ 6.6 äºŒå‰æ ‘æ€§è´¨# æ€»ç»“ç‚¹æ•°ï¼š$n=n_{0}+n_{1}+n_{2}$ åˆ†æ”¯çº¿æ€»æ•°ï¼š $n-1=n_{1}+2n_{2}$ å®Œå…¨äºŒå‰æ ‘æ·±åº¦ï¼š$[log_{2}n]+1$ å®Œå…¨äºŒå‰æ ‘æŒ‰å±‚åºæŽ’å·ï¼šèŠ‚ç‚¹$i$çš„å·¦èŠ‚ç‚¹ä¸º$2i$ 6.8 éåŽ†äºŒå‰æ ‘# 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport ( "fmt")type BinaryTree struct &#123; data string left *BinaryTree right *BinaryTree&#125;func PreOrderRec(bt *BinaryTree) &#123; //å‰åº if bt == nil &#123; return &#125; fmt.Print(bt.data, " ") PreOrderRec(bt.left) PreOrderRec(bt.right)&#125;func MidOrderRec(bt *BinaryTree) &#123; //ä¸­åº if bt == nil &#123; return &#125; MidOrderRec(bt.left) fmt.Print(bt.data, " ") MidOrderRec(bt.right)&#125;func PostOrderRec(bt *BinaryTree) &#123; //åŽåº if bt == nil &#123; return &#125; PostOrderRec(bt.left) PostOrderRec(bt.right) fmt.Print(bt.data, " ")&#125;func main() &#123; node9 := &amp;BinaryTree&#123;data: "I"&#125; node8 := &amp;BinaryTree&#123;data: "H"&#125; node7 := &amp;BinaryTree&#123;data: "G"&#125; node6 := &amp;BinaryTree&#123;data: "F"&#125; node5 := &amp;BinaryTree&#123;data: "E", right: node9&#125; node4 := &amp;BinaryTree&#123;"D", node7, node8&#125; node3 := &amp;BinaryTree&#123;"C", node5, node6&#125; node2 := &amp;BinaryTree&#123;data: "B", left: node4&#125; root := &amp;BinaryTree&#123;"A", node2, node3&#125; PreOrderRec(root) fmt.Println() MidOrderRec(root) fmt.Println() PostOrderRec(root)&#125;&gt; Output:command-line-argumentsA B D G H C E I F G D H B A E I C F G H D B I E F C A 6.8.6 æŽ¨å¯¼éåŽ†ç»“æžœ# å‰åºéåŽ†åºåˆ—+ä¸­åºéåŽ†åºåˆ—-&gt;äºŒå‰æ ‘ åŽåºéåŽ†åºåˆ—+ä¸­åºéåŽ†åºåˆ—-&gt;äºŒå‰æ ‘ å‰ä¸­åŽï¼šBAC ABC ACB 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package mainimport ( "fmt")type BinaryTree struct &#123; data string left *BinaryTree right *BinaryTree&#125;func PreOrderRec(bt *BinaryTree) &#123; //å‰åº if bt == nil &#123; return &#125; fmt.Print(bt.data, " ") PreOrderRec(bt.left) PreOrderRec(bt.right)&#125;func MidOrderRec(bt *BinaryTree) &#123; //ä¸­åº if bt == nil &#123; return &#125; MidOrderRec(bt.left) fmt.Print(bt.data, " ") MidOrderRec(bt.right)&#125;func PostOrderRec(bt *BinaryTree) &#123; //åŽåº if bt == nil &#123; return &#125; PostOrderRec(bt.left) PostOrderRec(bt.right) fmt.Print(bt.data, " ")&#125;func PreMid2Tree(pre, mid []string) *BinaryTree &#123; //å‰åº+ä¸­åºæŽ¨å¯¼äºŒå‰æ ‘ if len(pre) != len(mid) &#123; panic("ä¸¤ä¸ªåˆ‡ç‰‡çš„é•¿åº¦ä¸ç›¸ç­‰") &#125; if len(mid) == 0 &#123; return nil &#125; root := &amp;BinaryTree&#123; //å‰åºç¬¬ä¸€ä¸ªå…ƒç´ ä¸ºroot data: pre[0], &#125; if len(mid) == 1 &#123; return root &#125; position := IndexOf(root.data, mid) //æ‰¾å‡ºrootåœ¨ä¸­åºçš„ä½ç½® root.left = PreMid2Tree(pre[1:position+1], mid[:position]) //é€’å½’ root.right = PreMid2Tree(pre[position+1:], mid[position+1:]) return root&#125;func IndexOf(ele string, seq []string) int &#123; for i, v := range seq &#123; if v == ele &#123; return i &#125; &#125; panic("IndexOfé”™è¯¯ï¼Œå…ƒç´ ä¸å­˜åœ¨")&#125;func main() &#123; bt := PreMid2Tree([]string&#123;"A", "B", "D", "G", "H", "C", "E", "I", "F"&#125;, []string&#123;"G", "D", "H", "B", "A", "E", "I", "C", "F"&#125;) PostOrderRec(bt)&#125;&gt; Output:command-line-argumentsG H D B I E F C A 6.10 çº¿ç´¢äºŒå‰æ ‘# å°†èŠ‚ç‚¹çš„ç©ºæŒ‡é’ˆæ”¹ä¸ºæŒ‡å‘åœ¨éåŽ†åºåˆ—ä¸­çš„å‰é©±æˆ–åŽç»§çš„æŒ‡é’ˆã€‚ 12345678910111213141516171819202122232425262728293031type ThreadBiTree struct &#123; data string left *ThreadBiTree right *ThreadBiTree lTag *ThreadBiTree //ä¸€ä¸ªbitä½ï¼ŒåŒºåˆ†æ˜¯æŒ‡å‘å­©å­è¿˜æ˜¯çº¿ç´¢ rTag *ThreadBiTree&#125;var pre *ThreadBiTree //ä¿å­˜å‰é©±func MidThreading(bt *ThreadBiTree) &#123; //ä¸­åºéåŽ†çº¿ç´¢åŒ– if bt == nil &#123; return &#125; MidThreading(bt.left) if bt.left == nil &#123; //è‹¥btæœ‰å·¦ç©ºæŒ‡é’ˆï¼Œåˆ™æŠŠpreè®¾ä¸ºbtçš„å‰é©±ï¼Œå¹¶è®¾ç½®æ ‡å¿—ä½ bt.left = pre bt.lTag = 1 &#125; if bt.right == nil &#123; //è‹¥btæœ‰å³ç©ºæŒ‡é’ˆï¼Œåˆ™æŠŠbtè®¾ä¸ºpreçš„åŽç»§ï¼Œå¹¶è®¾ç½®æ ‡å¿—ä½ pre.right = bt pre.rTag = 1 &#125; pre = bt MidThreading(bt.right)&#125; 6.11.1 æ ‘è½¬æ¢ä¸ºäºŒå‰æ ‘# å…„å¼Ÿè¿žçº¿ï¼›åªä¿ç•™ç¬¬ä¸€ä¸ªå­©å­çš„è¿žçº¿ 6.12 èµ«å¤«æ›¼æ ‘# å¸¦æƒè·¯å¾„é•¿åº¦(WPL)æœ€å°çš„äºŒå‰æ ‘ WPL(a)= 51+152+403+304+104 WPL(b)= 53+153+402+302+102 æž„é€  æŽ’åºï¼šA5, E10, B15, D30, C40 7.4.1 é‚»æŽ¥çŸ©é˜µ(adjacency matrix)# æ— å‘å›¾ï¼š æœ‰å‘å›¾ï¼š æœ‰å‘ç½‘ï¼š æ— å‘ç½‘çš„å®žçŽ°ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package mainimport ( "fmt")const ( INFINITY int32 = 65536 // æ— ç©·)type Edge struct &#123; //è¾¹çš„é¡¶ç‚¹å’Œæƒå€¼ v0 string v1 string weight int32&#125;type Graph struct &#123; //æ— å‘ç½‘ v []string //é¡¶ç‚¹æ•°ç»„ e []Edge //è¾¹çš„æƒå€¼&#125;func IndexOfVertex(vs []string, v string) int &#123; //é¡¶ç‚¹åœ¨é¡¶ç‚¹æ•°ç»„çš„ä½ç½® for i, value := range vs &#123; if value == v &#123; return i &#125; &#125; panic("è¾¹çš„é¡¶ç‚¹ä¸åœ¨é¡¶ç‚¹æ•°ç»„ä¸­ï¼")&#125;func (this *Graph) AdjMatrix() [][]int32 &#123; vertexNum := len(this.v) adjM := make([][]int32, vertexNum) //ç”ŸæˆçŸ©é˜µç”¨ä¸¤æ¬¡make() for i := 0; i &lt; vertexNum; i++ &#123; //åˆå§‹åŒ– adjM[i] = make([]int32, vertexNum) for j := 0; j &lt; vertexNum; j++ &#123; if j == i &#123; adjM[i][j] = 0 &#125; else &#123; adjM[i][j] = INFINITY &#125; &#125; &#125; e := this.e v := this.v for _, edge := range e &#123; adjM[IndexOfVertex(v, edge.v0)][IndexOfVertex(v, edge.v1)] = edge.weight adjM[IndexOfVertex(v, edge.v1)][IndexOfVertex(v, edge.v0)] = edge.weight //å› ä¸ºæ˜¯æ— å‘å›¾æ‰€ä»¥æ˜¯å¯¹ç§°çŸ©é˜µ &#125; return adjM&#125;func main() &#123; v := []string&#123;"A", "B", "C", "D"&#125; e := []Edge&#123; Edge&#123;"A", "B", 5&#125;, Edge&#123;"A", "C", 3&#125;, Edge&#123;"A", "D", 6&#125;, Edge&#123;"B", "C", 7&#125;, Edge&#123;"C", "D", 9&#125;, &#125; graph := &amp;Graph&#123;v, e&#125; //ç”Ÿæˆæ— å‘ç½‘ fmt.Println(graph.AdjMatrix()) // A B C D //A [ 0 5 3 6 ] //B [ 5 0 7 65536 ] //C [ 3 7 0 9 ] //D [ 6 65536 9 0 ]&#125;&gt; Output:command-line-arguments[[0 5 3 6] [5 0 7 65536] [3 7 0 9] [6 65536 9 0]] 7.4.2 é‚»æŽ¥è¡¨# æ— å‘å›¾ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package mainimport ( "fmt")type Edge struct &#123; //ç»™å®šé¡¶ç‚¹å®šä¹‰è¾¹ v0 string v1 string&#125;type Graph struct &#123; //æ— å‘å›¾ v []string //é¡¶ç‚¹æ•°ç»„ e []Edge //è¾¹æ•°ç»„&#125;type Node struct &#123; //é‚»æŽ¥è¡¨çš„è¾¹è¡¨èŠ‚ç‚¹ adjvex int next *Node&#125;type Vertex struct &#123; //é‚»æŽ¥è¡¨çš„é¡¶ç‚¹ data string firstedge *Node&#125;type LinkList struct &#123; //é‚»æŽ¥è¡¨çš„é“¾è¡¨ head *Vertex rear *Node&#125;func (this *LinkList) Append(adjvex int) &#123; newNode := &amp;Node&#123;adjvex: adjvex&#125; if this.rear == nil &#123; this.head.firstedge = newNode &#125; else &#123; this.rear.next = newNode this.rear = newNode &#125; this.rear = newNode&#125;func IndexOfVertex(vs []string, v string) int &#123; //é¡¶ç‚¹åœ¨é¡¶ç‚¹æ•°ç»„çš„ä½ç½® for i, value := range vs &#123; if value == v &#123; return i &#125; &#125; panic("è¾¹çš„é¡¶ç‚¹ä¸åœ¨é¡¶ç‚¹æ•°ç»„ä¸­ï¼")&#125;func (this *Graph) AdjList() []LinkList &#123; vertexNum := len(this.v) v := this.v e := this.e adjL := make([]LinkList, vertexNum) //ç”¨ä¸€ä¸ªå•å‘é“¾è¡¨çš„æ•°ç»„æ¥è¡¨ç¤ºé‚»æŽ¥è¡¨ //for i := 0; i &lt; vertexNum; i++ &#123; //åˆå§‹ // adjL[i].head.data = v[i] å› ä¸ºæ­¤æ—¶headä¸ºnilï¼Œæ²¡æœ‰dataå­—æ®µ //&#125; for i := 0; i &lt; vertexNum; i++ &#123; //åˆå§‹ adjL[i].head = &amp;Vertex&#123;data: v[i]&#125; &#125; for _, edge := range e &#123; i := IndexOfVertex(v, edge.v0) j := IndexOfVertex(v, edge.v1) adjL[i].Append(j) adjL[j].Append(i) &#125; return adjL&#125;func main() &#123; v := []string&#123;"v0", "v1", "v2", "v3"&#125; e := []Edge&#123; Edge&#123;"v0", "v1"&#125;, Edge&#123;"v0", "v2"&#125;, Edge&#123;"v0", "v3"&#125;, Edge&#123;"v1", "v2"&#125;, Edge&#123;"v2", "v3"&#125;, &#125; graph := &amp;Graph&#123;v, e&#125; //ç”Ÿæˆæ— å‘å›¾ adjL := graph.AdjList() for _, v := range adjL &#123; fmt.Print(v.head.data, " ") for node := v.head.firstedge; node != nil; node = node.next &#123; fmt.Print(node.adjvex, " ") &#125; fmt.Println() &#125;&#125;&gt; Output:command-line-argumentsv0 1 2 3 v1 0 2 v2 0 1 3 v3 0 2 æœ‰å‘ç½‘ï¼š 7.5.1 æ·±åº¦ä¼˜å…ˆéåŽ†(Depth First Search)# 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package mainimport ( "fmt")var flag []bool //å…¨å±€å˜é‡type Edge struct &#123; //ç»™å®šé¡¶ç‚¹å®šä¹‰è¾¹ v0 string v1 string&#125;type Graph struct &#123; //æ— å‘å›¾ v []string //é¡¶ç‚¹æ•°ç»„ e []Edge //è¾¹æ•°ç»„&#125;func (this *Graph) AdjMatrix() [][]int &#123; vertexNum := len(this.v) adjM := make([][]int, vertexNum) //ç”ŸæˆçŸ©é˜µç”¨ä¸¤æ¬¡make() for i := 0; i &lt; vertexNum; i++ &#123; //åˆå§‹åŒ– adjM[i] = make([]int, vertexNum) for j := 0; j &lt; vertexNum; j++ &#123; adjM[i][j] = 0 &#125; &#125; e := this.e v := this.v for _, edge := range e &#123; adjM[IndexOfVertex(v, edge.v0)][IndexOfVertex(v, edge.v1)] = 1 adjM[IndexOfVertex(v, edge.v1)][IndexOfVertex(v, edge.v0)] = 1 &#125; return adjM&#125;func IndexOfVertex(vs []string, v string) int &#123; for i, value := range vs &#123; if value == v &#123; return i &#125; &#125; panic("è¾¹çš„é¡¶ç‚¹ä¸åœ¨é¡¶ç‚¹æ•°ç»„ä¸­ï¼")&#125;func DFSTraverse(adjM [][]int) &#123; //è¾“å…¥æ— å‘å›¾çš„é‚»æŽ¥çŸ©é˜µ vertexNum := len(adjM) flag = make([]bool, vertexNum) //åˆå§‹åŒ–flagï¼Œæ³¨æ„è¿™é‡Œä¸èƒ½ç”¨ := for i := 0; i &lt; vertexNum; i++ &#123; flag[i] = false &#125; for i := 0; i &lt; vertexNum; i++ &#123; //å¯¹æœªè®¿é—®çš„èŠ‚ç‚¹æ‰§è¡Œæ·±åº¦æœç´¢ if !flag[i] &#123; DFS(vertexNum, i, adjM) &#125; &#125;&#125;func DFS(vertexNum int, i int, adjM [][]int) &#123; flag[i] = true fmt.Print(i, " ") //æ‰“å°è¢«è®¿é—®çš„èŠ‚ç‚¹åºå· for j := 0; j &lt; vertexNum; j++ &#123; //å¯¹æœªè¢«è®¿é—®çš„é‚»èŠ‚ç‚¹é€’å½’ if adjM[i][j] == 1 &amp;&amp; !flag[j] &#123; DFS(vertexNum, j, adjM) &#125; &#125;&#125;func main() &#123; v := []string&#123;"A", "B", "C", "D", "E", "F", "G", "H", "I"&#125; e := []Edge&#123; Edge&#123;"A", "B"&#125;, Edge&#123;"A", "F"&#125;, Edge&#123;"B", "C"&#125;, Edge&#123;"B", "G"&#125;, Edge&#123;"B", "I"&#125;, Edge&#123;"F", "G"&#125;, Edge&#123;"F", "E"&#125;, Edge&#123;"C", "D"&#125;, Edge&#123;"C", "I"&#125;, Edge&#123;"G", "D"&#125;, Edge&#123;"G", "H"&#125;, Edge&#123;"E", "D"&#125;, Edge&#123;"E", "H"&#125;, &#125; graph := &amp;Graph&#123;v, e&#125; //ç”Ÿæˆæ— å‘å›¾ adjM := graph.AdjMatrix() for i := 0; i &lt; len(adjM); i++ &#123; fmt.Println(adjM[i]) &#125; fmt.Println("-------------------") DFSTraverse(adjM)&#125;&gt; Output:command-line-arguments[0 1 0 0 0 1 0 0 0][1 0 1 0 0 0 1 0 1][0 1 0 1 0 0 0 0 1][0 0 1 0 1 0 1 0 0][0 0 0 1 0 1 0 1 0][1 0 0 0 1 0 1 0 0][0 1 0 1 0 1 0 1 0][0 0 0 0 1 0 1 0 0][0 1 1 0 0 0 0 0 0]-------------------0 1 2 3 4 5 6 7 8 7.5.2 å¹¿åº¦ä¼˜å…ˆéåŽ†(Breadth First Search)# 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169package mainimport ( "fmt")type Edge struct &#123; //ç»™å®šé¡¶ç‚¹å®šä¹‰è¾¹ v0 string v1 string&#125;type Graph struct &#123; //æ— å‘å›¾ v []string //é¡¶ç‚¹æ•°ç»„ e []Edge //è¾¹æ•°ç»„&#125;type Node struct &#123; //é‚»æŽ¥è¡¨çš„è¾¹è¡¨èŠ‚ç‚¹ adjvex int next *Node&#125;type Vertex struct &#123; //é‚»æŽ¥è¡¨çš„é¡¶ç‚¹ data string firstedge *Node&#125;type LinkList struct &#123; //é‚»æŽ¥è¡¨çš„é“¾è¡¨ head *Vertex rear *Node&#125;type Queue struct &#123; nums []int&#125;func (this *Queue) Push(n int) &#123; this.nums = append(this.nums, n)&#125;func (this *Queue) Pop() int &#123; res := this.nums[0] this.nums = this.nums[1:] return res&#125;func (this *LinkList) Append(adjvex int) &#123; newNode := &amp;Node&#123;adjvex: adjvex&#125; if this.rear == nil &#123; this.head.firstedge = newNode &#125; else &#123; this.rear.next = newNode this.rear = newNode &#125; this.rear = newNode&#125;func IndexOfVertex(vs []string, v string) int &#123; //é¡¶ç‚¹åœ¨é¡¶ç‚¹æ•°ç»„çš„ä½ç½® for i, value := range vs &#123; if value == v &#123; return i &#125; &#125; panic("è¾¹çš„é¡¶ç‚¹ä¸åœ¨é¡¶ç‚¹æ•°ç»„ä¸­ï¼")&#125;func (this *Graph) AdjList() []LinkList &#123; vertexNum := len(this.v) v := this.v e := this.e adjL := make([]LinkList, vertexNum) //ç”¨ä¸€ä¸ªå•å‘é“¾è¡¨çš„æ•°ç»„æ¥è¡¨ç¤ºé‚»æŽ¥è¡¨ //for i := 0; i &lt; vertexNum; i++ &#123; //åˆå§‹ // adjL[i].head.data = v[i] å› ä¸ºæ­¤æ—¶headä¸ºnilï¼Œæ²¡æœ‰dataå­—æ®µ //&#125; for i := 0; i &lt; vertexNum; i++ &#123; //åˆå§‹ adjL[i].head = &amp;Vertex&#123;data: v[i]&#125; &#125; for _, edge := range e &#123; i := IndexOfVertex(v, edge.v0) j := IndexOfVertex(v, edge.v1) adjL[i].Append(j) adjL[j].Append(i) &#125; return adjL&#125;func BFSTraverse(adjL []LinkList) &#123; //è¾“å…¥é‚»æŽ¥è¡¨ vertexNum := len(adjL) flag := make([]bool, vertexNum) //æ ‡è®°è¢«è®¿é—®çš„èŠ‚ç‚¹ for i := 0; i &lt; vertexNum; i++ &#123; flag[i] = false &#125; Q := new(Queue) //é˜Ÿåˆ— for i := 0; i &lt; vertexNum; i++ &#123; if !flag[i] &#123; //å¦‚æžœé¡¶ç‚¹æœªè¢«è®¿é—® flag[i] = true Q.Push(i) for len(Q.nums) &gt; 0 &#123; //é˜Ÿåˆ—ä¸ä¸ºç©º j := Q.Pop() fmt.Print(adjL[j].head.data, " ") //æ‰“å°èŠ‚ç‚¹ for node := adjL[j].head.firstedge; node != nil; node = node.next &#123; if flag[node.adjvex] == false &#123; flag[node.adjvex] = true Q.Push(node.adjvex) &#125; &#125; &#125; &#125; &#125;&#125;func main() &#123; v := []string&#123;"A", "B", "C", "D", "E", "F", "G", "H", "I"&#125; e := []Edge&#123; Edge&#123;"A", "B"&#125;, Edge&#123;"A", "F"&#125;, Edge&#123;"B", "C"&#125;, Edge&#123;"B", "G"&#125;, Edge&#123;"B", "I"&#125;, Edge&#123;"F", "G"&#125;, Edge&#123;"F", "E"&#125;, Edge&#123;"C", "D"&#125;, Edge&#123;"C", "I"&#125;, Edge&#123;"G", "D"&#125;, Edge&#123;"G", "H"&#125;, Edge&#123;"E", "D"&#125;, Edge&#123;"E", "H"&#125;, &#125; graph := &amp;Graph&#123;v, e&#125; //ç”Ÿæˆæ— å‘å›¾ adjL := graph.AdjList() for _, v := range adjL &#123; fmt.Print(v.head.data, " ") for node := v.head.firstedge; node != nil; node = node.next &#123; fmt.Print(adjL[node.adjvex].head.data, " ") &#125; fmt.Println() &#125; fmt.Println("-----------------") BFSTraverse(adjL)&#125;&gt; Output:command-line-argumentsA B F B A C G I C B D I D C G E E F D H F A G E G B F D H H G E I B C -----------------A B F C G I E D H 8.4.1 äºŒåˆ†æŸ¥æ‰¾# 123456789101112131415161718192021222324252627282930313233package mainimport ( "fmt")func BiSearch(a []int, n, key int) int &#123; var low, high, mid int low = 1 high = n for low &lt;= high &#123; mid = (low + high) / 2 //mid = low + (high-low)(key-1)/(99-1) æ’å€¼ if key == a[mid] &#123; return mid &#125; else if key &lt; a[mid] &#123; high = mid - 1 &#125; else &#123; low = mid + 1 &#125; &#125; return 0&#125;func main() &#123; a := []int&#123;0, 1, 16, 24, 35, 47, 59, 62, 73, 88, 99&#125; fmt.Println(BiSearch(a, 10, 62))&#125;&gt; Output:command-line-arguments7 8.6 äºŒå‰æŸ¥æ‰¾æ ‘(Binary Sort Tree)# å·¦å°å³å¤§ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( "fmt")type BinaryTree struct &#123; data int left *BinaryTree right *BinaryTree&#125;func SearchBST(root *BinaryTree, key int) bool &#123; if root == nil &#123; return false &#125; switch &#123; case key &lt; root.data: return SearchBST(root.left, key) case key &gt; root.data: return SearchBST(root.right, key) default: return true &#125;&#125;func main() &#123; node10 := &amp;BinaryTree&#123;data: 37&#125; node9 := &amp;BinaryTree&#123;data: 93&#125; node8 := &amp;BinaryTree&#123;data: 51&#125; node7 := &amp;BinaryTree&#123;data: 35, right: node10&#125; node6 := &amp;BinaryTree&#123;data: 99, left: node9&#125; node5 := &amp;BinaryTree&#123;data: 73&#125; node4 := &amp;BinaryTree&#123;data: 47, left: node7, right: node8&#125; node3 := &amp;BinaryTree&#123;88, node5, node6&#125; node2 := &amp;BinaryTree&#123;data: 58, left: node4&#125; root := &amp;BinaryTree&#123;62, node2, node3&#125; fmt.Print(SearchBST(root, 73), " ") fmt.Print(SearchBST(root, 99), " ") fmt.Print(SearchBST(root, 37), " ") fmt.Print(SearchBST(root, 48), " ") fmt.Print(SearchBST(root, 100))&#125;&gt; Output:command-line-argumentstrue true true false false 8.6.2 äºŒå‰æŸ¥æ‰¾æ ‘æ’å…¥# 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( "fmt")type BinaryTree struct &#123; data int left *BinaryTree right *BinaryTree&#125;func InsertBST(root *BinaryTree, key int) (bool, *BinaryTree) &#123; //if SearchBST(root, key) &#123; //å‡è®¾ä¸å­˜åœ¨ // return false, root //&#125; return true, Insert(root, key)&#125;func Insert(root *BinaryTree, key int) *BinaryTree &#123; if root == nil &#123; return &amp;BinaryTree&#123;data: key&#125; //æ’å…¥çš„æœ¬è´¨è¦ç”Ÿæˆæ–°çš„èŠ‚ç‚¹ &#125; if key &lt; root.data &#123; root.left = Insert(root.left, key) &#125; else &#123; // æ²¡æœ‰key = root.data çš„æƒ…å†µ root.right = Insert(root.right, key) &#125; return root&#125;func main() &#123; node10 := &amp;BinaryTree&#123;data: 37&#125; node9 := &amp;BinaryTree&#123;data: 93&#125; node8 := &amp;BinaryTree&#123;data: 51&#125; node7 := &amp;BinaryTree&#123;data: 35, right: node10&#125; node6 := &amp;BinaryTree&#123;data: 99, left: node9&#125; node5 := &amp;BinaryTree&#123;data: 73&#125; node4 := &amp;BinaryTree&#123;data: 47, left: node7, right: node8&#125; node3 := &amp;BinaryTree&#123;88, node5, node6&#125; node2 := &amp;BinaryTree&#123;data: 58, left: node4&#125; root := &amp;BinaryTree&#123;62, node2, node3&#125; fmt.Print(root.right.right.left.data, root.right.right.left.right, " ") _, root = InsertBST(root, 95) fmt.Print(root.right.right.left.right.data)&#125;&gt; Output:command-line-arguments93 &lt;nil&gt; 95 8.6.3 äºŒå‰æŸ¥æ‰¾æ ‘åˆ é™¤# 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package mainimport ( "fmt")type BinaryTree struct &#123; data int left *BinaryTree right *BinaryTree&#125;//åˆ é™¤dataä¸ºkeyçš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å›žè¯¥äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚func DeleteBST(root *BinaryTree, key int) *BinaryTree &#123; if root == nil &#123; return nil &#125; switch &#123; case key &gt; root.data: //åœ¨å³å­æ ‘ä¸­ root.right = DeleteBST(root.right, key) case key &lt; root.data: //åœ¨å·¦å­æ ‘ä¸­ root.left = DeleteBST(root.left, key) default: //key == root.data if root.left == nil &amp;&amp; root.right == nil &#123; //è¯¥èŠ‚ç‚¹ä¸ºå¶èŠ‚ç‚¹ return nil &#125; else if root.left == nil &amp;&amp; root.right != nil &#123; //è¯¥èŠ‚ç‚¹ä»…æœ‰å³å­æ ‘ return root.right &#125; else if root.left != nil &amp;&amp; root.right == nil &#123; //è¯¥èŠ‚ç‚¹ä»…æœ‰å·¦å­æ ‘ return root.left &#125; else &#123; //è¯¥èŠ‚ç‚¹æœ‰å·¦ã€å³å­æ ‘ success := FindMin(root.right) //æ‰¾åˆ°keyçš„åŽç»§èŠ‚ç‚¹,å³48 root.right = DeleteBST(root.right, success) root.data = success &#125; &#125; return root&#125;//æ‰¾åˆ°BSTä¸­dataæœ€å°çš„èŠ‚ç‚¹func FindMin(root *BinaryTree) int &#123; if root.left == nil &#123; //æœ€å°å€¼åœ¨æ ¹èŠ‚ç‚¹ return root.data &#125; return FindMin(root.left) //æœ€å°å€¼åœ¨å·¦å­æ ‘&#125;func main() &#123; node16 := &amp;BinaryTree&#123;data: 50&#125; node15 := &amp;BinaryTree&#123;data: 48&#125; node14 := &amp;BinaryTree&#123;data: 36&#125; node13 := &amp;BinaryTree&#123;data: 56&#125; node12 := &amp;BinaryTree&#123;49, node15, node16&#125; node11 := &amp;BinaryTree&#123;data: 37, left: node14&#125; node10 := &amp;BinaryTree&#123;data: 29&#125; node9 := &amp;BinaryTree&#123;data: 93&#125; node8 := &amp;BinaryTree&#123;51, node12, node13&#125; node7 := &amp;BinaryTree&#123;35, node10, node11&#125; node6 := &amp;BinaryTree&#123;data: 99, left: node9&#125; node5 := &amp;BinaryTree&#123;data: 73&#125; node4 := &amp;BinaryTree&#123;data: 47, left: node7, right: node8&#125; node3 := &amp;BinaryTree&#123;88, node5, node6&#125; node2 := &amp;BinaryTree&#123;data: 58, left: node4&#125; root := &amp;BinaryTree&#123;62, node2, node3&#125; root = DeleteBST(root, 47) NewNode := root.left.left fmt.Print(NewNode.data, " ") //æ‰“å°ä»£æ›¿åˆ é™¤ä½ç½®çš„æ–°èŠ‚ç‚¹ fmt.Print(NewNode.left.data, NewNode.right.data)&#125;&gt; Output:command-line-arguments48 35 51 8.7 å¹³è¡¡äºŒå‰æ ‘(AVLæ ‘)# å¹³è¡¡å› å­(BF)=å·¦å­æ ‘çš„æ·±åº¦-å³å­æ ‘çš„æ·±åº¦ æ—‹è½¬ï¼š 123456789//å³æ—‹func RRotate(k2 *BinaryTree) *BinaryTree &#123; k1 := k2.left y := k1.right k1.right = k2 k2.left = y return k1&#125; åŒæ—‹è½¬ï¼š 12345//å·¦å³æ—‹è½¬func LRRotate(k3 *BinaryTree) *BinaryTree &#123; k3.left = LRotate(k3.left) return RRotate(k3)&#125; å°†ä»»æ„äºŒå‰æ ‘ä¸€æ¬¡æ€§è°ƒæ•´AVL 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185package mainimport ( "fmt")type BinaryTree struct &#123; data int bf int //Balance Factor left *BinaryTree right *BinaryTree&#125;//å³æ—‹func R_Rotate(root *BinaryTree) *BinaryTree &#123; a := root.left b := a.right a.right = root root.left = b return a&#125;//å·¦æ—‹func L_Rotate(root *BinaryTree) *BinaryTree &#123; a := root.right b := a.left a.left = root root.right = b return a&#125;//å·¦å³æ—‹è½¬func LR_Rotate(root *BinaryTree) *BinaryTree &#123; root.left = L_Rotate(root.left) return R_Rotate(root)&#125;//å³å·¦æ—‹è½¬func RL_Rotate(root *BinaryTree) *BinaryTree &#123; root.right = R_Rotate(root.right) return L_Rotate(root)&#125;//å°†ä»»æ„äºŒå‰æ ‘è½¬åŒ–æˆAVLfunc Balance(root *BinaryTree) *BinaryTree &#123; a := &amp;BinaryTree&#123;left: root&#125; //ç»™äºŒå‰æ ‘ç”Ÿæˆä¸€ä¸ªçˆ¶æ¯èŠ‚ç‚¹ _, isAVL := Bal(root) //è°ƒæ•´äºŒå‰æ ‘çš„å­æ ‘å¹¶åˆ¤æ–­äºŒå‰æ ‘æ˜¯å¦å¹³è¡¡ for !isAVL &#123; Bal(a) //å¤„ç†açš„å·¦å­æ ‘ï¼Œå³äºŒå‰æ ‘ _, isAVL = Bal(a.left) //åˆ¤æ–­äºŒå‰æ ‘æ˜¯å¦å¹³è¡¡ &#125; return a.left //è¿”å›žäºŒå‰æ ‘&#125;//è°ƒæ•´å­æ ‘func Bal(root *BinaryTree) (int, bool) &#123; if root == nil &#123; return 0, true &#125; leftHeight, leftIsBalanced := Bal(root.left) rightHeight, rightIsBalanced := Bal(root.right) if !leftIsBalanced &#123; root.left = Rotate(root.left) //è°ƒæ•´å·¦å­æ ‘ leftHeight = UpdateBF(root.left) //åˆ·æ–°å·¦å­æ ‘çš„BFå’Œé«˜åº¦ &#125; if !rightIsBalanced &#123; root.right = Rotate(root.right) rightHeight = UpdateBF(root.right) &#125; root.bf = leftHeight - rightHeight //è®¡ç®—æœ¬èº«çš„BF if Abs(root.bf) &lt;= 1 &#123; return Max(leftHeight, rightHeight) + 1, true &#125; return Max(leftHeight, rightHeight) + 1, false&#125;//å¯¹ä¸å¹³è¡¡æ ‘è¿›è¡Œæ—‹è½¬è°ƒæ•´func Rotate(root *BinaryTree) *BinaryTree &#123; if root.bf &gt; 0 &#123; //å·¦è¾¹å¤ªé‡ï¼Œéœ€è¦å³æ—‹ if root.left.bf &lt; 0 &#123; return LR_Rotate(root) &#125; return R_Rotate(root) &#125; if root.right.bf &gt; 0 &#123; return RL_Rotate(root) &#125; return L_Rotate(root)&#125;func UpdateBF(root *BinaryTree) int &#123; if root == nil &#123; return 0 &#125; leftHeight := UpdateBF(root.left) rightHeight := UpdateBF(root.right) root.bf = leftHeight - rightHeight return Max(leftHeight, rightHeight) + 1&#125;func Max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;func Abs(a int) int &#123; if a &gt; 0 &#123; return a &#125; return -a&#125;func InsertBST(root *BinaryTree, key int) (bool, *BinaryTree) &#123; //if SearchBST(root, key) &#123; //å‡è®¾ä¸å­˜åœ¨ // return false, root //&#125; return true, Insert(root, key)&#125;func Insert(root *BinaryTree, key int) *BinaryTree &#123; if root == nil &#123; return &amp;BinaryTree&#123;data: key&#125; //æ’å…¥çš„æœ¬è´¨è¦ç”Ÿæˆæ–°çš„èŠ‚ç‚¹ &#125; if key &lt; root.data &#123; root.left = Insert(root.left, key) &#125; else &#123; // æ²¡æœ‰key = root.data çš„æƒ…å†µ root.right = Insert(root.right, key) &#125; return root&#125;func PrintBF(root *BinaryTree) &#123; if root == nil &#123; return &#125; PrintBF(root.left) fmt.Print(root.bf, " ") PrintBF(root.right)&#125;func main() &#123; root := &amp;BinaryTree&#123;data: 1&#125; InsertBST(root, 7) InsertBST(root, 2) InsertBST(root, 4) InsertBST(root, 8) InsertBST(root, 3) InsertBST(root, 10) InsertBST(root, 5) InsertBST(root, 9) InsertBST(root, 6) UpdateBF(root) PrintBF(root) //äºŒå‰æ ‘çš„BF fmt.Println() PrintBF(Balance(root)) //å¹³è¡¡è°ƒæ•´åŽçš„äºŒå‰æ ‘çš„BF&#125;&gt; Output:command-line-arguments-5 -3 0 -1 -1 0 1 -2 0 1 0 0 0 -1 -1 0 0 0 0 0 9.2.1 æŽ’åºçš„ç¨³å®šæ€§# 9.2.2 å†…æŽ’åºå’Œå¤–æŽ’åº# å†…æŽ’åºæ˜¯åœ¨æŽ’åºçš„æ•´ä¸ªè¿‡ç¨‹ä¸­ï¼Œå¾…æŽ’åºçš„æ‰€æœ‰è®°å½•å…¨éƒ¨åœ¨å†…å­˜ä¸­ã€‚å¤–æŽ’åºçš„æ•´ä¸ªè¿‡ç¨‹åˆ™éœ€è¦åœ¨å†…å¤–å­˜ä¹‹é—´äº¤æ¢æ•°æ®ã€‚ 9.3.2 å†’æ³¡æŽ’åºç®—æ³•(Bubble Sort)# å†’æ³¡æŽ’åºå°±æ˜¯æŠŠå°çš„å…ƒç´ å¾€å‰è°ƒæˆ–è€…æŠŠå¤§çš„å…ƒç´ å¾€åŽè°ƒã€‚æ¯”è¾ƒæ˜¯ç›¸é‚»çš„ä¸¤ä¸ªå…ƒç´ æ¯”è¾ƒï¼Œäº¤æ¢ä¹Ÿå‘ç”Ÿåœ¨è¿™ä¸¤ä¸ªå…ƒç´ ä¹‹é—´ã€‚æ‰€ä»¥ï¼Œå¦‚æžœä¸¤ä¸ªå…ƒç´ ç›¸ç­‰ï¼Œæˆ‘æƒ³ä½ æ˜¯ä¸ä¼šå†æ— èŠåœ°æŠŠä»–ä»¬ä¿©äº¤æ¢ä¸€ä¸‹çš„ï¼›å¦‚æžœä¸¤ä¸ªç›¸ç­‰çš„å…ƒç´ æ²¡æœ‰ç›¸é‚»ï¼Œé‚£ä¹ˆå³ä½¿é€šè¿‡å‰é¢çš„ä¸¤ä¸¤äº¤æ¢æŠŠä¸¤ä¸ªç›¸é‚»èµ·æ¥ï¼Œè¿™æ—¶å€™ä¹Ÿä¸ä¼šäº¤æ¢ï¼Œæ‰€ä»¥ç›¸åŒå…ƒç´ çš„å‰åŽé¡ºåºå¹¶æ²¡æœ‰æ”¹ å˜ï¼Œæ‰€ä»¥å†’æ³¡æŽ’åºæ˜¯ä¸€ç§ç¨³å®šæŽ’åºç®—æ³•ã€‚ 12345678910111213141516171819202122232425262728package mainimport ( "fmt")package mainimport ( "fmt")func BubbleSort(a []int) &#123; length := len(a) for i := 1; i &lt; length-1; i++ &#123; //éœ€è¦äº¤æ¢(length-2)æ¬¡ï¼Œä»ŽåŽå¾€å‰æŽ’ for j := 1; j &lt; length-i; j++ &#123; //å½“i=1æ—¶ï¼Œjå¯ä»¥å–åˆ°(length-2) if a[j] &gt; a[j+1] &#123; a[j], a[j+1] = a[j+1], a[j] &#125; &#125; &#125;&#125;func main() &#123; a := []int&#123;0, 9, 1, 5, 8, 3, 7, 4, 6, 2&#125; BubbleSort(a) fmt.Println(a)&#125; é€’å½’å®žçŽ°. for å¾ªçŽ¯æ‰¾å‡ºæœ€å¤§å€¼æŽ’åˆ°æœ«å°¾ï¼ŒåŽ»æŽ‰æœ«å°¾æŠŠå¯¹æ–°çš„åºåˆ—é€’å½’ 1234567891011121314151617181920212223242526272829package mainimport ( &quot;fmt&quot;)func RecurBubble(a []int) &#123; length := len(a) if length &lt; 3 &#123; //é€’å½’è·³å‡ºæ¡ä»¶ return &#125; for j := 1; j &lt;= length-2; j++ &#123; if a[j] &gt; a[j+1] &#123; a[j], a[j+1] = a[j+1], a[j] &#125; &#125; a = a[0 : length-1] //ä¸åŒ…æ‹¬ç¬¬ length-1 ä¸ªå…ƒç´  RecurBubble(a)&#125;func main() &#123; a := []int&#123;0, 9, 1, 5, 8, 3, 7, 4, 6, 2&#125; RecurBubble(a) fmt.Println(a)&#125; 9.3.3 å†’æ³¡æŽ’åºä¼˜åŒ–# 123456789101112131415161718192021222324252627package mainimport ( "fmt")func BubbleSort2(a []int) &#123; flag := true // æœ‰æ•°æ®äº¤æ¢ length := len(a) for i := 1; i &lt; length-1 &amp;&amp; flag; i++ &#123; flag = false for j := 1; j &lt; length-i; j++ &#123; if a[j] &gt; a[j+1] &#123; a[j], a[j+1] = a[j+1], a[j] flag = true &#125; &#125; &#125;&#125;func main() &#123; a := []int&#123;0, 9, 1, 5, 8, 3, 7, 4, 6, 2&#125; BubbleSort2(a) fmt.Println(a)&#125; 9.4.1 ç®€å•é€‰æ‹©æŽ’åº(Simple Selection Sort)# å¤æ‚åº¦ä¸Žå†’æ³¡æŽ’åºåŒä¸º$O(n^{2})$,ä½†æ€§èƒ½æ›´ä¼˜(æ•°æ®äº¤æ¢æ¬¡æ•°æ›´å°‘)ã€‚é€‰æ‹©æŽ’åºæ˜¯ç»™æ¯ä¸ªä½ç½®é€‰æ‹©å½“å‰å…ƒç´ æœ€å°çš„ï¼Œæ¯”å¦‚ç»™ç¬¬ä¸€ä¸ªä½ç½®é€‰æ‹©æœ€å°çš„ï¼Œåœ¨å‰©ä½™å…ƒç´ é‡Œé¢ç»™ç¬¬äºŒä¸ªå…ƒç´ é€‰æ‹©ç¬¬äºŒå°çš„ï¼Œä¾æ¬¡ç±»æŽ¨ï¼Œç›´åˆ°ç¬¬n-1ä¸ªå…ƒç´ ï¼Œç¬¬nä¸ª å…ƒç´ ä¸ç”¨é€‰æ‹©äº†ï¼Œå› ä¸ºåªå‰©ä¸‹å®ƒä¸€ä¸ªæœ€å¤§çš„å…ƒç´ äº†ã€‚ 1234567891011121314151617181920212223242526272829303132package mainimport ( "fmt")func SelectionSort(a []int) &#123; var min int length := len(a) for i := 1; i &lt; length-1; i++ &#123; //æ’å…¥æ¬¡æ•°(length-2)ï¼Œä»Žå‰å¾€åŽæŽ’ï¼›æŠŠåŽé¢åºåˆ—ä¸­è¾ƒå°çš„æ•°æ’ min = i // å¾ªçŽ¯æ‰¾å‡ºåºåˆ—ä¸­çš„æœ€å°æ•°çš„ä¸‹æ ‡ for j := i + 1; j &lt; length; j++ &#123; //jå–åˆ°iåŽçš„æ‰€æœ‰æ•° if a[j] &lt; a[min] &#123; //ä¹‹åŽæœ‰æ›´å°çš„æ•° min = j &#125; &#125; if i != min &#123; //ä¸‹æ ‡æ”¹å˜ï¼Œäº¤æ¢ï¼Œé˜²æ­¢æ•°æ®ä¸¢å¤± a[i], a[min] = a[min], a[i] &#125; &#125;&#125;func main() &#123; a := []int&#123;0, 9, 1, 5, 8, 3, 7, 4, 6, 2&#125; SelectionSort(a) fmt.Println(a)&#125; åè¿‡æ¥æŽ’ 12345678910111213141516171819202122232425262728293031package mainimport ( &quot;fmt&quot;)func SelectionSort(a []int) &#123; var max int length := len(a) for i := length - 1; i &gt; 0; i-- &#123; ä»Žå¤§åˆ°å°æŽ’ max = i for j := 1; j &lt; i; j++ &#123; if a[j] &gt; a[max] &#123; max = j &#125; &#125; if max != i &#123; a[i], a[max] = a[max], a[i] &#125; &#125;&#125;func main() &#123; a := []int&#123;0, 9, 1, 5, 8, 3, 7, 4, 6, 2&#125; SelectionSort(a) fmt.Println(a)&#125; é€’å½’ 1234567891011121314151617181920212223242526272829303132package mainimport ( "fmt")func SelectionSort(a []int) &#123; length := len(a) if length &lt; 3 &#123; return &#125; max := length - 1 for j := 1; j &lt; length-1; j++ &#123; if a[j] &gt; a[max] &#123; max = j &#125; &#125; if max != length-1 &#123; a[length-1], a[max] = a[max], a[length-1] &#125; SelectionSort(a[:length-1])&#125;func main() &#123; a := []int&#123;0, 9, 1, 5, 8, 3, 7, 4, 6, 2&#125; SelectionSort(a) fmt.Println(a)&#125; 9.5.1 ç›´æŽ¥æ’å…¥æŽ’åº(Straight Insertion Sort)# æ’å…¥æŽ’åºæ˜¯åœ¨ä¸€ä¸ªå·²ç»æœ‰åºçš„å°åºåˆ—çš„åŸºç¡€ä¸Šï¼Œä¸€æ¬¡æ’å…¥ä¸€ä¸ªå…ƒç´ ã€‚å½“ç„¶ï¼Œåˆšå¼€å§‹è¿™ä¸ªæœ‰åºçš„å°åºåˆ—åªæœ‰1ä¸ªå…ƒç´ ï¼Œå°±æ˜¯ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚æ¯”è¾ƒæ˜¯ä»Žæœ‰åºåºåˆ—çš„æœ«å°¾å¼€ å§‹ï¼Œä¹Ÿå°±æ˜¯æƒ³è¦æ’å…¥çš„å…ƒç´ å’Œå·²ç»æœ‰åºçš„æœ€å¤§è€…å¼€å§‹æ¯”èµ·ï¼Œå¦‚æžœæ¯”å®ƒå¤§åˆ™ç›´æŽ¥æ’å…¥åœ¨å…¶åŽé¢ï¼Œå¦åˆ™ä¸€ç›´å¾€å‰æ‰¾ç›´åˆ°æ‰¾åˆ°å®ƒè¯¥æ’å…¥çš„ä½ç½®ã€‚å¦‚æžœç¢°è§ä¸€ä¸ªå’Œæ’å…¥å…ƒç´ ç›¸ ç­‰çš„ï¼Œé‚£ä¹ˆæ’å…¥å…ƒç´ æŠŠæƒ³æ’å…¥çš„å…ƒç´ æ”¾åœ¨ç›¸ç­‰å…ƒç´ çš„åŽé¢ã€‚æ‰€ä»¥ï¼Œç›¸ç­‰å…ƒç´ çš„å‰åŽé¡ºåºæ²¡æœ‰æ”¹å˜ï¼Œä»ŽåŽŸæ— åºåºåˆ—å‡ºåŽ»çš„é¡ºåºå°±æ˜¯æŽ’å¥½åºåŽçš„é¡ºåºï¼Œæ‰€ä»¥æ’å…¥æŽ’åºæ˜¯ç¨³ å®šçš„ã€‚ å¤æ‚åº¦åŒä¸ºä¸º$O(n^{2})$ï¼Œæ€§èƒ½ï¼šæ’å…¥æŽ’åº&gt;é€‰æ‹©æŽ’åº&gt;å†’æ³¡æŽ’åº 123456789101112131415161718192021222324252627package mainimport ( "fmt")func InsertionSort(a []int) &#123; length := len(a) var j int for i := 2; i &lt; length; i++ &#123; //ç¬¬äºŒä¸ªæ•°åˆ°æœ€åŽä¸€ä¸ªæ•° if a[i] &lt; a[i-1] &#123; //ç¬¬iä¸ªæ•°æ¯”å‰é¢çš„æ•°å°ï¼Œéœ€è¦æ’å…¥ a[0] = a[i] //å“¨å…µ for j = i - 1; a[j] &gt; a[0]; j-- &#123; //jå– i-1 åˆ° 1 a[j+1] = a[j] //å°†å¤§äºŽç¬¬iä¸ªæ•°çš„æ•°åŽç§»ä¸€ä½ï¼Œç•™å‡ºç©ºä½ &#125; a[j+1] = a[0] //å°†ç¬¬iä¸ªæ•°æ”¾å…¥ç©ºä½ &#125; &#125;&#125;func main() &#123; a := []int&#123;0, 9, 1, 5, 8, 3, 7, 4, 6, 2&#125; InsertionSort(a) fmt.Println(a)&#125; 9.6 å¸Œå°”æŽ’åº(Shell Sort)# å¸Œå°”æŽ’åºæ˜¯æŒ‰ç…§ä¸åŒæ­¥é•¿å¯¹å…ƒç´ è¿›è¡Œæ’å…¥æŽ’åºï¼Œå½“åˆšå¼€å§‹å…ƒç´ å¾ˆæ— åºçš„æ—¶å€™ï¼Œæ­¥é•¿æœ€å¤§ï¼Œæ‰€ä»¥æ’å…¥æŽ’åºçš„å…ƒç´ ä¸ªæ•°å¾ˆå°‘ï¼Œé€Ÿåº¦å¾ˆå¿«ï¼›å½“å…ƒç´ åŸºæœ¬æœ‰åºäº†ï¼Œæ­¥é•¿å¾ˆå°ï¼Œ æ’å…¥æŽ’åºå¯¹äºŽæœ‰åºçš„åºåˆ—æ•ˆçŽ‡å¾ˆé«˜ã€‚æ‰€ä»¥ï¼Œå¸Œå°”æŽ’åºçš„æ—¶é—´å¤æ‚åº¦ä¼šæ¯”o(n^2)å¥½ä¸€äº›ã€‚ç”±äºŽå¤šæ¬¡æ’å…¥æŽ’åºï¼Œæˆ‘ä»¬çŸ¥é“ä¸€æ¬¡æ’å…¥æŽ’åºæ˜¯ç¨³å®šçš„ï¼Œä¸ä¼šæ”¹å˜ç›¸åŒå…ƒ ç´ çš„ç›¸å¯¹é¡ºåºï¼Œä½†åœ¨ä¸åŒçš„æ’å…¥æŽ’åºè¿‡ç¨‹ä¸­ï¼Œç›¸åŒçš„å…ƒç´ å¯èƒ½åœ¨å„è‡ªçš„æ’å…¥æŽ’åºä¸­ç§»åŠ¨ï¼Œæœ€åŽå…¶ç¨³å®šæ€§å°±ä¼šè¢«æ‰“ä¹±ï¼Œæ‰€ä»¥shellæŽ’åºæ˜¯ä¸ç¨³å®šçš„ã€‚ 12345678910111213141516171819202122232425262728293031package mainimport ( "fmt")func ShellSort(a []int) &#123; var i, j int length := len(a) - 1 //åŽ»æŽ‰ç¬¬0ä½ inc := length //å¢žé‡ for inc &gt; 1 &#123; inc = inc/3 + 1 for i = 1 + inc; i &lt;= length; i++ &#123; //ç¬¬(1+inc)ä¸ªæ•°åˆ°æœ€åŽä¸€ä¸ªæ•° if a[i] &lt; a[i-inc] &#123; a[0] = a[i] for j = i - inc; j &gt; 0 &amp;&amp; a[j] &gt; a[0]; j -= inc &#123; a[j+inc] = a[j] &#125; a[j+inc] = a[0] &#125; &#125; &#125;&#125;func main() &#123; a := []int&#123;0, 9, 1, 5, 8, 3, 7, 4, 6, 2&#125; ShellSort(a) fmt.Println(a)&#125; 9.7 å †æŽ’åº# æ—¶é—´å¤æ‚åº¦$O(nlogn)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( "fmt")func HeapSort(a []int) &#123; length := len(a) - 1 //å¾ªçŽ¯åŽa[1]ä¸ºæœ€å¤§å€¼ for i := length / 2; i &gt; 0; i-- &#123; //(length/2)æ˜¯æœ€åŽä¸€ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹ HeapAdjust(a, i, length) &#125; for i := length; i &gt; 1; i-- &#123; //ä»Žæœ€åŽèŠ‚ç‚¹åˆ°ç¬¬äºŒä¸ªèŠ‚ç‚¹ a[1], a[i] = a[i], a[1] //æŽ’åºç¬¬iä½ HeapAdjust(a, 1, i-1) //å°†1åˆ°i-1ä¸­çš„æœ€å¤§æ•°æ”¾åˆ°a[1] &#125;&#125;func HeapAdjust(a []int, s, m int) &#123; var temp, j int temp = a[s] for j = 2 * s; j &lt;= m; j *= 2 &#123; //ä»¥sä¸ºçˆ¶èŠ‚ç‚¹å¼€å§‹ if j &lt; m &amp;&amp; a[j] &lt; a[j+1] &#123; //å–å‡ºè¾ƒå¤§çš„å­©å­èŠ‚ç‚¹ j = j + 1 &#125; if temp &gt;= a[j] &#123; //çˆ¶èŠ‚ç‚¹å·²ç»æœ€å¤§ break &#125; a[s] = a[j] //å°†æœ€å¤§çš„å€¼æ›¿æ¢ç»™çˆ¶èŠ‚ç‚¹ s = j //å°†å½“å‰èŠ‚ç‚¹ä½œä¸ºçˆ¶èŠ‚ç‚¹ï¼Œè¿›è¡Œä¸‹ä¸€è½®æ“ä½œ &#125; a[s] = temp&#125;func main() &#123; a := []int&#123;0, 9, 1, 5, 8, 3, 7, 4, 6, 2&#125; HeapAdjust(a, 1, 9) fmt.Println(a)&#125; 9.8 å½’å¹¶æŽ’åº# å½’å¹¶æŽ’åºæ˜¯æŠŠåºåˆ—é€’å½’åœ°åˆ†æˆçŸ­åºåˆ—ï¼Œé€’å½’å‡ºå£æ˜¯çŸ­åºåˆ—åªæœ‰1ä¸ªå…ƒç´ (è®¤ä¸ºç›´æŽ¥æœ‰åº)æˆ–è€…2ä¸ªåºåˆ—(1æ¬¡æ¯”è¾ƒå’Œäº¤æ¢),ç„¶åŽæŠŠå„ä¸ªæœ‰åºçš„æ®µåºåˆ—åˆå¹¶æˆä¸€ä¸ªæœ‰ åºçš„é•¿åºåˆ—ï¼Œä¸æ–­åˆå¹¶ç›´åˆ°åŽŸåºåˆ—å…¨éƒ¨æŽ’å¥½åºã€‚å¯ä»¥å‘çŽ°ï¼Œåœ¨1ä¸ªæˆ–2ä¸ªå…ƒç´ æ—¶ï¼Œ1ä¸ªå…ƒç´ ä¸ä¼šäº¤æ¢ï¼Œ2ä¸ªå…ƒç´ å¦‚æžœå¤§å°ç›¸ç­‰ä¹Ÿæ²¡æœ‰äººæ•…æ„äº¤æ¢ï¼Œè¿™ä¸ä¼šç ´åç¨³å®š æ€§ã€‚é‚£ä¹ˆï¼Œåœ¨çŸ­çš„æœ‰åºåºåˆ—åˆå¹¶çš„è¿‡ç¨‹ä¸­ï¼Œç¨³å®šæ˜¯å¦å—åˆ°ç ´åï¼Ÿæ²¡æœ‰ï¼Œåˆå¹¶è¿‡ç¨‹ä¸­æˆ‘ä»¬å¯ä»¥ä¿è¯å¦‚æžœä¸¤ä¸ªå½“å‰å…ƒç´ ç›¸ç­‰æ—¶ï¼Œæˆ‘ä»¬æŠŠå¤„åœ¨å‰é¢çš„åºåˆ—çš„å…ƒç´ ä¿å­˜åœ¨ç»“ æžœåºåˆ—çš„å‰é¢ï¼Œè¿™æ ·å°±ä¿è¯äº†ç¨³å®šæ€§ã€‚æ‰€ä»¥ï¼Œå½’å¹¶æŽ’åºä¹Ÿæ˜¯ç¨³å®šçš„æŽ’åºç®—æ³•ã€‚ é€’å½’æ–¹æ³• Merge()å½’å¹¶æŽ’åºç¤ºæ„å›¾ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package mainimport ( "fmt")// å°†aæŽ’åºåˆ°bfunc MergeSort(a []int) []int &#123; length := len(a) b := make([]int, length) MSort(a, b, 1, length-1) return b&#125;func MSort(a, b []int, s, t int) &#123; if s == t &#123; b[s] = a[s] //å°†aå¤åˆ¶åˆ°åˆ°b &#125; else &#123; m := (s + t) / 2 MSort(a, b, s, m) MSort(a, b, m+1, t) Merge(b, s, m, t) //å°†bå½’å¹¶æŽ’åº &#125;&#125;func Merge(SR []int, i, m, n int) &#123; TR := make([]int, len(SR)) //å½’å¹¶çš„åºåˆ—æš‚å­˜åˆ°TR s := i //ä¿å­˜èµ·å§‹ä½ç½® j := m + 1 k := i //TRåºå· for i &lt;= m &amp;&amp; j &lt;= n &#123; if SR[i] &lt; SR[j] &#123; TR[k] = SR[i] i++ &#125; else &#123; TR[k] = SR[j] j++ &#125; k++ &#125; if i &lt;= m &#123; for l := 0; l &lt;= m-i; l++ &#123; TR[k+l] = SR[i+l] &#125; &#125; if j &lt;= n &#123; for l := 0; l &lt;= n-j; l++ &#123; TR[k+l] = SR[j+l] &#125; &#125; for p := s; p &lt;= n; p++ &#123; //å°†æŽ’å¥½åºçš„TRå†™å›žåˆ°SR if SR[p] != TR[p] &#123; SR[p] = TR[p] &#125; &#125;&#125;func main() &#123; a := []int&#123;0, 9, 1, 5, 8, 3, 7, 4, 6, 5, 16&#125; fmt.Println(MergeSort(a))&#125; éžé€’å½’æ–¹æ³• 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package mainimport ( "fmt")func MergeSort2(a []int) &#123; length := len(a) - 1 for k := 1; k &lt; length; &#123; MergePass(a, k, length) k = k * 2 &#125;&#125;func MergePass(a []int, s, n int) &#123; i := 1 for i &lt;= n-2*s+1 &#123; Merge2(a, i, i+s-1, i+2*s-1) //i+2*s-1&lt;=n i = i + 2*s &#125; if i &lt; n-s+1 &#123; //n&gt;i+s-1,å½’å¹¶æœ€åŽä¸¤ä¸ªå­å— Merge2(a, i, i+s-1, n) &#125;&#125;func Merge2(SR []int, i, m, n int) &#123; TR := make([]int, n-i+1) //ä¸ŽMergeç›¸æ¯”æ ˆç©ºé—´æ›´å° s := i //ä¿å­˜èµ·å§‹ä½ç½® j := m + 1 k := 0 //TRåºå· for i &lt;= m &amp;&amp; j &lt;= n &#123; if SR[i] &lt; SR[j] &#123; TR[k] = SR[i] i++ &#125; else &#123; TR[k] = SR[j] j++ &#125; k++ &#125; if i &lt;= m &#123; for l := 0; l &lt;= m-i; l++ &#123; TR[k+l] = SR[i+l] &#125; &#125; if j &lt;= n &#123; for l := 0; l &lt;= n-j; l++ &#123; TR[k+l] = SR[j+l] &#125; &#125; for p := s; p &lt;= n; p++ &#123; //å°†æŽ’å¥½åºçš„TRå†™å›žåˆ°SR if SR[p] != TR[p-s] &#123; SR[p] = TR[p-s] &#125; &#125;&#125;func main() &#123; a := []int&#123;0, 9, 1, 5, 8, 3, 7, 4, 6, 5, 16, 3, 41, 7, 55, 21&#125; MergeSort2(a) fmt.Println(a)&#125; 9.9 å¿«é€ŸæŽ’åº# 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package mainimport ( "fmt")func QuickSort(a []int) &#123; Qsort(a, 1, len(a)-1)&#125;func Qsort(a []int, low, high int) &#123; if low &lt; high &#123; pivot := Partition(a, low, high) Qsort(a, low, pivot-1) Qsort(a, pivot+1, high) &#125;&#125;func Partition(a []int, low, high int) int &#123; pivotValue := a[low] for low &lt; high &#123; for pivotValue &lt;= a[high] &#123; //æ‰¾å‡ºa[high]&lt;pivotValue high-- &#125; a[low], a[high] = a[high], a[low] //å°†a[hign]æ”¾åˆ°pivoValueå·¦è¾¹ for low &lt; high &amp;&amp; pivotValue &gt;= a[low] &#123; //æ‰¾å‡ºa[low]&gt;pivotValue low++ &#125; a[low], a[high] = a[high], a[low] //å°†a[low]æ”¾åˆ°pivoValueå³è¾¹ &#125; return low&#125;func Partition2(a []int, low, high int) int &#123; pivotValue := a[low] for low &lt; high &#123; for pivotValue &lt;= a[high] &#123; //æ‰¾å‡ºa[high]&lt;pivotValue high-- &#125; a[low] = a[high] //å°†a[hign]æ”¾åˆ°è¾ƒä½Žçš„ä½ç½® for low &lt; high &amp;&amp; pivotValue &gt;= a[low] &#123; //æ‰¾å‡ºa[low]&gt;pivotValue low++ &#125; a[high] = a[low] //å°†a[low]æ”¾åˆ°è¾ƒé«˜çš„ä½ç½® &#125; a[low] = pivotValue return low&#125;func main() &#123; a := []int&#123;0, 50, 10, 90, 30, 70, 40, 80, 60, 20&#125; QuickSort(a) fmt.Println(a)&#125;]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>é•¿æ–‡</tag>
        <tag>æ•°æ®ç»“æž„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Goå†…å­˜æ¨¡åž‹]]></title>
    <url>%2F2018%2F11%2F14%2F2018-11-14%2F</url>
    <content type="text"><![CDATA[1. ä»€ä¹ˆæ˜¯ Goå†…å­˜æ¨¡åž‹ï¼Ÿ 2. Happens Before 3. Synchronization 3.1 Initialization 3.2 Goroutine creation 3.3 Goroutine destruction 3.4 Channel communication 3.5 Locks 3.6 Once 4. Incorrect synchronization æœ¬æ–‡ä¸»è¦ç¿»è¯‘è‡ªå®˜æ–¹æ–‡æ¡£ The Go Memory Model 1. ä»€ä¹ˆæ˜¯ Goå†…å­˜æ¨¡åž‹ï¼Ÿ# æˆ‘ä»¬çŸ¥é“ä¸åŒçš„ goroutine å¯ä»¥å¯¹åŒä¸€ä¸ªå˜é‡è¿›è¡Œè¯»å†™æ“ä½œã€‚Goå†…å­˜æ¨¡åž‹æŒ‡å®šäº†åœ¨ä»€ä¹ˆæ ·çš„æ¡ä»¶ä¸‹å¯ä»¥ä¿è¯ä¸€ä¸ª goroutine å†™å…¥åˆ°å˜é‡çš„å€¼å¯ä»¥è¢«å¦å¤–ä¸€ä¸ª goroutine æ­£ç¡®çš„è¯»å–ã€‚ 2. Happens Before# åœ¨å•ä¸ª goroutine ä¸­ï¼Œè¯»ã€å†™æ“ä½œæŒ‰ç…§ç¨‹åºè®¾è®¡çš„é¡ºåºè¿›è¡Œã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨ä¸æ”¹å˜ goroutine ç¨‹åºè¡Œä¸ºçš„å‰æä¸‹ï¼Œè¿™äº›è¯»ã€å†™é¡ºåºåœ¨ç¼–è¯‘çš„è¿‡ç¨‹ä¸­å¯èƒ½ä¼šè¢«é‡æŽ’ã€‚å› æ­¤å¯¼è‡´å¯¹ç›¸åŒå˜é‡çš„è¯»ã€å†™æ“ä½œåœ¨ä¸åŒçš„ goroutine çœ‹æ¥æ‰§è¡Œé¡ºåºå¯èƒ½ä¸åŒã€‚ä¾‹å¦‚ï¼Œå¦‚æžœåœ¨æŸä¸ª goroutine ä¸­æ‰§è¡Œ a = 1; b = 2;ï¼Œå¦ä¸€ä¸ª goroutine å¯èƒ½è§‚å¯Ÿåˆ°å˜é‡ b æ¯” a å…ˆè¢«èµ‹å€¼ã€‚ Happens Before æ˜¯é’ˆå¯¹Goè¯­è¨€ç¼–ç¨‹ä¸­å†…å­˜æ“ä½œçš„ä¸€ç§å±€éƒ¨æŽ’åºã€‚ å¦‚æžœ $e_{1}$ happens before $e_{2}$ï¼Œé‚£ä¹ˆä¹Ÿå¯ä»¥è¯´ $e_{2}$ happens after $e_{1}$ã€‚è¿›ä¸€æ­¥ï¼Œå¦‚æžœ $e_{1}$ æ—¢ä¸ happens before $e_{2}$ï¼Œä¹Ÿä¸ happens after $e_{2}$ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§° $e_{1}$ å’Œ $e_{2}$ happen concurrently (å¹¶å‘)ã€‚ åœ¨å•ä¸ª goroutine ä¸­ï¼ŒHappens Beforeé¡ºåºå°±æ˜¯ç¨‹åºè®¾è®¡çš„é¡ºåº $v$ï¼šæŸä¸ªå˜é‡ $w$: å¯¹$v$çš„å†™ $w'$: å¯¹$v$çš„å†™ï¼Œä¸åŒäºŽ$w$ $r$: å¯¹$v$çš„è¯» $w$å¯ä»¥è¢«$r$èŽ·å–çš„æ¡ä»¶ï¼š $r$ ä¸ happen before $w$. (åŒ…æ‹¬ happen after å’Œ happen concurrently) ä¸å­˜åœ¨å¦ä¸€ä¸ª $w'$ happens after $w$ but before $r$. $w$ä¿è¯èƒ½è¢«$r$èŽ·å–çš„æ¡ä»¶(è¯¥æ¡ä»¶ä¸å…è®¸$w'$ä¸Ž$w$æˆ–è€…$r$å¹¶å‘ï¼Œå› æ­¤æ¯”ä¸Šé¢çš„æ¡ä»¶æ›´å¼º): $w$ happens before $r$. ä»»ä½•å…¶å®ƒçš„ $w'$ è¦ä¹ˆ happens before $w$ï¼Œè¦ä¹ˆ happens after $r$. å½“æœ‰å¤šä¸ª goroutine å¯ä»¥è®¿é—®$v$æ—¶ï¼Œå¿…é¡»åˆ©ç”¨åŒæ­¥äº‹ä»¶(synchronization events)æ¥å»ºç«‹ happens before ä»¥ä¿è¯ $r$èƒ½å¤ŸèŽ·å–æƒ³è¦çš„$w$ã€‚ åœ¨åˆå§‹åŒ–è¿‡ç¨‹ä¸­ï¼Œèµ‹ç»™$v$ä»¥å…¶ç±»åž‹çš„é›¶å€¼çš„æ“ä½œå¯ä»¥çœ‹ä½œæ˜¯å†…å­˜æ¨¡åž‹ä¸­çš„ä¸€ç§$w$ 3. Synchronization# 3.1 Initialization# ç¨‹åºçš„åˆå§‹åŒ–åœ¨ä¸€ä¸ª goroutine ä¸­è¿›è¡Œï¼Œå¹¶ä¸”åœ¨è¯¥ goroutine ä¸­è¿˜å¯ä»¥åˆ›å»ºå…¶å®ƒçš„ goroutine å¦‚æžœåŒ… $p$å¯¼å…¥äº†åŒ…$q$ï¼Œé‚£ä¹ˆåŒ…$q$åœ¨è¢«å¯¼å…¥ä¹‹å‰å°±å®Œæˆäº†åˆå§‹åŒ–ï¼Œå‡½æ•°main.mainåœ¨æ‰€æœ‰çš„initå‡½æ•°å®ŒæˆåŽå¼€å§‹æ‰§è¡Œï¼Œè§astaxieçš„mainå‡½æ•°å’Œinitå‡½æ•°ä¸€æ–‡ 3.2 Goroutine creation# å¯åŠ¨ä¸€ä¸ªæ–°çš„ goroutine çš„ Goå£°æ˜Žå‘ç”Ÿåœ¨è¯¥ goroutineå¼€å§‹æ‰§è¡Œä¹‹å‰ 12345678910111213141516package mainvar a stringfunc f() &#123; print(a)&#125;func hello() &#123; a = "hello, world" go f()&#125;func main() &#123; hello()&#125; è°ƒç”¨hello()å°†ä¼šåœ¨æœªæ¥æŸä¸ªæ—¶é—´ç‚¹( å¯èƒ½åœ¨hello()è¿”å›žä¹‹åŽ )æ‰“å°hello, world 3.3 Goroutine destruction# æ— æ³•ä¿è¯ goroutine åœ¨å…¶åˆ›å»ºç¨‹åºä¸­çš„æŸä¸ªä½ç½®é€€å‡º 123456var a stringfunc hello() &#123; go func() &#123; a = "hello" &#125;() print(a)&#125; å¯¹ a çš„å†™(èµ‹å€¼)æ²¡æœ‰è¿›è¡Œä»»ä½•åŒæ­¥æ“ä½œï¼Œæ— æ³•è¢«å…¶å®ƒ goroutine èŽ·å–ï¼Œåœ¨æ¿€è¿›çš„ç¼–è¯‘å™¨ä¸­ç”šè‡³å¯èƒ½ä¼šåˆ é™¤æ•´ä¸ª go å£°æ˜Žã€‚ 3.4 Channel communication# é€šé“é€šä¿¡(channel communication)æ˜¯åŒæ­¥ä¸¤ä¸ª goroutine çš„ä¸»è¦æ–¹æ³•ã€‚ send å‘ç”Ÿåœ¨å®Œæˆç›¸åº”çš„ receive ä¹‹å‰ ç¨‹åºï¼š 12345678910111213141516var c = make(chan int, 10)var a stringfunc f() &#123; a = "hello, world" c &lt;- 0 // send&#125;func main() &#123; go f() &lt;-c // receive print(a)&#125;&gt; Output:command-line-argumentshello, world ä¼šä¿è¯æ‰“å° hello, worldï¼Œå› ä¸ºï¼š å¯¹ a çš„å†™ happens before é€šé“ c çš„ send é€šé“ c çš„ send happens before é€šé“ c çš„ receive é€šé“ c çš„ receive happens before print(a)ï¼Œå› æ­¤ , å¯¹ a çš„å†™ happens before print(a), å³ä¿è¯ main() èŽ·å–äº† goroutine å¯¹ açš„å†™ channel çš„å…³é—­å‘ç”Ÿåœ¨å®Œæˆ receive(æ­¤æ—¶å¾—åˆ°çš„æ˜¯é€šé“ç±»åž‹çš„é›¶å€¼)ä¹‹å‰ 123456789101112131415161718package mainvar c = make(chan int, 10)var a stringfunc f() &#123; a = "hello, world" close(c) // å…³é—­&#125;func main() &#123; go f() print(a, "\n", &lt;-c) // receive&#125;&gt;Output:command-line-argumentshello, world0 æ— ç¼“å­˜é€šé“çš„ receive å‘ç”Ÿåœ¨å®Œæˆ send ä¹‹å‰ è°ƒæ¢ c &lt;- 0 // send å’Œ &lt;-c // receiveçš„ä½ç½®ï¼Œå¾—åˆ°ç¨‹åº 123456789101112131415var c = make(chan int)var a stringfunc f() &#123; a = "hello, world" &lt;-c //receive&#125;func main() &#123; go f() c &lt;- 0 // send print(a)&#125;&gt; Output:command-line-argumentshello, world ä»ç„¶ä¿è¯æ‰“å° hello, world ä½†å¦‚æžœchannelå…·æœ‰ç¼“å­˜ï¼Œä¾‹å¦‚å½“c = make(chan int, 1)ï¼Œé‚£ä¹ˆç¨‹åºæ— æ³•ä¿è¯æ‰“å° hello, world å½“é€šé“çš„å®¹é‡ä¸º$c$æ—¶ï¼Œç¬¬ $k$ æ¬¡ receive å‘ç”Ÿåœ¨å®Œæˆç¬¬ $k+c$ æ¬¡ send ä¹‹å‰ ä¸‹é¢çš„ç¨‹åºç»™ work çš„æ¯ä¸ªæ¡ç›®(å‡½æ•°ç±»åž‹)å¯åŠ¨ä¸€ä¸ª goroutineï¼Œç”±äºŽé€šé“limitçš„å®¹é‡ä¸º3ï¼Œå› æ­¤æœ€å¤šå…è®¸3ä¸ª goroutine è°ƒç”¨è°ƒç”¨äº†å‡½æ•°w() 1234567891011var limit = make(chan int, 3)func main() &#123; for _, w := range work &#123; go func(w func()) &#123; limit &lt;- 1 w() &lt;-limit &#125;(w) &#125;&#125; 3.5 Locks# sync åŒ…å®žçŽ°äº†ä¸¤ç§ lock æ•°æ®ç±»åž‹, sync.Mutexå’Œ sync.RWMutex. å¯¹ä»»æ„çš„ sync.Mutex æˆ–è€… sync.RWMutexå˜é‡ lä¸”$n&lt;m$ï¼Œç¬¬$n$æ¬¡è°ƒç”¨ l.Unlock() å‘ç”Ÿåœ¨ ç¬¬ $m$æ¬¡è°ƒç”¨ l.Lock()è¿”å›žä¹‹å‰ ç¨‹åº 1234567891011121314151617181920212223package mainimport ( "sync")var l sync.Mutexvar a stringfunc f() &#123; a = "hello, world" l.Unlock() //ç¬¬ä¸€æ¬¡ l.Unlock()&#125;func main() &#123; l.Lock() go f() l.Lock() //ç¬¬äºŒæ¬¡ l.Lock() print(a)&#125;&gt; Output:command-line-argumentshello, world ä¿è¯æ‰“å°hello, worldï¼Œå› ä¸ºï¼Œ ç¬¬ä¸€æ¬¡ l.Unlock() happens before ç¬¬äºŒæ¬¡ l.Lock() è¿”å›ž ç¬¬äºŒæ¬¡ l.Lock() è¿”å›ž happens before print(a) å¯¹äºŽä»»æ„çš„l.RLockï¼Œå­˜åœ¨$k$æ»¡è¶³ï¼š ç¬¬ $k$ æ¬¡è°ƒç”¨ l.Unlock happens before l.RLockï¼› ä¸Žl.RLockå¯¹åº”çš„l.RUnlock happens before ç¬¬ $k+1$æ¬¡è°ƒç”¨ l.Lock 3.6 Once# å¯¹æŸä¸ªå‡½æ•°f()ï¼Œå¯ä»¥æœ‰å¤šä¸ªçº¿ç¨‹é€šè¿‡once.Do(f)æ¥å¯¹å…¶è°ƒç”¨ï¼Œä½†ä»…æœ‰çº¿ç¨‹èƒ½å¤Ÿè°ƒç”¨æ‰§è¡Œå‡½æ•°f()ï¼Œå…¶å®ƒçš„è°ƒç”¨ä¼šè¢«é˜»å¡žçŸ¥é“f()è¿”å›žã€‚ ç¨‹åº 123456789101112131415161718192021222324252627282930313233package mainimport ( "sync" "time")var a stringvar once sync.Oncefunc setup() &#123; a = "hello, world"&#125;func SETUP() &#123; a = "HELLO, WORLD"&#125;func doprint() &#123; once.Do(setup) //æ³¨æ„ä¸è¦æ‹¬å· once.Do(SETUP) print(a, "\n")&#125;func main() &#123; go doprint() go doprint() time.Sleep(time.Second)&#125;&gt; Output:command-line-argumentshello, worldhello, world ä¼šæ‰“å°ä¸¤æ¬¡ hello, worldï¼Œä½†æ˜¯ä»…åœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨ doprint æ—¶æ‰§è¡Œäº† setup 4. Incorrect synchronization# ç¨‹åº 12345678910111213141516171819202122232425package mainvar a, b intfunc f() &#123; a = 1 b = 2&#125;func g() &#123; print(b, "\n") print(a)&#125;func main() &#123; go f() g()&#125;&gt; Output: //å¤§å¤šæ•°è¾“å‡ºç»“æžœ00&gt; Output: //å°‘æ•°è¾“å‡ºç»“æžœ01 ä¹Ÿå¯èƒ½å…ˆæ‰“å°2ï¼Œç„¶åŽæ‰“å°0 ç¨‹åº 1234567891011121314151617181920212223242526272829303132package mainvar a stringvar done boolfunc setup() &#123; a = "hello, world \n" done = true&#125;func doprint() &#123; if !done &#123; setup() &#125; print(a)&#125;func twoprint() &#123; go doprint() go doprint()&#125;func main() &#123; twoprint()&#125;//æœ‰3ç§è¾“å‡ºçš„å¯èƒ½&gt; Output:hello, world hello, world &gt; Output:hello, world &gt; Output: ä¸‹é¢çš„ç¨‹åºï¼Œç”±äºŽä¸èƒ½ä¿è¯main()å…ˆèŽ·å–å¯¹doneçš„å†™ï¼Œå› æ­¤print()å¯èƒ½æ‰“å°ç©ºå­—ç¬¦ä¸²ã€‚ç”šè‡³main()å®Œå…¨æ²¡æœ‰èŽ·å–å¯¹doneçš„å†™ï¼Œæ­¤æ—¶main()è¿›å…¥æ­»å¾ªçŽ¯ 12345678910111213141516171819202122232425package mainvar a stringvar done boolfunc setup() &#123; a = "hello, world" done = true&#125;func main() &#123; go setup() for !done &#123; &#125; print(a)&#125;&gt; Output:hello, world&gt; Elapsed: 3.703s //ç­‰å¾…äº†è¾ƒé•¿çš„æ—¶é—´&gt; Result: Success&gt; Output:hello, world&gt; Elapsed: 0.704s &gt; Result: Success ç±»ä¼¼çš„ç¨‹åºå¦‚ä¸‹ 1234567891011121314151617181920package maintype T struct &#123; msg string&#125;var g *Tfunc setup() &#123; t := new(T) t.msg = "hello, world" g = t&#125;func main() &#123; go setup() for g == nil &#123; &#125; print(g.msg)&#125;]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ­å»ºIPFS ç§æœ‰ç½‘ç»œ]]></title>
    <url>%2F2018%2F11%2F05%2F2018-11-5%2F</url>
    <content type="text"><![CDATA[åœ¨serversä¸Šå®‰è£… Go çŽ¯å¢ƒ ç”Ÿæˆ ifps èŠ‚ç‚¹ åˆ›å»ºå…±äº«å¯†é’¥ æ·»åŠ å¯åŠ¨èŠ‚ç‚¹ å¯åŠ¨ç§æœ‰ç½‘ç»œ æœ¬ä¾‹ä¸ºå»ºç«‹åŒ…å«ä¸‰ä¸ªèŠ‚ç‚¹çš„IPFSç§æœ‰ç½‘ç»œï¼ŒèŠ‚ç‚¹åˆ†åˆ«ä¸ºï¼š server a: root@45.32.28.71 server b: root@207.148.109.110 æœ¬åœ° mac åœ¨serversä¸Šå®‰è£… Go çŽ¯å¢ƒ# 1234567891011cd ~ $wget https://dl.google.com/go/go1.11.2.linux-amd64.tar.gz$tar -C /usr/local -xzf go1.11.2.linux-amd64.tar.gz //è§£åŽ‹åˆ°å¾—åˆ°çš„ go ç›®å½•ï¼Œæ”¾åˆ° /usr/local ç›®å½•ä¸‹$vim .bashrcexport GOPATH=~/hejtao/go_projectsexport GOROOT=/usr/local/goexport GOBIN=$GOROOT/binexport PATH=$PATH:$GOBIN$source .bashrc$go version go version go1.11.2 linux/amd64 //å®‰è£…æˆåŠŸ mac ä¸Šçš„å®‰è£…ç±»ä¼¼ã€‚ ç”Ÿæˆ ifps èŠ‚ç‚¹# åœ¨ä¸‰å°æœºå™¨ä¸Šæ‰§è¡Œ 12345678910111213141516171819202122232425262728$go get -u -d github.com/ipfs/go-ipfs $cd $GOPATH/src/github.com/ipfs/go-ipfs$make installCommand &apos;make&apos; not found, but can be installed with:sudo apt install makesudo apt install make-guile$apt update \\ éœ€è¦å®‰è£… make ï¼Œ å…ˆæ£€æŸ¥å®‰è£…åŒ…...$apt upgrade \\ æ›´æ–°å®‰è£…åŒ…...$apt install make \\ å®‰è£… make...$make install/usr/local/go/pkg/tool/linux_amd64/link: running gcc failed: exec: &quot;gcc&quot;: executable file not found in $PATHcmd/ipfs/Rules.mk:37: recipe for target &apos;cmd/ipfs-install&apos; failedmake: *** [cmd/ipfs-install] Error 2$apt install gcc...$gcc -v...gcc version 7.3.0 (Ubuntu 7.3.0-27ubuntu1~18.04)$make install...$ipfs init... è®°ä¸‹æ¯ä¸ªèŠ‚ç‚¹çš„IDï¼Œæ¯”å¦‚æœ¬ä¾‹ server a çš„ID: QmQ9RjTGVDjhZ2kRVx9tjL4CciiKdNrQzknSyUnCMmB3m2 server b çš„ID: QmRyxoe9JpkDZuMK4G7PkXUy7nGv8VdM98d6Vr2wxFSa3V mac çš„ID: QmWKKVUy9XqWEGhrikJW8ugHuFzKJJGP5DCGFyvzUJFjzL åˆ›å»ºå…±äº«å¯†é’¥# å…ˆåœ¨ä»»æ„ä¸€å°æœºå™¨ä¸Šåˆ›å»ºå¯†é’¥ï¼Œç„¶åŽæ‹·è´åˆ°å‰©ä½™èŠ‚ç‚¹ã€‚æœ¬ä¾‹åœ¨macä¸Šåˆ›å»º 12$go get -u github.com/Kubuxu/go-ipfs-swarm-key-gen/ipfs-swarm-key-gen$ipfs-swarm-key-gen &gt; ~/.ipfs/swarm.key æ‰‹åŠ¨æ‹·è´ 1$vim ~/.ipfs/swarm.key \\ æ‰“å¼€swarm.key, æ‹·è´å†…å®¹ åœ¨serversä¸Šæ–°å»ºswarm.key 1$vim ~/.ipfs/swarm.key \\ å°†æ‹·è´çš„å†…å®¹ç²˜è´´ ä½¿ç”¨ scp å‘½ä»¤ 12$scp ~/.ipfs/swarm.key root@45.32.28.71:~/.ipfs/$scp ~/.ipfs/swarm.key root@207.148.109.110:~/.ipfs/ æ·»åŠ å¯åŠ¨èŠ‚ç‚¹# pfs initåŽçš„é»˜è®¤å¯åŠ¨èŠ‚ç‚¹æ˜¯è¿žæŽ¥ipfså…¬ç½‘çš„èŠ‚ç‚¹ã€‚å»ºç«‹ç§æœ‰ç½‘ç»œéœ€è¦åœ¨æ¯ä¸€ä¸ªèŠ‚ç‚¹ä¸Šåˆ æŽ‰é»˜è®¤å¯åŠ¨èŠ‚ç‚¹ 1$ipfs bootstrap rm --all å°†ç½‘ç»œä¸­ä»»æ„å…¶ä»–èŠ‚ç‚¹ä½œä¸ºå¯åŠ¨èŠ‚ç‚¹ã€‚ä¾‹å¦‚å°† server a ä½œä¸ºmacçš„å¯åŠ¨èŠ‚ç‚¹ 1$ipfs bootstrap add/ip4/45.32.28.71/tcp/4001/ipfs/QmQ9RjTGVDjhZ2kRVx9tjL4CciiKdNrQzknSyUnCMmB3m2 å¯åŠ¨ç§æœ‰ç½‘ç»œ# ç»™ä¸‰ä¸ªèŠ‚ç‚¹æ·»åŠ äº†å¯åŠ¨èŠ‚ç‚¹åŽï¼Œå¯åŠ¨æ‰€æœ‰èŠ‚ç‚¹ï¼Œä¾¿å»ºç«‹èµ·äº†å«æœ‰ä¸‰ä¸ªèŠ‚ç‚¹çš„IPFSç§æœ‰ç½‘ç»œã€‚åˆ†åˆ«æ‰§è¡Œ 1$ipfs daemon å¯ä»¥ä½¿ç”¨ bootstrap list```æŸ¥çœ‹èŠ‚ç‚¹æ‰€åŒ…å«çš„å¯åŠ¨èŠ‚ç‚¹ï¼Œä½¿ç”¨```ipfs swarm peers```æŸ¥çœ‹èŠ‚ç‚¹è¿žæŽ¥äº†å“ªäº›å…¶ä»–èŠ‚ç‚¹ã€‚ä½¿ç”¨```ipfs add file```ä¸Šä¼ æ–‡ä»¶åˆ°èŠ‚ç‚¹ï¼Œæ¯”å¦‚ç»™macèŠ‚ç‚¹ä¸Šä¼ pdfæ–‡ä»¶ï¼Œå¹¶å¾—åˆ°è¯¥æ–‡ä»¶çš„ID12```$ipfs add ~/files/GOè¯­è¨€ç¼–ç¨‹.pdf è¯¥æ–‡ä»¶çš„IDï¼šQmRDqZoSMCLMP2GH66MKKnduqgTqKBfqNeysPugp9xadUiã€‚çŽ°åœ¨ä¸Žmacå»ºç«‹äº†è¿žæŽ¥çš„serverå°±å¯ä»¥ä¸‹è½½è¯¥æ–‡ä»¶äº†ï¼Œåœ¨serverä¸Šæ‰§è¡Œ 1$ipfs get QmRDqZoSMCLMP2GH66MKKnduqgTqKBfqNeysPugp9xadUi \\åœ¨å½“å‰ç›®å½•ä¼šå¤šå‡ºä¸€ä¸ªæ–°çš„æ–‡ä»¶ä¾¿æ˜¯getåˆ°çš„æ–‡ä»¶]]></content>
      <tags>
        <tag>IPFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A Study for the Reed-Solomon Code]]></title>
    <url>%2F2018%2F10%2F18%2F2018-10-18%2F</url>
    <content type="text"><![CDATA[Introduction Galois Field Galois Field Arithmetic Addition and Subtraction Multiplication and Division RS Code Coding Matrix Method Generator Polynomial Method RS Code in Distributed Storage Systems 5.1 Rotated Reed-Solomon code Local Reconstruction Code (LRC) References Introduction# Reed-Solomon (RS) code is an error-correcting code first proposed by Reed and Solomon in 1960, which is the most frequently applied digital error correction code around the word. The applications include data storage(hard drives, CD/DVD/Blue Ray), data transmission and common commercial activities(bar codes, QR codes) . RS code has the advantage of high capability of correcting random or burst errors since it encodes groups of bits instead of one bit at a time. Redundant datas are generated so that the original data can be reconstructed with part of the stored or received data loss. People often back up important files which can be regarded as kind of data loss protection with redundant data. However, backup is just a copy of the original datas while the redundant data generated in the RS code is a fusion of the all the original data parts, which is more efficient for storage and error correction. In this article, I have run through the procedure of the RS code and hope it is usefull for you to understand what is going on with this erasure code. Its application in the distributed strorage system are briefly introduced at the end. Part of implementations in pure Go are also provided whose source files can be found on the Githup website . Galois Field# The finite field is also called Galois field which has finite elements and the property that arithmetic operations on field elements always have a result in the field. In the sequel, we illustrate two kind of representations of the finite elements and its arithmetic operations. Proposition 1. For any prime $ p $ and any natual number$ r $ there exists a finite field with $ p^{r} $ elements and vice versa. With the proposition 1, the Galois Field is denoted as $ GF(p^{r}) $. In fact, the nature of RS encoding is mapping $ k $ elments of $ GF(2^{r}) $ into another $ n $ elements of $ GF(2^{r}) $ and $k+2\leq n\leq 2^{r} $. This Galois fields can be represented with the help of $ \mathbf{Z}{2}[x] $, the set of polynomials with coefficients in the field of two elements $ \mathbf{Z}{2} $, namely the polynomial representation as $$0,1,x,x+1,x{2},..,x{r-1}+x^{r-2}+...+1 \tag{1}$$ This representation can also be seen as a $r$-bit digit or binary vector. Proposition 2. $ GF(q) $ has cyclic the multiplicative group $ {\alpha, \alpha{2},...,\alpha{q-1}=1}$, where $ \alpha $ is the primitive element. Thus, $ GF(2^{r}) $ has the exponential representation as $$0, 1(=\alpha^{255}), \alpha, \alpha^{2},..., \alpha{2{r}-2} \tag{2}$$ which is a better choice for the '$ \times $' and '$ / $' operation. Even a binary matrix can be used to represente the elements. For example, we can establish a bijection between the vector representation and matrix representation over $ GF(2^{4}) $ as follows where the first column is the vector representation and the columns satisfy $column(i)=2\times column(i-1)$. This matrix representation transforms arithmetic over $ GF(2^{4}) $ into arithmetic over $ GF(2) $ which only has XOR, AND operations. Galois Field Arithmetic# In this section, we discuss arithmetic in $ GF(2^{8}) $, whose element corresponds a byte data. Addition and Subtraction# Addition and subtraction are operated under the polynomial representation (also a byte in $ GF(2^{8}) $) and both are equivalent to XOR operation 1234567func galAdd(a, b byte) byte &#123; return a ^ b&#125;func galSub(a, b byte) byte &#123; return a ^ b&#125; Multiplication and Division# The multiplication is operated with the exponential representation $(2)$, before that we should establish a bijection (injection and surjection) between the two representations. Suppose $$\alpha^{i} -&gt; 2^{i}$$ where $0\leq i \leq 2^{8}-2=254$. According to proposition 2, $\forall j\geq 255,\alpha{j}=\alpha{j-255}$. Proposition 3.$ GF(2^{8}) $ has the irreducible polynomial $ f(x)=x{8}+x{4}+x{3}+x{2}+1 $ which has no factors of smaller polynomials. The irreducible polynomial is necessary to establish the bijection since some $2^{i}$ term are no longer in $GF(2^{8})$. Let $ f(\alpha) =0$, we have $$\alpha{8}=\alpha{4}+\alpha{3}+\alpha{2}+1=2{4}+2{3}+2^{2}+1=00011101$$ or 0x1d . For convenience, we record the bijection with a table, namely called exponent table, whose indexs is the exponents of elements in exponential representation and value is elements in byte representation. 1var expTable = [255]byte&#123;0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1d, 0x3a, ..., 0x8e&#125; Use logTable[expTable[$i$]]=$i$, the logarithmic table is generated, 12345var logTable = []byte&#123; 0, 0, 1, 25, 2, 50, 26, 198, ... 116, 214, 244, 234, 168, 80, 88, 175,&#125; With these tables, the $\times$ and $/$ functions in $GF(2^8)$ are easily defined, 12345678910111213141516171819202122232425262728293031func galMultiply(a, b byte) byte &#123; if a == 0 || b == 0 &#123; return 0 &#125; logA := int(logTable[a]) logB := int(logTable[b]) sum := logA+logB if sum&gt;254 &#123; sum -= 255 &#125; return expTable[sum]&#125;func galDivide(a, b byte) byte &#123; if a == 0 &#123; return 0 &#125; if b == 0 &#123; panic("Argument 'divisor' is 0") &#125; logA := int(logTable[a]) logB := int(logTable[b]) logResult := logA - logB if logResult &lt; 0 &#123; logResult += 255 &#125; return expTable[logResult]&#125; Based on the result above, the power and inverse functions can be further obtained. In fact, the method to establish the bijection is not unique. The original paper of Reed and Solomon in 1960 provides another method with finite difference equation which has better computability. RS Code# Coding Matrix Method# 1. Orignal approach: For arbitrary $ k $ 8-bit symbols,$ m_{0}$, $m_{1}$, $...$, $m_{k-1} $, we have the message polynomial $$m(x)=m_{0}+m_{1}x+...+m_{k-1}x^{k-1},$$ with this $ m(x) $, $ 2^{8} $ codewords, i.e. $ m(0)$,$m(1)$,$...$, $m(\alpha^{r-2}) $ are obtained and the the encoded messages, which will be transmitted or stored, are $ n $ of the codewords (professionally called stripe). Using linear algebra, the stripe are denoted collectively as follows $$ \begin{bmatrix} m(\alpha_{1})\ m(\alpha_{2})\ ...\ m(\alpha_{n}) \end{bmatrix} = \begin{bmatrix} 1 &amp; \alpha_{1} &amp; ... &amp; \alpha_{1}^{k-1} \ 1 &amp; \alpha_{2} &amp; ...&amp;\alpha_{2}^{k-1} \ ... &amp; ... &amp; ...&amp;... \ 1 &amp; \alpha_{n} &amp; ...&amp;\alpha_{n}^{k-1} \end{bmatrix} \begin{bmatrix} m_{0}\ m_{1}\ ...\ m_{k-1} \end{bmatrix}\tag{3} $$ Note that we only discuss one byte a shard (the messages are splited into multiple shards for encoding) here, in practice one input shard contains thousands of bytes, in this case the output shard contains same size of byte as input shard and the vectors in $(3)$ becomes matrice. Coding procedure : 1.Split the whole message into same size data shards; 2. Build the Vandermonde matrix (coding matrix); 3. Multiplies the coding matrix by data shards to produce code shards. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859func (r reedSolomon) Split(data []byte) ([][]byte, error) &#123; if len(data) == 0 &#123; return nil, ErrShortData &#125; // Calculate number of bytes per data shard. perShard := (len(data) + r.DataShards - 1) / r.DataShards if cap(data) &gt; len(data) &#123; data = data[:cap(data)] &#125; // Only allocate memory if necessary if len(data) &lt; (r.Shards * perShard) &#123; // Pad data to r.Shards*perShard. padding := make([]byte, (r.Shards*perShard)-len(data)) data = append(data, padding...) &#125; // Split into equal-length shards. dst := make([][]byte, r.Shards) for i := range dst &#123; dst[i] = data[:perShard] data = data[perShard:] &#125; return dst, nil&#125;func vandermonde(rows, cols int) (matrix, error) &#123; result, err := newMatrix(rows, cols) if err != nil &#123; return nil, err &#125; for r, row := range result &#123; for c := range row &#123; result[r][c] = galExp(byte(r), c) &#125; &#125; return result, nil&#125;// Multiplies a subset of rows from a coding matrix by a full set of// input shards to produce some output shards.// 'matrixRows' is The rows from the matrix to use.// 'inputs' An array of byte arrays, each of which is one input shard.// The number of inputs used is determined by the length of each matrix row.// outputs Byte arrays where the computed shards are stored.func (r reedSolomon) codeSomeShards(matrixRows, inputs, outputs [][]byte) &#123; for c := 0; c &lt; r.DataShards; c++ &#123; in := inputs[c] for iRow := 0; iRow &lt; outputCount; iRow++ &#123; if c == 0 &#123; galMulSlice(matrixRows[iRow][c], in, outputs[iRow], r.o.useSSSE3, r.o.useAVX2) &#125; else &#123; galMulSliceXor(matrixRows[iRow][c], in, outputs[iRow], r.o.useSSSE3, r.o.useAVX2) &#125; &#125; &#125;&#125; Since any $ k $ rows of Vandermonde matrix are linearly independent, with arbitrary $ k $ correct code shards, the original $ k $ data shards can be reconstructed by multiplying the corresponding inverse matrix. However, in practice, we usually do not know which one is correct or corrupted for the $ n $ received codewords. In this case, the plurality of votes method is necessary and $$ \left(\begin{array}{c} n-s\k \end{array} \right)&gt;\left(\begin{array}{c} s+k-1\k \end{array} \right) $$ or $$ s&lt;\frac{n-k+1}{2} $$ where $s$ is number of unkown errors, therefore $ n=k+2s $ always satisfies the in-equation. Another approach is to use the Berlekamp-Welsh Algorithm which avoids the heavy computation of votes: Berlekamp-Welsh decoder: 1. Send $m(0),m(1),...,m(n)$, receive $m'(0),m'(1),...,m'(n)$, and most $s$ of them such that $m(i)\neq m'(i)$ï¼› 2. $E(x)=x{s}+b_{s-1}x{s-1}+...+b_{0}$, $Q(x)=a_{k+s-1}x{k+s-1}+a_{k+s-2}x{k+s-2}+...+a_{0}$ 3. Solve the coefficients of co$E(x)$,$Q(x)$ with $ Q(i)=m'(i)E(i)$ 4. Derive $m(x)=Q(x)/E(x)$. And $\forall m(i)\neq m'(i)$,$E(i)=0$. The implicite principle: $Q'(x)/E'(x)$ and $Q(x)/E(x)$ agree on at least $k+s$ points. $E'(x)$ and $E(x)$ both have at most $s$ zero points. Elimilate $E'(x)$ and $E(x)$,$Q'(x)/E'(x)$ and $Q(x)/E(x)$ are degree at least $k-1$ and agree on at least $k$ points, thus $Q'(x)/E'(x)=Q(x)/E(x)=m(x)$. 2. Systematic coding matrix: In the original approach, all the code shards have been encoded. While in the systematic encoding, the original data shards become part of the code shards and only the parity shards should be encoded. In other words, the stripe contains the original datas and parity codewords together no longer codewords only. The coding matrix is composed of the top square identity matrix and the parity matrix. There are three methods of building the coding matrix in this systematic way are provided: Elementary transform on the Vandermonde matrix as the procedure 1. 123456789101112131415161718func buildMatrix(dataShards, totalShards int) (matrix, error) &#123; vm, err := vandermonde(totalShards, dataShards) if err != nil &#123; return nil, err &#125; top, err := vm.SubMatrix(0, 0, dataShards, dataShards) if err != nil &#123; return nil, err &#125; topInv, err := top.Invert() if err != nil &#123; return nil, err &#125; return vm.Multiply(topInv)&#125; Parity matrix is Vandermonde matrix. 1234567891011121314151617181920func buildMatrixPAR1(dataShards, totalShards int) (matrix, error) &#123; result, err := newMatrix(totalShards, dataShards) if err != nil &#123; return nil, err &#125; for r, row := range result &#123; // The top portion of the matrix is the identity // matrix, and the bottom is a transposed Vandermonde // matrix starting at 1 instead of 0. if r &lt; dataShards &#123; result[r][r] = 1 &#125; else &#123; for c := range row &#123; result[r][c] = galExp(byte(c+1), r-dataShards) &#125; &#125; &#125; return result, nil&#125; Parity matrix is Cauchy matrix. Cauchy matrices are easier to invert than general matrices [8]. 12345678910111213141516171819func buildMatrixCauchy(dataShards, totalShards int) (matrix, error) &#123; result, err := newMatrix(totalShards, dataShards) if err != nil &#123; return nil, err &#125; for r, row := range result &#123; // The top portion of the matrix is the identity // matrix, and the bottom is a transposed Cauchy matrix. if r &lt; dataShards &#123; result[r][r] = 1 &#125; else &#123; for c := range row &#123; result[r][c] = invTable[(byte(r ^ c))] &#125; &#125; &#125; return result, nil&#125; Generator Polynomial Method# Define the generator polynomial: $$ g(x)=(x-\alpha)(x-\alpha{2})\dots(x-\alpha{2s}) $$ and the codeword polynomial can be directly computed as $$c(x)=m(x)g(x)$$ For the systematic form, which is more often used in practice, we define $$ b(x)=x^{2s}m(x) \quad mod\quad g(x) $$ then the codeword polynomial becomes $$ c(x)=x^{2s}m(x)-b(x) $$ where $-b(x)$ is the parity codeword polynomial. All the polynomial operation above is processed over $GF(2^8)$. It is also observed that the correction of received message can be checked by testing its divisibility by g(x), and there is no need to decode for the systematic encoding if the answer is affirmative. Otherwise, we denote $r(x)=c(x)+e(x)$ and suppose there are $ v(\leq s) $ errors Syndrome based decoder: 1.Calculate the $2s$ Syndromes: $S_{j}=r(\alpha{j})=e(\alpha{j})$ 2. Solve $$ \begin{bmatrix} S_{1} &amp; S_{2}&amp; ... &amp; S_{v} \ S_{2} &amp; S_{3} &amp; ...&amp;S_{v+1} \ ... &amp; ... &amp; ...&amp;... \ S_{v} &amp; S_{v+1} &amp; ...&amp;S_{2v-1} \end{bmatrix} \begin{bmatrix} \Lambda_{v}\ \Lambda_{v-1}\ ...\ \Lambda_{1} \end{bmatrix}=\begin{bmatrix} -S_{v} \ -S_{v+1}\ ...\ -S_{2v}\tag{4} \end{bmatrix} $$ and use Chien search solve $\Lambda(x)=\Lambda_{v}x^{v} +\Lambda_{v-1}x^{v-1}+...+1=0$ to derive the $v$ roots, denoted as,$x_{1},..,x_{v}$. 3. Use Forney algorithm to solve $$ \begin{bmatrix} x_{1}^{-1} &amp; x_{2}^{-1}&amp; ... &amp; x_{v}^{-1} \ x_{1}^{-2} &amp; x_{2}^{-2} &amp; ...&amp;x_{v}^{-2} \ ... &amp; ... &amp; ...&amp;... \ x_{1}^{-2s} &amp; x_{2}^{-2s} &amp; ...&amp;x_{v}^{-2s} \end{bmatrix} \begin{bmatrix} e_{i_{1}}\ e_{i_{2}}\ ...\ e_{i_{v}} \end{bmatrix}=\begin{bmatrix} S_{1} \ S_{2}\ ...\ S_{2s}\tag{5} \end{bmatrix} $$ 4. The index $i_{j}$ of $e_{i_{j}}$ are determined by looking up the logarithmic table as earlier mentioned 5. Compute $e(x)=\sum_{j=1}{v}e_{i_{j}}x{i_{j}}$ and $c(x) = r(x)-e(x)$. It is worth mentioning that all the syndromes are zeros if $r(x)=c(x)$, this can be used to check if the received message is corrupted or if the message was completely constructed. RS encoding is relatively straightforward for the generator approach, but decoding needs complicated algebraic computation, especially for the step 2. Because the real value of $v$ is unknown and the normal way has to use the trial value untill the matrix in $(4)$ is nonsingular. Other algebraic methods for the evaluation of this error location polynomial $\Lambda(x)$ include Berlekampâ€“Massey algorithm and Extended Euclidean algorithm. This syndrome based decoder can be implemented with different hardware unit such as matrix vector multiplication unit, remainder unit, and performs hard-decision decoding up to $s$ errors. Hard-decision decoding decides the bit according to the a threshold, where each bit is definitely one or zero. While soft-decision decoding requires additional reliability information to improve the decision, which has better coding gain for the white Guassian channel [2]. RS Code in Distributed Storage Systems# The RS code are stored in different disks in the distributed storage systems, and the performance arasure code in distributed storage systems involves disk I/O and repair bandwidth overhead. 5.1 Rotated Reed-Solomon code# In the conventional RS code, all the parity blocds are encoded with data blocks in the same strip, while in the rotated reed-solomon code, parity blocks may be generated with different stripes as in the following figure, when the disk 5 in the figure fails, this method reduceS 3 operations of reading the data blocks than the conventional RS code [5]. Local Reconstruction Code (LRC)# LRC introduces local parity codes which requires slightly more storage space than conventional RS code, but significantly reduce the number of participating data discs for encoding, thus it is beneficial to the reduction of bandwidth and disc I/O overhead. The figure of pyramid code is shown as follows [6] However, repair of the global redundancy still needs to access all data discs, another LRC approach in [7] further introduces parity code ($ S_{3} $ in the figure) for the global parity codes ($P_{1}$,$P_{2}$,$P_{3}$,$P_{4}$) to avoid this undesirable situation. By choosing the coefficients of $c_{1}^{'}$, $c_{2}^{'}$, $c_{3}^{'}$, $c_{4}^{'}$ and $c_{5}^{'}$, $c_{6}^{'}$ properly, the parity code of $ S_{3} $ can be calculated by the existing parity codes $ S_{1} $ and $ S_{2} $. Thus parity code $ S_{3} $ does not have to occupy additional storage. Observation: Copy is kind of LRC. References# [1] I. Reed and G. Solomon, BPolynomial codes over certain finite fields,[ J. Soc. Ind. Appl. Math., vol. 8, no. 2, pp. 300â€“304, Jun. 1960. [2] Wicker and Bhargava, Reed-Solomon Codes and Their Applications, 1994. [3] James S. Plank and Lihao Xu, Optimizing Cauchy Reed-Solomon Codes for Fault-Tolerant Network Storage Applications. [4] Reedâ€“Solomon codes for coders. [5] Khan O, Burns R C, Plank J S, et al. Rethinking erasure codes for cloud file systems: minimizing I/O for recovery and degraded reads. [6] Huang Cheng, Chen Minghua, Li Jin. Pyramid codes: flexible schemes to trade space for access efficiency in reliable data storage systems. [7] Sathiamoorthy M, Asteris M, Papailiopoulos D, et al. Xoring elephants: novel erasure codes for big data. [8] J. Blomer, M. Kalfane, R. Karp, M. Karpinski, M. Luby, and D. Zuckerman, An XOR-Based Erasure-Resilient Coding Scheme.]]></content>
      <tags>
        <tag>RS Code</tag>
        <tag>Golang</tag>
        <tag>é•¿æ–‡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golangç¼–ç¨‹åŸºç¡€]]></title>
    <url>%2F2018%2F08%2F20%2F2018-8-20%2F</url>
    <content type="text"><![CDATA[åœ¨Ubuntuå®‰è£…: æ•°æ®ç±»åž‹: åŸºæœ¬ç±»åž‹ï¼š èšé›†ç±»åž‹ (aggregate types)ï¼š æ•°ç»„ ç»“æž„ å¼•ç”¨ç±»åž‹ æŒ‡é’ˆ åˆ‡ç‰‡ï¼ˆsliceï¼‰ å­—å…¸ï¼ˆmapï¼‰ å‡½æ•° é€šé“ï¼ˆchannelï¼‰ æŽ¥å£ç±»åž‹ï¼ˆinterfaceï¼‰ï¼š æŽ§åˆ¶æµ ï¼ˆfor if switch defer gotoï¼‰ï¼š åˆ›å»ºå·¥ç¨‹ç›®å½•ï¼š Tips: å…¶ä»–ï¼š å‚è€ƒèµ„æ–™ï¼š åœ¨Ubuntuå®‰è£…:# 123456789&gt;cd ~ &gt;wget https://dl.google.com/go/go1.11.2.linux-amd64.tar.gz&gt;tar -C /usr/local -xzf go1.11.2.linux-amd64.tar.gz // è§£åŽ‹åˆ°å¾—åˆ°çš„ go ç›®å½•ï¼Œæ”¾åˆ° /usr/local ç›®å½•ä¸‹&gt;vim .bashrc // å†™å…¥ä»¥ä¸‹å†…å®¹export GOPATH=~/hejtao/go_projectsexport GOROOT=/usr/local/goexport GOBIN=$GOROOT/binexport PATH=$PATH:$GOBIN&gt;source .bashrc æ•°æ®ç±»åž‹:# åŸºæœ¬ç±»åž‹ï¼š# æ•°å€¼ æ•´åž‹ï¼šintï¼› int8ï¼› int16ï¼› int32(runeï¼ŒUnicode)ï¼› int64ï¼› uintï¼› uint8(byte)ï¼› uint16ï¼› uint32ï¼› uint64ï¼› uintptr int, uint, uintptr åœ¨ 32 ä½ç³»ç»Ÿä¸Šæ˜¯ 32 ä½ï¼Œåœ¨ 64ä½ ç³»ç»Ÿä¸Šæ˜¯ 64ä½ æµ®ç‚¹åž‹ï¼šfloat32ï¼› float64 å¤æ•°åž‹ï¼šcomplex64ï¼› complex128 å­—ç¬¦ä¸²ï¼šä½¿ç”¨åŒå¼•å· &quot;a&quot; å¸ƒå°”: trueï¼› false å¸¸é‡ï¼šä¸‰ç§åŸºæœ¬ç±»åž‹ 12345const( kb = 1024 e = 2.71828182845904523536028747135266249775724709369995957496696763 F = false) åœ¨ ifè¯­å¥ä¸­ï¼Œè‹¥æ£€éªŒæ¡ä»¶ä¸ºi &gt;= 0ï¼Œåˆ™i çš„ç±»åž‹ä¸å®œä¸º uint åž‹ï¼ˆuint æ•°æ®å§‹ç»ˆ &gt;= 0ï¼‰ã€‚å°½ç®¡å†…ç½®å‡½æ•° len() è¿”å›žå€¼æ˜¯éžè´Ÿæ•´æ•°ï¼Œä½†å®ƒé™…è¿”å›ž int åž‹ï¼Œ 1234medals := []string&#123;"gold", "silver", "bronze"&#125;for i := len(medals)-1; i &gt;= 0; i--&#123; fmt.Println(medals[i]) // "bronze", "silver", "gold"&#125; åŸºæœ¬ç±»åž‹ä¸Žæ“ä½œç¬¦æž„æˆè¡¨è¾¾å¼ å–ä½™ % åªç”¨äºŽæ•´åž‹ï¼›ä½™æ•°ä¸Žè¢«é™¤æ•°ç¬¦å·ç›¸åŒï¼Œ5%3=2ï¼› -5%3=-2 5.0/4=1.25ï¼›5/4.0=1.25ï¼›5/4=1 &amp;&amp; è‹¥å·¦è¾¹çš„è¡¨è¾¾å¼ç»“æžœä¸º falseï¼Œä¸æ£€éªŒå³è¾¹çš„è¡¨è¾¾å¼ï¼›&amp; å§‹ç»ˆæ£€éªŒä¸¤è¾¹çš„è¡¨è¾¾å¼ ä¸Žæˆ–^ ; ä¸€å…ƒå‰ç¼€^ èšé›†ç±»åž‹ (aggregate types)ï¼š# æ•°ç»„# 12345var a [3]intr := [...]int&#123;99: 1&#125; // ç´¢å¼•ä¸º99çš„å…ƒç´ ï¼Œr[99]ï¼Œ ç­‰äºŽ 1ï¼Œå…¶ä»–é»˜è®¤ 0p := new([10]int) // å°†ç”Ÿæˆçš„æ•°ç»„çš„æŒ‡é’ˆèµ‹ç»™ p, ä¸º *[10]int ç±»åž‹p[0]=1 // ç»™ p æŒ‡å‘çš„æ•°ç»„çš„ç´¢å¼•ä¸º0çš„å…ƒç´ èµ‹å€¼ 1 æ•°ç»„çš„é•¿åº¦ä¹Ÿæ˜¯æ•°ç»„ç±»åž‹çš„ä¸€éƒ¨åˆ†ï¼Œå› æ­¤ [3]int å’Œ [4]int æ˜¯ä¸åŒç±»åž‹çš„æ•°ç»„ï¼Œä¸èƒ½è¿›è¡Œæ¯”è¾ƒæˆ–èµ‹å€¼ã€‚ ç»“æž„# ï¼ˆ1ï¼‰ç»“æž„çš„å­—æ®µï¼ˆfieldï¼‰ 1234567891011121314151617181920212223type person struct&#123; // å®šä¹‰ person ç±»åž‹ gender string age int&#125;func main()&#123; student := person&#123;&#125; student.age = 16 student.gender = "male" // or student := person&#123; gender : "male", age : 16, //é€—å·ä¸èƒ½çœ &#125; // or student := person&#123;"male", 16&#125; teacher := &amp;person&#123; //å–æŒ‡é’ˆ gender : "female", age : 30, &#125; teacher.age = 36 //æŒ‡é’ˆ teacher ä»ç„¶å¯ä»¥è¿›è¡Œç‚¹æ“ä½œ&#125; æŒ‡é’ˆä¹Ÿå¯ä»¥è¿›è¡Œç‚¹æ“ä½œã€‚ åŒ¿åç»“æž„ï¼Œå­—æ®µåŒ¿å 1234567891011121314student := struct&#123; // åŒ¿åç»“æž„ gender : string age : int&#125;&#123; gender : "male", age : "17",&#125;type person struct&#123; string int&#125;// æŒ‰ç…§é¡ºåºåˆå§‹åŒ–student := person&#123;"male", 10&#125; ç»“æž„åµŒå¥—ï¼Œ 12345678910111213141516171819202122232425262728type person struct&#123; gender string age int parents struct&#123; // åµŒå¥—ä¸€ä¸ªåŒ¿åç»“æž„ dad, mom : string &#125;&#125;type address struct&#123; state, city string&#125;type person2 struct&#123; gender string age int address // åµŒå¥—ä½ ä¸€ä¸ªç»“æž„address&#125;func main()&#123; student := person&#123;gender : "female", age : 10&#125; student.parents.dad = "Tom" student.parents.mom = "Lily" student2 := person2&#123;gender:"female", age:10, address : address&#123;county:"LA" state:"California"&#125; &#125; student2.address.state = "Massachusetts" // or student2.state = "Massachusetts" &#125; ï¼ˆ2ï¼‰ç»“æž„çš„æ–¹æ³•ï¼ˆmethodï¼‰ å‡½æ•°ä¸Žæ–¹æ³• 123456789101112131415161718192021222324package mainimport ( "fmt" "math")type Point struct&#123; X, Y float64 &#125;func Distance(p, q Point) float64 &#123; //å‡½æ•° return math.Hypot(q.X-p.X, q.Y-p.Y)&#125;func (p Point) Distance(q Point) float64 &#123; // æ–¹æ³•ï¼Œåœ¨å‡½æ•°åå‰å¢žåŠ ä¸€ä¸ªå½¢å‚ï¼ˆreceiverï¼‰ ç±»ä¼¼äºŽJavaçš„this å’Œpythonçš„ selfï¼Œ return math.Hypot(q.X-p.X, q.Y-p.Y) // æŽ¥æ”¶è€…çš„åç§°é€šå¸¸å–å®ƒçš„ç±»åž‹åç§°çš„ç¬¬ä¸€ä¸ªå­—æ¯&#125;func main() &#123; p := Point&#123;1, 2&#125; q := Point&#123;4, 6&#125; fmt.Println(Distance(p, q)) // æ‰“å° 5ï¼Œ è°ƒç”¨å‡½æ•° fmt.Println(p.Distance(q)) // è°ƒç”¨æ–¹æ³•&#125; å½“éœ€è¦ä½¿ç”¨æ–¹æ³•å¯¹å€¼ï¼ˆvalue of type Tï¼Œç›¸å¯¹äºŽæ–¹æ³•æ¥è®²å°±æ˜¯å®žå‚ï¼Œargumentï¼‰ çš„å­—æ®µè¿›è¡Œä¿®æ”¹æ—¶ï¼Œä½¿ç”¨æŽ¥æ”¶è€…ä¸ºæŒ‡é’ˆçš„æ–¹æ³•æˆ–è€…å«æŒ‡é’ˆæ–¹æ³• 1234func (p *Point) ScaleBy(factor float64) &#123; // æŽ¥æ”¶è€…å‚æ•°pçš„ç±»åž‹æ˜¯æŒ‡é’ˆç±»åž‹ p.X *= factor // påœ¨è¿™é‡Œæ˜¯æŒ‡é’ˆï¼Œç­‰ä»·äºŽ (*p).X p.Y *= factor&#125; åŒä¸€ä¸ª struct çš„æ–¹æ³•å’Œå­—æ®µå æ®ç›¸åŒçš„å‘½åç©ºé—´ï¼ˆname spaceï¼‰ï¼Œå› æ­¤ä¸¤è€…çš„åç§°ä¸èƒ½é‡å¤ï¼› æŒ‡é’ˆæ–¹æ³•çœ‹ä½œé«˜æƒé™æ–¹æ³•ã€‚ å¯¹æ–¹æ³•çš„è°ƒç”¨, å€¼ï¼ˆå®žå‚ï¼‰ å’Œ æŽ¥æ”¶è€…ï¼ˆå½¢å‚ï¼‰ç±»åž‹è¦ç›¸åŒ 12345678Point&#123;1, 2&#125;.Distance(q) // Point Pointpptr.ScaleBy(2) // *Point *Pointpptr.Distance(q) // éšå« (*pptr)p.ScaleBy(2) // éšå« (&amp;p) Point&#123;1, 2&#125;.ScaleBy(2) //é”™è¯¯ï¼ï¼ï¼(&amp;Point&#123;1, 2&#125;).ScaleBy(2) ä¸ä»…ä»…æ˜¯ struct 123456789101112131415161718package mainimport ( "fmt")type INT intfunc main() &#123; var a INT a = 1 a.Print() // æ‰“å° 2&#125;func (a *INT) Print() &#123; *a = 2 fmt.Println(*a)&#125; æ–¹æ³•æ˜¯ä¸Žå‘½åç±»åž‹(named type)ç›¸å…³è”çš„å‡½æ•°ã€‚ å¼•ç”¨ç±»åž‹# æŒ‡é’ˆ# 1234var p *inti := 20p = &amp;i*p = 10 // i çš„å€¼ä¸º 10 åˆ‡ç‰‡ï¼ˆsliceï¼‰# 123456789101112131415var s []int // å£°æ˜Žåˆ‡ç‰‡ sa := [5]int&#123;1, 2, 3, 4, 5&#125;s = a[:2] // [1, 2]ï¼Œ len(s)ç­‰äºŽ2ï¼Œcap(s)ç­‰äºŽ5s = a[0:1] // [1]ï¼Œlen(s)ç­‰äºŽ1ï¼Œcap(s)ç­‰äºŽ5s = a[3:] // [4, 5]ï¼Œlen(s)ç­‰äºŽ2ï¼Œcap(s)ç­‰äºŽ2s := make([]int, 2, 4) //make([]type, len, cap) ï¼Œåˆ‡ç‰‡é•¿åº¦ä¸º2ï¼Œåº•å±‚æ•°ç»„çš„é•¿åº¦ä¸º4s = append(s, 1) // s çš„åœ°å€ä¸å˜s = append(s, 2, 3) // ç”Ÿæˆæ–°çš„æ•°ç»„ï¼Œåœ°å€æ”¹å˜ï¼Œå®¹é‡ç¿»å€ï¼Œä¹Ÿå°±æ˜¯cap(s)ç­‰äºŽ4*2=8s1 := []int&#123;1, 2, 3&#125;s2 := []int&#123;4, 5&#125;copy(s1, s2) //æŠŠ s2 å¤åˆ¶åˆ° s1ï¼Œs1 ä¸º [4, 5, 3]s1 = []int&#123;1, 2, 3&#125;copy(s2, s1) // s2 ä¸º [1, 2] åˆ‡ç‰‡çš„æœ¬è´¨æ˜¯å¯¹åº•å±‚æ•°ç»„çš„å¼•ç”¨ï¼›åˆ‡ç‰‡çš„å®¹é‡ï¼ˆcapï¼‰æ˜¯åˆ‡ç‰‡çš„å§‹ç´¢å¼•åˆ°åº•å±‚æ•°ç»„çš„æœ«ç´¢å¼•çš„é•¿åº¦ã€‚ å­—å…¸ï¼ˆmapï¼‰# 123456var m map[int]string // key int åž‹ï¼›value string åž‹m = make(map[int]string)m2 := make(map[int]string)m[0] = "OK"delete(m, 0) // åˆ é™¤ m ä¸­é”®ä¸º0çš„é”®å€¼å¯¹ åµŒå¥—ï¼Œ 123m := make(map[int]map[int]string) // value mapåž‹m[1] = make(map[int]string)m[1][2] = "YES" å‡½æ•°# func main(int, []string) int meansï¼Œ function main takes an int and a slice of strings and returns an int å‡½æ•°ä½œä¸ºç±»åž‹ï¼Œ 1var f func(func(int,int) int, int) func(int, int) int ä¸å®šé•¿å˜å‚ï¼Œé—­åŒ… 12345678910111213141516171819202122232425262728package mainimport ( "fmt")func main()&#123; var_args(1) var_args(1, 2, 3) f := closure(10) fmt.Println(f(1)) fmt.Println(f(2)) &#125;func var_args(args ...int)&#123; fmt.Println(args)&#125;func closure(x int) func(int) int&#123; // è¿”å›žåŒ¿åå‡½æ•° return func(y int) int&#123; return x + y &#125;&#125;è¾“å‡ºï¼š[1][1 2 3]1112 é€šé“ï¼ˆchannelï¼‰# channel æ˜¯ goroutine æ²Ÿé€šçš„æ¡¥æ¢ï¼Œé€šè¿‡ make åˆ›å»ºï¼Œclose å…³é—­ 12345678910111213141516package mainimport ( "fmt")func main() &#123; c := make(chan bool) go func() &#123; fmt.Println("I from goroutine !") c &lt;- true &#125;() &lt;-c&#125; channel ä½œä¸ºå‡½æ•°å½¢å‚ 123456789101112131415161718package mainimport ( "fmt")func main() &#123; c := make(chan bool) go Hello(c) &lt;-c&#125;func Hello(c chan bool) &#123; fmt.Println("Hello, I from goroutine!") c &lt;- true &#125; å¤šä¸ª goroutineï¼Œå¤šä¸ªchannel 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( "fmt" "runtime")func main() &#123; runtime.GOMAXPROCS(runtime.NumCPU()) // å¼€å¯å¤šæ ¸ c := make(chan bool) for i := 0; i &lt; 5; i++ &#123; // å¯åŠ¨å¤šä¸ª goroutin go Decomposition(c, i, 100000007) &#125; for i := 0; i &lt; 5; i++ &#123; // å¤šä¸ª channel é˜»å¡ž &lt;-c &#125;&#125;func Decomposition(c chan bool, index int, n int) &#123; // è´¨æ•°åˆ†è§£ for i := 2; i &lt;= n; i++ &#123; for n != i &#123; if n%i == 0 &#123; fmt.Printf("%d*", i) n = n / i &#125; else &#123; break &#125; &#125; &#125; fmt.Printf("%d: %d\n", index, n) c &lt;- true&#125;è¾“å‡ºï¼š 0: 1000000072: 1000000071: 1000000074: 1000000073: 100000007ä»Žè¾“å‡ºç»“æžœçš„é¡ºåºå¯ä»¥çœ‹å‡º goroutine å¹¶éžå…ˆå¯åŠ¨å…ˆæ‰§è¡Œ ä½¿ç”¨åŒæ­¥åŒ…æ¥ä»£æ›¿ channel 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( "fmt" "runtime" "sync")func main() &#123; runtime.GOMAXPROCS(runtime.NumCPU()) wg := sync.WaitGroup&#123;&#125; wg.Add(5) // æ·»åŠ  5 ä¸ª ä»»åŠ¡ï¼ˆgoroutineï¼‰ for i := 0; i &lt; 5; i++ &#123; go Decomposition(&amp;wg, i, 100000007) &#125; wg.Wait() // ç­‰åˆ°ä»»åŠ¡æ•°å‡åˆ° 0 &#125;func Decomposition(wg *sync.WaitGroup, m int, n int) &#123; for i := 2; i &lt;= n; i++ &#123; for n != i &#123; if n%i == 0 &#123; fmt.Printf("%d*", i) n = n / i &#125; else &#123; break &#125; &#125; &#125; fmt.Printf("%d: %d\n", m, n) wg.Done() // ä»»åŠ¡æ•°å‡ 1&#125;è¾“å‡ºï¼š0: 1000000072: 1000000074: 1000000071: 1000000073: 100000007 selec{}è¯­å¥ï¼Œ å¦‚æžœæœ‰å¤šä¸ªcase è¯»å–æ•°æ®ï¼Œselectä¼šéšæœºé€‰æ‹©ä¸€ä¸ªcaseæ‰§è¡Œï¼Œå…¶ä»–ä¸æ‰§è¡Œï¼› å¦‚æžœæ²¡æœ‰caseè¯»å–æ•°æ®ï¼Œå°±æ‰§è¡Œdefaultï¼› å¦‚æžœæ²¡æœ‰caseè¯»å–æ•°æ®ï¼Œä¸”æ²¡æœ‰defaultï¼Œselectå°†é˜»å¡žï¼Œç›´åˆ°æŸä¸ªcaseå¯ä»¥æ‰§è¡Œã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport ( "fmt")func main() &#123; c1, c2, block := make(chan int), make(chan string), make(chan bool) go func() &#123; for &#123; select &#123; // æŒ‰éšæœºé¡ºåºå¤„ç†å¤šä¸ª case case message, open := &lt;-c1: if !open &#123; // å¦‚æžœé€šé“ c1 å…³é—­ï¼Œåˆ™è·³å‡ºæ— é™å¾ªçŽ¯ block &lt;- true break &#125; fmt.Println("A message from main by c1:", message) case message, open := &lt;-c2: if !open &#123; // å¦‚æžœé€šé“ c2 å…³é—­ï¼Œåˆ™è·³å‡ºæ— é™å¾ªçŽ¯ block &lt;- true break &#125; fmt.Println("A message from main by c2:", message) &#125; &#125; &#125;() c1 &lt;- 10 c2 &lt;- "hello" c1 &lt;- 20 c2 &lt;- "world" close(c1) // å…³é—­é€šé“ c1 &lt;-block&#125;è¾“å‡ºï¼šA message from main by c1: 10A message from main by c2: helloA message from main by c1: 20A message from main by c2: world 12345678910111213141516171819package mainimport ( "fmt" "time")func main() &#123; select &#123; case &lt;-time.After(2000000 * time.Microsecond): fmt.Println("2 seconds") case &lt;-time.After(1999999 * time.Microsecond): fmt.Println("1.999999 seconds") &#125;&#125;è¾“å‡ºï¼š1.999999 seconds æŽ¥å£ç±»åž‹ï¼ˆinterfaceï¼‰ï¼š# ï¼ˆ1ï¼‰æŽ¥å£ä»£è¡¨æŸäº›æ–¹æ³•çš„é›†åˆ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package mainimport ( "fmt")type game interface &#123; Strike_of_Kings() int Battle_Grounds() int&#125;type contact interface &#123; Wechat() QQ()&#125;type smartphone interface&#123; // æŽ¥å£åµŒå¥—ï¼Œ game contact&#125;type iphone struct &#123; version string price float32 user string&#125;func (iph iphone) Wechat() &#123; fmt.Println("I installed wechat on my iphone", iph.version)&#125;func (iph *iphone) QQ() &#123; fmt.Println("I installed wechat on my iphone", iph.version)&#125;// iphone ä¸æ»¡è¶³ contact æŽ¥å£func (iph iphone) Battle_Grounds() int &#123; fmt.Println("There are 4 teammates at most in the Battle Grounds.") return 4&#125;func (iph iphone) Strike_of_Kings() int &#123; fmt.Println("There are 5 teammates at most in the Strike of Kings.") return 5&#125;// iphone æ»¡è¶³ game æŽ¥å£func (iph *iphone) New_Version(version string) &#123; iph.version = version&#125;func all_round_game(game) &#123; // æŽ¥å£ä½œä¸ºå½¢å‚ fmt.Println("Both Strike of_Kings and Battle Grounds have installed.")&#125;func main() &#123; my_phone := iphone&#123;"X", 8316, "Xiaohe"&#125; my_phone.Wechat() fmt.Println(my_phone.Battle_Grounds()) all_round_game(my_phone) // my_phone ç¬¦åˆ game æŽ¥å£ï¼Œå¯ä½œä¸ºè¯¥å‡½æ•°çš„å®žå‚ var _ game = iphone // ç¡®ä¿ iphone å®žçŽ°äº†æŽ¥å£game &#125; ï¼ˆ2ï¼‰ä»»ä½•ç±»åž‹éƒ½æ»¡è¶³ç©ºæŽ¥å£ï¼›ç©ºæŽ¥å£interface{}ä½œä¸ºå½¢å‚å¯ä»¥æŽ¥å—ä»»ä½•ç±»åž‹çš„å®žå‚ 12345678910111213141516171819202122232425package mainimport ( "fmt")func main() &#123; m := make(map[int]interface&#123;&#125;) m[1] = "a" m[2] = 2 m[3] = false print_map(m)&#125;func print_map(m map[int]interface&#123;&#125;) &#123; for k, v := range m &#123; fmt.Println(k, ":", v) &#125;&#125;è¾“å‡ºï¼š1 : a2 : 23 : false []string å’Œ []interface{} æ˜¯ä¸åŒçš„ç±»åž‹ï¼› æŽ¥å£æ˜¯ä¸€ç§æŠ½è±¡ç±»åž‹ï¼Œå¯ç†è§£ä¸ºæ˜¯å°†æ‰€æœ‰å…·ä½“ç±»åž‹æŒ‰ç…§æ–¹æ³•é›†è¿›è¡Œå†åˆ†ç±»ï¼› æŒ‡é’ˆæ–¹æ³•é›†åŒ…å«éžæŒ‡é’ˆæ–¹æ³•é›†ã€‚ ï¼ˆ3ï¼‰æŽ¥å£å€¼ï¼ˆinterface valueï¼‰åŒ…å« ç±»åž‹ ï¼ˆæŽ¥å£çš„åŠ¨æ€ç±»åž‹ï¼‰å’Œ ç±»åž‹å€¼ ï¼ˆæŽ¥å£çš„åŠ¨æ€å€¼ï¼‰ ä¸¤ä¸ªéƒ¨åˆ†ï¼Œä»…å½“ä¸¤è€…å‡ä¸ºnil æ—¶ï¼ŒæŽ¥å£æ‰ä¸ºnil ï¼ˆ4ï¼‰åå°„ ï¼ˆreflectionï¼‰ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( "fmt" "reflect")type iphone struct &#123; version string price int user string&#125;func (iph iphone) Wechat() &#123; fmt.Println("I installed wechat on my iphone", iph.version)&#125;func main() &#123; my_phone := iphone&#123;"X", 8316, "Xiaohe"&#125; Info(my_phone)&#125;func Info(itf interface&#123;&#125;) &#123; t := reflect.TypeOf(itf) fmt.Println(t) for i := 0; i &lt; t.NumField(); i++ &#123; fmt.Println(t.Field(i)) &#125; fmt.Println("___________________") v := reflect.ValueOf(itf) fmt.Println(v) for i := 0; i &lt; v.NumField(); i++ &#123; fmt.Println(v.Field(i)) &#125;&#125;è¾“å‡ºï¼šmain.iphone&#123;version main string 0 [0] false&#125;&#123;price main int 16 [1] false&#125;&#123;user main string 24 [2] false&#125;___________________&#123;X 8316 Xiaohe&#125;X8316Xiaohe æŽ§åˆ¶æµ ï¼ˆfor if switch defer gotoï¼‰ï¼š# ï¼ˆ1ï¼‰forï¼š 1234567891011for (inti statement)ï¼›conditionï¼›(post statement) &#123;&#125;for i := 0; i &lt; 10; i++ &#123;&#125; for ; i &lt; 10; &#123; // åŽ»æŽ‰åˆ†å·&#125; for i &lt; 10&#123; // while è¯­å¥&#125;for&#123; // æ— é™å¾ªçŽ¯&#125; ï¼ˆ2ï¼‰ifï¼š 123456 if (init statement)ï¼›condition &#123;&#125; if (init statement)ï¼›condition &#123;&#125;else &#123;&#125; ï¼ˆ3ï¼‰switchï¼š 12345678910111213switch (init statement)ï¼›some value &#123; case 0ï¼š case f()ï¼š ... defaultï¼š&#125;switch &#123; case å¸ƒå°”è¡¨è¾¾å¼1ï¼š case å¸ƒå°”è¡¨è¾¾å¼2ï¼š ... defaultï¼š&#125; ä¸€æ—¦ç¬¦åˆæ¡ä»¶è‡ªåŠ¨ç»ˆæ­¢ï¼Œè‹¥å¸Œæœ›ç»§ç»­æ£€éªŒä¸‹é¢çš„caseï¼Œä½¿ç”¨ fallthrough è¯­å¥ã€‚ ï¼ˆ4ï¼‰deferï¼š defer åŽå¿…é¡»è·Ÿå‡½æ•°å¼•ç”¨ defer è¯­å¥è¢«æ£€éªŒåŽï¼Œå»¶è¿Ÿå‡½æ•°èŽ·å¾—å˜é‡çš„æ‹·è´ 123456func a() &#123; i := 0 defer fmt.Println(i) i++ return&#125; // defer è¯­å¥æ‰“å°0 defer è¯­å¥è¢«æ£€éªŒåŽï¼Œå»¶è¿ŸåŒ¿åå‡½æ•°èŽ·å¾—å˜é‡çš„åœ°å€ 12345678910111213func b() (i int) &#123; defer func() &#123; i++ &#125;() return 1 // å°†1 èµ‹ç»™ i&#125; // è¿”å›ž 2ã€‚åˆ©ç”¨ defer è¯­å¥ä¿®æ”¹å¤–å›´å‡½æ•°çš„å‘½åè¿”å›žå€¼func c() &#123; for i := 0; i &lt; 3; i++ &#123; defer func() &#123; fmt.Print(i) &#125;() &#125; return&#125; // æ‰“å° 333 defer è¯­å¥è¢«æ£€éªŒåŽï¼Œå»¶è¿Ÿå‡½æ•°çš„å¼•ç”¨è¢«æŽ¨å…¥å †æ ˆï¼Œå½“å¤–å›´å‡½æ•°è¿”å›žåŽï¼ŒæŒ‰ç…§åŽè¿›å…ˆå‡ºçš„é¡ºåºè¢«è°ƒç”¨ï¼ˆå³ä½¿å¤–å›´å‡½æ•°å‘ç”Ÿé”™è¯¯ï¼Œå¦‚ panicï¼Œå»¶è¿Ÿå‡½æ•°ä»ç„¶ä¼šè¢«è°ƒç”¨ï¼‰ 12345func d() &#123; for i := 0; i &lt; 4; i++ &#123; defer fmt.Print(i) &#125;&#125; // æ‰“å° 3210 æ›´å¤šç»†èŠ‚å¦‚ï¼Œpanicï¼Œ recoverï¼ˆåªèƒ½ç”¨åœ¨å»¶è¿Ÿå‡½æ•°ä¸­ï¼‰ å‚è€ƒ defer blogã€‚ ï¼ˆ5ï¼‰gotoï¼š 123456789101112131415161718192021222324LABEL: for &#123; for i := 0; i &lt; 10; i++ &#123; if i &gt; 3 &#123; break LABEL // è·³å‡ºä¸ŽLABELåŒçº§çš„å¾ªçŽ¯ï¼Œå³è·³å‡ºæ— é™å¾ªçŽ¯ &#125; &#125; &#125;LABEL: for i := 0; i &lt; 10; i++ &#123; for &#123; continue LABEL &#125; &#125;LABEL: for &#123; for i := 0; i &lt; 10; i++ &#123; if i &gt; 3 &#123; goto LABEL // å°†å†æ¬¡è¿›å…¥æ— é™å¾ªçŽ¯ &#125; &#125; &#125; é€šå¸¸æ ‡ç­¾æ”¾åˆ° goto çš„åŽé¢ã€‚ åˆ›å»ºå·¥ç¨‹ç›®å½•ï¼š# Goå·¥ç¨‹ä¸­å…±æœ‰ä¸‰ä¸ªéƒ¨åˆ†ï¼š srcï¼šå­˜æ”¾goæºç æ–‡ä»¶ pkgï¼šå­˜æ”¾ç¼–è¯‘åŽçš„åŒ…æ–‡ä»¶ binï¼šå­˜æ”¾ç¼–è¯‘åŽçš„å¯æ‰§è¡Œæ–‡ä»¶ **æ³¨æ„ï¼š**srcç›®å½•éœ€è¦è‡ªå·±åˆ›å»ºï¼Œpkgå’Œbinç¼–è¯‘æ—¶ä¼šè‡ªåŠ¨åˆ›å»ºã€‚ æ­¥éª¤ï¼š æ–°å»ºå·¥ç¨‹ç›®å½•ï¼Œmy_projectï¼Œå¹¶åœ¨è¯¥ç›®å½•ä¸‹åˆ›å»º srcç›®å½•ï¼› æŠŠmy_project æ·»åŠ åˆ° GOPATHï¼ŒGOPATH=/home/user/...;my_projectï¼ˆå¯ä»¥åŒæ—¶æ·»åŠ å¤šä¸ªè·¯å¾„ç›®å½•ï¼ŒLinuxä¸‹ç”¨å†’å·:éš”å¼€ï¼Œwindowä¸‹åˆ†å·;éš”å¼€ï¼‰; åœ¨ src ä¸‹åˆ›å»ºmy_pkg å’Œ my_cmd; åŒ…æ–‡ä»¶æ”¾å…¥åˆ° my_pkg ä¸­ï¼Œæ¯”å¦‚ test.go 1234567package my_pkgimport "fmt" func Test()&#123; fmt.Println("Hello,world!") fmt.Println("You used a function defined in my_package!")&#125; åœ¨å‘½ä»¤è¡Œsrcç›®å½•ï¼Œæ‰§è¡Œ go install my_pkg å°†åˆ›å»º pkg ç›®å½•å¹¶å£°æˆ my_pkg.a æ–‡ä»¶ã€‚ my_cmd ä¸­æ”¾å…¥ package mainï¼Œæ¯”å¦‚ hello_world.go 12345678package mainimport( "my_pkg")func main()&#123; my_pkg.Test()&#125; åœ¨å‘½ä»¤è¡Œsrcç›®å½•ï¼Œæ‰§è¡Œ go install my_cmd å°†åˆ›å»º bin ç›®å½•å¹¶ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶æˆ hello_world.exe æ–‡ä»¶ã€‚ ç›®å½•ç»“æž„ï¼š src/ $\quad$ my_pkg/ $\qquad$ test.go $\quad$ my_cmd/ $\qquad$ hello_world.go Tips:# import åŒ…Açš„æ—¶å€™ï¼Œä¼šè‡ªåŠ¨è°ƒç”¨åŒ…Açš„init()å‡½æ•°ï¼ˆiå­—æ¯å°å†™ï¼‰ã€‚å¦‚æžœè¯¥åŒ…Aåˆimportäº†åˆ«çš„åŒ…Bï¼Œä¼šä¼˜å…ˆè°ƒç”¨åŒ…Bçš„init()å‡½æ•°ï¼Œæœ€åŽæ‰è°ƒç”¨mainåŒ…çš„init()å‡½æ•°ã€‚ ä¸€ä¸ªåŒ…çš„init()å‡½æ•°å¯ä»¥å®šä¹‰å¤šä¸ªï¼Œæ¯ä¸ªéƒ½ä¼šè¢«è°ƒç”¨ï¼Œè°ƒç”¨çš„é¡ºåºæŒ‰æ–‡ä»¶åæŽ’åºã€‚åŒä¸€ä¸ªæ–‡ä»¶ä¹Ÿå¯ä»¥å®šä¹‰å¤šä¸ªinitå‡½æ•°ã€‚ å…¶ä»–ï¼š# fmt.printf verbsï¼š %x %bï¼š16è¿›åˆ¶ï¼Œ2è¿›åˆ¶æ˜¾ç¤ºï¼›%tï¼šæ˜¾ç¤º bool ç»“æžœï¼›%Tï¼šæ˜¾ç¤ºå€¼çš„ç±»åž‹ï¼›%vï¼šæ˜¾ç¤ºå€¼ï¼›%pï¼šæ˜¾ç¤ºåœ°å€ï¼›\nï¼šæ¢è¡Œ Sublime text 3 ä¸Šä¸€ä¸ªç¼–è¾‘å¤„: alt+- ä¸‹ä¸€ä¸ªç¼–è¾‘å¤„: alt+shift+- GoSublimeï¼š GoSublimeå¿«æ·é”®åˆ—è¡¨ï¼šctrl+.+. (è¿žå‡» .) æŸ¥çœ‹å£°æ˜Žï¼šctrl+.+h ä»£ç è·³è½¬ï¼šctrl+shift+å·¦é”® package controlï¼šctrl+shift+p Golandï¼šé€€å›žä¸Šä¸€æ¬¡å…‰æ ‡ä½ç½®ï¼šctrl+win+alt+å·¦é”® å‚è€ƒèµ„æ–™ï¼š# [1] æ— é—»;Goç¼–ç¨‹åŸºç¡€ç³»åˆ—è§†é¢‘. [2] Alan A.A. Donovan; Brain W. Kernighan; The Go Programming Language; 2015.]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>é•¿æ–‡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æœ¬åœ°é¡¹ç›®ä¸Šä¼ åˆ° Github ä»“åº“ã€Gitå¼€å‘å‘½ä»¤]]></title>
    <url>%2F2018%2F07%2F04%2F2018-7-4%2F</url>
    <content type="text"><![CDATA[ç”Ÿæˆæœ¬åœ°ç‰ˆæœ¬åº“ ï¼ˆ.git æ–‡ä»¶å¤¹ï¼‰ åˆ›å»º SSH key åˆ›å»º GitHub ä»“åº“ ä¸Šä¼ åˆ° GitHub ä»“åº“ æœ¬åœ°ä¿®æ”¹è·Ÿæ–°åˆ° GitHub ä»“åº“ ç”Ÿæˆæœ¬åœ°ç‰ˆæœ¬åº“ ï¼ˆ.git æ–‡ä»¶å¤¹ï¼‰# 123git initgit add .git commit -m "..." æ“ä½œå¦‚ä¸‹ï¼Œ åˆ›å»º SSH key# æŸ¥çœ‹ cç›˜ ç”¨æˆ·ç›®å½•æ˜¯å¦åŒ…å« .ssh ç›®å½•ã€‚å¦‚æžœåŒ…å«ï¼Œæ‰“å¼€ id_rsa.pub æ–‡ä»¶å¹¶å¤åˆ¶é‡Œé¢çš„å†…å®¹ï¼ˆå¯†é’¥ï¼‰ å¦‚æžœä¸åŒ…å« .ssh ç›®å½•ï¼ˆä¸Šè¿°æ“ä½œä¼šæŠ¥é”™ï¼‰ï¼Œé€šè¿‡å¦‚ä¸‹å‘½ä»¤åˆ›å»º 1ssh-keygen -t rsa -C "your email address" å…¶ä¸­ C ä¸ºå¤§å†™ã€‚ç„¶åŽæŒ‰ç…§å‰é¢çš„æ–¹å¼å¤åˆ¶å¯†é’¥ã€‚ å°†å¯†é’¥æ·»åŠ åˆ° GitHub åˆ›å»º GitHub ä»“åº“# ![](https://upload-images.jianshu.io/upload_images/1863961-d05408b0cfc2e198.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/650) ![](https://upload-images.jianshu.io/upload_images/1863961-f7edb952c890e069.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/650) ä¸Šä¼ åˆ° GitHub ä»“åº“# 12git remote add origin git@github.com:jiangtaohe/test.gitgit push -u origin master æœ¬åœ°ä¿®æ”¹è·Ÿæ–°åˆ° GitHub ä»“åº“# è‹¥æœ¬åœ°å·²ç»å…³è”åˆ°ä»“åº“ï¼Œgit remote add origin å‘½ä»¤è¡ŒåŽ»æŽ‰ã€‚ 1234git remote add origin git@github.com:jiangtaohe/test.gitgit add .git commit -m "..."git push 1git add file fileçš„ä¿®æ”¹æ·»åŠ åˆ°æš‚å­˜åŒº 1git commit file -m "å¤‡æ³¨ä¿¡æ¯" åˆ›å»ºæ–°çš„ç‰ˆæœ¬åº“ï¼Œå¹¶å°†fileåœ¨æš‚å­˜åŒºä¸­çš„ä¿®æ”¹æ·»åŠ åˆ°æ–°çš„ç‰ˆæœ¬åº“ä¸­ 1git stash å°†å·¥ä½œåŒºå’Œæš‚å­˜åŒºçš„ä¿®æ”¹è£…ç®±åŽå›žåˆ°ç‰ˆæœ¬åº“åˆå§‹çŠ¶æ€(ç›¸å½“äºŽæ’¤é”€æ‰€æœ‰ä¿®æ”¹) 1git stash pop å°† git stashè£…ç®±çš„ä¿®æ”¹å€’å‡º 1git checkout -- file æ’¤é”€fileå·¥ä½œåŒºçš„ä¿®æ”¹ 12git checkout --ours (--theirs) filegit add file fileå‘ç”Ÿmergeå†²çªæ—¶ï¼Œå®Œå…¨é‡‡å–æœ¬æ–¹(ä»–æ–¹)çš„ä¿®æ”¹ 1git fetch origin dev:local_dev èŽ·å–è¿œç¨‹åˆ†æ”¯devçš„ä»£ç ï¼Œå¹¶åœ¨æœ¬åœ°åˆ›å»ºæœ¬åœ°åˆ†æ”¯local_dev 1git pull origin dev æ‹‰å–è¿œç¨‹åˆ†æ”¯devä¸Žå½“å‰åˆ†æ”¯å’Œå¹¶(merge) 1git reset --hard commit_id(å‰4ä½æ•°) åˆ‡æ¢åˆ°æŸä¸ªç‰ˆæœ¬åº“ 1git branch branch_name æ–°å»ºåˆ†æ”¯ 1git branch -d branch_name åˆ é™¤åˆ†æ”¯ 1git merge branch_name åˆå¹¶åˆ†æ”¯ 123git statusgit loggit reflog 1git remote -v æ‰“å°è¿œç¨‹ä»“åº“åç§°å’Œåœ°å€ 1git remote set-url --add origin git@gitlab.com:jiangtaohe/test.git å¢žåŠ ä¸€ä¸ªè¿œç¨‹ä»“åº“]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é˜…åŽ†]]></title>
    <url>%2F2018%2F07%2F01%2F2018-7-1%2F</url>
    <content type="text"><![CDATA[æœ‰æ—¶äººçš„æˆé•¿åœ¨ä¸çŸ¥ä¸è§‰ä¸­å‘ç”Ÿï¼Œä¸”ä¸è®ºæ˜¯ç”Ÿç†ä¸Šçš„è¿˜æ˜¯å¿ƒæ™ºä¸Šçš„ã€‚æ¯”å¦‚äººçš„èº«é«˜çš„å˜åŒ–ï¼Œå¯¹äºŽæ—äººçœ‹æ¥æ˜¯å¾ˆå¤§çš„æ”¹å˜ï¼Œä½†å¯¹äºŽå½“äº‹äººå¯èƒ½æ˜¯ç›¸å½“æ— æ„Ÿçš„ï¼ˆé™¤éžä½ åˆ»æ„çš„åŽ»æµ‹é‡ï¼Œå¹¶ç”»å‡ºæŠ˜çº¿å›¾æ¥ï¼Œå¾ˆå°‘äººä¼šè¿™ä¹ˆåšå§ï¼‰ã€‚ä¸Žå‰è€…ç›¸æ¯”ï¼Œå¿ƒæ™ºçš„ å˜åŒ–æ›´åŠ éšè”½ï¼Œä½ ç”šè‡³éƒ½ä¸å¥½è®°å½•æ•°æ®ä½œå‡ºå›¾è¡¨æ¥ï¼Œä½†å¹¶éžä¸€æ— æ‰€çŸ¥ï¼Œæœ‰äº›æ˜¯å¯ä»¥ä»Žç”Ÿæ´»ä¸­çª¥è§ç«¯å€ªã€‚ å°‘å¹´æ—¶æœŸçš„æˆ‘éžå¸¸è®¨åŽŒåƒè‹¦ç“œã€‚ä½ å¯èƒ½å·²ç»è„‘è¡¥å‡ºæˆ‘ç¬¬ä¸€æ¬¡åƒè‹¦ç“œæ—¶å€™çš„è¡¨æƒ…äº†ã€‚ â€œæ˜¯äººåƒçš„å—ï¼Ÿâ€ï¼Œå½“ç„¶æ²¡æœ‰è¯´å‡ºå£ï¼Œä½†æˆ‘å½“æ—¶å°±é‚£ä¹ˆæƒ³çš„ã€‚è®©æˆ‘æƒŠå¥‡çš„æ˜¯æ¯äº²ç«Ÿåƒå¾—æ´¥æ´¥æœ‰å‘³ (ï¼ƒÂ°Ð”Â°) å¥½åƒæˆ‘åƒäº†ä¸€å£å‡çš„è‹¦ç“œã€‚è½¬å¿µä¸€æƒ³ï¼Œæ—¢ç„¶è¿™çŽ©æ„å„¿éƒ½å«è‹¦ç“œäº†ï¼Œé‚£æ˜¯å¿…è‹¦æ— ç–‘äº†ã€‚é‚£æ—¶çš„æˆ‘å“ä¸æ¥è‹¦ç“œçš„å‘³é“ï¼Œè‡ªç„¶ç†è§£ä¸äº†æ¯äº²çš„æœ‰æ»‹æœ‰å‘³äº†ã€‚åŽæ¥å¶å°”é‡åˆ°è‹¦ç“œä¹Ÿä¼šåƒä¸Šä¸€å°ç‰‡ï¼Œâ€œæµ…å°è¾„æ­¢â€ï¼Œæ¯•ç«Ÿè¿˜æ˜¯é‚£ä¸ªå‘³å„¿å•Šï¼Œå¹²å˜›äºå¾…è‡ªå·±ã€‚ç›´åˆ°ä¸Šäº†å¤§å­¦åŽæ‰æœ‰äº†æ”¹å˜ã€‚ è¯è¯´æˆ‘åœ¨å¤§å­¦åƒäº†å‡ å¹´é£Ÿå ‚ï¼Œå–œæ¬¢åƒçš„éƒ½åƒå¾—è…»äº†ã€‚æŸå¤©å¿ƒè¡€æ¥æ½®ï¼Œè¦ä¸æ¥ç›˜ç‚’è‹¦ç“œå§ã€‚æˆ‘çªç„¶å‘çŽ°è¿™çŽ©æ„å„¿ä¸é‚£ä¹ˆè‹¦äº†ï¼Œç”šè‡³æ„Ÿåˆ°åˆ«æœ‰ä¸€ç•ªé£Žå‘³ã€‚åŽŸä»¥ä¸ºè·Ÿè‹¦ç“œå“ç§æœ‰å…³ï¼Œæ‰€ä»¥åŽæ¥å›žå¤–å©†å®¶æ—¶ï¼Œæˆ‘ç‰¹æ„è®©å¤–å©†åšäº†é“ç‚’è‹¦ç“œï¼Œåƒèµ·æ¥ä¹Ÿæ˜¯ä¸é‚£ä¹ˆè‹¦ã€‚æˆ‘æ„è¯†åˆ°â€œç‰©æ˜¯äººå·²éžâ€ï¼Œè‹¦ç“œè¿˜æ˜¯å¹´å°‘æ—¶çš„è‹¦ç“œï¼Œè€Œæˆ‘å´ä¸ä¸€æ ·äº†ã€‚è¿™ç§å˜åŒ–å½“ç„¶æœ‰ç”Ÿç†ä¸Šçš„ï¼Œä½†æ›´å¤šçš„æ˜¯å¿ƒæ™ºä¸Šçš„ï¼Œè€ŒåŽè€…æ˜¯è‡ªå·±çš„é˜…åŽ†åœ¨ä¸æ–­å¢žé•¿çš„ç»“æžœã€‚æœ‰äº›äº‹æƒ…é˜…åŽ†å¤Ÿäº†è‡ªç„¶å°±ä¼šäº†ã€‚ ç±»ä¼¼çš„è¿˜æœ‰å¯¹æˆæ›²çš„ç†è§£ã€‚ä»¥å‰çš„æˆ‘æ ¹æœ¬å°±çœ‹ä¸äº†æˆæ›²çš„ï¼Œæ— æ„Ÿå•Šã€‚éšç€å¹´é¾„çš„å¢žé•¿ï¼Œæˆ‘å¯¹æˆæ›²çš„æ€åº¦ä¹Ÿå‘ç”Ÿæ”¹å˜ï¼Œè™½ç„¶è°ˆä¸ä¸Šçƒ­çˆ±ï¼Œä½†å¤šå°‘ä¹Ÿèƒ½å“åˆ°å…¶ä¸­çš„ä¸€äº›éŸµå‘³ã€‚å°¤å…¶æ˜¯äº¬å‰§ï¼Œä¸æ„§ä¸ºå›½ç²¹ï¼Œå°½ç®¡æ²¡çœ‹è¿‡ä¸€ä¸ªå®Œæ•´çš„å‰§ç›®ï¼Œä¹Ÿå«ä¸å‡ºå¤šå°‘å‰§ç›®çš„åå­—æ¥ï¼Œå½“æˆ‘è¢«è¡¨æ¼”è€…çš„ä¸€é¢¦ä¸€ç°‡ã€ä¸€å”±ä¸€æ‰“æ‰€ç‰µåŠ¨çš„æ—¶å€™ï¼Œæˆ‘çŸ¥é“é‚£å°±æ˜¯å¥½çš„æˆæ›²ï¼Œäº†ä¸èµ·çš„è‰ºæœ¯ï¼]]></content>
      <tags>
        <tag>éšæƒ³</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç‹¬æ†©]]></title>
    <url>%2F2018%2F06%2F19%2F2018-6-19%2F</url>
    <content type="text"><![CDATA[æœ‰æ—¶å€™æˆ‘çœŸåœ°å–œæ¬¢å®‰é™ï¼Œç‹¬è‡ªä¸€äººï¼Œä¸è¢«æ‰“æ‰°ï¼Œåšä¸€äº›æ²¡æœ‰æ„ä¹‰çš„äº‹æƒ…ã€‚ å½“ä¸‹ç®€å•åœ°å”¯æ°´ï¼Œç¬”ï¼Œå¸ƒè€Œå·²ã€‚]]></content>
      <tags>
        <tag>ä¹¦æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è¿åŠ¨ä¸Žå†¥æƒ³]]></title>
    <url>%2F2018%2F06%2F14%2F2018-6-14%2F</url>
    <content type="text"><![CDATA[è¿‘æ¥åˆæŠŠè·‘æ­¥çº³å…¥æ—¥å¸¸ã€‚è·‘ç€è·‘ç€ï¼Œè·‘å‡ºäº†ä¸€ç‚¹å¿ƒå¾—ï¼Œä»Šä»¥è®°ä¹‹ï¼Œç®—æ˜¯å¯¹è‡ªå·±åšæŒé”»ç‚¼çš„å‹‰åŠ±ã€‚ ä¸€å¼€å§‹ï¼Œæˆ‘æ˜¯è·Ÿç€å°ä¼™ä¼´ä¸€èµ·è·‘æ¥ç€ï¼Œç„¶åŽæœ‰å‡ æ¬¡è‡ªå·±è·‘ã€‚å›žæƒ³è¿åŠ¨æ—¶å€™çš„çŠ¶æ€ï¼Œæˆ‘å‘çŽ°è‡ªå·±è·‘è¿åŠ¨åœ°æ›´å……åˆ†ï¼Œé”»ç‚¼çš„æ•ˆæžœä¹Ÿæ›´å¥½ã€‚æ®è¯´è·‘æ­¥åŠä¸ªå°æ—¶æ˜¯ä¸€ç§å¾ˆå¥½çš„é”»ç‚¼æ–¹å¼ï¼Œå‰ææ˜¯è¦ä¿è´¨ä¿é‡ã€‚ä¿è´¨å°±è¦æ±‚å…¨ç¨‹ä¿æŒåœ¨è·‘çš„çŠ¶æ€ï¼Œä½ å¯ä»¥è·‘å¿«ç‚¹æˆ–è€…æ…¢ç‚¹ï¼Œä½†ä¸è¦æ˜¯ walking ã€‚ä¿é‡å°±æ˜¯æœ€å°‘è·‘åŠä¸ªå°æ—¶ï¼Œå½“ç„¶ä½ ä¹Ÿå¯ä»¥æŒ‰ç…§è·¯ç¨‹ï¼ˆå¤šå°‘åœˆè·‘é“ï¼‰æ¥è®¡ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè¿™ä¸ªä¿è´¨ä¿é‡å› äººè€Œå¼‚ï¼Œä½ éœ€è¦ç»™è‡ªå·±è®¾ç«‹åˆç†çš„ç›®æ ‡ä¸”ä¸èƒ½å¤Ÿè½»æ˜“å°±å¯è¾¾æˆã€‚ ä¸“æ³¨äºŽè·‘æ­¥æœ‰åˆ©äºŽç›®æ ‡çš„è¾¾æˆã€‚è¿™ä¹Ÿè§£é‡Šäº†ä¸ºä»€ä¹ˆç‹¬è‡ªè·‘æ­¥çš„æ•ˆæžœæ›´å¥½ï¼ˆä¸Žå°ä¼™ä¼´ç›¸äº’é¼“åŠ±å½“ç„¶ä¹ŸæŒºå¥½ï¼‰ï¼Œå› ä¸ºä¸ç”¨åˆ»æ„åŽ»åè°ƒåˆ«äººï¼Œä½ å¯ä»¥æ›´å¿«æ‰¾åˆ°è‡ªå·±çš„èŠ‚å¥ã€‚å½“ä½ æŒç»­åœ°ä¸“æ³¨äºŽè‡ªå·±çš„èº«ä½“å’Œæ„Ÿè§‰æ—¶ï¼Œä½ å¯ä»¥ä½“ä¼šåˆ°æŽ§åˆ¶ä¸Žæ´»åŠ›ï¼Œè€Œç»´æŒæ ‡å‡†åŠ¨ä½œå¯ä»¥åŠ æ·±è¿™ç§ä½“ä¼šã€‚å› æ­¤ï¼Œä¸å¦¨æŠŠè·‘æ­¥çœ‹ä½œä¸€æ¬¡å†¥æƒ³è®­ç»ƒï¼Œä¸“æ³¨äºŽè‡ªæˆ‘ï¼Œä½“ä¼šç§¯æžçš„åŠ›é‡ä¹ŸæŽ¥å—è„‘æ¶¨è…¿ä¹æ„Ÿè§‰ï¼Œä½†ä¸è¦è®©ç–²åŠ³å æ®ä¸Šé£Žï¼Œå¦åˆ™ä½ å°†åŠ¨ä½œå˜å½¢ï¼Œæ„ˆæ„Ÿä¸¾æ­¥ç»´è‰°ã€‚ é¿å…å¤–éƒ¨å¹²æ‰°å› ç´ æœ‰åŠ©äºŽä¸“æ³¨ï¼Œæ¯”å¦‚æ¡ç€æ‰‹æœºï¼Œæºå¸¦ç‹—ç‹—ç­‰å°½é‡é¿å…ã€‚ æœ€åŽéœ€è¦å¼ºè°ƒçš„æ˜¯æ³¨æ„å®‰å…¨ã€‚å½“èº«ä½“å‡ºçŽ°ä¸é€‚çš„æ—¶å€™ï¼Œåƒä¸‡ä¸è¦å‹‰å¼ºã€‚å‰ä¸¤äº›å¤©å°±æœ‰å…¬ä¼—å·æŠ¥é“æŸç”·å­è·‘æ­¥è¿‡ç¨‹ä¸­æ‘”å€’äº†ä¸¤æ¬¡ä»è¦åšæŒï¼Œæœ€ç»ˆå¯¼è‡´çŒäº¡çš„æ¯å…·ã€‚è¿˜æœ‰ä¸Šæ–‡æåˆ°ç‹¬è‡ªè¿åŠ¨æœ‰åŠ©äºŽä¸“æ³¨ï¼Œä½†è¿˜æ˜¯é¿å…åŽ»äººå°‘çš„åœ°æ–¹æ´»åŠ¨ï¼Œå°¤å…¶æ˜¯å¥³åŒå­¦ã€‚å­¦æ ¡çš„æ“åœºæ˜¯ç»ä½³çš„åœºæ‰€ï¼Œå› ä¸ºæœ‰å…¶ä»–çš„åŒå­¦è¿˜å¯ä»¥å‡å°‘å­¤ç‹¬æ„Ÿï¼Œå¯¹è‡ªå·±çš„åšæŒæ˜¯å¾ˆæœ‰å¸®åŠ©çš„ã€‚]]></content>
      <tags>
        <tag>éšæƒ³</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¤šå®å¡”ç¢‘ç²¾é€‰]]></title>
    <url>%2F2018%2F06%2F10%2F2018-6-10%2F</url>
    <content type="text"><![CDATA[ã€Šå¤šå®å¡”ç¢‘ã€‹ç²¾é€‰ä¸‰åä¸ƒå­—ã€‚æ¥æºäºŽæœç‹â€œä¹¦æ³•æ€è€ƒâ€ï¼Œä»Šè—ä»¥æ—¶ä¹ ä¹‹ã€‚ æ¨ªã€ç«–ï¼š(ä¸‰ã€çŽ‹ã€åã€åŠã€ä¸­)# æ’‡ã€æºï¼š(å¤§ã€æ‰‹ã€åˆã€å¹´ã€å…¥)# ç‚¹ï¼š(å¿ƒã€æ¶µã€æµ®ã€å¹¶ã€å°šã€å°ã€æ–¼ã€å…¶ã€æ„Ÿ)# é’©ã€æŒ‘ï¼š(å®—ã€æ±‚ã€è§‚ã€è¡¨ã€è§ã€å’¸ã€é£Ÿã€ä»¥)# æŠ˜ï¼š(è‡ªã€åã€äº†ã€å±±ã€ç‰™ã€çŸ£ã€æ¯ã€å¤–ã€å¥³)#]]></content>
      <tags>
        <tag>ä¹¦æ³•</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask ç¬”è®°]]></title>
    <url>%2F2018%2F05%2F28%2F2018-5-28%2F</url>
    <content type="text"><![CDATA[åˆ›å»º flask instanceï¼ˆä¹Ÿå°±æ˜¯ä¸€ä¸ªåº”ç”¨ï¼‰ä¸¤ç§æ–¹å¼ï¼š1. (module) åœ¨URL\my_app.pyä¸­åŠ å…¥ 12from flask import Flaskapp = Flask(__name__) 2.(package) åœ¨URL\app_folder\__init__.pyä¸­åŠ å…¥ 12from flask import Flaskapp = Flask(&apos;app_folder&apos;) é˜…è¯» Miguel Grinberg's book: Flask Web Developent SECOND EDITION ä¸­çš„ä¸€ä¸ªå°åº”ç”¨ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import os from datetime import datetime # python æ ‡å‡†åº“ï¼Œdatetime.utcnow()from flask import Flask, render_template, session, redirect, url_for, flash from flask_bootstrap import Bootstrap # flask æ‰©å±•from flask_moment import Moment # flask æ‰©å±•from flask_wtf import FlaskFormfrom wtforms import StringField, SubmitFieldfrom wtforms.validators import DataRequiredfrom flask_sqlalchemy import SQLAlchemyfrom flask_migrate import Migratebasedir = os.path.abspath(os.path.dirname(__file__))app = Flask(__name__) # åˆ›å»ºåº”ç”¨app.config['SECRET_KEY'] = 'hard to guess string'app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + os.path.join(basedir, 'data.sqlite')app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = Falsebootstrap = Bootstrap(app) # templates æ–‡ä»¶å¤¹ä¸­ base.html æ‰©å±•äº† bootstrap/base.htmlmoment = Moment(app) # è®¾ç½®æ—¥æœŸã€æ—¶é—´çš„æ ¼å¼ã€‚moment.js ç”± base.htmlå¯¼å…¥db = SQLAlchemy(app) # åˆ›å»ºæ•°æ®åº“migrate = Migrate(app, db)class Role(db.Model): __tablename__ = 'roles' # è¡¨æ ¼åç§° id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(64), unique=True) users = db.relationship('User', backref='role', lazy='dynamic') # ä¸Ž User ç±»å…³è”ã€‚backref ç»™ User ç±»åˆ›å»º role å±žæ€§ï¼Œåœ¨ç”Ÿæˆ User å¯¹è±¡æ—¶é€šè¿‡ role ä¸Žä¸€ä¸ª Role å¯¹è±¡å…³è”ã€‚ def __repr__(self): # ç›´æŽ¥è¾“å‡ºå¯¹è±¡æˆ–è€…é€šè¿‡ print æ‰“å°å¯¹è±¡æ—¶ï¼Œä¿¡æ¯éƒ½æŒ‰__repr__æ–¹æ³•ä¸­å®šä¹‰çš„æ ¼å¼è¿›è¡Œæ˜¾ç¤ºã€‚ ç±»ä¼¼çš„ __str__ åªæœ‰åœ¨ print æ‰“å°æ—¶æ‰ç”Ÿæ•ˆã€‚ä¾¿äºŽè°ƒè¯•ã€‚ return '&lt;Role %r&gt;' % self.nameclass User(db.Model): __tablename__ = 'users' id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(64), unique=True, index=True) role_id = db.Column(db.Integer, db.ForeignKey('roles.id')) def __repr__(self): return '&lt;User %r&gt;' % self.usernameclass NameForm(FlaskForm): name = StringField('What is your name?', validators=[DataRequired()]) # DataRequired()è¦æ±‚æäº¤æ—¶è¡¨å•ä¸ä¸ºç©º submit = SubmitField('Submit') # è¡¨å•çš„æäº¤æŒ‰é’®ã€‚ åœ¨ render html æ—¶ï¼Œæ·»åŠ  type='Submit' å±žæ€§@app.shell_context_processordef make_shell_context(): # è¿è¡Œ flask shell æ—¶è‡ªåŠ¨ä»Ž app(hello.py) å¯¼å…¥ db, User, Role return dict(db=db, User=User, Role=Role)@app.errorhandler(404) def page_not_found(e): # 404ï¼Œ500 ä¸º html é”™è¯¯ç±»åž‹ return render_template('404.html'), 404 # è¿”å›žå…ƒç»„@app.errorhandler(500)def internal_server_error(e): return render_template('500.html'), 500'''@app.route('/')def index(): return render_template('index.html', current_time=datetime.utcnow())'''@app.route('/user/&lt;name&gt;')def user(name): return render_template('user.html', name=name) # name=nameï¼Œ å‰è€…ä»£è¡¨ user.html ä¸­çš„ name å˜é‡ï¼ŒåŽè€…ä»£è¡¨ç”±ç”¨æˆ·åœ¨ç½‘å€æ ä¸­è¾“å…¥çš„å€¼ï¼Œå³&lt;name&gt;@app.route('/', methods=['GET', 'POST']) def index(): # Post/Redirect/Get patternï¼Œinde()è¢«è°ƒç”¨ä¸¤æ¬¡ form = NameForm() # ç”Ÿæˆè¡¨å•å®žä¾‹ if form.validate_on_submit(): # è¡¨å•è¢«æäº¤ä¸”é€šè¿‡æ‰€æœ‰çš„ validators ï¼ˆè¿™é‡Œåªæœ‰ DataRequired()ä¸€ä¸ªï¼‰æ—¶è¿”å›ž True old_name = session.get('name') if old_name is not None and old_name != form.name.data: flash('Looks like you have changed your name!') # å½“ä¸¤æ¬¡æäº¤çš„å†…å®¹ä¸åŒæ—¶æ˜¾ç¤ºæç¤ºæ¡†ã€‚flash() é‡Œçš„å‚æ•°è¢« æ¨¡æ¿ base.html ä¸­çš„ get_flashed_messages() å‡½æ•°æå–ã€‚ session['name'] = form.name.data # ä¿å­˜è¡¨å•æäº¤çš„ data return redirect(url_for('index')) # url_for('index') è¿”å›ž root URLã€‚redirect() å‘å‡ºå¯¹ root URL çš„ GETè¯·æ±‚ï¼Œä½œä¸ºå¯¹ POST è¯·æ±‚çš„å›žåº”ã€‚ return render_template('index.html', form=form, name=session.get('name')) # å¯¹ redirect() çš„ GETè¯·æ±‚çš„å›žåº”ã€‚# åŠ å…¥æ•°æ®åº“@app.route('/', methods=['GET', 'POST'])def index(): form = NameForm() if form.validate_on_submit(): user = User.query.filter_by(username=form.name.data).first() # æŸ¥è¯¢è¡¨å•æäº¤çš„ç”¨æˆ·å if user is None: # å¦‚æžœä¸åœ¨æ•°æ®åº“ä¸­å°±æŠŠå®ƒåŠ å…¥ user = User(username=form.name.data) db.session.add(user) db.session.commit() session['known'] = False else: session['known'] = True session['name'] = form.name.data return redirect(url_for('index')) return render_template('index.html', form=form, name=session.get('name'), known=session.get('known', False))]]></content>
      <tags>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to Create a Personal Blog]]></title>
    <url>%2F2018%2F05%2F22%2F2018-5-22%2F</url>
    <content type="text"><![CDATA[The Structure of The Blog Apply For a Github Account and Create a Repository Create hexo source file download and install create file select and add your theme 2.4 deploy the source file to the github repository When you see this blog post, you have already had some kind of motivation to create a personal blog, maybe it is to possess something, record your ideas or just to be cool. From my observation, most people who have a personal blog are the computer professionals. But this does not mean you have to create your blog with much computer knowledge. The rest of this post will show you the process can be easy and fun. The Structure of The Blog# From the structure, you almost know what to do next. You don't have to build a browser, since your PC has already had one. You just need to do the left two things, applying for a github account as the remote platform to store your blog files, creating the local source file which is the root of your blog. Apply For a Github Account and Create a Repository# Click Github to apply. Create hexo source file# Most of the source file is generated by Hexo which is a popular blog framework and is based on Node.js. We also need Git to deploy the source file to your newly created repository. download and install# Node.js Git Hexo is installed with the Git tool. After installing the Git, click your the right mouse button on the desktop and select the &quot;Git Bash Here&quot; option (means open the bash window in the current directory). Type the following commond to enter your home directory. 1cd ~ Input the following commond to install Hexo. 1npm install hexo-cli -g create file# Create hexo source file . You can make your own file name to replace &quot;hexo_source&quot;. 1hexo init hexo_source select and add your theme# Select a theme from hexo themes library . You can also use hexo-new-vno if you like the theme of my blog ðŸ˜‰. Then use the commond to add the theme file to your hexo source file you have already created. 12cd hexo_sourcegit clone https://github.com/monniya/hexo-theme-new-vno themes/new-vno You will see the new-vno file at ...\hexo_source\themes\new-vno if not wrong. In fact, hexo has a built-in theme landscape. Open ...\hexo_source\ _config.yml (you can use editors like atom, sublime etc.) and revise some arguments. 1234567891011121314151617181920title: å°ç¦¾ã®æ–°ä¸–ç•Œsubtitle: STAY HUNGRY, STAY FOOLISH!description: (ï½žï¿£â–½ï¿£)ï½ž å—¨ (âœ¿â—'â—¡'â—)keywords:author: #your name as authorlanguage: zh-Hans timezone: email: #your email addressurl: https://your_user_name.github.ioroot: /your_user_name.github.io/plugins: hexo-generate-feed # you need input "npm install hexo-generate-feed" in the git bash window to install this plugin.theme: new-vnodeploy: type: git repo: https://github.com/your_user_name/your_user_name.github.io.git branch: master More details of configuration click here. And revise arguments in ...\hexo_source\themes\new-vno\ _config.yml to configure the theme. 12345678910111213menu: å½’æ¡£: /archivesrss: /atom.xmldescription: RSSsocial: weibo: #your weibo address github: #your github address stack_overflow: facebook: twitter: google_plus: To write a blog, you just write a markdown file in .../hexo_source/source/ _posts folder. 1234567---title: How to Create a Personal Blogdate: 2018-05-22 21:37:37tags: hexo---My first blog post ...## The Structure of The Blog 2.4 deploy the source file to the github repository# Install the deploy tool. 1npm install hexo-deployer-git --save Start to deploy. 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d After the deploy you can visit your blog by typing &quot;your_user_name.github.io&quot; in the browser. You have already built the blog. Congratulations!]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
