<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>米琴香光</title>
  <icon>https://www.gravatar.com/avatar/0ada4b51ad3a273705846d0117a03f4f</icon>
  <subtitle>Some Notes</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hejtao.netlify.com/"/>
  <updated>2021-01-06T08:40:32.743Z</updated>
  <id>https://hejtao.netlify.com/</id>
  
  <author>
    <name>Jiang-Tao He</name>
    <email>hejtao@outlook.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>宝藏男孩</title>
    <link href="https://hejtao.netlify.com/2020/12/16/2020-12-16/"/>
    <id>https://hejtao.netlify.com/2020/12/16/2020-12-16/</id>
    <published>2020-12-15T16:00:00.000Z</published>
    <updated>2021-01-06T08:40:32.743Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><meta name="referrer" content="no-referrer"></p><p></p><p>今天是宝藏男孩的生日😺我写了一首小诗。其中“花园踢树”非我原创却是我最喜欢的一句😍🤞</p><br><br><p></p><div><p align="center"><font face="STFangsong" color="#4F4F4F" size="6">花园踢树，</font></p><p align="center"><font face="STFangsong" color="#4F4F4F" size="6">船头话愫。</font></p><p align="center"><font face="STFangsong" color="#4F4F4F" size="6">宝藏男孩，</font></p><p align="center"><font face="STFangsong" color="#4F4F4F" size="6">细作云图。</font></p></div><br><div><img src="/images/203.jpg" width="60%" align="center"><br><img src="/images/204.jpg" width="60%" align="center"></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="小文艺" scheme="https://hejtao.netlify.com/tags/%E5%B0%8F%E6%96%87%E8%89%BA/"/>
    
  </entry>
  
  <entry>
    <title>Vim Notes</title>
    <link href="https://hejtao.netlify.com/2020/10/22/2020-10-22/"/>
    <id>https://hejtao.netlify.com/2020/10/22/2020-10-22/</id>
    <published>2020-10-21T16:00:00.000Z</published>
    <updated>2020-11-11T03:02:58.018Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><meta name="referrer" content="no-referrer"></p><div class="toc"><!-- toc --><ul><li><a href="#ji-ben-ming-ling">基本命令</a></li><li><a href="#cha-ru-mo-shi">插入模式</a></li><li><a href="#yi-dong-guang-biao">移动光标</a></li><li><a href="#kao-bei-nian-tie">拷贝/粘贴</a></li><li><a href="#che-xiao-chong-zuo">撤销/重做</a></li><li><a href="#da-kai-bao-cun-tui-chu-gai-bian-wen-jian-buffer">打开/保存/退出/改变文件(Buffer)</a></li><li><a href="#ji-qiao">技巧</a></li></ul><!-- tocstop --></div><h3><span id="ji-ben-ming-ling">基本命令</span><a href="#ji-ben-ming-ling" class="header-anchor">#</a></h3><ul><li><code>i</code> 进入 Insert 模式</li><li><code>x</code> 删除当前光标所在的字符</li><li><code>:w</code> 存盘(后面可以跟文件名)</li><li><code>:q</code> 退出</li><li><code>:wq</code> 存盘并退出</li><li><code>dd</code> 删除当前行，并存到剪贴板里</li><li><code>p</code> 粘贴剪贴板</li><li><code>:help &lt;command&gt;</code> 要 :q 退出帮助</li></ul><p>如何浏览帮助呢？请牢记如下秘籍：</p><ul><li>移动: 使用光标键，或者用 h 向左，j 向下，k 向上，l 向右。</li><li>退出: 使用 :q<enter>。</enter></li><li>跳转到一个主题: 将光标置于标签 (例如 usr_01.txt) 上然后输入 CTRL-]。</li><li>跳回: 键入 CTRL-T。</li><li>翻页：键入 CTRL-F/B</li></ul><h3><span id="cha-ru-mo-shi">插入模式</span><a href="#cha-ru-mo-shi" class="header-anchor">#</a></h3><ul><li><code>a</code> 在光标后插入</li><li><code>o</code> 在当前行后插入一个新行</li><li><code>O</code> 在当前行前插入一个新行</li><li><code>cw</code> 替换从光标所在位置后到一个单词结尾的字符</li></ul><h3><span id="yi-dong-guang-biao">移动光标</span><a href="#yi-dong-guang-biao" class="header-anchor">#</a></h3><ul><li><code>0</code> 数字零，到行头</li><li><code>^</code> 到本行第一个不是blank字符的位置</li><li><code>$</code> 到本行行尾</li><li><code>g_</code> 到本行最后一个不是blank字符的位置。</li><li><code>/pattern</code> 搜索 pattern 的字符串(按n到下一个)</li><li><code>w b</code> 词移动</li></ul><h3><span id="kao-bei-nian-tie">拷贝/粘贴</span><a href="#kao-bei-nian-tie" class="header-anchor">#</a></h3><ul><li><code>p</code> 在当前位置之后粘贴</li><li><code>P</code> 在当前位置之前粘贴</li><li><code>yy</code> 拷贝当前行，相当于 ddP</li></ul><h3><span id="che-xiao-chong-zuo">撤销/重做</span><a href="#che-xiao-chong-zuo" class="header-anchor">#</a></h3><ul><li><code>u</code> undo</li><li><code>&lt;C-r&gt;</code> redo</li></ul><h3><span id="da-kai-bao-cun-tui-chu-gai-bian-wen-jian-buffer">打开/保存/退出/改变文件(Buffer)</span><a href="#da-kai-bao-cun-tui-chu-gai-bian-wen-jian-buffer" class="header-anchor">#</a></h3><ul><li><code>:e &lt;path/to/file&gt;</code> 打开一个文件</li><li><code>:w</code> 存盘</li><li><code>:saveas &lt;path/to/file&gt;</code> 另存为 <code>&lt;path/to/file&gt;</code></li><li><code>:x</code>, <code>ZZ</code> 或 <code>:wq</code> 保存并退出</li><li><code>:q!</code> 退出不保存</li><li><code>:qa!</code> 强行退出所有文件。</li><li><code>:bn</code> 和 <code>:bp</code> 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。</li></ul><h3><span id="ji-qiao">技巧</span><a href="#ji-qiao" class="header-anchor">#</a></h3><ol><li>打开 Vim之后，可以用 <code>:split filename</code>或 <code>:vsplit filename</code> 或 <code>new filename</code> 横向或纵向切割窗口，使用 <code>ctrl + w</code> 可以在个窗口之间跳转，使用 <code>ctrl + 方向键</code> 可以按照方向切换窗口。</li><li>用 Vim 打开一个文件，如果我们想实现所有文本行翻转，那么可以执行如下命令：<code>:g/^/m 0</code></li><li>在 Vim 中统计文本行数和当前光标的位置，可以使用 <code>ctrl + g</code>，统计字节数，可以使用 <code>g + ctrl + g</code></li><li>对文本进行简单排序：用 <code>shift v</code> 选中多行文本，输入 <code>:!sort</code>，看看效果如何</li><li>如果你想把当前目录下（包括子文件夹）所有后缀为 java 的文件中的 apache 替换成 eclipse，那么依次执行如下命令： 在当前目录下执行：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim</span><br><span class="line">:n **/*.java</span><br><span class="line">:argdo %s/apache/eclipse/ge | update</span><br></pre></td></tr></table></figure><p>gg 首行<br>G 末行<br>$ 行末<br>^ 行首</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="vim" scheme="https://hejtao.netlify.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Docker Notes</title>
    <link href="https://hejtao.netlify.com/2020/10/01/2020-10-01/"/>
    <id>https://hejtao.netlify.com/2020/10/01/2020-10-01/</id>
    <published>2020-09-30T16:00:00.000Z</published>
    <updated>2020-12-29T13:36:11.381Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><meta name="referrer" content="no-referrer"></p><div class="toc"><!-- toc --><ul><li><a href="#an-zhuang-mysql">安装Mysql</a></li><li><a href="#an-zhuang-redis">安装Redis</a></li><li><a href="#an-zhuang-nginx">安装Nginx</a></li><li><a href="#an-zhuang-yapi">安装Yapi</a></li><li><a href="#chang-yong-ming-ling">常用命令</a></li><li><a href="#go-fu-wu-bu-shu">Go服务部署</a><ul><li><a href="#using-an-official-image">Using an Official Image</a><ul><li><a href="#bian-xie-dockerfile">编写Dockerfile</a></li><li><a href="#bian-xie-dock-var-wen-jian-ji-lu-jing-xiang-de-ban-ben-can-shu">编写dock.var文件记录镜像的版本参数</a></li><li><a href="#bian-xie-shell-zhi-xing-wen-jian-dockploy-sh">编写shell执行文件dockploy.sh</a></li></ul></li><li><a href="#using-the-scratch-image">Using the Scratch Image</a><ul><li><a href="#chuang-jian-yi-lai-jing-xiang-my-alpine">创建依赖镜像my-alpine</a></li><li><a href="#bian-xie-dockerfile-wen-jian">编写Dockerfile文件</a></li><li><a href="#bian-xie-dock-var-wen-jian-ji-lu-jing-xiang-de-ban-ben-can-shu-1">编写dock.var文件记录镜像的版本参数</a></li><li><a href="#bian-xie-shell-zhi-xing-wen-jian-dockploy-sh-1">编写shell执行文件dockploy.sh</a></li></ul></li></ul></li></ul><!-- tocstop --></div><h3><span id="an-zhuang-mysql">安装Mysql</span><a href="#an-zhuang-mysql" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql mysq</span><br></pre></td></tr></table></figure><h3><span id="an-zhuang-redis">安装Redis</span><a href="#an-zhuang-redis" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 6379:6379 --name redis redis</span><br></pre></td></tr></table></figure><h3><span id="an-zhuang-nginx">安装Nginx</span><a href="#an-zhuang-nginx" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx nginx</span><br></pre></td></tr></table></figure><h3><span id="an-zhuang-yapi">安装Yapi</span><a href="#an-zhuang-yapi" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name mongo-yapi mongo</span><br><span class="line">docker pull hejtao/yapi</span><br><span class="line">docker run -d \</span><br><span class="line">  --name yapi \</span><br><span class="line">  --link mongo-yapi:mongo \</span><br><span class="line">  --workdir /api/vendors \</span><br><span class="line">  -p 3000:3000 \</span><br><span class="line">  hejtao/yapi \</span><br><span class="line">  server/app.js</span><br></pre></td></tr></table></figure><h3><span id="chang-yong-ming-ling">常用命令</span><a href="#chang-yong-ming-ling" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">docker search redis</span><br><span class="line">docker pull redis</span><br><span class="line"></span><br><span class="line">docker ps -aq</span><br><span class="line">docker ps -af status=exited  (created|restarting|running|removing|paused|exited|dead)</span><br><span class="line">docker ps -a --format <span class="string">"table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Names&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;"</span>  </span><br><span class="line"></span><br><span class="line">docker start $(docker ps -aqf status=exited)</span><br><span class="line">docker ps -aqf status=exited | xargs docker start</span><br><span class="line">docker stop redis</span><br><span class="line"></span><br><span class="line">docker rm redis</span><br><span class="line"></span><br><span class="line">docker logs redis</span><br><span class="line">docker logs --tail 8 redis</span><br><span class="line">docker logs --since 3s redis</span><br><span class="line">docker port redis</span><br><span class="line"></span><br><span class="line">docker run -it nginx bash</span><br><span class="line">docker run -it --rm linkd:v8 sh</span><br><span class="line">docker <span class="built_in">exec</span> -it nginx bash</span><br><span class="line">docker <span class="built_in">exec</span> -it ee7f1c1c8a49 sh</span><br><span class="line">docker <span class="built_in">exec</span> -it ee7f1c1c8a49 /bin/sh</span><br><span class="line"></span><br><span class="line">docker image tag registry.cn-hangzhou.aliyuncs.com/anoy/yapi ali/anoy/yapi</span><br><span class="line">docker rmi registry.cn-hangzhou.aliyuncs.com/anoy/yapi</span><br><span class="line"></span><br><span class="line">docker inspect mysql | grep -i ipaddress</span><br></pre></td></tr></table></figure><h3><span id="go-fu-wu-bu-shu">Go服务部署</span><a href="#go-fu-wu-bu-shu" class="header-anchor">#</a></h3><h4><span id="using-an-official-image">Using an Official Image</span><a href="#using-an-official-image" class="header-anchor">#</a></h4><h5><span id="bian-xie-dockerfile">编写Dockerfile</span><a href="#bian-xie-dockerfile" class="header-anchor">#</a></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:alpine</span><br><span class="line"></span><br><span class="line">ENV CGO_ENABLED=0</span><br><span class="line">ENV GO111MODULE=on</span><br><span class="line">ENV GOPROXY=https://goproxy.cn</span><br><span class="line"></span><br><span class="line">WORKDIR /root/go/src/app</span><br><span class="line">COPY . .</span><br><span class="line">EXPOSE 6666</span><br><span class="line"></span><br><span class="line">RUN go build -o app</span><br><span class="line"></span><br><span class="line">CMD [<span class="string">"./app"</span>]</span><br></pre></td></tr></table></figure><h5><span id="bian-xie-dock-var-wen-jian-ji-lu-jing-xiang-de-ban-ben-can-shu">编写dock.var文件记录镜像的版本参数</span><a href="#bian-xie-dock-var-wen-jian-ji-lu-jing-xiang-de-ban-ben-can-shu" class="header-anchor">#</a></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> IMA_TAG_NUM=4</span><br></pre></td></tr></table></figure><h5><span id="bian-xie-shell-zhi-xing-wen-jian-dockploy-sh">编写shell执行文件dockploy.sh</span><a href="#bian-xie-shell-zhi-xing-wen-jian-dockploy-sh" class="header-anchor">#</a></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> dock.var</span><br><span class="line"></span><br><span class="line">docker build -t app_img:v$((IMA_TAG_NUM)) .</span><br><span class="line">docker stop app</span><br><span class="line">docker rm app</span><br><span class="line">docker run --name app -p 8780:8780 -d app_img:v$((IMA_TAG_NUM))</span><br><span class="line">docker rmi app_img:v$((IMA_TAG_NUM-1))</span><br><span class="line"></span><br><span class="line">IMA_TAG_NUM=$((IMA_TAG_NUM+1))</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">export</span> IMA_TAG_NUM=<span class="variable">$&#123;IMA_TAG_NUM&#125;</span>&gt;dock.var</span><br></pre></td></tr></table></figure><h4><span id="using-the-scratch-image">Using the Scratch Image</span><a href="#using-the-scratch-image" class="header-anchor">#</a></h4><h5><span id="chuang-jian-yi-lai-jing-xiang-my-alpine">创建依赖镜像my-alpine</span><a href="#chuang-jian-yi-lai-jing-xiang-my-alpine" class="header-anchor">#</a></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine</span><br><span class="line"></span><br><span class="line">RUN apk update</span><br><span class="line">RUN apk --no-cache add tzdata zip ca-certificates   <span class="comment">#安装Go二进制程序的时区、tls认证等依赖组件</span></span><br><span class="line"></span><br><span class="line">WORKDIR /usr/share/zoneinfo</span><br><span class="line">RUN zip -q -r -0 /zoneinfo.zip .</span><br></pre></td></tr></table></figure><p>执行如下命令创建my-alpine镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-alpine .</span><br></pre></td></tr></table></figure></p><h5><span id="bian-xie-dockerfile-wen-jian">编写Dockerfile文件</span><a href="#bian-xie-dockerfile-wen-jian" class="header-anchor">#</a></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM my-alpine</span><br><span class="line">WORKDIR /root/go/src/app</span><br><span class="line">RUN mkdir ./static                  <span class="comment">#项目导出功能临时excel文件的存放目录</span></span><br><span class="line">COPY ./conf ./conf                  <span class="comment">#beego的配置文件</span></span><br><span class="line">COPY ./.env .                       <span class="comment">#项目的环境参数</span></span><br><span class="line">COPY ./app .                        <span class="comment">#编译的Go二进制文件</span></span><br><span class="line">EXPOSE 6666</span><br><span class="line">ENTRYPOINT [<span class="string">"./app"</span>]</span><br></pre></td></tr></table></figure><p>使用scratch镜像（本质上是个空的镜像）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ENV ZONEINFO /zoneinfo.zip</span><br><span class="line"><span class="comment">#the timezone data:</span></span><br><span class="line">COPY --from=my-alpine /zoneinfo.zip /</span><br><span class="line"><span class="comment">#the tls certificates:</span></span><br><span class="line">COPY --from=my-alpine /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/</span><br><span class="line"></span><br><span class="line">WORKDIR /root/go/src/app</span><br><span class="line">COPY ./static ./static         <span class="comment">#scratch镜像没有shell，不能使用“RUN mkdir ./static” </span></span><br><span class="line">COPY ./conf ./conf</span><br><span class="line">COPY ./.env .</span><br><span class="line">COPY ./app .</span><br><span class="line">EXPOSE 6666</span><br><span class="line">ENTRYPOINT [<span class="string">"./app"</span>]</span><br></pre></td></tr></table></figure><h5><span id="bian-xie-dock-var-wen-jian-ji-lu-jing-xiang-de-ban-ben-can-shu">编写dock.var文件记录镜像的版本参数</span><a href="#bian-xie-dock-var-wen-jian-ji-lu-jing-xiang-de-ban-ben-can-shu" class="header-anchor">#</a></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> IMA_TAG_NUM=1</span><br></pre></td></tr></table></figure><h5><span id="bian-xie-shell-zhi-xing-wen-jian-dockploy-sh">编写shell执行文件dockploy.sh</span><a href="#bian-xie-shell-zhi-xing-wen-jian-dockploy-sh" class="header-anchor">#</a></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rm app</span><br><span class="line">CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app</span><br><span class="line"><span class="built_in">source</span> dock.var</span><br><span class="line">docker build -t app:v$((IMA_TAG_NUM)) .</span><br><span class="line">docker stop app</span><br><span class="line">docker rm app</span><br><span class="line">docker run --name app -p 6666:6666 -d app:v$((IMA_TAG_NUM))</span><br><span class="line">docker rmi app:v$((IMA_TAG_NUM-1))</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">export</span> IMA_TAG_NUM=$((IMA_TAG_NUM+1))&gt;dock.var</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="docker" scheme="https://hejtao.netlify.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Labs in Action</title>
    <link href="https://hejtao.netlify.com/2020/08/03/2020-8-3/"/>
    <id>https://hejtao.netlify.com/2020/08/03/2020-8-3/</id>
    <published>2020-08-02T16:00:00.000Z</published>
    <updated>2020-08-06T15:18:15.221Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><meta name="referrer" content="no-referrer"></p><div class="toc"><!-- toc --><ul><li><a href="#xiang-guan-lian-jie">相关链接</a></li><li><a href="#data-lab">Data Lab</a></li></ul><!-- tocstop --></div><h3><span id="xiang-guan-lian-jie">相关链接</span><a href="#xiang-guan-lian-jie" class="header-anchor">#</a></h3><p><a href="https://www.cs.cmu.edu/~213/schedule.html" target="_blank" rel="noopener">Introduction to Computer Systems</a><br><a href="http://csapp.cs.cmu.edu/3e/labs.html" target="_blank" rel="noopener">Lab Assignments</a></p><h3><span id="data-lab">Data Lab</span><a href="#data-lab" class="header-anchor">#</a></h3><p>先看README<br>使用下面的命令来检验结果</p><blockquote><p>./dlc bits.c<br>./dlc -e bits.c<br>./btest  (执行这个命令前需要 make btest, apt install libc6-dev-i386)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://hejtao.netlify.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Garageband</title>
    <link href="https://hejtao.netlify.com/2020/07/19/2020-7-19/"/>
    <id>https://hejtao.netlify.com/2020/07/19/2020-7-19/</id>
    <published>2020-07-18T16:00:00.000Z</published>
    <updated>2020-12-16T15:25:48.989Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><meta name="referrer" content="no-referrer"></p><div class="toc"><!-- toc --><ul><li><a href="#jian-ting-er-ji-tui-jian">监听耳机推荐</a></li></ul><!-- tocstop --></div><h4><span id="jian-ting-er-ji-tui-jian">监听耳机推荐</span><a href="#jian-ting-er-ji-tui-jian" class="header-anchor">#</a></h4><p>ATH M30X<br>SONY MDR 7506<br>Status Audio CB-1<br>AKG K550</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="music" scheme="https://hejtao.netlify.com/tags/music/"/>
    
      <category term="garageband" scheme="https://hejtao.netlify.com/tags/garageband/"/>
    
  </entry>
  
  <entry>
    <title>Nginx Notes</title>
    <link href="https://hejtao.netlify.com/2020/03/22/2020-3-22/"/>
    <id>https://hejtao.netlify.com/2020/03/22/2020-3-22/</id>
    <published>2020-03-21T16:00:00.000Z</published>
    <updated>2020-03-22T23:29:31.064Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><meta name="referrer" content="no-referrer"></p><div class="toc"><!-- toc --><ul><li><a href="#qi-dong-ting-zhi-he-chong-qi">启动、停止和重启</a></li></ul><!-- tocstop --></div><h4><span id="qi-dong-ting-zhi-he-chong-qi">启动、停止和重启</span><a href="#qi-dong-ting-zhi-he-chong-qi" class="header-anchor">#</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br><span class="line">systemctl start nginx.service</span><br><span class="line">systemctl start nginx</span><br><span class="line">ps aux | grep nginx</span><br><span class="line"></span><br><span class="line">ngxin -s quit</span><br><span class="line">nginx -s stop</span><br><span class="line">killall nginx</span><br><span class="line">systemctl stop nginx.service</span><br><span class="line">systemctl stop nginx</span><br><span class="line"></span><br><span class="line">nginx -s reload</span><br><span class="line">systemctl restart nginx.service</span><br><span class="line">systemctl restart nginx</span><br><span class="line"></span><br><span class="line">netstat -tlnp</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="nginx" scheme="https://hejtao.netlify.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Flutter Notes</title>
    <link href="https://hejtao.netlify.com/2019/12/28/2019-12-28/"/>
    <id>https://hejtao.netlify.com/2019/12/28/2019-12-28/</id>
    <published>2019-12-27T16:00:00.000Z</published>
    <updated>2020-03-22T23:27:37.381Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><meta name="referrer" content="no-referrer"></p><div class="toc"><!-- toc --><ul><li><a href="#fascinating-flutter-pages">Fascinating Flutter Pages</a><ul><li><a href="#dynamical-disco">Dynamical Disco</a></li></ul></li><li><a href="#notes">Notes</a></li></ul><!-- tocstop --></div><h3><span id="fascinating-flutter-pages">Fascinating Flutter Pages</span><a href="#fascinating-flutter-pages" class="header-anchor">#</a></h3><h4><span id="dynamical-disco">Dynamical Disco</span><a href="#dynamical-disco" class="header-anchor">#</a></h4><p><img src="/images/44.gif" alt=""></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiscData</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> _rng = Random();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> size;</span><br><span class="line">  Color color;</span><br><span class="line">  Alignment alignment;</span><br><span class="line"></span><br><span class="line">  DiscData() &#123;</span><br><span class="line">    color = Color.fromARGB(</span><br><span class="line">      _rng.nextInt(<span class="number">200</span>),</span><br><span class="line">      _rng.nextInt(<span class="number">255</span>),</span><br><span class="line">      _rng.nextInt(<span class="number">255</span>),</span><br><span class="line">      _rng.nextInt(<span class="number">255</span>),</span><br><span class="line">    );</span><br><span class="line">    size = _rng.nextDouble() * <span class="number">40</span> + <span class="number">10</span>;</span><br><span class="line">    alignment = Alignment(</span><br><span class="line">      _rng.nextDouble() * <span class="number">2</span> - <span class="number">1</span>,</span><br><span class="line">      _rng.nextDouble() * <span class="number">2</span> - <span class="number">1</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  runApp(</span><br><span class="line">    MaterialApp(</span><br><span class="line">      debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        body: Container(</span><br><span class="line">          color: Color(<span class="number">0xFF15202D</span>),</span><br><span class="line">          child: SizedBox.expand(</span><br><span class="line">            child: VariousDiscs(<span class="number">50</span>),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariousDiscs</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> numberOfDiscs;</span><br><span class="line"></span><br><span class="line">  VariousDiscs(<span class="keyword">this</span>.numberOfDiscs);</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _VariousDiscsState createState() =&gt; _VariousDiscsState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_VariousDiscsState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">VariousDiscs</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _discs = &lt;DiscData&gt;[];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _makeDiscs();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _makeDiscs() &#123;</span><br><span class="line">    _discs.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; widget.numberOfDiscs; i++) &#123;</span><br><span class="line">      _discs.add(DiscData());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">      onTap: () =&gt; setState(() &#123;</span><br><span class="line">        _makeDiscs();</span><br><span class="line">    &#125;),</span><br><span class="line">      child: Stack(</span><br><span class="line">        children: [</span><br><span class="line">          Center(</span><br><span class="line">            child: Text(</span><br><span class="line">              <span class="string">'DISCO FACE'</span>,</span><br><span class="line">              style: TextStyle(color: Colors.white, fontSize: <span class="number">50</span>),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">final</span> disc <span class="keyword">in</span> _discs)</span><br><span class="line">            Positioned.fill(</span><br><span class="line">              child: AnimatedAlign(</span><br><span class="line">                duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>),</span><br><span class="line">                curve: Curves.easeInOut,</span><br><span class="line">                alignment: disc.alignment,</span><br><span class="line">                child: AnimatedContainer(</span><br><span class="line">                  duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>),</span><br><span class="line">                  decoration: BoxDecoration(</span><br><span class="line">                    color: disc.color,</span><br><span class="line">                    shape: BoxShape.circle,</span><br><span class="line">                  ),</span><br><span class="line">                  height: disc.size,</span><br><span class="line">                  width: disc.size,</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">    ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="notes">Notes</span><a href="#notes" class="header-anchor">#</a></h3><ol><li><p>组建调试   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">  Widget build(BuildContext context) &#123;    </span><br><span class="line">    debugPaintSizeEnabled = true;   </span><br><span class="line">    return Container();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ListView 支持 app body 的滚动, Column + SingleChildScrollView   </p></li></ol><p>3.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Flutter" scheme="https://hejtao.netlify.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Linux Notes</title>
    <link href="https://hejtao.netlify.com/2019/12/01/2019-12-1/"/>
    <id>https://hejtao.netlify.com/2019/12/01/2019-12-1/</id>
    <published>2019-11-30T16:00:00.000Z</published>
    <updated>2019-12-21T08:27:38.240Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><meta name="referrer" content="no-referrer"></p><div class="toc"><!-- toc --><ul><li><a href="#linux">linux</a><ul><li><a href="#wen-jian-yi-dong-fu-zhi">文件移动、复制</a></li><li><a href="#wen-jian-quan-xian">文件权限</a></li><li><a href="#linux-cha-zhao-ming-ling">Linux查找命令</a></li><li><a href="#qi-ta">其它</a></li></ul></li><li><a href="#vim">vim</a></li></ul><!-- tocstop --></div><h3><span id="linux">linux</span><a href="#linux" class="header-anchor">#</a></h3><h4><span id="wen-jian-yi-dong-fu-zhi">文件移动、复制</span><a href="#wen-jian-yi-dong-fu-zhi" class="header-anchor">#</a></h4><p><code>mv a b</code>：重命名<br><code>mv /home/music/往后余生.mp3 /home/loved_music/</code> ： 把往后余生剪切（移动）到 loved_music下<br><code>cp -a /home/jiangtao/* /home/huaxi</code> ： 复制jiangtao下的所有文件到huaxi下<br><code>cp -a /home/jiangtao /home/huaxi</code> ：文件夹拷贝，得到 <code>/home/huaxi/jiangtao</code><br><code>rm -rf /home/jiangtao/*</code> ： 删除jiangtao下的所有内容。<code>-r</code>不管有多少级目录，一并删除；<code>-f</code> 强行删除，不作任何提示<br><code>rm -rf /home/jiangtao</code> ：删除jiangtao目录<br><code>cat textfile</code>：显示内容<br><code>cat -n textfile1 &gt; textfile2</code>：把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里<br><code>cat -b textfile1 textfile2 &gt;&gt; textfile3</code>：把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到textfile3 文档里   </p><h4><span id="wen-jian-quan-xian">文件权限</span><a href="#wen-jian-quan-xian" class="header-anchor">#</a></h4><p><code>chown</code> (change ownership)将指定文件的拥有者改为指定的用户或组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;sudo chown -R $(whoami) /usr/local/Cellar</span><br><span class="line">&gt;sudo chown root:hejtao file.txt</span><br><span class="line">&gt;sudo chown hejtao:hejao file.txt</span><br></pre></td></tr></table></figure></p><p><code>-R</code>: 处理指定目录以及其子目录下的所有文件<br><code>chmod abc file</code><br>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限<br>r=4(可读)，w=2(可写)，x=1(可读写)<br>若要rwx属性则4+2+1=7；<br>若要rw-属性则4+2=6；<br>若要r-x属性则4+1=5。<br><code>chmod 765 file.txt</code> 等价于 <code>chmod u=rwx,g=rw,o=rx file.txt</code></p><h4><span id="linux-cha-zhao-ming-ling">Linux查找命令</span><a href="#linux-cha-zhao-ming-ling" class="header-anchor">#</a></h4><p><code>find . -type f -mmin -10</code> 搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录<br><code>find . -name &#39;my*&#39; -ls</code> 搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息<br><code>find . -type f -iname &quot;*.php&quot;</code><br><code>find . -size -1M</code> 小于1M的文件<br><code>find . -type d -not -iname &quot;*php&quot;</code> 找不以php结尾的目录<br><code>find . -maxdepth 1 -type f -iname &quot;*.conf&quot;</code> 当前和下一级目录<br><code>find . -type f -iname &quot;*.php&quot; -exec grep &quot;function&quot; {} +</code><br><code>locate -i hello.txt</code> 查找文件位置，<code>-i</code> 选项忽略大小写<br><code>locate ~/m</code> 搜索用户主目录下，所有以m开头的文件   </p><h4><span id="qi-ta">其它</span><a href="#qi-ta" class="header-anchor">#</a></h4><p><code>echo</code> 显示字符串，转义字符，变量；内容定向至文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;echo hello, world! &gt; hello   先清空在写入</span><br><span class="line">&gt;cat hello</span><br><span class="line">hello, world!</span><br><span class="line"></span><br><span class="line">&gt;echo hello, world! &gt;&gt; hello    换行后写入</span><br></pre></td></tr></table></figure></p><p><code>grep ipfs . -r -n</code> 在当前目录的多级文件进行（-r）递归搜索，并（-n）显示行号<br><code>grep -i -n &quot;function&quot; ./*</code><br><code>ps -ax | grep ipfs</code> : 显示系统中当前运行的包含 ipfs 的进程 </p><p>&nbsp;<br>一行输入多个命令,使用<code>;</code> 、<code>&amp;</code> 、<code>|</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;echo i am hejtao\n ; echo hello hejtao</span><br><span class="line">i am hejtao</span><br><span class="line"></span><br><span class="line">hello hejtao</span><br></pre></td></tr></table></figure></p><p>&nbsp;<br><code>ifconfig</code>: 查看和配置网络设备<br><code>mkdir</code><br><code>rmdir</code><br><code>touch new.txt</code>新建文件<br><code>man</code>查询命令的信息 </p><p>&nbsp;<br>停止命令 <code>Ctrl + c</code><br>强制停止命令 <code>Ctrl + z</code><br>清空窗口 <code>clear</code><br>自动联想<code>TAB</code><br>关闭<code>sudo halt</code><br>重启 <code>sudo reboot</code>.  </p><p>&nbsp;<br><code>ssh root@207.148.109.110</code><br><code>mosh root@207.148.109.110</code><br><code>scp ./Go语言编程_许式伟.pdf root@207.148.109.110:~/my_files</code> 本地上传到vps   </p><p>&nbsp;<br>清屏 <code>clear</code><br>屏幕翻页 <code>ctrl l</code><br><code>ls</code> <code>-l</code> (long)  <code>-r</code>(reverse)  <code>-s</code>(size)<br><code>ls &gt; outfile.txt</code> 结果写入outfile.txt<br><code>ls | tee outfile2.txt</code> 显示结果，并将结果写入outfile2.txt<br><code>apt-cache</code>   </p><p>&nbsp;<br>断开ssh：<code>ctrl d</code>   </p><h3><span id="vim">vim</span><a href="#vim" class="header-anchor">#</a></h3><p>保存退出：<code>shift zz</code><br>不保存退出：<code>shift zq</code><br>删除本行： <code>dd</code><br>复制本行：<code>yy</code><br>行标下粘贴：<code>p</code> 行标上粘贴：<code>P</code><br><code>u</code>   撤销上一步的操作,输入<code>u</code>两次，你的文本恢复原样<br><code>Ctrl+r</code> 恢复上一步被撤销的操作<br><code>ggVG</code> 全选 , 选中内容以后就可以<code>d</code>  删除选中内容 , <code>y</code>  复制选中内容到0号寄存器<br><code>gg</code> 让光标移到首行，在vim才有效，vi中无效<br><code>V</code>  是进入Visual(可视）模式<br><code>G</code>  光标移到最后一行<br><img src="/images/42.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://hejtao.netlify.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数学通识50讲</title>
    <link href="https://hejtao.netlify.com/2019/11/25/2019-11-25/"/>
    <id>https://hejtao.netlify.com/2019/11/25/2019-11-25/</id>
    <published>2019-11-24T16:00:00.000Z</published>
    <updated>2020-12-16T15:25:15.724Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><p><img src="/images/26.jpg" alt=""></p><div class="toc"><!-- toc --><ul><li><a href="#fa-kan-ci-shu-xue-gai-zen-me-xue">发刊词：数学该怎么学？</a><ul><li><a href="#mo-kuai-yi-shu-xue-de-xian-suo">模块一 ｜ 数学的线索</a></li></ul></li><li><a href="#01-dao-lun-shu-xue-tong-shi-ke-de-ti-xi-he-xue-xi-gong-lue">01 ｜ 导论：数学通识课的体系和学习攻略</a></li><li><a href="#02-gou-gu-ding-li-wei-shi-me-zai-xi-fang-jiao-bi-da-ge-la-si-ding-li">02 ｜ 勾股定理：为什么在西方叫毕达哥拉斯定理</a></li><li><a href="#03-shu-xue-de-yu-jian-xing-ru-he-yong-tui-li-zou-chu-ren-zhi-mang-qu">03 ｜ 数学的预见性：如何用推理走出认知盲区</a></li><li><a href="#04-shu-xue-si-wei-shu-xue-jia-ru-he-cong-luo-ji-chu-fa-xiang-wen-ti">04 ｜ 数学思维：数学家如何从逻辑出发想问题</a></li><li><a href="#05-shu-xue-bian-jie-cong-bi-da-ge-la-si-ding-li-dao-fei-ma-da-ding-li">05 ｜ 数学边界：从毕达哥拉斯定理到费马大定理</a></li><li><a href="#06-huang-jin-fen-ge-bi-da-ge-la-si-ru-he-lian-jie-shu-xue-he-mei-xue">06 ｜ 黄金分割：毕达哥拉斯如何连接数学和美学</a></li><li><a href="#07-shu-xue-ying-yong-hua-luo-geng-hua-fan-wei-jian-de-shen-lai-zhi-bi">07 ｜ 数学应用：华罗庚化繁为简的神来之笔</a></li><li><a href="#08-shu-lie-he-ji-shu-yi-dang-xia-hen-chong-yao-dan-qu-shi-geng-chong-yao">08 ｜ 数列和级数（一）：当下很重要，但趋势更重要</a></li><li><a href="#09-shu-lie-he-ji-shu-er-chuan-xiao-pian-ju-de-shu-xue-yuan-li">09 ｜ 数列和级数（二）：传销骗局的数学原理</a></li><li><a href="#10-shu-lie-he-ji-shu-san-cang-zai-li-xi-he-yue-gong-li-de-mi-mi">10 ｜ 数列和级数（三）：藏在利息和月供里的秘密</a><ul><li><a href="#mo-kuai-er-shu-xue-de-gai-nian">模块二 ｜ 数学的概念</a></li></ul></li><li><a href="#11-ji-tu-tong-long-fang-cheng-zhe-ge-shu-xue-gong-ju-wei-shi-me-hen-qiang-da">11 ｜ 鸡兔同笼：方程这个数学工具为什么很强大</a></li><li><a href="#12-san-ci-fang-cheng-shu-xue-shi-shang-de-fa-ming-quan-zhi-zheng">12 ｜ 三次方程：数学史上的发明权之争</a></li><li><a href="#13-xu-shu-xu-gou-zhe-ge-gong-ju-you-shi-me-yong">13 ｜ 虚数：虚构这个工具有什么用</a></li><li><a href="#14-wu-qiong-wo-men-wei-shi-me-nan-yi-li-jie-wu-xian-de-shi-jie">14 ｜ 无穷：我们为什么难以理解无限的世界？</a></li><li><a href="#15-wu-qiong-xiao-yi-ru-he-shuo-fu-gang-jing-zhi-nuo">15 ｜ 无穷小（一）：如何说服杠精“芝诺”？</a></li><li><a href="#16-wu-qiong-xiao-er-niu-dun-he-bei-ke-lai-zai-zheng-shi-me">16 ｜ 无穷小（二）：牛顿和贝克莱在争什么？</a></li><li><a href="#17-wu-qiong-xiao-san-yong-dong-tai-he-ji-xian-de-yan-guang-kan-shi-jie">17 ｜ 无穷小（三）：用动态和极限的眼光看世界</a></li><li><a href="#18-you-shi-me-bi-wu-qiong-da-geng-da-bi-wu-qiong-xiao-geng-xiao">18 ｜ 有什么比无穷大更大，比无穷小更小</a></li><li><a href="#19-fu-pan-shu-xue-gei-liao-wo-shi-me-qi-shi">19 ｜ 复盘：数学给了我什么启示？</a><ul><li><a href="#mo-kuai-san-ji-he-xue-yi-qie-yuan-zi-gong-li-he-luo-ji">模块三 ｜ 几何学 一切源自公理和逻辑</a></li></ul></li><li><a href="#20-ji-he-xue-wei-shi-me-shi-shu-xue-zhong-zui-gu-lao-de-fen-zhi">20 ｜ 几何学：为什么是数学中最古老的分支</a></li><li><a href="#21-gong-li-ti-xi-ji-he-de-xi-tong-li-lun-cong-he-er-lai">21 ｜ 公理体系：几何的系统理论从何而来</a></li><li><a href="#22-fei-ou-ji-he-xiang-dui-lun-de-shu-xue-ji-chu-shi-shi-me">22 ｜ 非欧几何：相对论的数学基础是什么</a></li><li><a href="#23-jie-xi-ji-he-yong-dai-shu-fang-fa-jie-jue-geng-nan-de-ji-he-ti">23 ｜ 解析几何：用代数方法解决更难的几何题</a></li><li><a href="#24-wei-shi-me-ji-he-neng-wei-fa-lu-ti-gong-li-lun-ji-chu">24 ｜ 为什么几何能为法律提供理论基础？</a></li><li><a href="#wen-da-shu-xue-de-ji-xian-he-sheng-huo-de-ji-xian-shi-yi-hui-shi-ma">问答 ｜ 数学的“极限”和生活的“极限”是一回事吗？</a><ul><li><a href="#mo-kuai-si-dai-shu-xue-yong-shu-liang-miao-hui-shi-jie">模块四 ｜ 代数学 用数量描绘世界</a></li></ul></li><li><a href="#25-han-shu-shang-cong-jing-tai-dao-dong-tai-cong-ge-ti-dao-qu-shi">25 ｜ 函数（上）：从静态到动态，从个体到趋势</a></li><li><a href="#26-han-shu-xia-ru-he-tong-guo-gong-shi-li-jie-yin-guo-guan-xi">26 ｜ 函数（下）：如何通过公式理解因果关系</a></li><li><a href="#27-xiang-liang-dai-shu-shang-fang-xiang-bi-nu-li-geng-chong-yao-shi-ji-tang-ma">27 ｜ 向量代数（上）：“方向比努力更重要”是鸡汤吗？</a></li><li><a href="#28-xiang-liang-dai-shu-xia-ru-he-tong-guo-xiang-liang-jia-jiao-li-jie-wei-du">28 ｜ 向量代数（下）：如何通过向量夹角理解“维度”？</a></li><li><a href="#29-xian-xing-dai-shu-ju-zhen-dao-di-zen-me-yong">29 ｜ 线性代数：“矩阵”到底怎么用？</a><ul><li><a href="#mo-kuai-wu-wei-ji-fen">模块五 ｜ 微积分</a></li></ul></li><li><a href="#30-wei-fen-shang-ru-he-cong-hong-guan-bian-hua-liao-jie-wei-guan-qu-shi">30 ｜ 微分（上）：如何从宏观变化了解微观趋势</a></li><li><a href="#31-wei-fen-xia-gao-dong-qi-dian-li-jie-lian-xu-xing">31 ｜ 微分（下）：搞懂“奇点”，理解“连续性”</a></li><li><a href="#32-ji-fen-ru-he-cong-wei-guan-qu-shi-liao-jie-hong-guan-bian-hua">32 ｜ 积分：如何从微观趋势了解宏观变化</a></li><li><a href="#33-yong-bian-hua-de-yan-guang-kan-zui-da-zhi-he-zui-xiao-zhi">33 ｜ 用变化的眼光看最大值和最小值</a></li><li><a href="#34-wei-ji-fen-dao-di-shi-shui-fa-ming-de">34 ｜ 微积分到底是谁发明的</a><ul><li><a href="#mo-kuai-liu-gai-lu-tong-ji-bo-yi-lun">模块六 ｜ 概率、统计、博弈论</a></li></ul></li><li><a href="#35-gai-lu-jian-shi-yi-men-lai-zi-du-tu-de-xue-wen">35 ｜ 概率简史：一门来自赌徒的学问</a></li><li><a href="#36-bo-nu-li-shi-yan-dao-di-ru-he-li-jie-sui-ji-xing">36 ｜ 伯努利实验：到底如何理解随机性</a></li><li><a href="#37-bo-song-fen-bu-wei-shi-me-bao-xian-gong-si-de-ke-hu-qun-du-hen-da">37 ｜ 泊松分布：为什么保险公司的客户群都很大？</a></li><li><a href="#zui-xin-jie-du-shu-ju-zi-chan-ni-de-shu-ju-dao-di-shu-yu-shui-you-gai-zen-me-yong">最新解读 ｜ 数据资产：你的数据到底属于谁，又该怎么用？</a></li><li><a href="#38-gao-si-fen-bu-da-gai-lu-shi-jian-yi-wei-zhao-shi-me">38 ｜ 高斯分布：大概率事件意味着什么？</a></li><li><a href="#39-tiao-jian-gai-lu-he-bei-xie-si-gong-shi-ji-qi-fan-yi-shi-ru-he-gong-zuo-de">39 ｜ 条件概率和贝叶斯公式：机器翻译是如何工作的？</a></li><li><a href="#40-gai-lu-gong-li-hua-yi-ge-bi-xu-bu-shang-de-li-lun-lou-dong">40 ｜ 概率公理化：一个必须补上的理论漏洞</a></li><li><a href="#41-tong-ji-xue-he-da-shu-ju-wei-shi-me-da-duo-shu-gong-si-yong-bu-hao-shu-ju">41 ｜ 统计学和大数据：为什么大多数公司用不好数据？</a></li><li><a href="#42-gu-de-tu-ling-zhe-kou-gu-ji-hei-tian-e-shi-jian-ke-yi-fang-fan-ma">42 ｜ 古德-图灵折扣估计：黑天鹅事件可以防范吗？</a></li><li><a href="#43-ling-he-bo-yi-an-dian-li-lun-ru-he-zhao-dao-shuang-fang-de-ping-heng-dian">43 ｜ 零和博弈（鞍点理论）：如何找到双方的平衡点？</a></li><li><a href="#44-fei-ling-he-bo-yi-na-shi-jun-heng-zhen-de-cun-zai-gong-ying-ma">44 ｜ 非零和博弈（纳什均衡）：真的存在共赢吗？</a></li><li><a href="#wen-da-dao-di-ru-he-you-xiao-shai-xuan-shu-ju">问答 ｜ 到底如何有效筛选数据？</a><ul><li><a href="#mo-kuai-qi-shu-xue-de-ji-chu-zuo-yong">模块七 ｜ 数学的基础作用</a></li></ul></li><li><a href="#45-shu-xue-he-zhe-xue-yi-tou-yi-wei-de-liang-men-xue-ke">45 ｜ 数学和哲学：一头一尾的两门学科</a></li><li><a href="#46-shu-xue-yu-zi-ran-ke-xue-shu-xue-ru-he-gai-zao-zi-ran-ke-xue">46 ｜ 数学与自然科学：数学如何改造自然科学？</a></li><li><a href="#47-shu-xue-yu-luo-ji-xue-wei-shi-me-luo-ji-shi-yi-qie-de-ji-chu">47 ｜ 数学与逻辑学：为什么逻辑是一切的基础？</a></li><li><a href="#48-shu-xue-yu-qi-ta-ke-xue-wei-shi-me-shu-xue-shi-geng-di-ceng-de-gong-ju">48 ｜ 数学与其它科学：为什么数学是更底层的工具？</a></li><li><a href="#49-jia-luo-wa-he-gu-dian-shu-xue-nan-ti-nan-ti-gei-wo-men-de-qi-fa">49 ｜ 伽罗瓦和古典数学难题：难题给我们的启发</a></li><li><a href="#50-dang-jin-de-qi-da-shu-xue-qian-xi-nan-ti">50 ｜ 当今的七大数学千禧难题</a><ul><li><a href="#shu-xue-jie-ke-zhi-shi-kai-shi-tong-shi-ke-xi-lie-di-yi-men-wan-zheng-shang-xian">数学结课 ｜ 只是开始：通识课系列第一门，完整上线</a></li><li><a href="#ke-wai-yue-du-zhu-ming-shu-xue-jia-xi-er-bo-te-tui-xiu-qian-de-yan-jiang">课外阅读 ｜ 著名数学家希尔伯特退休前的演讲</a></li><li><a href="#re-dian-jie-du-tuo-yuan-qu-xian-jia-mi-bi-te-bi-jia-mi-de-shu-xue-ji-chu">热点解读 ｜ 椭圆曲线加密：比特币加密的数学基础</a></li><li><a href="#xin-shu-tui-jian-gu-ge-qian-ceo-shi-mi-te-de-guan-li-jing-sui">新书推荐 ｜ 谷歌前CEO施密特的管理精髓</a></li><li><a href="#yuan-dan-cai-dan-2020-tan-sha-shi-bi-ya-bu-xiu-de-xi-ju-jiao-se-fu-si-ta-fu">元旦彩蛋 ｜ 2020谈莎士比亚：不朽的喜剧角色福斯塔夫</a></li></ul></li></ul><!-- tocstop --></div><h3><span id="fa-kan-ci-shu-xue-gai-zen-me-xue">发刊词：数学该怎么学？</span><a href="#fa-kan-ci-shu-xue-gai-zen-me-xue" class="header-anchor">#</a></h3><!-- ![](/images/18.jpg) --><p>&emsp;&emsp;在上个世纪80年代，国内流行过一句口号：“学好数理化，走遍天下都不怕。”因为当时的教学体系还不完善，数理化这些基础学科比重大，而且容易培养出建设型人才，所以受到重视。当然，随着综合教育体系的完善，这个口号也就不再流行了。</p><details><summary>...</summary>&emsp;&emsp;但是，在今天来看，无论你的专业和工作是什么，你都会发现，数理化这些底层学科是不是牢固，真的决定了一个人的知识结构能搭多高，在专业上能走多远，尤其是数学。数学作为一切科学的基础，它化繁为简，直击本质的思考方式，让很多人获益。那些数学成绩好的人，做起事来总是一通百通，很容易脱颖而出。&emsp;&emsp;但是事实上，很多学习数学的人会感觉自卑，并产生厌恶。这是为什么呢？当然不是数学本身的问题，也不是我们人的问题，而是因为我们和数学之间缺失了一个桥梁。数学是一种抽象的知识体系，而我们人要靠经验感知才能认识世界，这中间需要一个桥梁，这个桥梁一旦构建起来，每一个人都能受益于数学。&emsp;&emsp;那么是否每一个人都有可能学好数学呢？公平地讲，数学往深了学确实很费脑力，对大多数人来讲有点难度，但是把平时用到的、能够提升我们思维的数学学好，是每个人都能做到的。接下来我就用一个例子谈谈怎么学数学。&emsp;&emsp;2017年，一位原央视的主持人请我和中国科技馆前馆长王渝生先生，做一个有关数学的节目。在节目开始前，主持人对我说，她高考时数学不及格，是个学渣。我说，你能有今天这样的成就，显然不是学渣。数学没学好，不是你的问题，是教学的方法和考量学生的方法不对。&emsp;&emsp;然后我就告诉她美国顶级的高中和大学是怎样教数学的。在美国最好的高中，把数学课由中国的一门课变为8～10门内容不同的课程，每门课还要开A、B、C三个难度不同的班。比如我们中国（从初中到高中）的几何，被分为平面几何A、B、C，解析几何A、B、C，等等各种难度的课程和班级。&emsp;&emsp;入门的那几门数学课足够浅显，难度较低的班会讲得更浅，内容更精简。比如平面几何的A，讲清楚几何学的原理和用途，以及推理的思维方式就好，就不让学生再做那些比较难的证明题了。像点、线、面、三角形、四边形和多边形等概念，以及平行、垂直等关系，其实对任何人都不难，都能取得好成绩。&emsp;&emsp;当然，由于你选择了简单的数学，也就没有浪费时间去攻克对自己来说很难的数学内容，就可以学更多自己喜欢的文学或历史，然后申请那些更适合自己的大学。更重要的是，虽然你所学的数学课不多，也不深，但好歹掌握了基本概念，掌握了相应的思维方式，**如果将来真想再继续学，还是有可能的**。否则你学了一大堆理解不了，考试通不过的内容，不仅浪费时间，而且本来能学会的简单内容也全丢掉了。&emsp;&emsp;不信我问你，还记得住计算圆球体积的公式，或者方程组的解法吗？那些都不是什么很难的内容，但是因为大家做不出数学题，考不出满意的分数，就从心里彻底放弃了这门课，以至于那些本应该记住的简单内容也干脆全忘光了。可以说，结果就是早早地就把通往数学的桥梁毁掉了，从此以后，再也没有体会过数学思维的乐趣，放弃了智识生活的可能。&emsp;&emsp;**那么在我的数学课中，我会教什么？大家又应该怎么学？学完以后应该怎么用呢？**&emsp;&emsp;在教学方面，我会模仿美国的数学教学方式，为你做好三件事，也是我这门数学课的三个教学特色：&emsp;&emsp;**首先，我会为你重建这座通往数学的桥梁，帮你把那些熟悉的知识点各安其位，放进知识体系里。** 我的讲法是把一门数学课从完整的体系变成一个个的知识点，讲透之后，再还原回体系。让你能够熟练地把握知识点和课程体系的关系，这门课的体系也就搭建好了。&emsp;&emsp;以最难的几何学为例，再难的几何题，其实最终都可以拆成那五个最基本的公理。这五个公理，又可以推导出几何学的任何结论。就如同几种乐高积木可以搭出任何形状一样，我会在几何那个模块介绍给大家。&emsp;&emsp;至于这个体系能构建得多大，则要看学生能够接受的程度，学生接受的程度高，就搭一些复杂的，接受程度低，就搭一些简单的。但是能够拆解和搭建哪怕是比较小的体系，通识教育的目的就达到了。&emsp;&emsp;**其次，在介绍这些关键数学知识点的同时，我会讲清楚它们在数学上的位置，以及和各种知识体系的相关性。**这样不仅能够把各种知识打通，而且能够让你在自己的行业中超越绝大部分从业者。&emsp;&emsp;我的《数学之美》出版后，很多人读后感慨，原来数学对信息处理帮助这么大。但其实那本书中介绍的全部内容，不过是一些知识点。而仅仅是理解了那些知识点的计算机从业者，就已经获得更强的竞争力了。&emsp;&emsp;再比如，为什么大家熟知的勾股定理，在国际上通行的叫法是毕达哥拉斯定理？因为勾股定理只是经验，而毕达哥拉斯定理却完成了数学证明，但教科书出于发明权的考量并没有说明，结果就是把数学这门课的逻辑基础搞丢了。以至于很多人大学毕业工作多年依然搞不清物理上用实验证实的定律和数学上用逻辑证明的定理有什么差别。如果基础就打歪了，以后进入工作，很可能出大错。&emsp;&emsp;**最后一点，也是最重要的，是通过学习数学，实现思维方式的跃进。**为了做到这一点，并不需要讲述太难的数学知识，而是需要讲透。事实上，我们无论是讲透毕达哥拉斯定理，还是更难懂一些的欧拉公式，都可以在讲述的过程中将数学家超出凡人的思维方式讲清楚。毕竟对于大部分人来讲，一辈子用不到欧拉公式，如果他们不容易理解，用简单的例子把道理讲清楚就变得格外重要了。&emsp;&emsp;至此，我为你搭建的桥梁就算建造好了，当然，还是需要你亲自从这头走到那头去，我们接下来谈谈你怎么做，才能跟着我学好数学：&emsp;&emsp;一个学好数学最重要的办法是，不断训练自己的思维方式。&emsp;&emsp;很多人喜欢读侦探小说和悬念小说，喜欢解决各种谜题，这其实是人类的一种天性，也是对头脑的一种训练。学数学能够提高我们这方面的能力，让自己成为一个“深入的思考者”（Deep Thinker）。&emsp;&emsp;世界上有两种所谓的聪明人，一种是反应很快的人，被称为Quick Thinker，另一类则是Deep Thinker，也被称为Hard Thinker，无论是哪一种，其实都是可以后天训练的。训练快速反应最好的办法就是多听多看。但是训练Deep Thinker，就需要练习一环扣一环解套的本事了。&emsp;&emsp;用数学做这种训练的好处是，它经过上千年的发展，已经有一整套训练材料了。所以学数学，就像打游戏晋级一样，一点点往前探索，一个个击破难题。最后，请你查看课表（即目录），当然我还是想再从不同的维度上帮你提炼一下。&emsp;&emsp;首先，我们会学到虚数、极限、微分、积分等等这样的具体知识点，掌握它们之间的关联，以及它们在人类认知方面的地位。这样我们就能理解人类是如何扩展自己的认知的。如果我们把自己成长的过程和人类成长的过程做一个对标，就能通过它们扩展我们自己的认知。&emsp;&emsp;再往上一个维度，你还能了解数学在人类知识体系中的地位，比如数学和艺术的关系，和法律，和经济学的关系，等等。很多时候，数学不能直接解决我们的实际问题，但是它能够给我们提供一个思路。在更高的维度上，我会通过介绍数学的发展史，帮你理解数学思维，也就是人类的认识是如何从直观到抽象，从静态到动态，从宏观到微观和宇观，从随意到确定，再到随机，等等。&emsp;&emsp;好，如果你想重新认识一下数学，和我一起感受一次数学之美，那么欢迎你加入我的《数学通识50讲》。当然，除了数学通识，我还将开设一系列的通识课程，把每个人都需要掌握的人类知识精华，整理成课程，帮每个现代人装备自己的头脑，找到最适合这个世界的思维方式。&emsp;&emsp;好，我们马上开始数学之旅！</details><h2><span id="mo-kuai-yi-shu-xue-de-xian-suo">模块一 ｜ 数学的线索</span><a href="#mo-kuai-yi-shu-xue-de-xian-suo" class="header-anchor">#</a></h2><h3><span id="01-dao-lun-shu-xue-tong-shi-ke-de-ti-xi-he-xue-xi-gong-lue">01 ｜ 导论：数学通识课的体系和学习攻略</span><a href="#01-dao-lun-shu-xue-tong-shi-ke-de-ti-xi-he-xue-xi-gong-lue" class="header-anchor">#</a></h3><!-- ![](/images/17.jpg) --><p>&emsp;&emsp;这一讲算是数学通识课的学习地图，我会带你俯瞰一下这门课的全貌，便于你系统地把握课程内容。</p><details><summary>...</summary>&emsp;&emsp;如果把人类的知识体系用学科来划分的话，数学可能是其最大的一个，因此要想在50讲左右的时间里介绍它的全貌是不可能的。&emsp;&emsp;所幸的是，作为通识教育，你不需要学那么多，而且数学的各个分支，无论难易，从体系到研究方法，再到应用方法是共通的。&emsp;&emsp;成年人接受数学通识教育，其实只要做到一点就够了，就是从理解初等数学到理解高等数学——（也就是）把自己对所有和数学相关的概念和方法的理解程度，从静态的、具体的，上升到动态的、规律性的。要达到这个目的，不需要讲很多内容，但需要一些线索。&emsp;&emsp;下面我就简单介绍一下课程的内容和我选择它们来串联课程的理由。&emsp;&emsp;**第一模块讲的是数学究竟是怎么从一个猜想，得出推论，然后又产生实际应用的。**&emsp;&emsp;根据《时间简史》和《大设计》的共同作者蒙洛迪诺的讲法，人类早期的所有知识体系都是：“前科学”。这是好听的说法，难听的说法叫做“巫术式”的。&emsp;&emsp;在所有早期文明中，唯一的例外是古希腊。但即使是在古希腊，我们所知的那些大学问家们比如泰勒斯、赫拉克利特、亚里士多德，他们的思维依然是前科学的，不是科学的，因为他们对客观世界的解释，加入了太多主观的想象。而在古希腊，真正具有划时代意义的人则是毕达哥拉斯。&emsp;&emsp;毕达哥拉斯是将数学从经验上升到系统性学科的第一人。他确立了数学的起点，也就是必须遵循严格的逻辑证明才能得到结论的研究方法，这就让数学从早期那些需要靠测量和观测的学科，比如天文学、地理学和物理学中，脱身出来，成为所有基础学科之上，带有方法论性质的特殊学科。&emsp;&emsp;因此，我们会先从毕达哥拉斯学起，他也是整个第一模块的主线。那么我会怎么讲这个模块呢？&emsp;&emsp;首先，我会讲毕达哥拉斯最出名的毕达哥拉斯定理，也就是我们所说的勾股定理。&emsp;&emsp;我们还知道，毕达哥拉斯最被后人所诟病的地方是否认无理数的存在，并假装视而不见，还把提出这个问题的学生害死了。&emsp;&emsp;对此，今天很多人说他无知，顽固，拒绝接受真理等等。但是要知道，在当时人们所知的有限的数学领域中，毕达哥拉斯是这个体系的教主，他需要这个建立在逻辑之上的体系的一致性和完备性，而逻辑上的一致性也是数学最基础的原则。&emsp;&emsp;因此，他发现无理数的出现会破坏他所理解的数学体系的完备性，动摇数学大厦时，他就采取了教主们才会采用的激进行为。&emsp;&emsp;毕达哥拉斯真正的错误在于，他不懂得要维系数学这个体系，需要定义“无理数”这样的新概念。无理数造成的数学危机解决之后，数学反而发展了，并没有像毕达哥拉斯想的那样崩溃。&emsp;&emsp;毕达哥拉斯另一个了不起的成就，就是算出了黄金分割的比例。从黄金分割出发，毕达哥拉斯发现了数学和美学的关系，并且开始用数学指导音乐。&emsp;&emsp;概括来讲，我们在第一模块“数学的线索”里面，以毕达哥拉斯为线索，一方面将很多数学知识点串联起来，向大家展示数学是什么样的体系，另一方面，我们把毕达哥拉斯作为例子，说明数学发展和体系构建常常经历的步骤。也就是，**从特例到引理再到定理、推论，最后到应用的全过程。**&emsp;&emsp;但是数学的发展又非单一线索，从一个点出发可能产生了很多并列的推论，因此我们不得不在课程中把并行的内容按顺序来讲。比如在第一模块中，我们在讲完黄金分割的应用后，又会回来讲和它有关的等比数列。&emsp;&emsp;当你知道数学定理是如何从猜想到推论再到应用的过程，我们就进入课程的**第二个模块“数的概念”，通过讲述人类对数字这个概念的认识历程，我会给你一个思维工具——“从具体到抽象”**，从而解释为什么你从小学数字，但其实对数字的认识并没有提高，以及学数学多年都不能为己所用的原因。&emsp;&emsp;照理讲，我们的认知水平应该随着所学内容难度的提升而提升，但是通常不是如此。很多人学到大学关于数字的概念时，对数字的理解方式，还停留在小学阶段。&emsp;&emsp;比如，对于无穷大和无穷小这样的概念，很多人依然以为它们只是巨大的数字和极小的数字。事实上它们和我们日常遇到的具体数字不同，代表着变化的趋势和变化的快慢。因此从小学到了大学，大家对数字的理解就应该从静态到动态，但遗憾的是，很多人并没有这样的认识。&emsp;&emsp;当一个人用小学的思维方式，学习大学的数学内容，一定会觉得难以理解，于是对数学敬而远之。这并不能怪学习的人，而是怪很多数学课在设计时，没有把听众当作未来的主人，而只是把他们当作未来的工匠，教给他们一些具体知识让他们干活，而非更高级的思维认知。&emsp;&emsp;因此，在第二模块中，我们会突出数学作为“抽象思维”工具的作用，比如人们从具体算术到抽象代数，用到解方程、虚数等等，为什么要学习它们？因为它们的角色是人类造出来的抽象工具，在现实生活中并不存在，但是有了它们，现实的问题就好解决了。数学通识教育，一个重要目的就是让大家习惯于使用这样的抽象工具。&emsp;&emsp;**第三、第四模块的内容集中在我们熟知的几何和代数。**在几何的模块中，我们会以它为例子介绍什么是公理化的知识体系，它是如何建立的。&emsp;&emsp;在代数的模块中，我们会重点介绍函数和向量。函数这个概念的发明，把我们人类的认知从个体上升为整体，从单点联系，上升为规律性的网状联系。&emsp;&emsp;比如同一道题目，从小学到大学，理解是不同的，这是一个从单纯理解数字大小，到理解它方向性的过程。在小学，如果我们看到一道题，说张三以50公斤的力拉箱子，李四以30公斤的力拉，拉箱子的力是多少？答案很简单，就是80公斤。但是到了初中，我们有了负数的概念，你就要问他们拉箱子的力是相同的还是相反的，如果是相反的，只有20公斤。&emsp;&emsp;再往上学，我们就要问他们拉箱子的力夹角是多少度，在90度时和120度时，受力可是不同的，这就进入到了大学思维。&emsp;&emsp;向量和线性代数，就是把数字从单纯的数值，变成了有方向的数值。所以，我认为这两大知识点，最能代表代数模块的内涵，可以帮助大家提升认知。&emsp;&emsp;**第五模块是微积分，这已经是高等数学的内容了。**但是，我们其实在第二模块里已经不知不觉地把微积分中最难的内容提前讲了，因此在这个模块，大家反而会觉得简单。&emsp;&emsp;对于微积分，它和初等数学的工具有什么不同呢？人们开始对把数学从关注静态的关系，变成了对动态规律，特别是瞬间规律的把握上。理解这一点，并且主动应用到工作中，是我们学习微积分的目的。那些很难的概念，解题技巧，其实毫不重要。&emsp;&emsp;好，前面你学习了数学公理、数字、几何、代数和微积分，提纲挈领地回顾了数学发展的历史，这些分支有个特点，就是能给出问题唯一的答案。&emsp;&emsp;但是到了近代，很多现实问题很难有完全确定的答案。于是，**为了研究不确定世界的规律性，概率和统计发展起来了。**数学的这个分支在今天我们充满不确定性的世界里非常重要，也是所谓的大数据思维的科学基础。&emsp;&emsp;纵观数学发展的历程，以及我们应该具有的数学思维历程，我们可以看到这样的趋势，从个案到整体规律，从个别定理到完整的知识体系，从具体到抽象，从完全的确定性，到把握不确定性。&emsp;&emsp;无论是在整个的课程中，还是每一个模块之内，我们都能看到这样人类认知升级的过程。当然，我觉得这也应该是我们自己的认知升级过程。&emsp;&emsp;在课程的最后，我们会介绍数学和其它学科的关系。这样能够在完整的知识体系中，更好地理解数学。接下来，我们就先从毕达哥拉斯讲起，从数学的起点开始我们的数学之旅。</details><h3><span id="02-gou-gu-ding-li-wei-shi-me-zai-xi-fang-jiao-bi-da-ge-la-si-ding-li">02 ｜ 勾股定理：为什么在西方叫毕达哥拉斯定理</span><a href="#02-gou-gu-ding-li-wei-shi-me-zai-xi-fang-jiao-bi-da-ge-la-si-ding-li" class="header-anchor">#</a></h3><!-- ![](/images/20.jpg) --><p>&emsp;&emsp;我们的第一个模块，会为大家介绍数学的线索，也就是它从猜想到定理再到应用的整个过程。我会以毕达哥拉斯定理为例来展开。</p><details><summary>...</summary>&emsp;&emsp;勾股定理大家都不陌生，它讲的是直角三角形两条直角边的平方之和等于斜边的平方。&emsp;&emsp;但是，这个定理在国外都被称为毕达哥拉斯定理。毕达哥拉斯（Pythagoras，约公元前580年—约公元前500年）是古希腊著名的数学家和知识的集大成者。&emsp;&emsp;相关阅读：《科技史纲60讲》15｜为什么其他文明没有诞生古希腊的科学？&emsp;&emsp;接下来有两个疑点，你的中学老师可能在刻意回避或者说没有讲清楚，而它们又实在太重要了。&emsp;&emsp;**第一个疑点：这个定理是否在毕达哥拉斯之前就被发现了？**&emsp;&emsp;我们过去的教科书里讲，据汉朝的数学书《周髀算经》的记载，早在公元前1000年的时候，周公和商高这两个人就谈到了“勾三股四弦五”。他们的年代比毕达哥拉斯早，因此教科书中讲是中国人商高最早提出这个定理的，于是称之为勾股定理或者商高定理。&emsp;&emsp;我们先不说《周髀算经》里所记载是否靠谱，就算靠谱，它也只是记载了一组勾股数（即直角三角形直角边和斜边都是整数的情况），并不能说明发现了其中的规律。因为比周公和商高早1500年，古埃及人在建造大金字塔时就已经按照勾股数在设计墓室的尺寸了。&emsp;&emsp;如果再往前推，美索不达米亚人早在公元前18世纪左右就知道很多组的勾股数（包括勾三股四弦五），而且留下了实物证据。比如耶鲁大学的博物馆里就保存了一块记满勾股数的泥板。![](/images/21.jpg)&emsp;&emsp;**接下来就产生了第二个疑点，古埃及和美索不达米亚为什么不去争夺这个定理的发现权呢？**&emsp;&emsp;简单地讲，所有这些古代文明不过是举出了一些特例而已，甚至没有提出假说。我们在后面的课程中会看到，很多时候特例中反映出的规律和后来真正的定理可能是不同的。所以，这种特例就没有意义。&emsp;&emsp;如果像美索不达米亚人那样举了很多特例，而且没有发现例外，是否可以认为他们最先发现这个定理呢？答案是否定的，因为光举例子还是不够的，还需要做出一个明确的规律性的描述，这种描述我们可以把它称为命题。一个命题在没有证明之前，只能算是猜想，比如著名的哥德巴赫猜想。而总结出一个猜想和证明定理依然是两回事，当然这是比举几个例子进了一大步了。&emsp;&emsp;再接下来，猜想如何证实呢？在这一点上数学和自然科学完全不同。那么我们就要说到数学和自然科学的三个本质差别，也是这一讲最重要的三个知识点，它们能够帮助我们理解数学特殊的方法和思维方式，或者说了解数学的推理世界与我们真实的测量世界的区别。&emsp;&emsp;**1.测量和逻辑推理的区别**&emsp;&emsp;我们知道几何学源于古埃及，当地人出于农业生产的考虑，对天文和土地进行度量，发明了几何学。但是，度量出来的几何其实和真正的数学还有很大的差距。&emsp;&emsp;比如说，古代文明的人们确实观察到勾股数的现象，他们画一个直角三角形，勾三尺长、股四尺长时，弦长恰好就是五尺长，于是就有了勾三股四弦五的说法。&emsp;&emsp;但是这里面存在一个大问题，我们说长度是三尺，其实并非数学上准确的长度，用尺子量出来的3，可能是3.01，也可能是2.99。这样一来勾三股四弦五就是一个比较模糊的说法了。为了让你更好地理解这一点，我们不妨看这样一个例子。![](/images/22.jpg)&emsp;&emsp;图中左上方有一个8x8的方格，它的面积是64，这没有疑问吧？我按照图中所示的粗线将它剪成四部分，两黄两灰，再重新组合，就得到了一个13x5的长方形，它的面积是65。请问面积是64的正方形怎么重新组合一下面积就多出1，变成65了呢？&emsp;&emsp;当然我们知道64不等于65，这里面一定有问题。那么问题在哪儿呢？其实，问题就出在再拼接时，它们并不是严丝合缝的，只不过缝隙较小，大部分人看不出来罢了。&emsp;&emsp;在数学上，观察的经验可以给我们启发，但是它不能成为我们得到数学结论的依据，数学上的结论只能从定义和公理出发，使用逻辑严格证明得到，不能通过经验总结出来。讲回到勾股定理，一个工匠注意到勾三股四弦五这个现象，和提出一个具有普遍意义的定理是两回事。&emsp;&emsp;我们通过观察还可以发现，如果勾3.5，股4.5，那么弦大约是5.7，这个“大约”的误差只有万分之一点六左右（弦长大约是5.700887），古代任何测量都发现不了。这时如果你说勾3.5股4.5弦5.7，从物理上来说基本正确，但是在数学上就错了。这是第一个差别，就是测量会出错，但推理不会。&emsp;&emsp;那么，如果我们抛开误差的影响，是否可以认为早期文明的人们发现了勾股定理呢？也不能，只能说他们观察到一些现象，而非发现了定理。这涉及到数学和自然科学的第二个主要区别，证实和证明的区别了。&emsp;&emsp;**2.用事实证实和用逻辑证明的区别**&emsp;&emsp;在自然科学中，一个假说通过实验证实，就变成了定律。比如说与牛顿同时代英国的大科学家波义耳同法国科学家马略特一同发现：一个封闭容器中气体的压强和体积成反比。这很好理解，因为体积压得越小，内部的压强肯定越大。这两个人通过很多实验，都证实了这件事，于是这个定律就由他们两个人的名字命名了。&emsp;&emsp;但是，如果有一个非常爱较真的人一定要抬杠，说你们证实了所有的情况（各种体积和压强的组合）吗，你们敢保证没有例外么？波义耳和马略特肯定会说，我们不敢保证没有例外，但是这个规律你平时使用肯定没有问题。果然，后来人们真的发现当压强特别大时，这个定律就不管用了。但是没有关系，在大多数条件下，这个定理依然成立，今天人们在做产品时，依然可以用。&emsp;&emsp;事实上，今天几乎所有的自然科学的定律和理论，不仅存在一个被推翻的可能性，而且有很多的例外。比如，证实引力波的实验，也只能保证99.9999%的可能性结论是对的。&emsp;&emsp;但是，在数学上，用实验来验证一个假说（在数学上常常被称为猜想）是不被允许的，我们在后面介绍无穷大时，大家还会看到这甚至是做不到的。数学的结论只能从逻辑出发，通过归纳或者演绎得出来。它必须完全正确，没有例外，因为但凡有一个例外（也被称为反例），就要被完全否定掉。这里面最著名的例子就是哥德巴赫猜想。&emsp;&emsp;今天人们利用计算机，在可以验证的范围内，都验证了这个猜想是对的，但是因为没有穷尽所有的可能，就不能说猜想被证明了。因此，我们依然不能在这个基础上，构建其它的数学定理。所以，数学世界和测量世界第二个区别就是，数学理论必须要证明，保证没有例外。&emsp;&emsp;**3.科学结论相对性和数学结论绝对性的区别**&emsp;&emsp;为什么数学要那么严格，它的定理为什么不能有任何例外，更不能特殊情况特殊处理呢？因为数学上的每一个定理都是一块基石，后人需要在此基础上往前走，试图建立一块新的基石，然后数学的大厦就一点点建成了。在这个过程中不能有丝毫的缺陷，一旦有，整个数学大厦就轰然倒塌了。&emsp;&emsp;还是以勾股定理为例，它的确立，其实教会了人们在平面计算距离的方法，在此基础之上，三角学才得以建立，笛卡尔的解析几何才得以确立，再往上才能建立起微积分等数学工具。此外我们这个模块后面会讲到的无理数的出现、黄金分割，都和它有关。&emsp;&emsp;人类今天发明的各种科技，像无线通信、航天等等，依赖于这些定理。如果出现了一个违反毕达哥拉斯定理的反例，不仅是这个定理失效了，而且整个数学就完蛋了，我们的科技也就时灵时不灵了。因此，数学上的每一个定理，必须也只能通过逻辑推演来证明，用多少实例来验证都没有用。&emsp;&emsp;理解了数学定理确立的过程，以及它随后产生的巨大影响，我们就清楚定理和定理证明在数学中的重要性了。正是因为这个原因，西方才将这个定理命名为毕达哥拉斯定理，以彰显他的贡献。是他明确提出这个定理，并且严格地证明了它，从此毕达哥拉斯定理才成为了数学上普遍的规律。&emsp;&emsp;有了一个个的定理，数学就得以建立起来，而且这个建立在逻辑推理基础上的大厦很坚固。在数学上，当一个新的定理被证明后，就会产生很多自然的推论，每一个推论可能都是一个重大的发现，甚至能带来人类认识的升级。毕达哥拉斯定理的一个直接推论，就是无理数的存在。这个内容我们下一讲再讲。**要点总结：**&emsp;&emsp;数学和自然科学不同，它不相信测量，不是建立在实证基础之上，而是建立在逻辑基础之上的。数学也不接受大部分情况正确，但是包含例外的定理。这样整个数学大厦的基础才得以稳固。&emsp;&emsp;数学定理确立的过程大致是这样的，一开始可能只是大家注意到几个特例，然后发现很多例证提出猜想，猜想经过证明就成为了定理，定理会有推论，在此基础上，会有新的定理和应用。**思考题：**&emsp;&emsp;在物理学中，从不同的角度理解光，会得到粒子说和波动说两种解释，数学从两个角度证明一个定理，会不会得到不同的结论？</details><h3><span id="03-shu-xue-de-yu-jian-xing-ru-he-yong-tui-li-zou-chu-ren-zhi-mang-qu">03 ｜ 数学的预见性：如何用推理走出认知盲区</span><a href="#03-shu-xue-de-yu-jian-xing-ru-he-yong-tui-li-zou-chu-ren-zhi-mang-qu" class="header-anchor">#</a></h3><!-- ![](/images/19.jpg) --><p>&emsp;&emsp;上一讲，我们通过毕达哥拉斯定理解释了数学的起点，它必须是从逻辑推理和证明得来的，而非测量和实验出来的。我们这一讲就看看以毕达哥拉斯定理为起点出发，人们又发现了什么。</p><details><summary>...</summary>&emsp;&emsp;在古希腊毕达哥拉斯（Pythagoras，约公元前580年—约公元前500年）所处的时代，人们认识到的数学上的数字都是有理数，它们都有我们平时所说的分数，具有A/B这样的形式，比如2/3，其中A和B都是整数，当然，整数本身可以被看成分母等于1的分数，比如5=5/1。&emsp;&emsp;毕达哥拉斯有一个很怪的想法，他坚信世界的本源是数字，而数字必须是完美的。整数很完美，而且分数的分子分母也都是整数，不会是零碎的，因此也很完美，整数和分数所构成的有理数让毕达哥拉斯一直坚信自己的想法。&emsp;&emsp;但是，一旦毕达哥拉斯定理被他证明以后，麻烦就来了。&emsp;&emsp;我们上一讲讲过，数学的定理具有永真的特点，它一旦被证明，你就找不到反例。当人们在用毕达哥拉斯定理时，就发现了问题。假设某一个直角三角形的两条直角边长都是1，那么斜边该是多少呢？&emsp;&emsp;你可以根据毕达哥拉斯定理算一下，既然两条直角边都是1，它们各自的平方也是1，加起来是2，因此斜边的平方是2，这个斜边就是一个自己乘以自己等于2的数字，从大小来看，它应该在1和2之间。接下来请问，这个自己乘以自己等于2的数字是否是“完美”的有理数？&emsp;&emsp;根据毕达哥拉斯对所有的数字都是有理数的认识，它必须是啊！好，我们就假定存在一个数字是R，它能够写成R=A/B的形式，其中A、B都是互素的整数（互素指的是两个数写成分数的形式，不可再约分），那么现在假设这个数字R的平方恰好等于2。注意一下，这里面有三个条件，请一定牢记：&emsp;&emsp;A、B都是整数。&emsp;&emsp;A、B互素，也就是不能再约分了。&emsp;&emsp;A/B的平方等于2。这三个条件能否同时满足呢？答案是不能。为了说明这一点，大家不妨跟着我做一个简单的逻辑训练。&emsp;&emsp;好，这次我们用的方法，在数学上被称为反证法，就是先假定你说的条件都满足，然后我来找出矛盾之处，这样就能推翻原来的假设。&emsp;&emsp;具体到上面这个问题，我们从上面第三个条件出发，就得知分子A的平方除以分母B的平方等于2：&emsp;&emsp;&emsp;&emsp;$ A^{2} / B^{2} = 2 $&emsp;&emsp;我们把B的平方移到等式的右边2那边，就是：&emsp;&emsp;&emsp;&emsp;$ A^{2} = 2 \times B^{2} $&emsp;&emsp;接下来我来问你，A是奇数还是偶数？你会说它当然是偶数，因为等式的右边是2乘以B的平方，都乘以2了，那A的平方结果肯定是偶数，奇数的平方不可能是偶数，所以A必须是偶数啊。既然A是偶数，我可以把A写成2乘以一个数，比如C，也就是A=2C这种形式，其中C是一个整数。&emsp;&emsp;那么A的平方等于什么呢，等于4倍的C的平方，我就用这个4倍的C的平方代替A的平方，放在原来等式的左边，右边还是2乘以B的平方：&emsp;&emsp;&emsp;&emsp;$ 4 \times C^{2} = 2 \times B^{2} $&emsp;&emsp;这个等式的两边都可以用2去同时除一下，于是就成了两倍的C的平方等于B的平方：&emsp;&emsp;&emsp;&emsp;$ 2 \times C^{2} = B^{2} $&emsp;&emsp;这时我问你，B是偶数还是奇数？你会说当然是偶数，因为两倍的C的平方是偶数啊。&emsp;&emsp;这下子问题来了，怎么A和B都是偶数呢，这不就和上面的第二个条件，也就是“A、B互素，不能再约分”矛盾了吗？&emsp;&emsp;那么到底哪里发生了错误呢？我们先要检查一下我们的推导过程，我们发现没有错误。因此，要么是数学错了，要么是认知错了。勾股定理的证明是通过严格的逻辑推导出来的，也不会有错，于是只能是我们的认知错了。&emsp;&emsp;也就是说，存在一种数字，我们过去没有认识到，它们无法写成有理数的形式，即A/B，它们是无限的不循环小数，在这样的数中有一个自己乘以自己时等于2。我们今天把这个数字称为√2。这一类的数字其实很多，它们被统称为无理数。&emsp;&emsp;据说毕达哥拉斯的学生希帕索斯最初发现了上述矛盾，于是就去和他的老师讲了。而毕达哥拉斯是个把数学看成宗教的人，出现无限的不循环小数在毕达哥拉斯看来是数学的漏洞，但他又无法把这件事解释圆满，这就是数学史上的第一次危机。&emsp;&emsp;毕达哥拉斯决定把这位学生扔到海里杀死，好把这件事隐瞒下来。&emsp;&emsp;当然，像√2这样的“无理数”存在的事实，却不可能一扔了之，无理数是客观存在的，毕达哥拉斯是隐瞒不住的，这件事成为了这位确立了数学在人类知识体系中地位的大学问家的一个污点。另一方面，无理数的危机也带来了数学思想一次大的飞跃，它告诉人们，人类在对数字的认识上还具有局限性，需要有新的思想和理论来解释，认识本身不能有禁区，那些事先为科学设定的条条框框，最终都不得不被抛弃掉。&emsp;&emsp;从这个例子中，我们能学到什么呢？&emsp;&emsp;首先，在遇到数学和现实的矛盾时，我们需要仔细检查推理的过程是否有疏漏，这种情况占大多数。&emsp;&emsp;在排除了推导的错误后，接下来，两种情况必居其一：&emsp;&emsp;要么，我们的眼睛和我们的认知欺骗了我们，就如同我们以为所有的数都是有理数，但其实不是。这是常有的事情。&emsp;&emsp;要么，最初的假设错了或者说不够好。这种事情在历史上偶尔发生过，但是很少，我们后面在介绍非欧几何时会仔细讲到这种情况。这种情况我们通常不需要考虑。&emsp;&emsp;既然在推导没有错误时，通常是我们的观察或者认知欺骗了我们，那么我们就应该把危机看成是转机。人类在科技历史上，很多重大的发明发现恰恰来自于上述的矛盾。在数学史上，除了无理数被发现之外，几个重大的事件，比如无穷小概念的提出，对无穷大的重新认识，以及公理化集合论的确立，都和那些矛盾有关。这些矛盾有时看似造成了数学危机，但是，人们化解了危机之后，就拓展了认知，建立起新的理论。它们或者让数学本身进步了，或者在科学上做出重大的预言。&emsp;&emsp;几年前约翰·霍普金斯大学的天体物理学家亚当·里斯（Adam Riess）教授给我讲的一堂课，我至今记忆犹深，他让我坚信了对数学本身的信心。里斯等人通过计算，发现宇宙的质量是负数，这怎么可能？难道是数学错了，还是我们对宇宙的理解完全错了？&emsp;&emsp;里斯在做了仔细的检查后首先排除了推理有误的可能性，然后他们不得不承认数学的结论是对的，出错的是我们眼睛（包括观测的仪器）。于是，他们认定宇宙中一定存在我们看不见，更不了解的东西，那些就是所谓的暗能量，亚当·里斯等人后来因此获得了诺贝尔奖。&emsp;&emsp;在自然科学上，很多重大的发现，最初都不是直接和间接观测到的，而是根据数学推导出来的，比如说黑洞、引力波便是如此。在历史上，血液循环论、现代原子论最初都是建立在数学推导上的假说，然后才逐渐被实验验证了。&emsp;&emsp;世界上有很多我们不能依靠直觉和生活经验理解的事物，但是我们可以从数学出发，经过一步步推导得到正确的结论，我们甚至不需要亲力亲为地做一遍就知道我们的结论一定是正确的。这就如同你不需要会踢足球，才能评论足球一样，你只需要把握住一些准则就可以了，而数学就是这样的准则。**要点总结：**&emsp;&emsp;从数学的定理出发，可以推导出很多针对现实世界的推论，从而改变我们对现实世界的看法，这就是数学的预见性。比如，毕达哥拉斯定理的一个直接结果指出了无理数的存在，它把人类对于数字的认识范围从有理数扩展到了无理数。&emsp;&emsp;当然，可能有读者朋友会想，那些预见性可能和我们相去甚远，其实不然，后面我们会举一些和大家相关的例子，比如如何识破庞氏骗局，为什么不能做空股票，等等。>康德讲：“世界上只有两样东西是值得我们深深景仰的，一个是我们头上的灿烂星空，另一个是我们内心的崇高道德法则。”他所说的星空，其实包括数学这样的知识体系。对于很多云山雾罩的事情，我们只需要在逻辑上推演一遍，就能把问题的真相搞清楚了。**思考题：**&emsp;&emsp;我们都知道，整体要大于部分，因此10厘米长的线段上的点应该比5厘米长的多，但是如果我能用严格的逻辑证明它们上面的点一样多，你相信么？<details><summary>answer</summary>容易发现，对每个 [0, 5] 中的一个数 x，对应在 [0, 10] 中就是2*x；相反的，对每个在 [0, 10] 中的一个数 y，在 [0, 5] 中就对应着 0.5*y；并且这种对应关系是不会漏掉任何一个点的。[作者：梦幻王gr, 出处： bilibili](https://www.bilibili.com/read/cv3900327/)</details><p>&emsp;&emsp;欢迎给我留言，并把文章分享出去，让更多的人感受到数学之美。我们下一讲再见。<br>&lt;/details&gt;</p><h3><span id="04-shu-xue-si-wei-shu-xue-jia-ru-he-cong-luo-ji-chu-fa-xiang-wen-ti">04 ｜ 数学思维：数学家如何从逻辑出发想问题</span><a href="#04-shu-xue-si-wei-shu-xue-jia-ru-he-cong-luo-ji-chu-fa-xiang-wen-ti" class="header-anchor">#</a></h3><!-- ![](/images/23.jpg) --><p>&emsp;&emsp;这一讲就来举一个发生在我们身边的例子，说明如何利用数学原理思考问题，并且久而久之在遇事时本能地用一个数学的头脑辅助判断。</p><details><summary>...</summary>&emsp;&emsp;当然，数学思维高深精妙，但是万法归一，最重要的那个原则就是，从逻辑出发想问题，这样就可以发现很多日常中被忽略的问题，从而找出真正答案。&emsp;&emsp;我们先从最近的一次金融危机讲起。在金融危机之后，英国女王问全世界的经济学家们，你们这么多人怎么没有一个预测到金融危机？这让学者们都很没面子。&emsp;&emsp;经济学家们当时确实是过于乐观了，所以很多暂时不会出问题的隐患被隐瞒了下来，因此大家会觉得没问题。不过当时有一些其实并不懂经济学的人，利用特殊的方法，嗅出了问题。&emsp;&emsp;比如巴菲特从直觉出发，觉得那些金融衍生品刻意包装，一定是为了掩盖很多真相，坚决不参与那场赌博。像这样的投资人并不少，其中最著名的是一个叫贝尔（Michael Burry）的医生，他数学很好，而且雇了一些数学家替他做事，靠坚守数学上的一些基本道理，成为那场豪赌中获利最丰厚的赢家。&emsp;&emsp;贝尔他们的逻辑其实很简单，就是我们常常说“复利”增长从数学上讲是无法长期为继的。比如说，财富每年增长7%，这个速度在很多人看来并不算快，但是如果两千多年前的陶朱公以及他的后人能维持这个财富增长速度，哪怕当年他只留下一个铜板，今天他的传人所拥有的铜钱的数量要超过宇宙中的原子的数量，这在现实中当然不可能。&emsp;&emsp;做投资的人都清楚，在一开始投资基数较小的时候，能够维持指数增长，一旦基数变大，就做不到了，还不切实际地想维持，就是拆东墙补西墙的庞氏骗局了。&emsp;&emsp;很多人觉得自己足够聪明不会上庞氏骗局的当。但是变相的庞氏骗局要识破就没那么容易了。2008年金融危机中的罪魁祸首CDS，就是奸商们包装的一个不容易看懂的庞氏骗局，接下来我们就来说说它。我们知道2008年金融危机的原因是美国房屋的次级贷款出了大问题，那它和CDS有什么关系呢？别着急，我们从次级贷款说起，然后你就明白什么是CDS了。&emsp;&emsp;让我们先回到克林顿当总统的时代。那时，克林顿政府为了让本来付不起首付的穷人也能买房子，允许银行提供购房首付的贷款。比如100万的房子，通常需要贷款80万，首付20万，但是假如有一个人叫林肯，他没钱支付首付，当时除了允许他把房子先抵押了，从A银行获得正常的80万贷款，还允许他以较高的利息从B银行获得首付20万的贷款。&emsp;&emsp;如果房价一直上涨，这没有问题，因为即使林肯付不起月供了，A银行也可以通过变卖房子收回自己的80万贷款，剩余的钱，还够B银行也能拿回自己的20万。B银行提供的就是次级贷款，由于它的风险显然比A银行大，因此利率也高，这样如果有个别几个人的贷款拿不回，它也能从其他购房者偿还的利息中填补漏洞。&emsp;&emsp;当然，B银行还有一个更稳妥的做法，就是从高利息（比如每年10%）中拿出一部分（比如1%），向C保险公司购买贷款者违约的保险。&emsp;&emsp;保险公司C根据历史数据发现房屋贷款收不回来的情况很少，只占房贷的2%左右，而它从B银行可以连续挣15年的钱（不考虑复利的因素），15年下来，担保10亿的房产就能收入1.5亿，成本只有2000万，这利润率高达650%的事情保险公司自然就答应了。&emsp;&emsp;接下来，投资银行D看到C公司做了这样一笔好买卖，非常眼红，就和C商量将这10亿美元的保险生意卖给自己，并愿意留给C公司20%的好处，即3000万美元。C公司想，1.5亿虽然多，但是要承担15年的保险义务，不如一次性得到3000万实在，就答应了。&emsp;&emsp;D公司是投资银行，更精明，将C公司为B银行作担保的业务，包装成证券，叫做CDS（信用违约交换），加价3000万美元卖给了另一家投资银行E。E公司可能将各种类似的CDS又打了一个包，以新的证券形式在市场上市了。&emsp;&emsp;就这样，在经过无数次包装后，CDS的内部结构大部分人已经看不懂了，但是人们总觉得自己可以从下家身上赚到钱。于是一同把CDS炒到了50万亿美元这么大的规模，这甚至超过当时美国房市本身的总值。&emsp;&emsp;这个骗局的本质是什么呢？就是大家炒来炒去，都是在赌一件事，就是今后15~30年，房价会一直快速上涨。&emsp;&emsp;然而，房价不可能永远快速上涨，特别是在经济本身没有上涨的前提下。一旦有大量房主还不上钱，或者不愿意还钱，这些CDS就变得一钱不值。更糟糕的是，给购房者提供次级贷款的银行，后面的保险公司以及很多购买了CDS的投资银行也都完蛋了，整个金融体制就垮了。&emsp;&emsp;这件事可以通过数学算出来，其实不只是刚才提到的贝尔，当时有不少人在CDS的骗局破灭之前，发现了问题，后来挣到了大笔的钱。只不过贝尔挣钱的比例太高，他的故事后来被拍成了电影《大空头》，他从此成为了名人。&emsp;&emsp;接下来我们就说说什么叫做具有数学的思维。它不是指算小账算得清楚，而是说善于基于数学知识，使用逻辑发现问题，或者预见到不得不做的事情。我们在生活中，有时不得不面对非常复杂的问题，里面有很多噪音难以一一滤出，这时就需要掌握一种工具让我们能够不受噪音影响作出正确的判断。而数学常常是我们可以信赖的工具。&emsp;&emsp;下面我和你分享一个我的经历。有一次在一个由政府组织的关于“一带一路”的座谈会上，几位领导问我，“吴教授，咱们关起门来讲，中国输出了那么多资本，最后钱能回来么？”&emsp;&emsp;我说，挣得回来，挣不回来，我不知道，因为这里面牵扯太多的因素。但是资本输出和帮助其它国家富裕这两件事都必须做，我可以从数学证明这两件事的必要性。他们很好奇这件事和数学有什么关系，于是我继续讲：&emsp;&emsp;中国在过去的四十年里，实现了每年8%的指数增长，除了中国人勤劳勇敢。另外有两个数学上的原因，一是因为最初的基数小，能够持续高速增长。二是过去国内市场空白一片，供不应求，国际上其它国家人均财富，比中国高很多，相比中国过去的生产能力，购买力近乎无限。&emsp;&emsp;但是40年后的今天，中国人均GDP已经达到了世界的平均水平，总的经济体量已经世界第二，占全世界的18%。那么中国还能不能维持过去的增长速度呢？从数学上讲，根本做不到。&emsp;&emsp;我们就假定中国经济能够按照每年6%的速度增长，这个速度虽然比过去慢了一点，但是比全世界3%的平均水平快很多。再过40年，中国GDP大约能增长10倍。而全世界经济增长的速度只有3%左右，再扣除中国的贡献，中国以外的国家和地区的增速只有2.34%左右，这样增长40年，只能增长1.5倍左右，那时中国GDP大约占到全世界50%。&emsp;&emsp;这时候矛盾就出现了，中国以外有全世界4/5以上的人口，总的财富仅仅和中国一样多。那时，全世界都没有足够的财富买得起中国不断制造的产品和不断提供的服务。这时只有两个办法，一个是提高世界其它地区的购买力和经济增长，另一个是让中国经济增长降到世界的平均水平。&emsp;&emsp;后者显然不是我们想要的，于是借钱给其它国家购买中国的产品和服务，当然中国可以换得一些战略资源，同时让世界其它国家也维持足够高的经济增长，以便它们能维持购买力，并且还得起钱，就是中国不得不做的事情了。而这就是“一带一路”要实现的目标。至于投资和贷款能否拿得回来，那要看操作的水平了。&emsp;&emsp;在历史上，19世纪的英国，二战后的美国，以及80年代的日本，都是资本输出国，因为你不输出资本，大家就买不起你的东西，而你也就无法维持体面的经济增长。中国10年前不提“一带一路”的事情，一是因为还没有必要性，二是因为自己的钱不多；近几年才提出，是因为今天中国正好从处在人均GDP低于世界平均水平到变成高于平均水平的转折点上。因此在商业和资本两个层面全球化就变得迫在眉睫了。&emsp;&emsp;我们在生活中，常常说“算笔账”这三个字。其背后其实就是说基于一些事实，用数学这个工具来考量，发现问题。为什么数学思维可以很容易地发现问题呢？因为我们常常用到在数学证明中的工具：矛盾律。就是说一个事物不能既有A属性，又没有A属性。比如我们上一讲在证明√2是无理数时说到，如果它是有理数P/Q，那么P和Q这两个整数，既不能同时是素数，又必须同时是偶数，这就违背了矛盾律。同样，中国既不可能拥有全世界所有的财富，还让世界其它地区买得起中国的商品，这也违背了矛盾律。**要点总结：**&emsp;&emsp;通过数学的思维方式，发现生活中的问题，看清我们必须采取的行动，这就是学习数学的意义所在。这既可以被看成是认知的升级，也可以被认为是掌握了数学原理之后的灵活应用。当然，数学有很多它做不到的事情，下一讲我们进一步讲讲数学思维的边界。</details><h3><span id="05-shu-xue-bian-jie-cong-bi-da-ge-la-si-ding-li-dao-fei-ma-da-ding-li">05 ｜ 数学边界：从毕达哥拉斯定理到费马大定理</span><a href="#05-shu-xue-bian-jie-cong-bi-da-ge-la-si-ding-li-dao-fei-ma-da-ding-li" class="header-anchor">#</a></h3><!-- ![](/images/24.jpg) --><p>&emsp;&emsp;我们前面讲了数学的预见性，以及数学思维的用处，但是这讲我想和你谈谈数学的局限性，大家可能会有一个疑问，就是这种局限性是来自于我们自己的数学知识不够，还是来源于数学本身的局限性呢？</p><details><summary>...</summary>&emsp;&emsp;应该讲这两方面的原因都有，第一部分因素在大家听完这门课后会补上很多，不用担心；第二部分则是我们这一讲要讲的内容。我们有必要了解数学本身的局限性，才能更好地使用它的原理和思维方式。今天我们还是从毕达哥拉斯定理的推广说起。&emsp;&emsp;在几何上有很多整数组满足毕达哥拉斯定理，它们就是勾股数，比如（3，4，5），（5，12，13）等。从代数上解释勾股数，就是方程 $ a^{2}+b^{2}=c^{2} $ 的整数解。&emsp;&emsp;当然，人类总是很好奇，人们就在想，如果上面方程中的平方变成立方，甚至任意N次方，它还有整数解吗？比如，是否有三个整数a，b，c，使得，$ a^{3}+b^{3}=c^3 $ ？&emsp;&emsp;这个问题困扰了人类几千年。后来有一个叫费马的数学爱好者就提出一个假说，说除了平方的情况，其他更高次方的方程都找不到整数解，它被称为费马大定理（或者费马最后定理）。&emsp;&emsp;虽然它被称为定理，但数学家们只是把它看成是猜想，或者假说，因为没有证明。我们前面讲到，猜想，哪怕用很多数据验证过了，只要没有证明，就无法成为数学大厦中的一块砖，就无法在它的基础上搭建新的东西。&emsp;&emsp;因此，在费马之后的几百年里，很多数学家都试图证明它，但是都不得要领。费马自己说他已经证明了这个定理，只是那张纸不够大写不下，但后人认为是费马搞错了。&emsp;&emsp;于是费马大定理就成了一道跨越了三个多世纪的超级难题。直到1994年，才由著名的英国旅美数学家怀尔斯证明出来，而这个过程也是一波三折。&emsp;&emsp;1986年，怀尔斯在做了十多年的准备后，觉得证明费马大定理的时间成熟了，终于决定将全部精力投入到该定理的证明上了。为了确保别人不受他的启发率先证明了这个著名的定理，他决定在证明出这个定理以前不发表任何关键性的论文。&emsp;&emsp;但是，如果一个人苦思冥想，推导的逻辑错了自己也看不出来，为了避免这种情况的发生，怀尔斯利用在普林斯顿大学教课的机会，不断地将自己部分的想法作为课程的内容讲出来，让博士生们来挑错。&emsp;&emsp;1993年6月底，怀尔斯觉得自己准备好了，便回到他的故乡英国剑桥，在剑桥大学著名的牛顿研究所举行三场报告会。为了产生爆炸性的新闻效果，怀尔斯甚至没有预告报告会的真实目的。因此，前两场报告其实人不多，但是这两场报告之后，大家都明白接下来他要证明费马大定理了。&emsp;&emsp;于是在举行最后一场报告时，牛顿研究所里挤满了人，据估计可能只有1/4的人能听懂讲座，其余的人来这里是为了见证一个历史性的时刻。&emsp;&emsp;很多听众带来了照相机，而研究所所长也事先准备好了一瓶香槟酒。当怀尔斯写完费马大定理的证明时，很平静地说道：“我想我就在这里结束”，会场上爆发出一阵持久的鼓掌声。这场报告会被誉为了20世纪该研究所最重要的报告会。&emsp;&emsp;不过故事到此并没有结束，数学家们在检查怀尔斯长达170页证明的逻辑之后，发现了一个小漏洞。怀尔斯开始认为这个小漏洞很快能补上，但是后来才发现这个小漏洞会颠覆整个证明的过程。&emsp;&emsp;怀尔斯又独立地工作了半年，但毫无进展，在他准备放弃之前，向普林斯顿大学的另一个数学家讲述了自己的困境。对方告诉他，他需要一位信得过的，可以讨论问题的助手帮忙。&emsp;&emsp;经过一段时间的考虑和物色，怀尔斯请了剑桥大学年轻的数学家泰勒来一同工作，最后在泰勒的帮助下怀尔斯补上了那个小漏洞。由于有了上一次带有乌龙性质的经历，怀尔斯这次有点怀疑自己是在做梦。于是他到外面转了20分钟，发现自己没有在做梦，这才喜出望外。&emsp;&emsp;由于怀尔斯在证明这个定理时已经超过了40岁，无法获得菲尔兹奖，因此国际数学大会破例给他颁发了一个特别贡献奖，这也是迄今为止唯一一个特别贡献奖。关于费马大定理证明过程的更多细节，大家可以听罗辑思维的第85期节目。&emsp;&emsp;那么证明这个古老的数学难题有什么意义呢？**这个定理证明过程本身导致了很多数学研究成果的出现，特别是对于椭圆方程的研究。今天区块链技术用到的椭圆加密方法，就是以它为基础的。**&emsp;&emsp;在怀尔斯之前，有一批数学家，特别是日本的谷山丰，对这一系列理论做出了重大的贡献，怀尔斯的成功是在他们的工作基础之上的。今天的比特币可以讲完全是谷山丰理论的一次有意义的应用。而在怀尔斯之后，泰勒等人还在不断发展这方面的理论。&emsp;&emsp;对于三个世纪数学家们证明费马大定理的过程，我和大家分享我的三点体会：- 今天的数学（指纯粹数学，不是应用数学）真的很难，想在这方面取得突破性贡献不容易，怀尔斯从10岁开始就立志解决这个问题，他努力了30年。他最后的证明长达200页。但是，有了理论，使用它做有意义的事情，还是容易得多。比特币就是一个很好的例子。- 数学是世界上最严密的知识体系，任何的推导不能有丝毫的纰漏。怀尔斯差点因为一个小的疏忽毁掉了整个工作，希望通过这一点，大家对数学的严密性有所体会。- 数学走到今天这一步，是在一个个定理的基础上一点点搭建起来的，而今天的成就，又为明天的发展奠定了基础，这样数学就获得了可叠加的进步。&emsp;&emsp;毕达哥拉斯定理是，a的平方+b的平方=c的平方的情形。费马大定理是，a的N次方+b的N次方=c的N次方的情形。因此，前者是起点，后者是一个普遍情况的延伸。接下来，如果我们沿着毕达哥拉斯定理和费马大定理继续往前拓展，会是什么情况呢？&emsp;&emsp;比如任意一个多项式方程 $ 2x^{2} + 3 y^{3} = z^{4} $ ，或者 $ x^{2} + 3 y^{3} - w^{5} = z^{4} $ ，请问它们有没有整数解？这个问题就是著名的希尔伯特第十问题（简称第十问题）。&emsp;&emsp;对于任意一个多项式方程，我们能否在有限步内，判定它是否有解？&emsp;&emsp;对于一些特例，我们知道有整数解，比如 $ x^{2} + y^{2} = z^{2} $ 就有；对于另一些特例，我们知道没有整数解，比如费马大定理所描述的情况。&emsp;&emsp;但是，对于更多的，一般性的不确定方程，我们不仅不知道怎么解，甚至无法判断一个方程有没有整数解。因此，1900年在巴黎举行的国际数学大会上，希尔伯特在提出23个著名的数学问题时，把它列为了第十个。&emsp;&emsp;第十问题其实隐含了一个更为深刻的认识论问题，就是对于大部分数学问题，我们能否找到答案？到目前为止，我们所能解决的数学问题其实只是所有数学问题中很小的一部分。&emsp;&emsp;当然，很多人会说尚未找到答案不等于没有答案。第十问题实际上在直接挑战数学的边界，也就是说，通过数学的方法，我们可能根本无法判断一些问题的答案存在与否。如果连答案是否存在都不知道，就更不用说通过数学的方法解决它们了。&emsp;&emsp;这样就为数学划定了一个明确的边界。从1900年之后，特别是在二战之后，欧美不少数学家致力于解决这个问题，因为这也涉及到计算机所能处理问题的边界。&emsp;&emsp;第十问题的解决颇具戏剧性。在上个世纪60年代，被认为最可能解决这个难题的是美国著名的女数学家朱莉娅·罗宾逊，她从博士一毕业就致力于研究这个问题，也取得了很多突破性的进展。&emsp;&emsp;虽然罗宾逊因为这方面的贡献成为了美国科学院第一位女院士，美国数学学会第一位女会长，她离解决这个问题最终还是差几步。1970年，俄罗斯天才的数学家尤里·马季亚谢维奇在大学毕业后一年就解决了这个问题，证明了这类问题是无解的，从此在世界上一举成名。&emsp;&emsp;纯数学这个学科除了需要一些运气之外，比拼的是人的智力，智力到哪个程度，成就就到哪个水平，这倒不是宿命论，而是说明人要根据自己的特长选择做事。&emsp;&emsp;第十问题的解决其实扑灭了人类的一丝希望，但是也让人类老老实实地在边界内做事情。人类过去常常希望找到一个工程问题的解析解，即答案是以一个公式的形式存在，这样套入任何数字，就得到了具体的答案。&emsp;&emsp;但是，很多问题最后证明找不到严格推导出来的解析解，当然这也不妨碍大家在工程上可以使用近似的数值解，解决实际问题。认清这一点，做事的方法也就改变了。&emsp;&emsp;搞流体力学和控制理论的人都知道，那里面有很多复杂的非线性方程要解决。在上个世纪，美苏两国走了两条不同的道路。前苏联因为数学水平较高，而计算机技术很落后，因此他们习惯于下硬功夫做很难的数学题，找到非线性问题的解析解。&emsp;&emsp;而在美国方面，数学水平高的人没有前苏联多，但是计算机技术先进，因此他们习惯于把很麻烦的非线性问题变成很多计算量大，但是却很简单的线性问题（或者其它数值计算问题），找到工程上能接受的近似解。&emsp;&emsp;那么谁取得的效果好呢？从结果来看，美国似乎更好些。关于什么是线性方程，我们后面会讲到，这里大家记住线性方程简单，非线性方程非常复杂即可。**要点总结：**&emsp;&emsp;我们介绍了费马大定理的来龙去脉，它往前和毕达哥拉斯定理的关系，往后和希尔伯特第十问题的关系。我也和大家分享了我对这个定理被证明过程的体会。&emsp;&emsp;**我们通过希尔伯特第十问题介绍了数学的边界，这是一个硬的边界，大家不要试图逾越。但是数学的边界有些时候不是我们解决问题的边界，因为世界上除了数学的方法，还有其他方法。**&emsp;&emsp;到目前为止，我们以毕达哥拉斯定理的产生和发展为线索，介绍了数学猜想到数学公理的推导过程，接下来的两讲，我们还是以毕达哥拉斯这个人为线索，谈谈数学的应用，以及在其它知识体系中的位置。我们下一讲再见。</details><h3><span id="06-huang-jin-fen-ge-bi-da-ge-la-si-ru-he-lian-jie-shu-xue-he-mei-xue">06 ｜ 黄金分割：毕达哥拉斯如何连接数学和美学</span><a href="#06-huang-jin-fen-ge-bi-da-ge-la-si-ru-he-lian-jie-shu-xue-he-mei-xue" class="header-anchor">#</a></h3><!-- ![](/images/25.jpg) --><p>&emsp;&emsp;今天大家对毕达哥拉斯的了解，除了勾股定理，还有就是黄金分割。而他用数学指导艺术和音乐，也确立了数学在其它知识体系和人类文明成就中的中心地位。这一讲，我们就从黄金分割出发，进一步理解数学的用途。这个用途不仅仅是在思维方面，也能实实在在指导我们的工作。</p><details><summary>...</summary>&emsp;&emsp;我们先来看一张照片，感受一下黄金分割。![](/images/27.jpg)&emsp;&emsp;这是雅典卫城的帕特农神庙，它无论是在艺术史上，还是建筑史上地位都很高，如果你度量一下它正面的宽与高，正好符合我们所说的黄金分割。&emsp;&emsp;黄金分割大家并不陌生，你可能还会说出它的比例大约是1:0.618，也就是1.618。其实不仅帕特农神庙本身和里面很多雕塑的关键比例符合黄金分割，著名的雕塑《断臂的维纳斯》，它的身高和腿长的比例，腿和上身的比例也都符合黄金分割。符合这个黄金比例的雕塑或建筑就看上去很顺眼，很美观。&emsp;&emsp;那么黄金分割是如何确定的呢，这个比例为什么看起来顺眼呢？**简单地讲，它的美感来自几何图形的相似性。**&emsp;&emsp;比如我画了一个符合黄金分割的长方形，它的长度是X，宽度是Y。如果我们用剪刀从中剪掉一个边长为Y的正方形（也就是图中灰色的部分），剩下来的长方形，长宽之比依然会符合黄金分割。![](/images/28.jpg)&emsp;&emsp;当然，我们还可以继续剪掉一个正方形（图中绿色的部分），剩下的长方形（图中透明的部分）的长宽依然会符合黄金分割的比例。也就是说，如果我们这样不断地切下去，剩余部分都是成同一比例的。&emsp;&emsp;黄金分割的这个比例很容易算出来。根据黄金分割上述的相似性质，我们可以很容易算出来X/Y的比例是1.618左右，更精确地讲，是√5加上1之后的和除以2，这是一个无理数，通常用希腊字母Ф来表示。&emsp;&emsp;黄金分割为什么漂亮？除了在几何上层层相似，这个相似性之外，它也反映了自然界的物理学特征。如果我们把刚才图中的长方形不断做切割，然后将每个被切掉的正方形的边用圆弧替代，就得到了这样一个螺旋线。由于这个螺旋线每转动同样的角度，得到的圆弧是等比例的，因此它也被称为等角螺线。如果你对比这个螺旋线和下面的蜗牛壳，是否觉得很相似？![](/images/29.jpg)![](/images/30.jpg)&emsp;&emsp;不仅蜗牛壳如此，龙卷风的性质乃至像银河系这样星系的形状都是如此。需要指出的是，这不是巧合，而是因为任何东西如果从中心出发，同比例放大，必然得到这样的形状。![](/images/31.jpg)![](/images/32.jpg)&emsp;&emsp;或许正是因为黄金分割反映了宇宙自身的一个常数，我们对它才特别有亲切感，所以哪个建筑或者画作如果有意无意满足了这个条件，它就显得特别美。除了帕特农神庙，埃菲尔铁塔等建筑的主要尺寸的比例，也正好符合黄金分割，甚至符合等角螺旋线。![](/images/33.jpg)&emsp;&emsp;类似的，《蒙娜丽莎》的主要结构部分也可以对应一条等角螺旋线。需要说明的是，无论是帕特农神庙的设计者，还是达·芬奇或者埃菲尔，他们都知道黄金分割，并且刻意使用了这个比例。![](/images/34.jpg)&emsp;&emsp;最先提出黄金分割的人是谁呢？古埃及人似乎早在4500年前就知道了这个比例的存在，因为大金字塔从任何一个面看上去，其正切面的斜边长和金字塔高度之比正好是黄金分割的比例。&emsp;&emsp;当然，没有证据表明他们算出了精确的比例公式，因为他们不知道有无理数存在。&emsp;&emsp;今天一般认为，算出黄金分割公式的还是毕达哥拉斯。虽然相传毕达哥拉斯是在一次听到一个铁匠打铁和谐而动听的声音后，研究出了黄金分割，但是我觉得这种说法缺乏依据。&emsp;&emsp;大家更认可的说法是，毕达哥拉斯学派的人在做正五边形和五角星的图形时，发现了黄金分割的比例。在正五角星中，每一个等腰三角形的斜边和底边的比例都是黄金分割1.618。![](/images/35.jpg)&emsp;&emsp;我们刚才说毕达哥拉斯还可能是从铁匠的打铁声中获得了黄金分割的启发，但是无从考证，不过毕达哥拉斯学派利用数学指导音乐是真实的事情。毕达哥拉斯认为，要产生让人愉快的音乐，就不能随机在连续的音调中选择音阶，而需要根据数学上的比例设计：&emsp;&emsp;首先，人们发现两根琴弦，如果它们的长度比是2:1，它们所奏出来的音节就相差一个8度，如果我们用简谱来记录，也就是1-2-3-4-5-6-7-i，高音1的音高是中音1的两倍。在这一个8度中最高音和最低音的频率之比也就是为2:1。&emsp;&emsp;接下来，将这8度又一分为二，按照4:3和3:2的比例，分出一个4度音和一个5度音，它们分别对应1-2-3-4和4-5-6-7-i。注意，由于4/3 x 3/2 = 2:1，因此一个4度音和一个5度音会还原成一个8度音。&emsp;&emsp;最后，每个4度音分成两个整声调，即分出2和3，5度音分为三个整声调，即分出5，6，7。这样就是按照比例设计的了。&emsp;&emsp;如果不按照比例分配音节是什么结果呢？我们听到的声音就如同噪音，而不是有规律的乐音。今天对耳蜗的解刨学研究发现，耳蜗的形状其实也是螺旋线的，和黄金分割的螺旋线非常吻合。这可能是按照黄金分割设定音律后，声音悦耳的原因。&emsp;&emsp;毕达哥拉斯和他的学派对音乐和美学的影响一直影响到柏拉图和亚里士多德，以及后来诸多文艺复兴的学者。&emsp;&emsp;数学不仅和音乐密切相关，也对建筑和绘画艺术产生了重大的影响。我们看从文艺复兴时期开始，到19世纪浪漫主义时期的西方油画，都会惊叹于它们的逼真。这个逼真的效果从哪里来？它源于艺术家们使用单点透视的方法，成功地将三维形象绘制到一个二维平面上。当然，这个绘画技术不是一天发明的。&emsp;&emsp;其实，早在古希腊时期，人们就发现了远处景物显得小，近处的显得大这样的特点，并且将这种特点反映到绘画中了，他们把这种方法叫做短缩法。但是，古希腊人并不知道物体在离开我们远去时，该遵循什么数学法则进行缩小。&emsp;&emsp;到了文艺复兴时期，佛罗伦萨的画家乌切洛沉溺于使用几何学技术将绘画变得逼真，在他为美第奇家族绘制的《圣罗马诺之战》中，我们可以看到明显采用透视法炫技的痕迹。&emsp;&emsp;大家可以仔细看看地上倒下的战士和旁边的长矛，都指向远方的消失点。他用透视法为绘画构建了立体的舞台。不过，如果你仔细看，会觉得这幅画中有不少别扭的地方，因为这幅画好像不止一个透视的方向。![](/images/36.jpg)&emsp;&emsp;那么是谁真正解决了透视法中的数学问题，并且将这种技巧给予了广大艺术家的呢？他是文艺复兴时期大名鼎鼎的建筑师和工程师布鲁内莱斯基，今天佛罗伦萨的圣母百花大教堂就是他的杰作。关于这座在建筑史上划时代建筑的建造过程，我们在《科技史纲60讲》中已经介绍了，这里就不再赘述了。&emsp;&emsp;布鲁内莱斯基所发明的单点透视法，完全符合我们视觉应有的几何学原理，具体讲就是相似三角形的原理，因此按照这样的方法画出来的画就非常逼真。下面我们就从视觉中的几何学原理出发，简单介绍一下单点透视法。&emsp;&emsp;假定我们前方100米和500米处各有一棵大树，它们都是50米高。我们知道近处的树在我们的眼睛里显得高，远处的显得小。那么看起来，它们的比例到底该是几比几呢？简单地讲，就是应该和距离成反比，即100米处50米高的树，放到500米处，应该显得只有10米高。如果放到无穷远处，则应该是0米高，也就是地平线上的一个点。对于其他的距离，我们看到的高度也是同样和距离成反比。这样，如果我们把各个距离之处50米高的大树连城一条线，就是我们得到的透视的视觉效果了。&emsp;&emsp;下图是我在电视剧《权力的游戏》的外景地（北爱尔兰）拍的照片。从照片可以看出，所有相同大小的景物，按照远近的比例缩小，在远处汇聚到一点。![](/images/37.jpg)&emsp;&emsp;理解了我们视觉的数学原理，就可以利用它创造出不同的艺术效果。比如在现实世界里，我们看到的是单点透视，因为人的眼睛不可能同时往两边看，但是我们可以在艺术创作中采用两点和多点透视。&emsp;&emsp;下图是两点透视的效果图，景物消失在一左一右两点上。我们通常目光只能集中在一个方向，看不了这么广的视角，但是你如果用鱼眼镜头拍照，就能拍出这样的效果。![](/images/38.jpg)&emsp;&emsp;我们在今后的课程中，还会讲到，艺术需要数学，也需要光学。印象派绘画的一大特点，就是很好地利用了当时人类在物理上对于色彩和亮度认识的进步。**要点总结：**&emsp;&emsp;最后总结一下今天的内容，其实我们是在回答数学的用途。&emsp;&emsp;数学和艺术，以及其他的知识体系有着千丝万缕的联系，我们以黄金分割和透视法为例子介绍了这种关系。了解一些基本的数学知识和方法对我们做其他事情有很多好处。当然，有些人会讲，我们学不会那些数学上的道理啊，没关系，有些方法你只要记住就好。&emsp;&emsp;我们下一讲就从黄金分割出发，介绍优选法，大家只要掌握它的一些基本原则，就能直接使用了。</details><h3><span id="07-shu-xue-ying-yong-hua-luo-geng-hua-fan-wei-jian-de-shen-lai-zhi-bi">07 ｜ 数学应用：华罗庚化繁为简的神来之笔</span><a href="#07-shu-xue-ying-yong-hua-luo-geng-hua-fan-wei-jian-de-shen-lai-zhi-bi" class="header-anchor">#</a></h3><!-- ![](/images/45.jpg) --><p>&emsp;&emsp;我们前面讲过，由于数学是一个纯粹依靠脑力进行研究的学科，而它的严密性又非任何自然科学可比，因此很多数学家们有一种高高在上的自我认知，你如果让他们来解决一些实际问题，他们可能会看不上眼。</p><details><summary>...</summary>&emsp;&emsp;我在一次聚会中遇到一位数学家和一位数学基础非常好的理论物理学家。后者可能是想往数学上靠近一点，对数学家讲，我们也是搞数学的，数学家马上说，你们搞的那些东西怎么能算是数学？&emsp;&emsp;这类情况并不是个案，我见过很多持这种态度的数学家，他们甚至不觉得统计学是数学的一个分支。数学家好像每天研究的东西都深不可测，几乎成为了一种神乎其神的群体。&emsp;&emsp;但是，很多真正高水平的数学家，他们不仅能够研究复杂的理论问题，还能够为复杂的实际问题找到简单的，可重复使用的解决方法，比如我国老一辈著名的数学家华罗庚先生。华先生是20世纪唯一一位能够称得上是世界级的中国数学家，他在数论等方面有很多贡献。&emsp;&emsp;不过，绝大部分中国人都不知道华先生的贡献在哪里，只记住了他所推广的优选法。大家之所以记得住优选法，还是因为很多工业生产受益于此。&emsp;&emsp;在现实的世界里，有一大类的问题可以归结为数学上的最优化问题。小到大家平时发面蒸个馒头，一公斤面先要发酵多长时间，然后放多少克碱，或者做一盘菜放多少盐，多少糖；中到我们在投资时，为了同时兼顾风险和收益，股票配比占总资产的多少比较合适；大到设计一个火箭，燃料和氧气的配比多高最合适。这些问题从本质上讲都是最优化问题。&emsp;&emsp;当然，在很多时候决定好坏的因素不止一个，而衡量标准也不止一个。所以很多看起来简单的优化问题，往往在设计时就得非常复杂。&emsp;&emsp;在生活和工作中，在解决每一个复杂的优化问题时，都可以建立一个特定的数学模型，然后用一大堆工具和计算机刻意接近它。但是，对于大多数各行各业的从业者，并不具有足够多的数学知识，也搞不懂那么复杂的数学模型，他们仅仅是希望你给我几个简单的原则来遵守，几个简单的步骤来执行就好。&emsp;&emsp;于是1958年，华罗庚先生就率领了一大批数学家走出大学和科学院大门，到工农业生产单位去寻求实际问题进行研究，提出解决方案。&emsp;&emsp;华先生最先想到的是线性规划。所谓线性规划，就是用很多线性方程在多维空间里划定一个区域，在区域里找最佳值。&emsp;&emsp;下图中每一条直线就是一个限制条件，它们一同划定了一个蓝色的框框，线性规划就是一个简单的在蓝色框框中寻找最佳值的方法。当然，在实际应用中，经常是在高维空间，而非图中的二维空间里求解，但道理都是一样的。![](/images/46.jpg)&emsp;&emsp;线性规划的本质是将实际应用中那些复杂的非线性求解问题，变成很多个线性方程的问题。要直接解决前者那些复杂问题，需要数学家们做很多推导，显然在实际生产中办不到。而后者，说白了就是死算，当时虽然没有计算机，但是用计算尺还是能完成计算的。&emsp;&emsp;应该讲，华罗庚先生等人的工作，当时还是取得了一批应用成果的，但是不大，因为在工厂机关企业里，就是解线性方程这样简单的数学题，一般人也做不对。&emsp;&emsp;大部分数学家遇到这种情况，恐怕就直接埋怨一线工作的人数学水平低了。但是华先生却没有怪大家水平低，而是觉得自己依然没有把数学变得更简单，于是他进一步总结经验，制定出一套易于被人接受、应用面广的数学方法。他把这些方法称之为优选法。&emsp;&emsp;这种方法非常简单，对当时中国既缺乏数学人才，又缺乏计算机的企事业单位提高效率起到了巨大的作用。&emsp;&emsp;优选法有两个含义，首先它能够找到实际问题的最佳解。其次，它强调寻找最优解的方法本身最简单，或者说最优，具体来说，就是用最少的试验次数来找出最优解在哪里。&emsp;&emsp;假如我们蒸馒头，想试验一下一公斤面放多少碱合适。按照优选法来说，首先我们要找到这个问题的答案，当然你可以每次增加10%一次次地试验，但是这样可能试验的次数特别多。因此，优选法还希望只进行两三次试验，就找到合适的分量。&emsp;&emsp;优选法的原理就是基于我们前面介绍的黄金分割，因此华先生又称之为“0.618法”。为方便说明，我们就假定影响结果的变量（华先生称之为因子）只有一个，比如做馒头时放碱的量。&emsp;&emsp;我们假定1公斤面粉，放碱的重量范围为0～10克之间，精准度到0.1克。当然碱放得太多太少都不行。我们还假定用不同碱量做出来的馒头的口味是可以量化度量的：![](/images/47.jpg)&emsp;&emsp;根据优选法，第一次试验取在黄金分割点，也就是0～10克之间6.18克的位置。如果我们发现这样做出来的馒头碱多了，那么怎么办呢？根据华先生的优选法，第二次做试验选择从0到6.18克之间的黄金分割点。&emsp;&emsp;我们在前面讲了，黄金分割有一个特别好的性质，就是(1-0.618)/0.618=0.618，这样一来，0到6.18克的黄金分割点正好是10-6.18 = 3.82克的位置，这就使得这前后两次找到的黄金分割点，6.18和3.82中间出现了中间点，恰好是5.0克，也就是说5.0成了两次黄金分割点的对称点：![](/images/48.jpg)&emsp;&emsp;当然，你如果和没有多少数学基础的人来讲对称中轴之类的话，他未必听得懂。华先生用了一个非常生动形象的方法来解释这一特征，他称之为折纸法，即把第一个黄金分割点，点在一张纸上，然后把纸从中间对折一下，第二个黄金分割点的位置也显就出来了。&emsp;&emsp;优选法的效率可以从理论上严格证明。比如说做5次试验，就可以将范围缩小到原来的9%，6次可以将范围缩小到6%以下。&emsp;&emsp;华罗庚先生的优选法，给这一大类问题找到了一个结果比较令人满意的，步骤非常容易遵循的方法。&emsp;&emsp;上个世纪70年代，华先生出版了小册子《优选法平话》，后来又扩充了一些案例编写了《优选法平话及其补充》。这两本书用了极为通俗的语言和生活中的案例对优选法的原理和操作进行了描述，当时初中毕业的普通工人都能学会使用，于是优选法在中国得到了极大的普及。&emsp;&emsp;当然，在实际应用中，很多问题有多个变量，而不只是一个。优选法对这种问题设计了一种二维的折纸法，具体做法大致是这样：- 先确定第一个维度的黄金分割点；- 再确定第二个维度的黄金分割点，这样就把二维空间划分为四个部分；- 接下来确定第一个维度的第二个黄金分割点；- 再确定第二个维度的第二个黄金分割点。重复第三、第四个步骤，直到找到最佳点。&emsp;&emsp;在数学上很容易证明，在一个平面区间里存在唯一的最佳点，这种方法很容易找到。对于有更多变量的问题，也可以沿着上述思路扩展，但是这时大家会发现，它其实就是线性规划的一个特例。&emsp;&emsp;**华罗庚先生的贡献在于找到了一种一线职工都很容易掌握和运用的数学方法解决实际问题，并且用非常通俗的语言把复杂的方法简单化。**这才体现出大师的水平。反观我们一些专家学者，喜欢故意把理论包装得高、大、上，然后哗众取宠。他们和真正的大师高下立判。&emsp;&emsp;学了知识，关键要使用好。黄金分割的妙处可以讲是上天赐予的，因此了解了它之后，在很多地方我会有意无意地使用这个比例。比如我拍照片时，喜欢将照片中的主角放在照片的黄金分割点处。&emsp;&emsp;下图是我在爱尔兰拍的海边风车，它在照片的黄金分割点。此外，天空的比例、海水的比例，也基本上符合黄金分割的原则。如果把风车放在画面的中央，看起来就显得呆板了，此外无论画面中天太多，或者水太多，都有失平衡。![](/images/49.jpg)&emsp;&emsp;在投资的配比上，我喜欢将60%～65%左右的资产放在回报高，风险也相对高点的股市上，这基本上符合黄金分割的比例。在剩余的大约38%的资产中，大约25%左右放在相对稳妥的债券上，这也大约是38%的黄金分割点。最后的百分之十几，则是各种复杂的组合投资。&emsp;&emsp;在很多需要作决定的事情上，我自觉或者不自觉地把作决定的时间放在黄金分割点或者反方向的黄金分割点上。&emsp;&emsp;比如需要更多一点时间作比较、作决定的事情，不妨往后放放，但是不要到最后一刻，比如出门度假寻找酒店和机票，你需要时间了解情况，并且货比三家，但是真到了最后一刻，要么酒店订不上了，要么机票太贵。&emsp;&emsp;另一种情况是，我们在作出决定后，需要较长的时间来实现我们的想法，我一般就把作决定的时间点放在0.382的地方，也就是反方向的黄金分割点上。比如要创业，就不要把大部分时间放在想做什么事情上，而需要花更多的时间来做。&emsp;&emsp;当然，每到具体的问题，一定存在比简单利用黄金分割更好的解决办法。但后者的好处是，在你对细节无法了解，甚至一辈子学不会的情况下，总要有一定的做事准则，得到不会太坏的结果，这其实就是数学在很多场合的作用。&emsp;&emsp;很多人抱怨数学不够灵活，其实任何无条件的硬性规定和原则都有这个特点，但是在绝大部分情况下，有准则总比没有好。这是我对数学，特别是对黄金分割的一些感悟，也算是对今天内容的总结。&emsp;&emsp;接下来三讲，我们还是从黄金分割出发，重新理解数列和级数。我们下一讲见！</details><h3><span id="08-shu-lie-he-ji-shu-yi-dang-xia-hen-chong-yao-dan-qu-shi-geng-chong-yao">08 ｜ 数列和级数（一）：当下很重要，但趋势更重要</span><a href="#08-shu-lie-he-ji-shu-yi-dang-xia-hen-chong-yao-dan-qu-shi-geng-chong-yao" class="header-anchor">#</a></h3><!-- ![](/images/50.jpg) --><p>&emsp;&emsp;这一讲的主题是：数列和级数：要知道当下很重要，但趋势更重要。</p><details><summary>...</summary>&emsp;&emsp;有人问我，是否通过学习数学提高了见识水平？公平地讲，很难找到某一个数学知识点，学了之后让见识马上提升，这种直接产生效果的知识我是没有遇到。但是通过学习一些数学知识和方法，帮助我形成了系统的做事方法，并且改进了看待世界的角度，这却不是虚言。&emsp;&emsp;今天和大家分享两点体会，第一点是我们如何举一反三，通过对单个事件，或者说对个案的研究，寻找出对一系列问题的通解，第二点是从很多孤立事件出发，看到并理解趋势和规律。&emsp;&emsp;为了说明这两点，在接下来的几讲里我们用数列这个专题作为例子，练习把握从个体到群体的规律。当然，讲数列还有一个目的，就是承上启下，它会用到前面讲的黄金分割的知识，并且为后面讲极限、无穷大和无穷小奠定基础。&emsp;&emsp;我们先来看一个具体的数列，给你这样一串数字：<center>1，1，2，3，5，8，13，……</center>&emsp;&emsp;如果我来问大家下一个数字应该是什么，比较善于琢磨规律的人会指出，由于每一个数字（除了前两个）都是前面两个数字之和，因此下一个应该是21，即8+13。这个答案完全正确，这样一连串有规律的数字放到一起，就形成了我们要说的数列。&emsp;&emsp;上面这个数列，就是数学中鼎鼎大名的斐波那契数列。在这个数列中，我们是有规律可循的，根据数列中开头几个元素的具体数值，知道整个数列每一个位置元素的数值，就是提升自己从孤立事件里发现规律的能力。&emsp;&emsp;数列其实在今天中国的小学已经讲到，比如常见的两种数列分别是这样的：<center>1，2，3，4，5，6，7，……以及1，2，4，8，16，32，……</center>&emsp;&emsp;前一种数列由于相邻两个数字（我们称之为元素）的差距都是1，因此被称为等差数列，后一种由于相邻两个数字的比值都是相同的（都是2），因此被称为等比数列。&emsp;&emsp;在学校里，老师会讲从1加到100怎么计算，也会讲到等比数列（也被称为几何数列）会增长很快。但是为什么要把这些数字放到一起研究，其实老师们是语焉不详的。当然即使老师讲，以小学生的理解能力也未必能体会。因此今天我们就从这里入手，讲讲数列和数字的关系。&emsp;&emsp;数列是一种工具。**它看似是一串数字，但这里重要的是彼此的关联，以及数字的规律，而不是数字本身。**那些规律和我们现实生活中一些事情的发展过程相关，于是这个工具就能够运用到我们真实的世界里了。&emsp;&emsp;比如我们后面要讲到的媒体转播的发散和收敛问题，以及利息问题，就和几何数列有关。以斐波那契数列为例，它其实反映出一个物种自然繁衍，或者一个组织自然发展过程中成员的变化规律。斐波那契数列最初是这样描述的：>有一对兔子，它们生下了一对小兔子，前面的我们叫做第一代，后面的我们叫做第二代。然后这两代兔子各生出一对兔子，这样就有了第三代。这时第一代兔子老了，就生不了小兔子了，但是第二、第三代还能生，于是它们生出了第四代。然后它们不断繁衍下去。那么请问第N代的兔子有多少对？这个数列，就是1，1，2，3，5，8，13，21，……&emsp;&emsp;如果我们稍微留心一下这个数列的增长速度，虽然它赶不上1，2，4，8，16这样的翻番增长，但其实也很快，也呈现出一种指数增长的趋势。在现实生活中，兔子的繁殖曾经就是这么迅猛。&emsp;&emsp;1859 年，一个名叫托马斯·奥斯汀的英国人移民来到澳大利亚，他喜欢打猎，但发现澳大利亚没有兔子可打，便让侄子从英国带来了24只兔子。&emsp;&emsp;这24只兔子到了澳大利亚后被放到野外，由于没有天敌，它们便快速繁殖起来。兔子一年能繁殖几代，年初刚生下来的兔子，年底就会成为“曾祖”。几十年后，兔子数量飙升至40亿只，这在澳大利亚造成了巨大的生态灾难。&emsp;&emsp;有人可能会问，为什么不吃兔子？澳大利亚人也确实从1929年开始吃兔子肉了，但是吃的速度没有繁殖的快。澳大利亚政府甚至动用军队捕杀，也收效甚微。&emsp;&emsp;最后，在1951年，澳大利亚引进了一种能杀死兔子的病毒，终于消灭了99％以上的兔子，可是少数大难不死的兔子产生了抗病毒性，于是“人兔大战”一直延续至今。从这个故事我想说的是，真遇上指数增长的事情，是非常可怕的。&emsp;&emsp;接下来，我们就定量地分析一下斐波那契数列增长有多快。我们不妨用Fn代表数列中第n个数，那么Fn+1就表示其中的第n+1个数。我们再用Rn，代表Fn+1和Fn的比值，也就是后一个数和前一个数的比值，你可以把它们看成是数列增长的相对速率。&emsp;&emsp;下面的表给出了斐波那契数列中前12个元素的数值，以及增长的速率。![](images/51.jpg)&emsp;&emsp;大家可以看出Rn这个比值，很快趋近于1.618了，这恰好是黄金分割的比例。这个结论说明，数学的各个知识点，可能存在某种天然的联系，这似乎是数学这套系统本身浑然天成的结果，因此很多人讲这其实就是数学之美的体现。&emsp;&emsp;我们课程从毕达哥拉斯，讲到黄金分割，然后通过黄金分割，由此把一些数学知识关联起来。这其实就是一个学习数学的技巧了，绝大部分时候不在于题做得有多难，而在于你闭上眼睛，能够用一两条关键的线索把各个知识点串联起来。&emsp;&emsp;通过上面这个比例，我们需要说明两件事情。首先，虽然这个数列最终的走向是收敛于黄金分割的比例，但是在一开始的几个数，并不符合这个规律。这在数学上不是偶然现象，很多时候，仅仅通过少数几个数字得到的所谓的“规律”，其实和采用大量数据后得到的规律完全是两回事，这一点要特别注意。&emsp;&emsp;其次，上述这个比率，几乎是一个企业扩张时能够接受的最高的员工数量增长速率，如果超过这个速率，企业的文化就很难维持了。企业在招入新员工时，通常要由一个老员工带一个新员工，缺了这个环节，企业的人一多就各自为战了。&emsp;&emsp;而当老员工带过两三个新员工后，他们都会追求更高的职业发展道路，不会花太多时间继续带新人了，因此带新员工的人基本也就是职级中等偏下的人，这很像兔子繁殖，只有那些已经性成熟而且还年轻的在生育。&emsp;&emsp;我们在谈到等比数列时，通常会想到指数爆炸，变得越来越大。但是还有另一类等比数列，它们的数字每一个都比前一个小，最终就会趋近于零。&emsp;&emsp;炒股的人有这样的经验，如果每次损失10%，用不了几次就损失一半了，这就是等比数列中每一个数字都在不断按比例衰减的结果。具体讲，大约6次，就会损失一半，大约13次就会损失3/4。&emsp;&emsp;再举一个例子，今天用于测定年代的碳-14测定法，利用的就是这个原理。碳-14是自然界里一种天然的元素，是宇宙射线照射大气的产物，因此它会不断产生，但是它有放射性，因此过一段时间会衰变掉一部分，于是它在自然界保持着一个动态平衡。&emsp;&emsp;生物体在活着的时候，会吸入大气中的碳-14元素（通过二氧化碳），因此它体内的比例就和自然界的比例相同。但是生物体一死，就不会再吸入碳-14了，因此体内碳-14的比例就会逐渐降低。&emsp;&emsp;根据生物遗骸体内碳-14的比例，结合碳-14衰变的速率（也称为半衰期），就能算出古代生物体距今的时间。所以，对于等比数列，我们一般理解的是快速上涨，但是它也可能代表不断地衰减。&emsp;&emsp;数列，其实讲的就是一个趋势。很多时候，我们不仅关心当前这个数有多大，或者我们有多少钱，多少资源，还关心明天它能变得多大，变得多快，这就是数列的意义。至于等差数列，其实是缓慢上涨的，即使每一个都比前面的大，到后来的增长也很不明显。&emsp;&emsp;也就是说，同样是增长的趋势，我们还需要关心积累的速度。比如说，一个刚工作的年轻人，一年挣10万元，能存20%的收入，他每年的工资增长10%。当地的房价是300万元，首付要20%也就是60万，那么他工作多少年能够付得起首付呢？&emsp;&emsp;这就要计算数列中每一个元素之和了，这个算出来的和，被称为级数。具体到这个问题，我们知道这位年轻人第一年能存2万元，第二年能存2.2万，然后是2.42万、2.66万、2.93万……假如他要存N年才能凑够首付，这个N最后算出来就是15年。&emsp;&emsp;计算公式：S（N）= 2（1 + 1.1 + 1.1^2 + 1.1^3 + …… + 1.1^[N-1]) &emsp;&emsp;建议你亲自算一算这道题，这样你就更能体会为什么必须进步，而且要比同龄人更快地进步了。**思考题：**&emsp;&emsp;如果房价保守估计，每年上涨3%，那年轻人又需要存多少年呢？**要点总结：**&emsp;&emsp;我们通过数列（和级数），扭转一下大家对数学的认识：数学大部分时候研究的不是一个个孤立的数，而是要揭示一些规律和趋势。我们通过斐波那契数列介绍了几何数列可能会带来的指数爆炸问题；同时我们还介绍了另一种几何数列——不断递减的数列。通过斐波那契数列，将它和我们前面介绍的黄金分割关联起来。让大家体会到数学知识点的关联性。在数列这个领域，我们不仅关心趋势，还关心积累的效果，这是我们接下来两讲要讲的内容。&emsp;&emsp;我们下一讲再见。</details><h3><span id="09-shu-lie-he-ji-shu-er-chuan-xiao-pian-ju-de-shu-xue-yuan-li">09 ｜ 数列和级数（二）：传销骗局的数学原理</span><a href="#09-shu-lie-he-ji-shu-er-chuan-xiao-pian-ju-de-shu-xue-yuan-li" class="header-anchor">#</a></h3><!-- ![](/images/52.jpg) --><p>&emsp;&emsp;今天，我们来讲讲数列的求和，也就是所谓的级数。在讲这个问题之前，我们来看一个传销的例子。</p><details><summary>...</summary>&emsp;&emsp;传销通俗来说，就是拉人头发展下线，你拉别人进来，别人再拉新人进来，每次进人，你都有提成。这么一来，只要你的下线不断把新人拉进来，你什么都不用干，就能躺着拿钱了。大多数搞传销的老鼠会都是这么忽悠你的，我们今天从数学上看看这个看似没问题的“发财经”是否可行。&emsp;&emsp;我们先假定某个传销公司的提成方式只覆盖两层：- 每一个人入会需要缴纳1万元（或者买1万元的东西）；- 发展一个直接下线，可以从后者的身上提成20%；- 直接下线每发展一个下线，可以从下线的下线身上再提成20%的20%。接下来的问题是，张三入会了，他在什么情况下可能挣到钱？我们先分析两种情况：&emsp;&emsp;**情况1：**张三找到5个朋友也加入这个老鼠会，而他的每一个下线也发展了5个下线。这样，他付出1万元，而从每个直接的下线身上得到10000x20%=2000元，五个下线一共给他带来1万元。类似的，下线的下线也可以给他带来一共1万元，两者相加是2万元，张三赚1万元。&emsp;&emsp;**情况2：**张三找到3个朋友也加入这个老鼠会，而他的每一个下线也发展了3个下线，这样他的收入一共只有9600元，反而亏了400元。&emsp;&emsp;从这两个例子可以看出，要想在老鼠会中挣钱，并不是一件容易的事情。一个人可能会因为一时冲动，或者贪财而被卷进去，但是他要在朋友中找到5个和他同样糊涂或者贪财的人，并不容易。而且，由于朋友之间的朋友圈有很大的交集，通常的情况就是张三想发展的人，和他的朋友想发展的人都是一群人。&emsp;&emsp;接下来我们再看另一种情况，假设这个老鼠会对会员“特别好”，每一个会员可以自己拿下面所有层会员的提成，当然每往下一层，提成的比例要逐级指数递减。这样的话，如果层数不断加深，直到无穷，是否处在比较高层的人就有无限的钱可以拿了呢？也未必，这要看每一层的人能发展多少会员了。&emsp;&emsp;在上面第一种情况下，即张三成功地发展了五个下线，而每个下线也发展了5个，张三还真能拿无限多的钱，因为每一层都给他贡献了10000元，如果层数不断涨下去，他就能拿无限的钱。&emsp;&emsp;但是，在情况2时，也就是张三和他所有的下线（既包括直接的，也包括间接的）每人都发展了三个人。虽然张三挣的钱可以超过他付出的10000元，但却是有限的。具体来讲，他从下一层下线获得6000元，下面第二层获得3600元，第三层获得2160元，这样逐渐减少，最后无限加下去，总和并不是无穷大，而是一个有限的数，只有1.5万元。&emsp;&emsp;此外，让我们再看另一个可能性。&emsp;&emsp;**情况3：**张三和他所有的下线每人都发展了两个人，这样张三从各层下线挣到的钱的总数是：<center>4000 + 1600 + 640 + …… = 6666.67元</center>&emsp;&emsp;虽然看上去他从无穷多的人身上挣到了钱，可是，这挣钱的效率衰减很快。他挣的钱还没有付出的本钱多。很多人误以为只要从无限多的人身上挣钱，就能挣很多钱，这其实是不了解级数这个概念而产生的误解。&emsp;&emsp;接下来我们就从理论上分析一下几何级数，也就是几何数列求和的问题，把这个问题搞清楚，上面那个老鼠会挣钱效率的问题就迎刃而解了。&emsp;&emsp;我们还是从老鼠会分配钱的方法入手。我们假设每一个人发展了K个下线，从每个直接下线分钱的百分比为p，从第二级下线分钱的比例为p^2，那么第三级的比例为p^3，因为要分3次，以此类推，逐级下降。&emsp;&emsp;如果每一个人交的会费为A，那么一个人能拿到的钱就是：<center>A*K*p + A*(K*p)^2 + A*(K*p)^3 + A*(K*p)^4 + ……</center>&emsp;&emsp;这是一个等比级数，或者叫做几何级数。&emsp;&emsp;这么加下去等于多少呢？很显然，如果K*p>=1，它就是无穷大，这也就是为什么当分成比例为20%时，每个人只要发展五个下线，从理论上讲，能挣无限多的钱。这时，上述的级数被称为发散的。&emsp;&emsp;但是，K*p<1时，上面这个式子虽然加了无穷多项，但到后面都是零点几这样的小数的次方，只能是越乘越小，所以总和是一个有限的数（a*k*p （1-k*p））。当然，k*p越接近于1，这个数越大，k*p越小，这个数越小。这时，上述级数被称为是收敛的。="" &emsp;&emsp;其实可以把每一项的“k*p”用r来表示。什么时候发散什么时候收敛，这个r是关键，它其实是后一个元素和前一个的比值，比如斐波那契数列，它的后一项比前一项，就是黄金分割1.618，至于翻番的指数数列，它就是2，因为我们知道翻番就是翻两倍。当r="">=1时，这个级数就发散，加起来无穷大。当r<1时，它就收敛，加起来是一个有限的数。 &emsp;&emsp;了解了级数的发散性和收敛性，对我们生活、工作和科研会有很多帮助，可以帮我们看清很多类似的迷局。下面我们就来看两个例子：="" &emsp;&emsp;例一，社交网络上的信息传播问题。="" &emsp;&emsp;在社交网络上，有时一篇文章会被不断地转发，然后大家就看到相关的事件被发酵了。这很好理解，我们常说，一传十，十传百，其实就是说当r="10的时候，一个人发出信息后，经过几何级数的增长，数量剧增的情况。" &emsp;&emsp;但事实上，一条信息总是传着传着就死了。大部分公众号文章的阅读量都不过万。那么问题出在哪里呢？我们就用等比级数分析一下。="" &emsp;&emsp;我们假定订阅公众号的人中阅读了某篇文章的第一批读者数量是a0。大家读了之后觉得有价值，然后转发了的百分比为p，每一次转发，平均能有k个受众，而这些受众中打开阅读的比例为q，那么第二批读者就有a0*p*k*q个，我们把p*k*q用r代替，这就是前面的等比级数了，第三批有a0*r^2个读者，以此类推。如果r=""> 1，那么这篇文章就霸屏了。&emsp;&emsp;但是如果r<1，无论怎么传播，无论一开始花多少钱让a0变得很大，读的人数都有限。比如，第一批读者是5000人（不算少了），接下来r=1 2，最终所有的读者加起来，不到1万。如果r="0.9，那么读者数量就可以达到5万。" &emsp;&emsp;我在2019年接受了大约50次采访，只有两篇报道不是标题党（甲子光年的一篇和澎湃新闻的一篇），这还是对媒体进行了严格筛选，并在我强烈要求不可以标题党的情况下发生的。="" &emsp;&emsp;从这里可以看出，标题党的问题只会比我遇到的更严重。但是从结果来看，标题党并没有帮助提升阅读量，因为真实的阅读量摆在那里。这里面根本的原因就是，一旦读者发现一篇文章是标题党，他就有上当的感觉，都未必会读完，更不要说转发了，这个时候转发传播的因子r就可能远远小于1，第二批读者要比第一批少很多，第三批更少，然后就渐渐趋于零了。="" &emsp;&emsp;不仅媒体如此，任何一个产品，要想成为爆款，都需要提高转发率p这个比例，也就是大家使用后满意，然后愿意主动宣传的比例。="" &emsp;&emsp;第二个例子是关于核裂变的链式反应的。="" &emsp;&emsp;我们知道，核裂变就是一个快速运动的中子撞击原子之上后，又会裂变为一些原子和中子，随即释放很多能量。如果每一个中子又撞上一个铀原子，那么就会释放更多的能量。这样一级级撞下去就形成了所谓的链式反应，所有的铀原子都被撞开，并释放出大量的能量，这就是原子弹的原理。="" &emsp;&emsp;但是，运动的中子随机撞上铀原子的原子核概率是很低的，大约是百万分之一，这就是天然铀矿不会变成原子弹的原因。我们假定第一批参加核裂变的原子数量是a0，那么第二批只有a0*r个。我们知道只有r="">1，链式反应才能继续，而且越来越剧烈。&emsp;&emsp;那么怎样才能提高r这个值呢？很简单，首先铀纯度要高，这样中子就有更多的机会撞到铀原子上。其次，铀块的体积要足够大，这样当中子错过了第一个铀原子时，它还有机会撞到其它铀原子上。&emsp;&emsp;能够让链式反应维持的最小铀块体积被称为临界体积，它其实就是保证r>1的体积。原子弹的临界体积是多少起初大家并不清楚，而这又显然无法通过试验测量出来，因为搞不好就会产生核爆炸。所幸的是，奥本海默通过数学计算准确算出了这个临界体积，这才让曼哈顿计划得以成功。从这里我们又可以看到数学的预见性。**要点总结：**&emsp;&emsp;首先，我们讨论了级数什么时候会是无穷大，什么时候是有限的。这里面扮演关键角色的是相邻两个元素的比例r，如果r>=1，即后一个比前一个大，级数就是无穷大，就是发散的。反之，如果r<1，它就是收敛的，多少项加到一起，它也是一个有限的数字。 &emsp;&emsp;其次，我们在生活中，有些时候希望r="">1，比如我们要传播消息，但是有些时候我们希望r<1，比如我们不希望谣言扩散，时间会让r逐步下降，这时要做的事情是千万不要挑起新的事端，火上浇油。 &emsp;&emsp;通过介绍级数，我希望大家能够对趋势有量化的体会。下一讲我们介绍一个和大家投资、贷款相关的金融问题，有关利息的问题。我们下一讲再见。="" <="" details=""><h3><span id="10-shu-lie-he-ji-shu-san-cang-zai-li-xi-he-yue-gong-li-de-mi-mi">10 ｜ 数列和级数（三）：藏在利息和月供里的秘密</span><a href="#10-shu-lie-he-ji-shu-san-cang-zai-li-xi-he-yue-gong-li-de-mi-mi" class="header-anchor">#</a></h3><!-- ![](/images/53.jpg) --><p>&emsp;&emsp;今天我们讲述两方面的内容，一来是应用前两讲讲的有关几何级数的知识，分析贷款利率方面的一些注意事项，特别是要防止陷入某些坑中。有些人不知不觉多付了几倍的利息却毫无知觉。二来讲讲利率和债券投资方面的关系。</p><details><summary>...</summary>&emsp;&emsp;不过我要先做一个提示，这讲提到的数字和计算稍微有些多，不过都是些加减乘除，不会很难，而且我也会帮大家算好。希望你坚持听完，这样能帮你省下不少冤枉钱。&emsp;&emsp;我们先来说说贷款的问题。&emsp;&emsp;假定你买房要向银行贷款120万，年化利率是6%，那么月利率是0.486%，接近0.5%，为了方便起见，我们就算是0.5%。假如你一年还清，每个月还一次，一共十二次还款，也就是12期。在12期的贷款中，每个月所还的钱该是多少呢？&emsp;&emsp;有人可能会想，利率6%，一年还清，利息就是120万x6% = 7.2万。每个月既要还本金，也要还利息，本息平摊到12个月，每个月10万本金，6千利息，一共10.6万。&emsp;&emsp;这个算法对不对呢？今天很多P2P贷款公司，就是这么和大家算账的，一些不良中介，也是这么算钱的。但是，这其实多交了很多的利息。那么我们每个月应该付多少钱呢？这取决于两种常见的还款方式我们采用哪一种。&emsp;&emsp;第一种被称为等额本金偿付，这种方法顾名思义，就是每个月还的本金数相同。在这个例子中，总贷款120万，12个月还清，每个月要还10万本金。当然，你每个月还要还利息，但其实，利息是随着本金归还后，不断减少的。&emsp;&emsp;我们先看看第一个月，你要还全部贷款的0.5%作为利息，也就是120万x0.5%=6000元的利息。因此第一个月你需要还10.6万元，这和P2P公司对你的要求一样。&emsp;&emsp;但是到了第二个月，由于你所欠的本金只有110万了，这110万的利息是5500元，比第一个月120万时的利息少了500元，因此这个月你只需要还10.55万。以此类推，第3个月你只需要付100万本金的利息，最后到第12个月，这样你所需还的利息就逐渐减少了。&emsp;&emsp;这是一个等差级数，十二个月加起来是123.9万。其中利息3.9万，而在前面P2P贷款错误的计算方法中，你支付了7.2万的利息，多付出了3万多的利息。&emsp;&emsp;刚才说了第一种等额本金偿付，我们再说第二种支付方式：等额本息偿付，就是说把贷款的本金和利息都加起来，除以还款期数，这样每个月还的本金和利息都是相同的。在这种情况下，每个月还款中一部分被用于还了利息，剩下的才用于减少所欠的本金。那么每个月要付多少钱呢？&emsp;&emsp;等额本息偿付的本金和利息计算相对复杂。具体到这个例子每月要偿付本息103,279.72元，利息共支付39,356.59元。&emsp;&emsp;相比第一种支付方式，这种方法多支付了300多元的利息，但是它的好处是前几个月的月供较低，这对需要钱的年轻人来讲更有吸引力。今天大部分银行向客户提供的是这种支付方案。&emsp;&emsp;但是，通常没有人只贷款1年，一般期限都在15年以上。如果是15年，那就是180期贷款，贷款的年利率还是6%，那么每月的月供是10,126.28元，15年下来，要支付约622,730.75元，大约是本金120万的一半。&emsp;&emsp;如果利率降到4%，那么15年算下来，大约能省23万元的利息（只要支付397,725.92元），这不是一笔小钱。由于支付的利息降低，同样收入的人可以买更贵的房子。在这个例子中，支付同样的月供大约可以买136万的房子。也就是说，利息降一点，10多年下来能省很多钱。&emsp;&emsp;相反，如果利息涨到8%，维持月供不变，只能买大约105万的房子（120万的贷款就要支付864,208.50元的利息）。很多人在买房子时，会为省一万块钱来回来去讨价还价，但是他们在接受贷款利率时，常常在不知不觉中多付出0.5%甚至更高的利率，这其实是捡了芝麻丢了西瓜。&emsp;&emsp;今天绝大多数正规的银行，在给顾客贷款时，都是采用上述方法计算和收取利息的，可以讲是明码收费，是公平的。但是，很多民间的P2P公司提供贷款时，都有很多的坑，我们不妨来看一看。&emsp;&emsp;首先，它们贷款的利息就高，比如同样是贷款120万，12期还清。他们说每个月收1%的利息，很多人算不过账来，觉得年化利息就是12%，比银行6%的利息只多出一倍，还可以接受。其实（1+1%）^12 -1 = 12.68%，比银行的利息多出1.1倍。当然这还不是最大的坑。&emsp;&emsp;其次，它们采用我们一开始说的算法计算利息，你的借期是一年，它们会让你支付120万x12.68%=15.2万的利息。而银行等额本金偿付的方式才3.9万元。&emsp;&emsp;这还没完，很多P2P贷款公司要求你先支付利息，你借了120万，它只给你120万-15.2万 = 104.8万元，然后每个月它还按照你借了120万要求你归还本金，即每月10万元。当然，如果你想要拿到120万，就得向它更多地借款，需要在合同上写137.4万，当然还的利息也就多了，共计17.4万。&emsp;&emsp;这样算下来，你比向银行借款多付了将近3倍多的利息。也就是说，如果以等额本金偿付的方式正规地贷款，这相当于借了年息27%左右的高利贷。很多人问学数学有什么用，搞清楚这里面的猫腻，就是最现实的用途。&emsp;&emsp;当然，很多人会说，我还是算不清这里面的账，没关系，只要记住下面两个原则即可：&emsp;&emsp;借钱不要去所谓的P2P一类的机构。永远记住“卖的人比买的人精”，不要试图贪便宜。&emsp;&emsp;除了借款，我们很多时候还会把钱借给别人，还想拿到更高的利息收益。比如说你存银行或者买债券，当然银行通常把债券包装成理财产品，让你搞不清它的本质。实际上，这类固定收益的投资和买国库券是没有差别的，国库券风险很小，一般被认为是无风险利率，用来对比其他理财产品，我们就以它为例来说明。&emsp;&emsp;今天中国二手债券市场并不发达，大家很少交易二手国库券。但是在美国等发达国家，人们通常会有大约20%～30%的资产放在类似于国库券的债券上，而且二手债券交易频繁，很多中间商利用大家对微小利息变化带来的债券价值变化不敏感的弱点挣了很多钱。&emsp;&emsp;各国国债付利息的方式有两种，一种是到期后连本带息归还，还有一种是半年（或者一年）付一次利息。很多人觉得前者是利滚利，更合算，这其实是误解。因为当你在每半年拿到利息后，可以再买新的国库券，依然能实现利滚利。因此，这两种方式在投资上基本上是等价的，我们就以连本带息一次归还的债券来说明。&emsp;&emsp;假如你购买10000元十年期的国库券，（复利的）年息5%，10年后到期，你可以拿到6290元左右的利息，也就是说10年下来，你的投资获利62.9%，还是不错的。&emsp;&emsp;通常发行债券的机构会把它包装成年利率6.29%的单利金融产品，这样显得投资回报更高一些，也好计算一些。中国的国库券说的利息，都是折算后的单利利息，每年实际的回报要比标称的利息少一些。&emsp;&emsp;接下来我们看两种情况。第一种情况，如果你刚买了国库券，央行就加息0.5%，新的10年期国库券的（复利）利息变成了5.5%，你手上的国库券就瞬间贬值了。这是怎么回事呢？我们不妨假设你的邻居小明在加息后买了10000元的新国库券，他10年后大约能获得17080元，比你手上面值10000元的国库券多出了大约800元的利息。因此，我们可以得到第一个结论，加息意味着同样面值的债券实际价值的贬值 。&emsp;&emsp;另一种情况，你手上的国库券会升值，那就是降息。比如央行的利率降低了0.5%，相应10年期国库券的利率也下调到4.5%，这时你手上那10000元的国库券，就相当于10489元新发行的国库券，等于瞬间升值了5%左右。因此我们可以得到第二个结论，降息意味着同样面值债券的升值 。大家如果对里面的细节搞不太清楚，记住这两个结论就好。&emsp;&emsp;未来在中国，随着金融市场的完善，债券交易也会像股票交易一样普遍，大家都需要了解这方面的知识。而这里面核心的知识，就是复利增长的数学原理。**要点总结：**- 我们通过对比正规银行收取利息的方式，和那些打擦边球钻空子的P2P收取利息方式的不同，说明在贷款这方面有非常多的坑，你一不小心就要多支付很多倍的利息。- 我们通过利率和国库券等固定收益债券价值的关系，说明了利率的调整是如何影响到我们手头上投资产品的价格的。这两个例子实际上是我们这几天所讲述的数学知识的应用。大家既可以看到数学在生活中非常现实的用途，更应该看到它能够帮助我们更好地看待“趋势”这个概念。比如央行通过调整看似不多的利率，就会影响很多年债券价格的趋势。</details><h2><span id="mo-kuai-er-shu-xue-de-gai-nian">模块二 ｜ 数学的概念</span><a href="#mo-kuai-er-shu-xue-de-gai-nian" class="header-anchor">#</a></h2><h3><span id="11-ji-tu-tong-long-fang-cheng-zhe-ge-shu-xue-gong-ju-wei-shi-me-hen-qiang-da">11 ｜ 鸡兔同笼：方程这个数学工具为什么很强大</span><a href="#11-ji-tu-tong-long-fang-cheng-zhe-ge-shu-xue-gong-ju-wei-shi-me-hen-qiang-da" class="header-anchor">#</a></h3><!-- ![](/images/54.jpg) --><p>&emsp;&emsp;从这讲开始，我们进入第二模块的学习，看看人类对数的认知，是如何从具体到抽象的。</p><details><summary>...</summary>&emsp;&emsp;上学时，数学想要考高分，老师和家长总是会说，要多做题，题做得多了自然就会了。大部分人也确实通过题海战术取得了还可以的成绩，但是往往题目稍微改变就又不会了，而有些人，做题不多，成绩却很好，这其中的差别在哪里呢？&emsp;&emsp;我们先从一个大家最熟悉的鸡兔同笼问题讲起，这是现在小学生都要学习解决的数学题，它讲起来并不复杂，但是对于智力还在发育中的小学生，多少有点费劲。今天很多老师把做法教给学生们，大家长大后基本上也忘了，所以这样学数学基本上等于白学。&emsp;&emsp;鸡兔同笼这个问题是这样说的：&emsp;&emsp;在一个笼子里，有鸡和兔子，从上面数，数出来35个头，从下面数，数出来94只脚，请问鸡和兔子各有几只？&emsp;&emsp;这个问题最初出现在中国南北朝时期的《孙子算经》。《孙子算经》给了一个不算太好理解的解法，它是这么说的：>将所有动物的脚数除以2，也就是94/2 = 47。每只鸡有一对脚，兔子有两对脚。假设所有的动物都是鸡的话，就应该有35对脚，但事实上有47对脚。如果将一只鸡换成一只兔子的话，用47减去35，得到12，说明需要有12只鸡被换成兔子，这就是兔子的数目。知道了兔子的数目，鸡的数目也就知道了。&emsp;&emsp;不知道你听了这个解法是否明白了，我估计第一次听的人，听了之后至少要想几分钟，或者在纸上画一画，才能明白。上述方法是《孙子算经》里给的算法，它不缺乏巧妙性，但是太不直观。不直观的结果，就是无法让人举一反三，因为这个方法只针对这个特定的问题有效。比如我把问题改一下：&emsp;&emsp;假如有若干辆三轮车和汽车（四轮），一共有20辆，有65个轮子，请问有多少辆汽车，多少辆三轮车？&emsp;&emsp;这个问题就无法用上面的方法解决。因为无论先把车辆的轮子数除以3，或者除以4，都不可以，因为65既不能被3整除，也不能被4整除。&emsp;&emsp;这道题在古代就没法解了，中国古代有不少数学著作流传下来，里面解了不少问题，但是中国的这些数学论著相比欧洲的和阿拉伯的有一个大的缺陷，就是它们给出的都是一个个具体问题的解法，而不是一套系统的方法，因此再多解法也难穷尽所有的问题。&emsp;&emsp;今天小学里教的方法在通用性方面要比古代的方法好了不少。通常学校里会这么教：>我们假定笼子里全是鸡，那么应该有35 x 2 =70条腿。但是现在有了94条腿，多出24条，就应该是由四条腿的兔子造成的。如果我们用一只兔子替换一只鸡，就会多出两条腿，那么替换24条腿需要多少只兔子呢？24 / 2 = 12，于是就有12只兔子，剩下的就是鸡。&emsp;&emsp;这个方法可以直接解决上面的汽车和三轮车的问题，具体做法你可以想想，自己算一下：>我们假定都是三轮车，那么应该有20 x 3 = 60个轮子。现在有了65个轮子，多出了5个，它们应该是汽车造成的。如果用一辆汽车换一辆三轮车，就会多出1个轮子。现在多出了5个轮子，因此应该有5辆汽车。&emsp;&emsp;今天在学校里，如果遇上一个好老师能把鸡兔同笼问题讲透，孩子是能做出汽车和三轮车问题的。当然依然会有一些同学不会做，因为他们只是记住了鸡兔同笼算法，不会应用到其他问题上。&emsp;&emsp;这些学生要考满分，只好多做题，把三轮车的题目做一遍，再把其他相似的题目也做了，于是就很辛苦。但是即使能够灵活运用鸡兔同笼的解法，大部分人也还是不能解决所有这类问题，比如我再出一个题还是做不出来：&emsp;&emsp;红皮鸡蛋5元3个，白皮鸡蛋3元2个，小明花了19元，买了12个鸡蛋，问红皮的和白皮的各几个？&emsp;&emsp;这个问题其实是鸡兔同笼问题的变种，但是用上面改进的鸡兔同笼的解法也不管用。对于这个问题，有兴趣的同学可以在留言区讲讲你的解法，前提是不要用方程。&emsp;&emsp;那么能不能针对所有这些问题，提供一个寻找答案的思路呢？美国人的教法很有趣，下面我就和你分享一下。&emsp;&emsp;首先，在小学他们不教学生那些需要技巧的解法。对于鸡兔同笼问题，就是列表的笨办法。比如，在第一个例子中，他们先让学生们明白，兔子的数量不能超过94/4 = 24只，然后就列一张表，从24只开始往下试验，看看脚的数量有多少：![](/images/55.jpg)&emsp;&emsp;我当时看了他们的教科书，就想美国人真笨，果然数学学不好。&emsp;&emsp;但是发现他们再做其它相似的问题时，就可以从上述过程中受到启发，比如前面的鸡蛋问题，美国人也是列表：![](/images/56.jpg)&emsp;&emsp;事实上，只要是有整数解的各种二元一次方程的问题，都可以用列表这种笨办法解决。也就是说，美国小学的做法实际上是教给了大家一个很笨的，但是很通用的工具。这样，能解决一个就能解决很多，虽然办法很笨，很花时间，但总不至于让孩子们无从下手。&emsp;&emsp;至于那些解题技巧，他们很少在小学教，省得大家学不会，有挫败感。那些聪明的孩子，可以去上课外班。上述笨办法的另一个好处是，学生们在列表的过程中，更感受到数字变化的趋势，慢慢地就会知道大约从多少开始试验，而不是永远从零开始。&emsp;&emsp;相比之下，中国学校里教的那些聪明办法，常常和具体问题有关，除非是悟性很好的学生，普通孩子并不容易举一反三，因此家长总是责怪孩子笨。&emsp;&emsp;当然，在这一类问题中如果数字很大，列表就不太现实了。这时，老师会告诉大家，别着急，到了中学（或者小学高年级），学了解方程自然就会了。&emsp;&emsp;很多人在离开学校之后，除非辅导孩子，可能一辈子不会再解方程了，以至于会质疑为什么要在中学学习它。因为他们并不知道，方程就是用来解你之前不会的难题的，它是一个非常强大的解题工具，它可以让我们脑子想不清的很多数学问题变得非常直观、简单。&emsp;&emsp;还是以上面的鸡兔同笼问题为例。我们只要假设鸡有X只，兔子有Y只，然后列这样两个方程即可：<center>X+Y=352X+4Y=94</center>对于汽车和三轮车的问题，相应的方程是：<center>X+Y=203X+4Y=65</center>&emsp;&emsp;对于鸡蛋的问题，我们可以把问题稍微变一下，也是一样的解法，解法我放进文稿了，你可以先自己试着做一下，再看答案。&emsp;&emsp;解：红皮鸡蛋3个一盒5元，白皮鸡蛋2个一盒3元，一共花了19元买了12个鸡蛋，问红皮和白皮的各几盒？我们假设它们为X和Y，就有下面的两个方程：<center>3X+2Y=125X+3Y=19</center>&emsp;&emsp;X和Y分别是2和3，于是我们就知道两盒红皮鸡蛋有6个，白皮三盒也是6个。&emsp;&emsp;上述三组方程，对于高年级的学生来讲，做出来是分分钟的事情。如果你不教会他们方程这个工具，让他们苦思冥想，这几个问题还真有点绕脑筋。从这三个例子中，我们体会一下方程是什么，它是一种工具，这种工具有一整套合乎逻辑的解法，只要通过一个问题掌握这个解法，就能把成千上万的问题解决掉。这才是学习数学的正道，而不是做更多的题。&emsp;&emsp;那么如何把形形色色的题目抽象成同一类题目呢？这就涉及做数学应用题的核心关键了，就是要把用自然语言描述的现实世界的问题变成用数学语言描述的问题，比如列出方程。人的作用其实相当于一种翻译器，做练习题就是练习翻译，只要现实世界的问题变成了数学的问题，就能用现成的工具解决它们。&emsp;&emsp;学习数学也好，物理也好，其实关键不在于刷多少道题，而是在于理解它们中工具的作用，然后学会把生活中的问题用数学或者物理学的语言来表达，剩下的就交给工具了。&emsp;&emsp;多年前我问张首晟教授，为什么老一辈（当时50岁以上）的理论物理学家很少能再发表具有轰动性效应的论文？他说他们的数学工具不够先进，因为他们读研究生的时候学的数学和新生代科学家相比多有不足。&emsp;&emsp;对此我也深有体会。当我们掌握了中学的一些数学工具后，小学的各种数学难题就变得非常容易。当我们掌握了微积分这个工具后，很多中学的数学难题就不值一提了。我们常说，工欲善其事，必先利其器，这就是说明了工具的力量。&emsp;&emsp;中国古代在数学上有很多贡献，但大多集中在解决一个个具体的难题，而不是创造工具。相比之下，无论是古希腊还是后来的伊斯兰文明，在这方面贡献都要大得多。&emsp;&emsp;我们今天说的解方程，无论是有很多未知数的一次方程（比如我们前面给的三个方程组，它们的未知数的次数都只有一次），还是一元二次方程，比如X^2 + 2X = 3，在阿拉伯伟大的数学家花拉子密的著作《代数学》中都有详细的论述，只要读了他的这本书，一大堆数学问题就都会做了。&emsp;&emsp;相比之下，读那些只涉及到具体问题的书，就算读书破万卷，遇到新的问题还是没法解决，因此，学会把具体问题抽象成模型，才能解决更多更难的新问题。**要点总结：**&emsp;&emsp;我们用鸡兔同笼问题，说明了数学的本质是工具。美国人为了强调数学的工具性，在小学教学生们笨办法，但是从工具的角度讲却是一个好工具，到了中学，就有解方程这个工具。&emsp;&emsp;相比之下，我们学了很多针对具体问题的解题技巧，其实用处远没有想象的大。在学习数学时，我们最需要做的，就是将生活中的某些问题，由自然语言翻译成数学语言，然后用相应的工具来解决。&emsp;&emsp;最后介绍一下下一讲的内容，数学发展到花拉子密的时候，已经有了解决一元二次方程的公式了。但是在接下来的几百年里，没有人能够找到诸如X^3 + X + 1 = 0这样的一元三次方程的解法。当然最终它的解法还是被发现了，至于是谁发现的，则是数学史上一桩著名的公案，而这个方法的发现，你还可以看到数字的概念是如何从实数扩展到虚数的。&emsp;&emsp;欢迎你把这篇文章分享到自己的家长群，帮助家长朋友们和自己的孩子一起重新理解数学。我们下一讲再见。</details><h3><span id="12-san-ci-fang-cheng-shu-xue-shi-shang-de-fa-ming-quan-zhi-zheng">12 ｜ 三次方程：数学史上的发明权之争</span><a href="#12-san-ci-fang-cheng-shu-xue-shi-shang-de-fa-ming-quan-zhi-zheng" class="header-anchor">#</a></h3><!-- ![](/images/57.jpg) --><p>&emsp;&emsp;我们上一讲说了方程是一个能办具体问题，等量转化成类型问题的好工具，我们在中学也学了一元二次方程的解法，但是当学到一元三次方程时通常就被卡住了，因为没有通用解法，只有那些特殊方程用巧妙的办法才能把解凑出来。</p><details><summary>...</summary>&emsp;&emsp;现在回想起来，大家可能有疑问，那一元三次方程的解法是否有现成的公式可以套用呢？确实有！但是为什么世界各国的中学都不讲呢？因为这个公式太复杂，而且大家今天有了计算机，只要理解这一类方程的意义，让计算机帮助解决就好了。&emsp;&emsp;但是在过去没有计算机，大家对这一类问题束手无策，因此只能靠技巧来解个别具体的方程。直到15世纪，人类还不知道它的通解，当时在欧洲，谁能解几个三次方程，就算得上是数学家了。&emsp;&emsp;欧洲早期最著名的大学是意大利的博洛尼亚大学，它也是全世界最早的大学。该大学里面有一个叫费罗的数学家，他有一个学生叫菲奥尔，这个学生既不聪颖，也不好学，看样子将来是找不到工作了。&emsp;&emsp;费罗临死前就对他说，你将来怎么办啊，要不为师传给你一些秘诀，你将来就拿它去找最有名的数学家挑战，如果赢了他，也便能在数学界扬名立万站住脚了。不久费罗老师就去世了。&emsp;&emsp;菲奥尔在老师死后，果然混得不太好，于是就拿出了老师的秘籍，去找一个叫做塔尔塔利亚的数学家挑战，“塔尔塔利亚”是意大利语“口吃”的意思，这个数学家的真名叫做尼科洛·丰塔纳，但是今天大家都很少提及他的真名，而用他的绰号。&emsp;&emsp;当时欧洲数学家之间盛行挑战，就是各自给对方出一些自己会做的难题，如果自己做出了对方的题，同时把对方难倒了，就算赢了。1535年，菲奥尔听说塔尔塔利亚会解一些三次方程，当时大家还不知道三次方程的通解，解具体的三次方程都靠玩技巧，就给他出了一堆难题，像这样的一些：<center>$ x^3+8x+2=0 $$ 2x^3+7x+5=0 $</center>&emsp;&emsp;看了这些题目你会发现，它们都大同小异，都是解三次方程，而这些方程中都没有二次项。我们不妨将这些三次方程称为第一类的三次方程。费罗老师给菲奥尔留下的“九阴真经”，其实就是这一类方程的解法，费罗在发现了这样方程的通解后，除了悄悄告诉了自己的女婿，以及这位不上进的学生，没让旁人知道。&emsp;&emsp;在拿到菲奥尔给的这些难题后，塔尔塔利亚也毫不客气地给对方出了一堆难题，也是求解三次方程，但形式上略有不同，诸如下面这样：<center>$ x^3+x^2-18=0 $</center>&emsp;&emsp;它没有一次项，但是有二次平方项，我们不妨将它们称为第二类的三次方程。这一类三次方程的解法，塔尔塔利亚已经想出来了。双方约定30天为期，并且压上了一笔钱做赌注，于是比赛算是正式开始。&emsp;&emsp;菲奥尔看了一眼对方的题，知道自己做不出来，也就根本没打算做。然后他每天晚上跑到塔尔塔利亚的窗外去侦察，看看对方进展怎么样。菲奥尔的如意算盘是，对方也做不出来自己的题，于是双方打平，这样菲奥尔就一战成名，比肩塔尔塔利亚了。&emsp;&emsp;塔尔塔利亚并不知道这些，他就每天从早到晚在书房里做数学题。眼看30天的期限快到了，塔尔塔利亚还没有解出来，菲奥尔暗自高兴，这场比赛看似能打平。然而，皇天不负有心人，塔尔塔利亚最后经过努力解出了对方的难题，赢得了比赛，菲奥尔自然就退出了历史舞台。在这之后，塔尔塔利亚又花了6年时间，完全解决了一元三次方程的问题，这是后话了。&emsp;&emsp;从1535年开始，就有很多人想从塔尔塔利亚那里学习三次方程的解法，但是塔尔塔利亚就是不说。后来有一位叫做卡尔达诺的数学家，不断恳求塔尔塔利亚，想知道第一类和第二类一元三次方程的解法，后者受求不过，让卡尔达诺发下毒誓保守秘密后，将第一类三次方程的解法告诉了他。&emsp;&emsp;卡尔达诺有一个学生叫费拉里，这个人很厉害。这师徒俩在塔尔塔利亚工作的基础上，很快发现了所有一元三次方程的解法，我们可以把它称为是通解。他们俩自然兴奋不已。但是由于之前发了誓要保守秘密，因此他们不能向外宣布自己的发现，这让他们非常郁闷。&emsp;&emsp;几年后，也就是1541年，塔尔塔利亚也发现了所有的一元三次方程的解法，但是他依然保守秘密，不和别人说。&emsp;&emsp;1543年，也就是塔尔塔利亚和菲奥尔的挑战赛过去八年之后，卡尔达诺和费拉里访问了博洛尼亚，在那里他们见到了费罗的女婿，得知费罗早就发现了第一类和第二类一元三次方程的解法，这下让这师徒二人兴奋不已，因为觉得憋在心里的话终于可以说出来了。&emsp;&emsp;于是卡尔达诺决定不需要再恪守对塔尔塔利亚的承诺了，便于1545年将所有一元三次方程的解法发表了，这本书的中译名叫做《大术》（Arts Magn，就是《数学大典》的意思），这是过去关于代数学一本非常重要的书。&emsp;&emsp;在书中，卡尔达诺讲，费罗是第一个发现了一元三次方程的解法的人，他所给出的解法其实就是费罗的思想。同时在三次方程解法的基础上，费拉里还给出了一元四次方程的一般性解法。&emsp;&emsp;塔尔塔利亚知道了这件事，当然对卡尔达诺极为愤怒，认为他失信。失信在当时学术圈是一件了不得的事情。不过卡尔达诺解释道，他没有发表对方的工作，而发表的是费罗很多年前的工作，因此没有失信。&emsp;&emsp;这件事在当时就成为了一件很轰动的事情，而双方各执一词，旁人也分不出是非，于是只好采用“决斗”的方式来解决，当然，这种决斗是数学家们比拼智力，而非武力相向。&emsp;&emsp;卡尔达诺这一边决定由学生费拉里出战，他和塔尔塔利亚各给对方出了些难题，结果费拉里大获全胜。从此塔尔塔利亚就退出了学术圈。不过今天三次方程的标准���法公式依然被称为费拉里-塔尔塔利亚公式，大家并没有完全否认他的功绩。&emsp;&emsp;说到这里有人可能会问，既然一元三次方程有标准的解法公式，为什么我们中学的时候，老师不讲，而让我们费劲巴拉地用各种技巧来算呢？更糟糕的是，解每一道题的技巧都不一样，以至于我们学习得特别辛苦。&emsp;&emsp;要回答这个问题，我先把标准解法的公式，即费拉里-塔尔塔利亚公式给大家看一眼：![](/images/58.jpg)&emsp;&emsp;要算出它的第一个解，需要先算下面三个中间变量。![](/images/59.jpg)&emsp;&emsp;然后再根据这三个中间变量，按照下面的公式算出第一个解。![](/images/60.jpg)&emsp;&emsp;有了一个解，三次方程就可以简化为二次的，接下来就好解决了。&emsp;&emsp;我估计你看了上面这一堆密密麻麻的公式，头已经开始大了。因此，中学不教这个公式是对的，否则会把学生们都吓回去。但是，老师又不能完全不讲怎样解一元三次方程，于是学校就教了一大堆解特殊方程的方法，聪颖用功一点的学生学得多一些，成绩就好一些，条件差的学生学会的技巧就少一些。但是那些技巧你无论学多少，都很难举一反三。&emsp;&emsp;相比之下，我倒觉得美国中学的教法更好一些，它除了教学生们最简单的，谁都能学会的技巧，还有就是让学生们使用一种叫做Mathematica的软件工具来自动解决。&emsp;&emsp;根据我个人的体会，今天学习数学，重要的是把实际问题变成数学问题，然后知道如何利用各种软件工具来解决，而不是花很多时间学一大堆无法举一反三的技巧。讲到Mathematica，我还要说一句题外话，这款软件可以推导你能遇到的几乎所有数学公式，他的编写者沃夫兰姆是一位真正的天才。20岁便博士毕业了。&emsp;&emsp;因此我想对很多家长说，不要高估自己孩子的智商，当然，也不要埋没他们在某些方面的天赋。大部分人老老实实学好数学的基本方法，理解其中的思维方式最重要，不要苦练解题技巧。需要技巧的时候，我们应该善于利用沃夫兰姆的大脑，不要自己傻推公式。&emsp;&emsp;现在，我想让你再看一眼上面这一大堆密密麻麻的公式，把注意力集中在那个根号上。我们知道，如果根号里的数字是负数，那么它在过去是没有意义的。在解二次方程时，我们可对这个问题视而不见，直接宣布它没有实数解即可。&emsp;&emsp;但是三次方程是一定有实数解的（原因以后再讲），因此这个根号里面负数的问题就回避不掉，为此，数学家们就不得不正视这个问题，并且引入了虚数的概念。关于虚数我们明天会详细讲，今天只是通过这段历史，介绍它的来源和存在的必要性。**要点总结：**&emsp;&emsp;首先，通过数学史上这段著名的公案，说明了数学定理发明的过程。通常先有引理，你可以把引理看成是一个简单、辅助性的定理，它们存在的目的是为了后面证明定理。在一元三次方程的解法里，无论是费罗对第一类三次方程，还是塔尔塔利亚对第二类三次方程的解法，只能算是引理，它们能解决部分问题，但不具有普遍意义，不能算定理。&emsp;&emsp;后来卡尔达诺、费拉里和塔尔塔利亚发现的对于任意三次方程的解法，则可以看成是定理，它是建立在引理之上的。定理具有里程碑的意义，但它不是凭空产生的。数学的发展是层层叠加的，学习数学也应该如此，理解这一点是学习好理科课程的关键。&emsp;&emsp;其次，我们要特别强调数学是个工具，学习数学是练习自己使用工具的能力，花很多时间在学习小的解题技巧上不值得。因此不要因为掌握不了一个小技巧而沮丧。最要注重学习的是概念，以及概念之间的联系，然后能够把现实的问题转化为数学问题。接下来怎么解决，工具是很多的。&emsp;&emsp;那么三次方程的解到底是怎么得出来的？这就需要人类再次抽象对数的认识，虚构出一个认知工具来，我们下一讲再见。</details><h3><span id="13-xu-shu-xu-gou-zhe-ge-gong-ju-you-shi-me-yong">13 ｜ 虚数：虚构这个工具有什么用</span><a href="#13-xu-shu-xu-gou-zhe-ge-gong-ju-you-shi-me-yong" class="header-anchor">#</a></h3><!-- ![](/images/62.jpg) --><p>&emsp;&emsp;我们上一讲讲了一元三次方程的解法，说里面可能涉及到一种并不存在的虚数。也就是说它们自身的平方是负数。</p><details><summary>...</summary>&emsp;&emsp;虚数在现实中显然不存在，我这讲会通过这个例子告诉你，数学家是如何虚构一个现实中不存在的概念，解决现实问题的。&emsp;&emsp;我们在初中学到平方根这个概念时，老师会说，只有正数和零才有平方根，没有哪个数字自己乘以自己会等于负数。在解二次方程时，我们可能会遇到根号里面有一个负数的情况，但是老师说，不用管它，我们就认定它无实数解即可。&emsp;&emsp;但是当学到了三次方程时，这个问题就回避不了了，因为根据上一讲介绍的公式，即使一个有实数解的三次方程，在求解的过程中，也会遇到要对负数开根号的情况。比如下面这个方程：<center>X^3-15X-4=0</center>显然X=4是一个解。&emsp;&emsp;但是，如果我们利用昨天说的费拉里-塔尔塔利亚公式算，得到的是这样一个解，听音频的朋友可以看一眼，你不用关注细节，只要留心里面有√-121就好。![](/images/63.jpg)&emsp;&emsp;于是给负数开根号这件事就绕不过去了。数学家们只好虚构出一个数，让它的平方等于-1，这个数我们常常把它写成字母i，就是拉丁语中imagini（相当于英语中的image）“影像”一词的首字母，它代表非真实、幻影的意思。&emsp;&emsp;有了这个人造的、虚幻的数，上面那个复杂的一堆根号的式子就能计算下去了，而且算出来就是4。你可能会问其中的虚数去哪里了，很有意思的是，它们正负抵消了，数学基础比较好的同学可以自己推导一下，算是留给你的思考题。&emsp;&emsp;这件事你如果细想是很有意思的。如果我们真实的世界里有一个三次方程，比如给一些限制条件后计算一个长方体的尺寸，也就是解三次方程的问题，卡尔达诺等人找到了一个公式，可以计算出问题的答案，但是算到一半你就遇到一堵墙越不过去了，于是你引入一个不存在的工具，用了一下就翻过墙了。&emsp;&emsp;这在哲学上其实很有意思，**明明是现实世界的问题，而且在现实世界里也有答案，但是却无法直接得到，非要发明一个不存在的东西作为桥梁。**&emsp;&emsp;怎么能够形象地理解虚数这种抽象概念的作用呢？我们的数学课基本上不讲，老师只是说，记住它的定义就好，回头学生们就一头雾水了。我通常用三个例子来形容它的作用。&emsp;&emsp;一个是化学中的催化剂。我们知道，催化剂在化学反应完成前后是不改变的，它只是起到一个媒介的作用，但是没有它，化学反应要么特别慢，要么干脆进行不下去。&emsp;&emsp;另一个例子不算太确切，但是好理解，就是传话筒。我们经常看到这样的现象，夫妻俩吵架后，谁也不愿意和对方说话，但是都清楚这个交流不能中断，要继续下去，于是就找孩子带话，比如教孩子说：“去，和你妈说明天的家长会我去，她就不用去了。”孩子把这个意思传递后，又带回一句话：“妈妈说，你要是去开家长会，她就先回家做饭了。”&emsp;&emsp;这样传几次话，可能夫妻间的问题就解决了。在这个过程中，夫妻间的问题不涉及到孩子，孩子在传话时甚至不明白其中的含义，但是没有这个局外的传话筒，夫妻之间的问题可能就解决不了了。&emsp;&emsp;最后一个例子是虫洞。我们接下来就开一下脑洞。假如你和一个相爱的人在同一个宇宙中，但相隔几十光年，你想对她说一句我爱你，但哪怕你搭载光速飞船去找她，她听到的时候都已经老了。&emsp;&emsp;现在有一个虫洞，你可以从中穿过去，在瞬间到达另一个平行宇宙中，然后再从另一个虫洞穿回现在的宇宙，这也是瞬间的事情，这样你就能很快到她身边了。你们二人本来是在同一个宇宙中，但是却要依赖另一个和你们无关的宇宙来回穿越。&emsp;&emsp;虚数也是如此，在上面的式子中，我们把它创造出来，又把它正负相抵消，该得到实数的答案依然是实数的。从更广义的角度讲，很多数学工具都是如此，它们并非我们这个世界存在的东西，而是完全由逻辑虚构出来的。但是我们现实世界的事情，却要用这些虚构的工具来解决。&emsp;&emsp;那么虚数除了解三次方程还有什么用？它的用途可以归结为三个层面。&emsp;&emsp;**第一个层面是对于数学本身的影响。**引入虚数的概念后，数学的一些逻辑上可能的漏洞就被补上了。&emsp;&emsp;比如说，在实数的范围内，X^2+1=0是无解的，这样一来，有的多项式方程有解，有的无解，数学就不完美了。引入一个虚拟的概念，虚数i，就让所有的方程都变得有解了。更漂亮的是，引入虚数的概念后，所有的一元N次方程都会有N个解，没有例外。&emsp;&emsp;**第二个层面是作为工具的作用。**有了虚数之后，很多复杂的数学问题，可以用简单的方法解决，这就如同前面介绍的三次方程的解法问题。这个问题虽然引出了虚数的概念，但是并不是它最大的用途。虚数作为数学工具最大的用途，可能是便于将直角坐标变成极坐标。&emsp;&emsp;关于这两种坐标我们后面还会讲，简单地讲，在飞行、航海等场景里，极坐标更方便使用，比如我们说往两点钟的方向飞行20公里，这就是极坐标的描述方式。在极坐标的计算中，如果只用实数，非常复杂，如果引入虚数，就极为简单。&emsp;&emsp;**第三个层面是应用层面。**量子力学、相对论、信号处理、流体力学和控制系统的发展都离不开虚数。&emsp;&emsp;通过虚数这个例子，我首先想说的是，人类可能是唯一一个能够构想出不存在的事物的物种，这个能力对我们来讲非常重要。在我们生活的世界里，存在着大量的构想出来的东西。比如早期的人类要靠宗教崇拜团结起来，虽然最后一起去打仗，去探险的都是人，但是要没有宗教，人和人直接沟通，达不到团结的目的。&emsp;&emsp;今天虽然大家不太需要宗教了，但是很多虚拟的概念已经深入我们人心，比如法律、有限公司、法人团体等概念便是如此，它们在自然界中并不存在，只是人们脑子里构建出的概念，但是如果没有它们，这个社会就运行不下去。当我们习惯于使用这些虚构的概念后，就会把它们真实化，感觉和真的一样。&emsp;&emsp;为了让大家更好地理解这一点，我们不妨看一个法律学的概念——法人。&emsp;&emsp;在早期的罗马法中，提出了法律主体的概念，它最初只涉及到自由人，后来因为要处理经济纠纷，就把一些机构看成是法律的主体，当作人一样看待，这就是法人概念的来源。这些法人，其实就相当于数学中所说的虚数的概念。&emsp;&emsp;我们今天和一个公司打官司，其实在打官司的过程中接触到的还是人，但是你不会去告里面某个具体的人，而是针对这个虚构出的组织。当你打赢这个官司后，是里面具体的人执行对你的赔偿，但是你拿到的赔偿却是法人这个机构给你的。这就如同解方程时，我们需要借助于虚数，得到实数的解一样。&emsp;&emsp;今天，衡量一个人认知水平的一个方法，就是看他接受虚拟概念的能力有多强，如果他只停留在看得见摸得着的东西，这个人的水平就不是很高。我们经常说那些只知道买房置地，收藏奢侈品的人是土财主，其实也是这个道理。&emsp;&emsp;其次，虚数的出现，标志着人类对数这个概念认识的进步，特别是从形象思维到抽象思维的进步。&emsp;&emsp;人类早期认识的数字都是正整数，1，2，3，4……因为大家接触到的周围的世界就是这样实实在在一个又一个的东西。事实上除了古印度，其他文明在早期数字中都没有零这个数，因为零这个概念比较抽象，人类从有数字开始花了几千年才搞明白。&emsp;&emsp;接下来有了数字就要做运算，两个自然数相加或者相乘，结果还是自然数。但是，到做减法和除法时就出现了问题，因为2-3=？，2/3=？在自然数中找不到。于是人们就发明了负数和分数（就是有理数）的概念。这两个概念就比自然数要抽象一些了。&emsp;&emsp;很多人觉得数学越到后来越难学，就是没有能突破抽象思维的瓶颈。有了正负的概念，有了分数的概念，就形成了有理数的概念，加减乘除和乘方五种运算就都没有问题了。自从毕达哥拉斯定理被发现，人类就不得不面对开方这件事，就不得不定义出无理数。&emsp;&emsp;再往后，又因为要对负数开方，便发明了虚数的概念。实数和虚数合在一起，就形成了复数。我把人类认识数的过程用一张图表示出来，它是从中心往四周扩散的：![](/images/64.jpg)&emsp;&emsp;那么复数有什么用呢？为什么要搞出这么一个在现实世界中完全不存在的概念呢？仅仅是为了让开方运算变得完备么？当然不是。复数是一个非常强大的数学工具，使用这个建立在现实生活中所不具备的事实的基础之上的数学工具，可以解决很多现实世界里的问题。&emsp;&emsp;这句话可能听起来有点绕口，换一种方式讲是这样的，复数的基础在现实世界里并不存在，但是建立在不存在基础上的工具，却能解决实际问题。&emsp;&emsp;比如我们使用的三相交流电是实实在在地存在的，它里面的很多问题，用复数这个工具解决，要比用实数加上三角函数解决起来容易得多。实际上，涉及到电磁波的几乎所有问题，都需要使用复数这个工具来解决。&emsp;&emsp;对于今天的内容，你如果体会到像虚数这样媒介工具的作用，以及通过数字的扩展历史，体会到人类认知升级的过程，就算是掌握精髓了。&emsp;&emsp;下一讲，我们再继续突破认知，去理解无限的世界。欢迎你把文章分享到自己的家长群，帮助家长朋友们重新理解数学，帮孩子把数学变得更容易。我们下一讲再见。</details><h3><span id="14-wu-qiong-wo-men-wei-shi-me-nan-yi-li-jie-wu-xian-de-shi-jie">14 ｜ 无穷：我们为什么难以理解无限的世界？</span><a href="#14-wu-qiong-wo-men-wei-shi-me-nan-yi-li-jie-wu-xian-de-shi-jie" class="header-anchor">#</a></h3><!-- ![](/images/65.jpg) --><p>&emsp;&emsp;我们在前几讲的课程中讲了人在数学上认知进步的过程，从具体数字、具体问题到用方程解决类型问题，用抽象的虚数解决现实问题。今天我们看看人类怎样进一步突破对数的认知局限，动态认识数的。当然，讲突破之前，先要讲讲人是如何受困于认知局限性的。</p><details><summary>...</summary>&emsp;&emsp;庄子有句话：“夏虫不可以语于冰者，笃于时也。”意思是说，夏天的虫子无法理解冰雪，因为它受限于生命的时长，等不到能看见冰雪的冬天就死了。其实在庄子看来，人的生命也很短暂，认识也很有限。&emsp;&emsp;他说，“吾生也有涯，而知也无涯”，就是说用短暂、有限的生命，无法理解无限世界的事情。不过，人具有想象力，虽然看不到无限的事物，却能想象出一些规律，并且通过逻辑保留合理的。**有些人做到了这一点，他们的认知水平就比其他人高出好几个层次了。**&emsp;&emsp;我们今天就从无穷大说起，说说认知升级的事情。&emsp;&emsp;说起无穷大，先要说大数字。小孩子们常常爱比谁说的数大，比如一个孩子说出一百，另外一个孩子说一万。别的孩子就问了，一万有多大？他说，一万就是一百个一百，别人只好不说话认输了，因为孩子们还是有基本逻辑的，知道一百个一百显然比一个一百多。&emsp;&emsp;当然，过两天输了的孩子跑去问家长，从家长那里知道一亿这个数，他就又赢回来了。这时，如果输了的孩子脑瓜子灵，会说出两亿来翻盘，最后孩子们就不断地喊，一亿亿亿亿亿亿……，最后是肺活量最大、气最长的那个孩子赢。&emsp;&emsp;接下来，可能又有孩子要回去问家长，家长告诉他无穷大，这回，他就可以回去秒杀那些一亿亿亿……不断喊下去的孩子们了。但是你要问他无穷大是多少，谁也说不出来，大家只是接受了这个虚构的概念，认为它是世界上最大的数。&emsp;&emsp;下面我就问大家一个问题，无穷大是一个数吗？它可以被看成是数轴的终点吗？它在数学上和某个具体的大数一样大吗？&emsp;&emsp;这些很基本的问题很多人在大学里学完高等数学其实也没有一个明确的概念，在绝大多数人心目中，无穷大是一个数，只是它比你能想象的数更大而已，人们依然会用理解一些具体数字的方式去理解它。无穷大的世界和我们日常认知的世界完全不一样。&emsp;&emsp;当然人类也是直到现代才开始正确认识无穷大。1924年，大数学家希尔伯特讲了一个旅馆悖论，让人们重新认识无穷大的哲学意义。他的悖论是这样讲的：&emsp;&emsp;假如一个酒店有很多房间，每一个都住满了客人，这时你去酒店问，还能给我安排一间房子吗？老板一定说：“对不起，所有的房间都住上了客人，没有办法安排您了。”&emsp;&emsp;但是，如果你去一家拥有无限多个房间的旅馆，情况可能就不同了。虽然所有的房间均已客满，但是老板还是能帮你“挤出”一间空房的。&emsp;&emsp;他只要这样做就可以了。他对服务生讲，将原先在1号房间的客人安排到2号房间，将2号房间原有的客人安排到3号房间，以此类推，这样空出来的1号房间就可以给你了。类似的，如果来了十个、八个人，也可以用这种方式安排进“已经满客”的酒店。&emsp;&emsp;接下来的问题来了，既然每个房间都被现有的客人占据了，怎么又能挤下新的客人？因此我们说这是悖论。但是“旅馆悖论”其实并不是真正意义上的数学悖论，它仅仅是与我们直觉相悖而已。&emsp;&emsp;在我们的直觉中，每个房间都被占据，和无法再增加客人是等同的，但这只是在有限的世界里的等价性，在无穷大的世界里，数学中的很多逻辑都需要重新梳理一遍。我们在有限的世界里得到的很多结论，放到无穷大的世界里，需要重新检验，有些能够成立，有些不成立。&emsp;&emsp;比如说在有限的世界里，一个数加上1就不等于这个数了，因为比它大1，但是在无穷大的世界里，这条结论就不成立，因为无穷大加1还是无穷大，就如酒店悖论中的那个酒店一样，再增加一个客人，酒店依然能够容纳得下。&emsp;&emsp;事实上，在希尔伯特做完那个报告后，全世界数学家不得不回去把所有的数学结论在无穷大的世界里又推导了一遍，看看有没有什么漏洞。&emsp;&emsp;在上面的问题中，客满的、无穷多房间的旅馆，不仅可以增加有限个客人，甚至能增加无限个新客人。那么当无限的客人来住店，怎么办呢？具体的做法是这样的，我们让原来住在第1间的客人搬到第2间，第2间的客人搬到第4间，第3间的搬到第6间。&emsp;&emsp;总之，就是让第N间的客人搬到第2N间即可。这样就腾出无数间的客房安排新的客人了。我们知道一万乘以2是两万，不等于原来的一万，但是无穷大乘以2还是无穷大，并不是两个无穷大。&emsp;&emsp;无限集合的性质与有限集合的性质并不相同。对于拥有有限个房间的旅馆，其偶数号房间的数量显然总是小于其房间总数的，比如1万个房间，偶数号的有5000间，不等于总数。然而，在无穷房间的旅馆中，偶数号房间的数量与总房间数量是相同的。&emsp;&emsp;类似的，我们可以证明一条长5厘米的线段上的点，和一条长10厘米线段上的点是“一样多”的。这个证明也很简单：![](/images/66.jpg)&emsp;&emsp;在图中，下面的线段长度是10厘米，上面的是5厘米。我们将它们平行放置，于是将它们两端相连（虚线），就会交会到一个点S处。接下来，对于10厘米长线上的任意一个点X，我们将X和S相连，就和5厘米短线有一个交点，我们假设为Y，这就说明长线上的任意点，在短线上都可以找到对应点。&emsp;&emsp;因此，短线上的点应该不少于长线上的点。这样，在无穷大的世界里，我们可以认为10厘米线段上点的数量和它的一个子集，即5厘米线段上的点是“相同的”。当然更准确的说法是基数相同。&emsp;&emsp;接下来就有一个问题了，不同类型的无穷大，比如整数的个数，或者10厘米长线段上的点数，它们彼此能比较么？答案是可以，这里面的细节我们省略了，在这里我直接给大家答案，就是一根很短的线段上的点数，要比所有的有理数数量都多，前者的基数比后者大。我知道这可能有点颠覆你的直觉，但这个结论是正确无疑的。&emsp;&emsp;讲到这里，我们一开始的问题，“无穷大是不是一个特别特别大的数？”现在有答案了。它不是一个具体的数，它和万亿、googol数（10的一百次方）等等都不同。它不是静态的，而是动态的，它反映一种趋势，一种无限增加的趋势。在增大的过程中，有的无穷大会比其它的更大，因为它变化的趋势比其他的无穷大更快，这一点我们后面会仔细讲。&emsp;&emsp;对于无穷大的概念，关键要理解它是动态变化到了最终尽头的描述。事实上，无穷大（和以后要介绍的无穷小）代表着一种新的科学世界观，就是让我们关注动态变化的趋势，特别是发展变化延伸到远方之后的情况。&emsp;&emsp;上面这些关于无穷大世界的特点可能有些颠覆你的认知，这并不是说你原先的认知有问题，而是说我们在有限世界里得到的认知太狭隘了，相比浩瀚的宇宙和人类的知识体系，我们的认知可能就如同夏天的虫子，受限于我们的生活环境。这也是我们比较接受通识教育的原因，因为这样可以让我们以最快速度走出我们认知的围墙。&emsp;&emsp;当然，有些同学可能会问，了解无穷大世界这件事情有什么现实的意义？它的意义很多，这里我不妨说一个具体的例子。&emsp;&emsp;我在《谷歌方法论》中讲到了关于计算机算法的衡量标准。假如有三个完全相同功能的算法，A、B和C。- 算法A要进行100,000*N次运算；- 算法B要进行N^2次运算；- 算法C要进行N次运算。请问哪种算法好？&emsp;&emsp;很多人会说，当然是算法C好，至于A和B，要看情况。如果N<100,000，那么算法b更好，否则就是算法a好。比如，n是20万时，a方案就相当于10万*20万，b方案相当于20万*20万，可见b是很大的。 &emsp;&emsp;但是，在计算机科学中，衡量两个算法的复杂度时，只会考虑这两种算法在处理近乎无穷大的问题上的表现，也就是n趋近于无穷大的情况。因为它关心的是，当问题越来越复杂后，每一种算法所需要消耗的计算机资源（比如计算时间）的增长趋势。这样一来，算法b显然是计算量最大的。="" &emsp;&emsp;至于两个算法在复杂度上只差出常数倍，在计算机科学上就认为它们是等价的。对计算机科学家们来讲，将一个算法从平方的复杂度降低到线性，这是捡西瓜的事情，将一个线性复杂度的算法的计算量再减小几倍，这是捡芝麻的事情。这些内容我们在后面会更仔细地分析。="" **要点总结：**="" &emsp;&emsp;首先，我们通过希尔伯特旅馆悖论，说明生活在有限世界的人，其实很难想象无穷大的世界，在那里，很多规律和有限世界是不同的。比如说，在无穷大的世界里，部分可以完全和整体等价。="" &emsp;&emsp;因此，我们不能以有限的认知，去理解无限的事物，也不能把那些从很少的经验中得到的结论，放大后用于更大的场景。比如，有些人受过一两次骗，就得到一个结论，世界上没有一个是好人。这就陷入了以有限的经验理解无限事物的误区。="" &emsp;&emsp;接下来我们强调了，无穷大并非是一个静态的、具体的大数字，而是一个动态的、不断扩大的变化趋势，希望通过这个概念，提示大家能够以动态的眼光看待世界。="" &emsp;&emsp;至于无穷大这个概念的现实意义，我们举了计算机科学中算法复杂度的例子，量级的差异，要比同量级之间几倍的差异重要得多。我们在工作中，要优先考虑量级的提高，而不是捡芝麻的事情。="" &emsp;&emsp;接下来三讲，我会拿无穷小为例，详细解释什么是动态地看世界。我们下一讲再见。="" <="" details=""><h3><span id="15-wu-qiong-xiao-yi-ru-he-shuo-fu-gang-jing-zhi-nuo">15 ｜ 无穷小（一）：如何说服杠精“芝诺”？</span><a href="#15-wu-qiong-xiao-yi-ru-he-shuo-fu-gang-jing-zhi-nuo" class="header-anchor">#</a></h3><!-- ![](/images/78.jpg) --><p>&emsp;&emsp;上一讲我们讲了无穷大，主要是从突破认知局限的角度来讲的。在接下来的三讲里，我们来讲讲无穷小。</p><details><summary>...</summary>&emsp;&emsp;你可能会奇怪，为什么无穷小要花三讲来介绍？它不就是零么？有什么好讲的。如果你把无穷小看成是一个数，确实没什么好讲的。但遗憾的是，无穷小并不是一个确定的数，更不是零，它和无穷大一样，是一种趋势，一种帮助我们把握“动态”和“变化”的工具，也是一种新的认知世界的方式。&emsp;&emsp;一个人是小学数学水平，还是高等数学水平，不在于是否会做高等数学的练习题，而在于他在把握世界变化方面处在什么层次上，那么他是否掌握了无穷小这个概念，就是很好的检验标准。&emsp;&emsp;因此，从概念的来龙去脉到数学家最后的应用，我有必要花3讲，来为你解释清楚。&emsp;&emsp;世界上最初认认真真思考无穷小这个概念的，是公元前五世纪时古希腊的芝诺，后世虽然把芝诺说成是数学家，但其实他一生没有留下什么数学成果，因此对他的生平鲜有记载。&emsp;&emsp;由于他是一个“杠精”，喜欢和人辩论，而且还提出了好几个自己搞不清楚，别人也解释不了的问题，因此被亚里士多德写进了书中，后人才知道有这个人存在。&emsp;&emsp;我们不妨看看他的四个著名的悖论：**悖论一（二分法悖论）：从A点到B点是不可能的。**&emsp;&emsp;看了这个命题，你会马上说，这怎么不可能？别着急，我们先来看看芝诺的逻辑。&emsp;&emsp;芝诺讲，要想从A到B，先要经过它们的中点，我假设是C点，而要想到达C点，则要经过A和C的中点，假设是D点……这样的中点有无穷多个，找不到最后一个。因此从A点出发的第一步其实都迈不出去。**悖论二（阿喀琉斯悖论）：阿喀琉斯追不上乌龟。**&emsp;&emsp;我们知道阿喀琉斯是古希腊神话中著名的飞毛腿，但是芝诺讲如果他和乌龟赛跑，只要乌龟跑出去一段路程，阿喀琉斯就永远追不上了。按照我们的常识，芝诺的讲法当然是错的。不过我们还是听听他的逻辑。&emsp;&emsp;为了方便起见，我们简单地假设阿喀琉斯奔跑的速度是乌龟的10倍。如果乌龟先跑出10米。等阿喀琉斯追上了这10米，乌龟又跑出1米，等阿喀琉斯追上这1米，乌龟又跑出0.1米……总之阿喀琉斯和乌龟的距离在不断接近，却追不上。&emsp;&emsp;这两个悖论其实本质上是一个。我们如果从常识出发，觉得芝诺的观点不值一驳。我们从天安门出发，一步就走过了芝诺所说的无数中点，阿喀琉斯一步迈得大一点，不就超越乌龟了吗？在这里我们的常识当然没有错。&emsp;&emsp;但是，如果按照芝诺的逻辑来思考，他似乎也有道理，只是忽略了一些事实，因此要想驳倒他，让他心服口服，就不能绕过他的逻辑！在解释这个问题之前，我们再来看看他的另两个悖论。**悖论三（飞箭不动悖论）：射出去的箭是静止的。**&emsp;&emsp;在芝诺的年代，运动最快的是射出去的箭。但是芝诺却说它是不动的，因为在任何一个时刻，它有固定的位置，既然有固定的位置，就是静止的。而时间则是由每一刻组成，如果每一刻飞箭都是静止的，那么总的说来，飞箭就是不动的。&emsp;&emsp;这个悖论，可能就比前两个难辩驳了。**悖论四（基本空间和相对运动悖论）：两匹马跑的总距离等于一匹马跑的距离。**&emsp;&emsp;如果有两匹马分别以相同的速度往两个方向远离我们而去，我们站在原地不动。在我们看来，单位时间里它们各自移动了一个单位Δ（Δ通常表示增量），显然一匹马跑出去的总距离就是很多Δ相加。但是如果两匹马上有人，那么在彼此看来，对方在单位时间却移动了两个Δ长度，彼此的距离应该是很多两倍的Δ相加。![](/images/61.jpg)&emsp;&emsp;那么，如果Δ非常非常小，小到无限接近于零，芝诺就干脆认为Δ=0，0乘以任何数还是0，那么1Δ＝2Δ。但是左右两匹马跑出去的总距离怎么可能等于一匹马跑的距离呢？其实芝诺的错误就是把无穷小直接当做了0。&emsp;&emsp;听了这些问题不知道你有何感觉。我想，除了当年庄子和惠子也讨论过类似的问题之外，绝大部分时候中国人讲究的是要学以致用，因此，在古代，士大夫们是不屑于理会芝诺的这种没有用的傻问题。&emsp;&emsp;直到今天这种情况其实也没有太多的改变，我在大学时，一些老师还觉得这一类的问题是唯心主义的。但是正是这些问题，让古希腊文明和其它文明有所不同，而这种严守逻辑的思维方式，才让数学和自然科学成体系地发展。&emsp;&emsp;当逻辑和我们的经验有了矛盾时，**有两个结果，一个结果是我们的经验错了**。比如说，到底是地球围绕太阳转，还是太阳围绕地球转？在这件事上，我们的经验就错了。**当然还有一个可能性就是，我们看似正确的逻辑，本身可能有问题，因为有概念的缺失，芝诺的这两个悖论就属于第二种。**&emsp;&emsp;在这种情况下，找到了所缺失的概念，或者分清了不该混淆的概念，数学或者科学就获得一次巨大的发展。我们前面讲的从毕达哥拉斯定理引出无理数的概念，也属于这一种。今天回答芝诺的问题其实很容易，因为有了无穷小的概念，以及微积分中关于导数的概念，这个缺失被补上了。&emsp;&emsp;今天我们就用无穷小的概念回答芝诺的第1、2和第4个悖论，由于第一个和第二个悖论其实是一回事，我们只讨论第二个，也就是阿喀琉斯和乌龟赛跑的例子。至于第三个悖论，我们下一讲讲到导数的时候会回答。&emsp;&emsp;话说在芝诺之后的上千年里，欧洲总有人不断地试图找出芝诺逻辑上的破绽，包括阿基米德和亚里士多德，但都没有给出好的回答。不过亚里士多德的思考还是道破了这几个悖论的本质，就是一方面距离是有限的，另一方面又可以把时间分成无穷多份，以至于有限和无限对应不上。&emsp;&emsp;直到牛顿、莱布尼茨等人发明了微积分，发明了无穷小量和极限的概念，才作出了比较圆满的解释。&emsp;&emsp;接下来，就让我们一层层抽丝剥茧，来解决这些悖论。&emsp;&emsp;我们知道，在阿喀琉斯悖论中，芝诺其实把阿喀琉斯追赶的时间分成了无限份，每一份逐渐变小却又不等于零。比如我们假设阿喀琉斯一秒钟跑10米，那么芝诺所分的每一份时间就是1秒、0.1秒、0.01秒，等等。如果我们把它们加起来，就是之前讲的等比级数。<center>S=1+0.1+0.01+0.001+……</center>&emsp;&emsp;接下来的问题是，这样无限份的时间加起来是多少？假如每一份时间都存在一个最小的、具体的长度，那么这样子的无限份加起来显然就是无限大，这是矛盾所在。但是，如果我们能够定义一个被称为“无穷小”的量，它满足这样两个条件，芝诺的悖论就能够解决了。- 它不是零；- 它的绝对值小于任何一个你能够给定的数。比如你说10^-100（10的负100次方就是10的100次方分之一）非常小，那么我这个无穷小比你说的还小，如果你说再来一个更小的数10^-10000，那么我这个无穷小依然比你的数字小。具体到芝诺悖论的例子中，这两个条件如何理解呢？当我们把时间分为无穷多份之后，到后来，不仅每一份是一个无穷小量，而且无穷多个无穷小量加起来依然是无穷小。&emsp;&emsp;那么怎么证明在上面的等比级数S中，无穷多个无穷小量加起来不会是无穷大呢？这在数学上有好几种方法可以证明，我们就不细讲了。在这里我们提示两个要点：- 无穷多个无穷小量加在一起可以有三种情况，分别是一个有限的数，无穷大，或者是无穷小，我们在后面介绍无穷大和无穷小的比较时会详细讲。- 在这个具体情况中，无限个无穷小量加起来是一个有限的数，这一点我们在后面讲到极限的概念时会说明，S这个级数的极限是10/9。因此引入了无穷小的概念，就解决了阿喀琉斯悖论。可以讲，正是阿喀琉斯悖论帮助我们补上了数学上的一个缺失。&emsp;&emsp;至于第四个相对运动悖论，其实说起来就更简单了。芝诺所说的Δ，其实就是无穷小，虽然它趋近于零，但是不等于零，因此Δ≠2Δ。**要点总结：**&emsp;&emsp;无穷小的本质是什么？它补上了关于数字在连续性方面的一个定义的缺失。我们随便画一个数轴，数轴上的每一个点都应该是连续的，当然数轴中间那个点是零。&emsp;&emsp;如果我要问你，在数轴上紧挨着零的那个点等于多少呢？你就没法回答了，你如果说是10^-100，遇到一个抬杠的，会说10^-1000离0点更近，只要你能说一个，他都可以和你抬杠。&emsp;&emsp;因此，我们定义一个新的概念，叫做无穷小，它无限接近零。从它的定义可以看出，无穷小不是一个具体的数，而是一个概念、一个趋势，就和无穷大一样。&emsp;&emsp;当我们的头脑开始接受数的概念可以超出一个具体的数，而是一个趋势时，我们的思维就进步了，我们看待世界也不会一个点一个点地去看了，而是一个趋势一个趋势地去看。&emsp;&emsp;举一个具体的例子，你可能听说过现代物理学上的弦论，它被认为是到目前为止最有可能统一相对论和量子力学的工具，相比今天建立在基本粒子上的物理学模型，弦论讲的就不是一个个具体的点，而是一个个趋势。&emsp;&emsp;牛顿和莱布尼茨等人虽然通过无穷小和极限的概念，解决了芝诺悖论，但是他们当时对无穷小以及极限的定义还不准确，以至于受到了大哲学家贝克莱的挑战。这一点我们下一讲再讲。&emsp;&emsp;欢迎你把课程分享到家长群，帮家长们重新理解数学背后的道理。</details><h3><span id="16-wu-qiong-xiao-er-niu-dun-he-bei-ke-lai-zai-zheng-shi-me">16 ｜ 无穷小（二）：牛顿和贝克莱在争什么？</span><a href="#16-wu-qiong-xiao-er-niu-dun-he-bei-ke-lai-zai-zheng-shi-me" class="header-anchor">#</a></h3><!-- ![](/images/67.jpg) --><p>&emsp;&emsp;我们上一讲知道了芝诺提出的飞箭是静止的这个悖论，这和我们的常识是相违背的。这一讲，我们说说这些一千多年前的悖论是如何得到解释，以及它们的现实影响。</p><details><summary>...</summary>&emsp;&emsp;利用无穷小这个概念，牛顿发明了“流数”的概念，用于研究函数的变化，从而找出物体运动瞬间的变化规律。&emsp;&emsp;在牛顿之前，物理学家们对很多物理概念其实搞不清楚，比如大家会混淆质量和重量，速度和加速度，动量和动能这些物理概念。牛顿第一次清晰地定义了这些物理量，其中一个重要的物理量就是速度。&emsp;&emsp;我们今天知道，如果你2小时走了10公里，速度V就是每小时5公里，更确切地讲，就是位移的距离ΔS=10公里除以完成这段位移的时间Δt2小时，即V=ΔS/Δt。这其实说的是平均速度。如果你按照这个平均速度从北京的颐和园走到香山公园，其实每分每秒的速度都是变化的。&emsp;&emsp;如果我们想知道某一时刻特定的速度怎么办呢？牛顿说，当间隔的时间Δt趋近于零的时候，算出来的速度就是那一瞬间的速度。![](/images/68.jpg)&emsp;&emsp;在图中，横轴代表时间变化，纵轴代表距离变化。从t0这个点出发，经过Δt的时间，走了ΔS的距离，因此在那个点的速度大约是ΔS/Δt。这个比值，就是图中那个红色三角形斜边的斜率。&emsp;&emsp;对比左图和右图，你会发现如果Δt减少，ΔS也会缩短，但是ΔS/Δt的比值就更接近t0那一瞬间的速度。极限的情况则是Δt趋近于零，那么时间-距离曲线在t0点切线的斜率就是t0的瞬间速度。由此，牛顿给出了一个结论，时间-距离曲线在各个点切线的斜率，就是各个点的瞬间速度。&emsp;&emsp;瞬间速度其实反映了在某个点距离的变化率。至于为什么我们想了解瞬间速度，因为在很多应用中我们只关心瞬间速度，而不是平均速度。比如我们关心子弹出膛的速度，命中目标的速度，汽车在出交通事故一瞬间的速度，等等，它们都是瞬间速度。&emsp;&emsp;有了瞬间速度的概念，我们就很好解释芝诺的第三个悖论，即飞箭是静止的这一悖论。芝诺其实混淆了两个概念，即瞬间位移量和瞬间速度的差别。芝诺注意到了当间隔时间Δt趋近于零的时候，箭头飞行的距离ΔS也趋近于零。但是，它们的比值，也就是速度，并不是零。就如同我们在图中画的，曲线的斜率并不是零。&emsp;&emsp;牛顿把上面这种数学方法推广到任意一个曲线。他将一个曲线在某一个点的变化率，定义成一个新的数学概念，这就是前面我们讲到的流数。今天我们在数学上称之为导数，因此以后我们就不再用“流数”这个名词了。导数是微积分的基础。&emsp;&emsp;导数这个概念的提出，把很多物理量之间的数学关系建立起来了。比如速度是位移曲线的导数，而另一个物理量加速度则又是速度的导数。类似的，动量就是动能的导数。此外，在经济学上，经济增长率，就是GDP的导数，而增长率增速，又是增长率的导数。&emsp;&emsp;今天在我们的生活中，导数或者说瞬间变化率，其实用得特别多，只是大家对这个名称未必很熟罢了。导数概念的提出，使得人类能够从掌握平均规律，进入到掌握瞬间规律。可以讲，没有导数的分析方法，人类只能体会变化，但体会不出加速变化。&emsp;&emsp;遗憾的是，虽然牛顿对于速度的定义在物理上很容易理解，并且被大家接受，但是在数学上却有一个小缺陷，就是对这个无穷小概念解释得不够清晰。具体讲，就是到底Δt能不能等于零？&emsp;&emsp;对此，牛顿以及微积分的另一个发明人莱布尼茨都有点含糊其辞。虽然说那个年代人的数学水平没有今天高，绝大部分人看不出问题，但是有一个讲究逻辑的学者却向牛顿提出了质疑。这个人叫贝克莱。&emsp;&emsp;贝克莱这个名字对熟悉哲学的人来讲是如雷贯耳，对非哲学专业的人来讲也未必陌生，因为他在中国哲学课中是“臭名昭著”的唯心主义哲学家的代表人物，他的一句名言是“存在就是被感知”，在我们的课程中被批评和嘲笑。当我在国内学习微积分和科学史时，贝克莱就成了一个被嘲笑的对象，被笑话为不懂微积分，孤立静止地看待世界。&emsp;&emsp;然而，在西方世界，贝克莱是很受尊敬的，他被认为是一位了不起的哲学家和学者，和约翰·洛克、大卫·休谟一同，被誉为经验主义哲学的三大代表人物。今天著名的加州大学伯克利分校里面“伯克利”三个字，其实就是贝克莱的名字。&emsp;&emsp;贝克莱讲“存在就是被感知”，可不是拍脑袋想出来的，而是做了科学研究的。这里面的细节我们就不多讲了，总之，贝克莱研究了人们如何在两个维度的视网膜上感知和觉察到有深处的第三维度图像，他的结论和今天生理学所给出的结论基本一致。&emsp;&emsp;贝克莱挑战牛顿，主要是两人的宗教观不同。贝克莱是一位天主教的大主教，而牛顿在骨子里有自然神论的倾向。恰好贝克莱对运动学也有不少研究，也非常讲究逻辑，他找到了牛顿的一个小漏洞，于是就挑战牛顿说，你说的无穷小的时间Δt到底是不是零啊？如果是零，它不能做分母，如果不是零，你的公式给出的还是一个平均速度，而不是瞬间速度。&emsp;&emsp;对于贝克莱的质疑，牛顿也不知道怎么回答，因为在那个年代，无论是他还是莱布尼茨，虽然用到了无穷小，但是也没有能对它进行准确的定义。你如果问牛顿什么是无穷小，牛顿可能会说，就是非常非常小，可以忽略不计。&emsp;&emsp;我们上一讲给出的无穷小的那种描述，其实是一百多年后柯西和魏尔斯特拉斯给出的。贝克莱提出的问题看似很小，却引发了第二次数学危机，第一次是前面讲到的发现无理数造成的危机，危机的根据就在于牛顿那个时代的人在逻辑上讲不清楚无穷小是什么。&emsp;&emsp;讲到这里，可能有人会想，这件事情这么重要么？是的！接下来我们就来分析一下这件事。我们要从两个角度来看这件事，第一是从数学逻辑的重要性来看，第二是从具体的无穷小这个概念本身来看。&emsp;&emsp;我们先从第一个角度来说明，那些抽象的话我们就不多说了，我们来看一个实际的例子，伽利略发现物体落地时间和重量无关的例子。&emsp;&emsp;伽利略是在牛顿之前最伟大的物理学家。我们今天知道他，主要不是了解他对物理学的贡献，而是比萨斜塔铁球实验的故事。他通过扔下两个铁球，发现它们同时落地，否定了亚里士多德过去的“重物要比轻的物体先落地”的论断。&emsp;&emsp;这个实验是否是他的学生虚构的，今天有争议。实际上，伽利略质疑亚里士多德的结论还真不是从做实验开始的，他是从简单的数学逻辑中找出了亚里士多德结论中的矛盾之处。&emsp;&emsp;伽利略的逻辑很有意思，既然亚里士多德说了重的物体比轻的物体能更快地落地，那么将10磅和1磅的两个球绑在一起，它们是比10磅的球更快落地还是更慢呢？&emsp;&emsp;如果你认为它们是两个球，一个快一个慢，一磅的要拖10磅的后腿，那么它们就要比单独一个10磅的球落地慢。但是，如果你认为它们是一个整体，一共11磅，就要更快。&emsp;&emsp;这就在逻辑上产生了矛盾。这个矛盾就推翻了亚里士多德的结论。这一类的例子我们在《科技史纲60讲》中举了很多，有兴趣的同学可以复习一下那门课。这些例子都说明，数学千万不能有逻辑错误，否则不仅是数学，很多人类的知识体系都会出问题。&emsp;&emsp;接下来我们从第二个角度，专门看看无穷小这个概念为什么如此重要呢？我们来梳理这里面的逻辑。&emsp;&emsp;我们前面讲了微积分的意义是，让人类的认知从静态或者宏观变化进入到把握瞬间动态变化和加速变化，这是人类认知的一大飞跃。有了它，近代的物理学和天文学，以及后来的古典经济学，才得以建立。&emsp;&emsp;但是，微积分是以导数为基础的，而无穷小又是导数的逻辑前提和基础。如果无穷小这个基础本身出问题，在上面建立起来的所有大厦都可能被推翻。因为，贝克莱提出的无穷小悖论，是一次实实在在的数学危机。&emsp;&emsp;解决第二次数学危机的，并不是牛顿、莱布尼茨等人。事实上，某个时代发现的危机，同时代的人常常是想不清楚的，需要后面的人发展新理论来解决。&emsp;&emsp;是19世纪的一大批数学家解决了这个问题，他们的名字我就不列举了，因为比较多。这里面特别要提一下的是法国伟大的科学家柯西和德国的魏尔斯特拉斯。关于他们的工作，我们下一讲再讲。&emsp;&emsp;这里我们简单地说一下他们二人在思维方式上比牛顿进步的地方，那就是他们把无穷小这个“概念”从过去人们理解的小得不能再小的数，看成了一个动态变化，往零这个点靠近的趋势。这其实是人类认知的一大飞跃。**要点总结：**&emsp;&emsp;我们今天讲了平均速度和瞬间速度的关系和区别。牛顿用（流数）导数来定义瞬间速度，其实是描述了一个曲线或者物理量变化的趋势和速率。人类在早期的时候，只能认识到平均速度等概念，只有当人类理解了导数这个概念后，才能搞清楚瞬间变化的规律，特别是加速变化的规律，这是人类历史上一次很大的认知升级。&emsp;&emsp;牛顿在计算瞬间变化时，引入了无穷小这个概念，但是当时的人对它的确切含义想得不是那么清楚。因此，贝克莱就提出了质疑，即无穷小悖论，导致了第二次数学危机。对于贝克莱以及之前芝诺这样爱较真，但讲理的人，不要觉得他们讨厌，他们对数学的完善是有贡献的。&emsp;&emsp;数学不是实证科学，不能简单通过实验来证实，要在逻辑上非常完美，否则后果不堪设想。具体到第二次数学危机的解决，则是靠新时代的数学家的贡献。</details><h3><span id="17-wu-qiong-xiao-san-yong-dong-tai-he-ji-xian-de-yan-guang-kan-shi-jie">17 ｜ 无穷小（三）：用动态和极限的眼光看世界</span><a href="#17-wu-qiong-xiao-san-yong-dong-tai-he-ji-xian-de-yan-guang-kan-shi-jie" class="header-anchor">#</a></h3><!-- ![](/images/69.jpg) --><p>&emsp;&emsp;我们上一讲讲到贝克莱对牛顿的挑战。看似不起眼的无穷小的概念，却引发了数学上第二次危机。 第二次数学危机，看似是围绕“无穷小”引发的争论，但从认识论上讲，是身处于渐变世界的人类，难以理解瞬间突变造成的。</p><details><summary>...</summary>&emsp;&emsp;要解决这个问题，单纯围绕“无穷小”争来争去是不行的，要在认识上有所提升，具体讲，就是要认识极限这个概念。&emsp;&emsp;极限这个概念从字面上讲不难理解，因为我们会联想到生活中一个达不到的限度。但是这个理解是不精确的。比如我们知道，1/2+1/4+1/8+1/16…..是不断增加的，那么它能达到多少呢？事实上它的极限仅仅是1。&emsp;&emsp;如果你拿尺子在纸上画一条1厘米的线段，在一半也就是0.5厘米的位置标一下，在后一个0.5厘米的一半，也就是0.75厘米的位置再标一下，重复这个取一半的动作，最后无论多么精细，这些刻度加起来，总不能达到1厘米，1厘米就是它的极限。![](/images/70.jpg)&emsp;&emsp;今天很多人想自学微积分，但是基本上看到极限那里就卡壳了，因为脑子没有换成“动态的数学脑子”，还是静态地看问题。&emsp;&emsp;这也怪不得大家，因为伟大如牛顿、莱布尼茨，也不得不在极限这个概念上含糊其辞，由于他们给的概念都很绕口：&emsp;&emsp;*「牛顿认为极限是逐渐变小的量之间的最终比值。你如果回想一下我们上一讲所说的他对于速度的定义，其实就是时间和距离这两个逐渐变小的量之间的比值。牛顿认为，平均速度在时间间隔不断缩小后，极限就是瞬间速度。*&emsp;&emsp;*莱布尼茨不是物理学家，他是数学家，更是哲学家和符号学家。因此他从纯逻辑的角度看待极限，他认为，如果任何一个连续变化都以一个极限为终结，那么在这个变化过程中的普遍规律，也适用于最终的极限。」*&emsp;&emsp;那么我们到底应该怎么理解极限呢？我们回顾一个具体的例子，前面讲到的斐波那契数列前后两项之比，大家可以看到它趋近于黄金分割点，这个黄金分割点1.618……就是它的极限。![](/images/71.jpg)从这个图中大家可以看到两点：**首先，极限是客观存在，**比如图中的点就是围绕着黄金分割点波动。这一点大家其实并不难理解。**其次，极限最大的特征是“无限逼近”，最后趋同。**上述这种对极限的认知，来自于柯西，最终被魏尔斯特拉斯用数学的语言描述清楚了。&emsp;&emsp;柯西是19世纪法国数学界的集大成者，他在法国数学史上的地位，犹如牛顿在英国，高斯在德国，我们今天所学习的微积分，其实并不是牛顿和莱布尼茨所描述的微积分，而是经过柯西等人改造过的，严格得多的微积分。&emsp;&emsp;相比牛顿，他放弃了微积分在物理学上直接的应用场景，完全是从数学本身出发来重新定义微积分中那些含混的概念，把微积分打造成像欧几里得几何那样公理化的系统。&emsp;&emsp;这种更抽象的描述也意味着更准确、更普适。而且柯西和魏尔斯特拉斯比牛顿高明的地方在于，他们不是对概念进行静态的定义，而是进行了动态的描述。那么该如何去描述一个动态的概念呢？我们看看他们是怎么做到的。&emsp;&emsp;极限是微积分里最重要的定义之一，对极限进行准确的定义要分两步。第一步是把概念搞清楚，没有二义性，这件事是柯西完成的。&emsp;&emsp;第二步就是用数学的语言将它们表述出来，这就有点反人性了。因为虽然人类对自然语言有着天然的好感，而且我说什么你很容易直观地理解我的意思，但是在数学上这可能不够严密，以至于会导致很多悖论。&emsp;&emsp;在微积分的定义上，将柯西那些直观的观念，变成严格符合逻辑的数学语言的人，是德国数学家魏尔斯特拉斯。魏尔斯特拉斯对微积分的贡献很大。我们这里只说说他是如何定义极限的。&emsp;&emsp;我们先来看一个序列：<center>1，4/3，6/4，8/5，10/6……2N/（N+1）…….</center>&emsp;&emsp;如果当N足够大时，它的值是多少？你可能会说是2；也可能说它趋近于2，但是比2小一点点，这两种说法都对。当然，更准确的说法是，它的极限是2，因为它无限逼近2。&emsp;&emsp;这就是柯西对极限给出的直观的定义。需要指出的是，柯西对极限的定义已经有了动态的概念，和牛顿、莱布尼茨他们说的“到头”不一样。&emsp;&emsp;但是，魏尔斯特拉斯却说，柯西，你的定义，还不够精确。&emsp;&emsp;柯西就说，那你能你上。&emsp;&emsp;于是魏尔斯特拉斯给出了他的定义法。&emsp;&emsp;首先，他肯定了极限是关于一个无限逼近的趋势的观点。但是在描述无限逼近的方法上，他采用了逆向思维。&emsp;&emsp;那魏尔斯特拉斯的逆向思维是什么意思呢？我们常人的想法，就是这个序列，当N越大时，它和2的差距越小，但是小到什么程度，就不容易量化说清楚。魏尔斯特拉斯的逆向思维是这样的，他先这么问大家：&emsp;&emsp;你们觉得误差多么小算是趋近了？大家可能就说了，总得小于一亿分之一吧。&emsp;&emsp;魏尔斯特拉斯就说，这容易做到，只要N大于一亿之后，这个序列和2的差距，就小于你说的一亿分之一了。&emsp;&emsp;这时，你可能说，且慢，一亿分之一的误差还是误差啊，在数学上它还是不等于2。&emsp;&emsp;魏尔斯特拉斯就说，没关系，你再说一个更小的数，我还能做到。于是你说10^-100。魏尔斯特拉斯说，N大于10^100就可以了。总之，不管你说的数多么接近，他都能做到。这就是无限逼近。&emsp;&emsp;上面这一段对话当然是我虚构的。魏尔斯特拉斯对极限的描述是这样的：&emsp;&emsp;任意给一个小的数字𝛆，如果总能找到一个数字M，当N比M大之后，上面那个序列和2的差距小于𝛆。于是，我们就说上面那个序列的极限的是2。&emsp;&emsp;有了对于一个数列极限的定义，魏尔斯特拉斯对函数的极限也作了类似的定义。比如我们看这样一个函数sin(x)/x，它的分子是一个正弦函数，分母就是变量自己。&emsp;&emsp;这个函数，当x趋近于0时，它等于多少呢？&emsp;&emsp;我们列一个表：![](/images/72.jpg)&emsp;&emsp;从表中可以看出x趋近于零的时候，这个函数值就趋近于1。&emsp;&emsp;我们知道x是分母，不能等于0，不过没关系，我们可以让它趋近于零。&emsp;&emsp;对于该函数在零附近的极限，魏尔斯特拉斯是这样定义的：&emsp;&emsp;*你只要给定一个很小的数字𝛆，我总能在0附近，设法找到一个范围，只要x落在这个范围内，算出来的函数的值和1的误差就比你给的𝛆要小。*&emsp;&emsp;从这个定义中我们可以看出，极限也是一个动态的，对趋势的定义，而且使用了逆向思维。&emsp;&emsp;有了极限严格的定义，我们可以看出无穷小其实是一种特殊的极限，它也可以准确定义，我们这里就不再把它用数学的语言描述了，大家记住这个结论就可以了。&emsp;&emsp;有了对极限严格的定义，以及对于无穷小准确的定义，牛顿所说的速度问题，其实就是当时间在t0这个时刻间隔趋近于零的时候，距离和时间比值的极限，到此，贝克莱引出的无穷小悖论，以及之前所有的芝诺悖论才算彻底解决。&emsp;&emsp;当然，本来用大白话说的道理，变成了严格的数学语言，就让数学显得高冷了，有些人读起数学的语言（大量的公式）就觉得费劲，而老师的作用，就是再用大白话，把数学语言所写的知识，翻译成大家容易明白的内容。做不到这一点，那还不如让学生自己看书自学了。&emsp;&emsp;到此为止，我们关于极限的内容就讲完了。我们为什么要讲这件事？不是给大家一个比生活中所理解的极限更准确的定义，而是学会用动态的眼光，无限变化的眼光看待世界。&emsp;&emsp;人类认识极限、无穷大和无穷小这些在有限世界里难以理解的概念时，一开始也是一头雾水。这是因为人类受限于自己生活的有限世界。&emsp;&emsp;在有限的世界里，数字都是具体的，因此人们就会想当然地觉得无穷大就是非常大的数，无穷小就是反过来，但是这样以静止的眼光看待数，就会遇到一些数学悖论，这些悖论导致数学危机。&emsp;&emsp;危机的根源是什么呢？就是我们人类直观的认识和数学内在的逻辑的矛盾。解决这些矛盾的方法是什么呢？不是像毕达哥拉斯那样视而不见，甚至否认，而是先存疑，后完善。&emsp;&emsp;要完善数学上的那些“漏洞”，就要引入新的概念，把原来数学的体系扩大为新的体系。这里我对“漏洞”一词打了引号，因为它不是数学本身的漏洞，其实是我们人认识上的漏洞。&emsp;&emsp;为什么需要把数学体系扩大呢？因为任何封闭体系内所遇到的漏洞，在这个体系内是无法弥补的。用中国话讲，叫做“不识庐山真面目，只缘身在此山中”，这是我们人类发展到今天应有的智慧。而在扩大体系的过程中，最重要的是把问题的定义搞清楚。我们今天人和人之间在沟通中最重要的基础，就是对定义有共同认知。&emsp;&emsp;具体到对无穷世界的认识，以及对极限的认识，最初发现漏洞的人居然是芝诺这样胡搅蛮缠的大反角，牛顿和莱布尼茨为了弥补芝诺发现的漏洞，发明了无穷小的概念，但是他们的发明也有漏洞，被贝克莱抓住了。于是才有了后来柯西和魏尔斯特拉斯等人的贡献。&emsp;&emsp;魏尔斯特拉斯超出前人和常人的地方有两个，一个是他定量地描述出无限的趋势，另一个是他用逆向思维让大家理解了这种趋势的含义。定量和逆向思维，是我们今天应用的思维方式。&emsp;&emsp;人认识世界的过程，其实是人类认识世界的缩小版，前人摸索几百年的认知进步，我们可能通过学习和做事情，几年就体会出来了。结合这几天的内容，我把一个便捷的认知升级的过程总结如此：- 不要怕提出傻问题，符合逻辑的傻问题常常是认知升级的开始。- 如果之前的知识解决不了那些看似傻问题的悖论，我们可能要跳出圈子了，因为在圈子里转永远解决不了问题。- 当我们扩大我们的知识体系的时候，之前的傻问题可能有了答案。- 但是不要指望一次就能完美地解决所有问题。我们的解决方案可能有漏洞，不要怕被别人指出来。当我们进一步弥补漏洞后，我们的认知就再次升级。下一讲，我们再来讨论一个进一步扩张我们思维认知的数学问题，就是看看无穷大、无穷小还能不能再比比大小。我们下一讲再见。</details><h3><span id="18-you-shi-me-bi-wu-qiong-da-geng-da-bi-wu-qiong-xiao-geng-xiao">18 ｜ 有什么比无穷大更大，比无穷小更小</span><a href="#18-you-shi-me-bi-wu-qiong-da-geng-da-bi-wu-qiong-xiao-geng-xiao" class="header-anchor">#</a></h3><!-- ![](/images/73.jpg) --><p>&emsp;&emsp;我们讲无穷大是比任何数都大，那么世界上只有一个无穷大吗？如果有多个，能比较大小吗？类似的，无穷小就是无限接近于零，那么世界上会有不同的无穷小么？</p><details><summary>...</summary>&emsp;&emsp;如果我们用静态的眼光看待这两个概念，答案都是否定的：无穷大和无穷小都是独一无二的。比如，无穷大再加上1，或者再乘以2，都是无穷大。&emsp;&emsp;但是，我们已经知道，它们其实不是具体的数字，而是数列或者函数变化的趋势，是动态的，因为必然有某些数列或者函数会比其他的增加更快，有些则相对慢一点的情况。&emsp;&emsp;同样，往无穷小方向变化也是类似。因此，无穷大或者无穷小应该有很多，而且可以通过比较它们之间的变化速率，来比较大小。&emsp;&emsp;我们先看两个无穷小的函数，来比比大小：f(x)=x和正弦函数g(x)=sin x。我们知道，当x趋近于零的时候，f（x）和g（x）都趋近于零，那么它们趋近于零的速率相同吗？我们看一眼下表。&emsp;&emsp;我曾经试图用图来对比这两个函数变化的趋势，但是由于两条曲线很快合并到一处，看不清楚，因此只能用表来表示。![](/images/74.jpg)&emsp;&emsp;从表中可以看出，x本身和正弦函数趋近于零的速率是惊人地一致。于是，我们可以得到这样一个结论，上述两个函数它们趋近于零的速率是相同的。&emsp;&emsp;接下来我们再看另一个趋近于零，速率不同的无穷小。我们对比一下上述的正弦函数g(x)=sin (x)和平方根函数h(x)=√x&emsp;&emsp;我们还是用一张表把它们趋近于零的速率描绘一下：![](/images/75.jpg)&emsp;&emsp;你会发现平方根函数h(x)相比正弦函数g(x)趋近于零的速率慢得多。这时候我们其实就比较出两个无穷小谁“更小”了。&emsp;&emsp;这里面我对“更小”两个字打了引号，因为我们这里说的比较大小其实不是具体数字大小的比较，而是趋势快慢的对比。当一个无穷小量比另一个以更快的速度趋近于零，我们就说第一个比第二个更小。&emsp;&emsp;具体到上面的例子，正弦函数在零附近，相比平方根函数，是更小的无穷小。当然，更准确的说法是，“高阶无穷小”。&emsp;&emsp;下面我给出了一些函数，它们在零附近都是无穷小，它们的阶数也越来越高：- 平方根- x本身、正弦函数- 平方函数 x^2- 立方函数 x^3- 指数函数的倒数类似的，我们也可以对无穷大比较大小。你可能会问，无穷小是趋近于0，然后谁接近0的速率更快，谁就是更小。那么无穷大应该和谁去比较呢，它只能和另一个无穷大去比？其实如果两个无穷大，一个增加的速率比另一个更大，我们就说前面的相比后面的是高阶的。&emsp;&emsp;比如我们看这样一个例子，有两个函数：f(x)=x和平方根函数h(x)=√x&emsp;&emsp;当x趋近于无穷大时，它们都是无穷大，但是它们变化的速率不同，我也列举几个数字，放到下面这张表中，给大家一些直观的感受。![](/images/76.jpg)&emsp;&emsp;你会发现，第三行的平方根函数比上面的线性函数x增加的速率要慢很多，越到后来差距越大。当然还有比平方根函数增长更慢的函数，比如第四行的对数函数。至于增长更快的，也有很多，像平方函数就比线性函数更快，当然指数函数要快非常多。&emsp;&emsp;我们按照各个函数往无穷大方向增长的速率，从快到慢给出了下面这样一些例子：- 指数函数 10^x- 幂函数 x^N，通常N=2，3，4……- 自身 x- 平方根 √x- 立方根- 对数函数lg（x）**特别需要指出的是，很多个低阶无穷大，加在一起增长的速率都比不上一个高阶的。**比如说10000x和x的平方相比谁大，当x趋向于无穷大时，后者要大得多。当然，x的立方又要比任意有限个x的平方大。&emsp;&emsp;当然，遇到一个较真的朋友会说，这些函数最后反正都趋近于无穷大，你比较它们有意义吗？答案是有的，因为无穷大本身的含义就是一种趋势，而不是一个数字。特别是在计算机科学出现之后，它的意义更明显。&emsp;&emsp;我们知道，计算机是一个计算速度极快的机器。对于小规模的问题，无论怎么算，也花不了多少时间。如果说它会遇到什么难题，那就是规模很大的问题。&emsp;&emsp;因此，计算机算法所关心的事情，是当问题很大时，不同的算法的计算量以什么速度增长。比如，我们把问题的规模想成是N，当N向着无穷大的方向增长时，计算量是高阶的无穷大，还是低阶的。&emsp;&emsp;假如算法A的计算量和N成正比，那么当N从10000增加到100万时，计算量也增加100倍；如果算法的计算量和N的平方成正比，事情就麻烦得多了，当N同样从10000增加100倍到100万时，计算量要增加10000倍。&emsp;&emsp;类似的，如果算法C的计算量是N的立方，则要增加100万倍。当然遇到极端的情况，计算量是N的指数函数，问题就无法解决了。相反，如果算法D的计算量是N的对数函数，那么太好了，无论N怎么增加，计算量几乎不增加。&emsp;&emsp;因此，计算机算法的精髓其实就是在各种无穷大中，找一个小一点的无穷大。一个好的计算机从业者，他在考虑算法时，是在无穷大这一端，考虑计算量增长的趋势，一个平庸的从业者，则是对一个具体的问题，一个固定的N，考虑计算量。&emsp;&emsp;前者可以讲是用高等数学武装起头脑，后者对数学的理解还在小学水平。我们上大学的目的首先是通过学习课程换脑筋，然后才是掌握知识点。&emsp;&emsp;那么对于无穷小，区别出高阶和低阶有意义吗？有意义，而且意义也很大。我们还是拿计算机算法举例子。很多时候我们要求计算的误差在经过一次次迭代后不断下降，往无穷小的方向走。&emsp;&emsp;比如我们控制导弹和火箭飞行的精度，要在微调中向着目标方向靠近。那么通过几次的迭代就趋近于目标方向，还是要经过很多次迭代才达到，这个差异就很大了。&emsp;&emsp;假如我们有一种控制的方法，它是按照下面一个序列将误差逐步消除：<center>1，1/2，1/3，1/4，……，1/1000……</center>这个序列最终发展下去是无穷小，但是如果我们想让误差小于1/1000，需要调整1000次。&emsp;&emsp;假如我们有办法让误差按照下面的序列消除：<center>1，0.1，0.01，0.001，……</center>那么只需要四次调整，就能做到误差小于1/1000。&emsp;&emsp;你可以想象，在高速飞行的火箭中，每一秒，火箭都能飞出去几公里到十几公里，如果需要调整一千次，在调整好之前，火箭早就偏出十万八千里了。因此，在很多计算机算法里，希望以高阶无穷小的速度接近零。&emsp;&emsp;无穷大和无穷小不仅能比较，而且也能计算。有些计算结论是一目了然的，比如无穷大和无穷大相加相乘，结果都是无穷大，而无穷小之间做加减乘，结果都是无穷小。这比较好理解。&emsp;&emsp;但是，无穷大除以无穷大，无穷小除以无穷小等于多少呢？那就要看分子和分母上的无穷大或者无穷小谁变化快了。比如说，当x趋近于零时，sin x是无穷小，根号 x 也是无穷小，那么sin x /√x等于几呢？&emsp;&emsp;我们前面讲过，前者变化快，以更快的速度趋近于零，后者变化慢，因此相除的结果就是0。如果反过来，根号 x在分子的位置，sinx在分母的位置，这个比值就是无穷大。&emsp;&emsp;对于无穷大的除法，情况也是类似。此外，如果一个无穷大乘以一个无穷小，结果可以是一个常数，也可以是零，或者无穷大，就看它们谁的阶数更高了。&emsp;&emsp;我们在前面讲芝诺悖论时提到，在等比数列中，无穷多个无穷小相加，结果是有限的，就是这个道理，因为不断变小的等比数列，会形成一个高阶无穷小。**要点总结：**&emsp;&emsp;虽然无穷大和无穷小不是具体的数，但它们也能比较大小，比的不是具体的数值，而是变化的趋势。变化趋势快的，叫做高阶，变化趋势慢的，叫做低阶。通过它们的比较，我们把“比大小”这个概念的认知拓展了。&emsp;&emsp;这有什么意义呢？我给你打个比方，假如房价每年的增长是以几何级数上升的，当然你的收入增长也是如此，如果时间足够长，它们都往无穷大的方向发展。但是，如果房价每年涨3%，你的收入涨10%，只要你的生命足够长，你早晚买得起房子。&emsp;&emsp;如果你的收入增长是每年20%，这就是一个相对高阶的无穷大，你会很快买得起房子。相反，如果你的收入增长不到3%，相比房价的增长，它就是低阶无穷大，你永远买不起房子。&emsp;&emsp;无穷大和无穷小不仅可以比较，还可以做加减乘除运算。当然，这种运算和3+5=8这样确定性的运算不同，特别是在做乘除法时。我通常喜欢用“博弈”这个词形容一个无穷大和一个无穷小相乘的情况，因为结果是什么，就看谁的阶高了。&emsp;&emsp;这就好比你和你的女朋友，彼此的激情随着苯基乙胺浓度降低在不断减退，另一方面，亲情的却随着内啡肽的浓度上升会逐渐稳定，最后是成功，还是分手，就是无穷大和无穷小趋势的博弈。&emsp;&emsp;讲到这里，你可能会想，我为什么发此感慨，其实通过数学的逻辑，理解人生的一些道理，是把数学作为通识课讲的原因。下一讲我们就系统回顾一下这个模块的内容，我也和你分享一下数学对我的影响。我们下一讲再见。</details><h3><span id="19-fu-pan-shu-xue-gei-liao-wo-shi-me-qi-shi">19 ｜ 复盘：数学给了我什么启示？</span><a href="#19-fu-pan-shu-xue-gei-liao-wo-shi-me-qi-shi" class="header-anchor">#</a></h3><!-- ![](/images/77.jpg) --><p>&emsp;&emsp;到上一讲为止，我们讲完了我们这门数学通识课的第二模块，这个模块可能是所有模块中最难的一个，如果你坚持听完了，恭喜你，微积分中最难理解的部分，你也就拿下了。</p><details><summary>...</summary>&emsp;&emsp;在模块的一开始，我并没有说我要讲微积分，就是因为怕一些人知难而退。但是从大家的留言可以看出，经过我们系统地学习，大家开始理解和慢慢掌握高等数学的本质了。&emsp;&emsp;而对于那些过去学过微积分的人，可能会发现我的讲法和大学里完全不同，我并没有强调具体的知识点，而是在改变大家的一种思维方式，从孤立、静止地看待一个个数学定理，做一道道数学题，变成用动态发展的眼光，从趋势来理解世界。这个过程，就是人的认知从初等，到高等的过程。&emsp;&emsp;我回顾自己学习高等数学的道路，发现大家走过的弯路我也都走过，做了很多没必要的数学题。当时苏联吉米多维奇的《数学分析习题集》我大约做了三分之一（这套书里面有4000多道题），考试却不一定能考好。&emsp;&emsp;突然有一天我决定不做了，数学分析考成什么样就是什么样了，这时觉得有一种解脱。腾出时间后，把基本的概念理解清楚，结果成绩也不差。&emsp;&emsp;后来到了研究生时，学了数学系更底层的数学课，发现我过去完全学错了，不是老师内容讲得不对，而是没有学到该学的东西。那些题其实我根本不需要会做，如果将来遇到，要么查参考书，要么用计算机工具解决就可以了。&emsp;&emsp;关键是我在20岁之前，不理解应该用什么样的眼光来认识数学，看待数学里的那些概念和方法。后来当我懂得了高等数学本质上是对趋势的动态描述，是对各种相关性抽象的表述后，再回头看微积分，就觉得容易得不得了了。非常遗憾我在刚上大学时，没有人这么引导我。&emsp;&emsp;数学的世界，在很大程度上可以被看成是我们这个真实世界高度抽象的结果，它的概念是对我们生活中各种对象的浓缩，它的规律是我们生活中很多规律的抽象表述。因此在有了一些生活阅历后，再回过头来看看数学书，我有时会把一些零碎的想法和头绪理清楚。今天我和你分享我的9个体会：**1.有穷和无穷**&emsp;&emsp;我们花了不少篇幅在讲无穷大，特别强调在无穷大的世界里，有限生活的不适用。这种感觉有时让我觉得个人的渺小和见识短浅。很多时候，处于很底层的人，是无法理解高层人的想法的。&emsp;&emsp;我们常说“贫穷限制了想象力”，其实贫穷不会限制想象力，贫穷的人可以胡思乱想，但是他们在某一些维度上的经验极少，以至于让人觉得是刘姥姥进大观园。&emsp;&emsp;十年前中国有一本关于罗斯柴尔德家族和美联储的阴谋论的书，我的一些做投资的朋友看了后说，这个作者一定是个穷人，不曾拥有过大钱，不知道世界上的钱放在哪里。&emsp;&emsp;这位作者缺的不是想象力，而是凭空想象的世界完全不靠谱。胡思乱想不会增加自己的智慧，倒是像苏格拉底那样，知道自己的知识有穷尽，而未知世界无穷尽，反而会更接近真理，更容易提高自己的认知。**2.静态和动态**&emsp;&emsp;我们的世界需要静态，没有静态的稳定，我们就无法立足。但是，很多时候，我们做事情需要以动态作前提假设，这就如同在足球赛中，除了罚定位球，没有人给你机会站着不动从容射门的。从初等数学到高等数学，就是要把看数学的眼光，从一个个静态的数字、孤立的公式，上升到动态变化的趋势。&emsp;&emsp;比如我们在谈论无穷大这个概念时，我一再强调要把它看成是一个动态的趋势，而不是一个大数。我还特别讲了，x²这个函数，在无穷大的世界里，要比10000x大得多。中国有句话，叫做莫嫌少年贫，其实很有道理，我们看待一个年轻人，要看他成长的趋势，而不是现在有多少钱。&emsp;&emsp;很多人在创业时，喜欢凑热闹，找风口，生怕错过了机会。我对他们讲，如果那个时间窗只有几个月、半年，那根本不是机会，只是一次投机而已。这就是静态地看待时机。真正的大趋势，总是持续十几年甚至几十年，是不容易错过的，几十年复合增长下来，比任何投机获利都大，这就是对动态看世界的人的褒奖。**3.精明与聪明**&emsp;&emsp;从静态和动态的关系，让我想到这个话题。&emsp;&emsp;有人觉得数学好的会算账，遇事可以精明不吃亏。但是过分精明的结果就是眼睛都盯在了眼前的利益上，看不到长期的利益，这样反而不聪明了。&emsp;&emsp;比如在投资方面，很多人喜欢寻找低买高卖的机会赚差价，他们有时会得手，但是失手的时候一般比得手更多，更糟糕的是，这些人永远无法把握长期增长的机会。事实上，任何一个向上持续增长的趋势，假以时日，都能涨得很多很快。**4.现实与虚构**&emsp;&emsp;数学中很多工具都是建立在世界并不存在的虚构概念之上的，但是，将它们用于现实的社会非常有用，比如说无理数便是如此。人不仅要有形象思维，更要有抽象思维，能够通过抽象思维理解无理数，那么学习物理，做信号处理的工作，搞控制系统，都会很顺手。&emsp;&emsp;人是特别善于创造虚拟概念的物种，我们今天的生活其实离不开各种虚拟物作为实体的媒介。比如说，世界上的财富是真实的，但是度量它们的货币其实是人虚拟出来的。你不可能在买东西时把真实的财富带在身上，大家只把自己在银行账上的钱从一个虚拟的空间搬到另一个去而已。&emsp;&emsp;不仅钱是虚的，很多实实在在的商品虚拟意义也大于实际意义。据估计，个人手里的茅台酒在被喝掉之前，会被当作礼品转手不下十次，它就像数学中那些虚构的概念一样，而不是简单的酒精饮料，没有它们，真实世界的问题就不好解决。**5.攒钱和赚钱**&emsp;&emsp;我在《硅谷来信》有一次谈到钱，讲到没有人靠攒钱发财的，发财要靠赚钱。今天攒钱，钱实际上在不断贬值，虽然各国公布的CPI看似并不高，但是CPI并不包括房价的上涨。我们在前面介绍指数函数时讲过，如果每年购买力萎缩10%，用不了几年购买力就少掉一半。&emsp;&emsp;但是，年轻人只要努力，一年收入增长20%，还是能做到的。事实上，在过去的30年里，北京计算机专业毕业生的入职年薪平均每年上涨17%，有经验的优秀从业者后来的增长速度更快。&emsp;&emsp;我们在前面的课程中讲了，往无穷小变化的趋势和往无穷大变化的趋势如果相乘，最后是清零，是常数，还是不断放大，就看谁的阶高了。&emsp;&emsp;通胀、房价上涨等因素都是将财富贬值到无穷小的力量，而且不是人为可控的因素；但是另一方面，收入的增长则是让财富往无穷大增长的力量，对每个人来讲最终就看哪个力量大了。因此，财富靠赚，而不靠攒。**6.直觉和逻辑**&emsp;&emsp;我们的直觉常常是对的，但是这只是在我们熟悉或者能够感知到的世界里。世界的很多规律和我们的直觉不一致，比如我们说的芝诺悖论和贝克莱的无穷小悖论，就是因为我们的直觉和无穷小世界里的规律不一致所造成的。&emsp;&emsp;逻辑可以帮助我们分析清楚我们看不到的事情，甚至不存在的事情。在课程中，我们举了伽利略的例子，他之所以认定亚里士多德关于质量重的球先落地是错误的结论，是因为找到了这种说法的逻辑错误。这一类例子，在生活中不胜枚举。**7.概念和表述**&emsp;&emsp;今天，交流在我们的生活中占据重要的位置。将一件事情表述清楚非常重要，很多时候，我们需要通过彼此能够理解的形象的比喻来说明，这就如同我们在讲述极限这个概念时用“越来越接近”描述。&emsp;&emsp;但是，在很多场合，这样形象的描述还不够，还需要用极为严格的语言表述，数学的语言是一种，法律的语言也是一种，更普遍地讲，任何专业的术语都是为了这个目的而出现的。做事专业，就需要掌握专业的术语。**8.朋友和理性的对手**&emsp;&emsp;很多时候，取得小成就要靠朋友帮忙，但是要取得惊人的成就，就需要一个理性的对手。在数学的发展史上，芝诺、贝克莱，以及后面我们要讲到的罗素，都起到了反角的作用。正是他们给尚未完善的数学体系挑毛病，才让数学体系变得完美。&emsp;&emsp;我们在前面讲到金融危机时，似乎经济学家们没有预警，实际上当所有的人都在赞同同一个想法时，根本无法发现系统中的漏洞。因此，我们在工作中，对于那些理性的对手，即使不喜欢，我们也应该尊重他们的意见，因为那些看似不同的意见，恰恰是我们进步所需要的。**9.荣誉和财富**&emsp;&emsp;科学是没有专利可言的，因为科学家们所发现的规律是客观存在的，只是他们发现了而已，因此科学很难直接带来财富。而技术是有专利可言的，因为他们是使用科学改变世界的方法。它们不能混为一谈。&emsp;&emsp;对科学家最大的褒赏是荣誉，因此今天科学家们争的是谁第一个发现某个规律，而不是保守秘密。&emsp;&emsp;我们在前面讲了三次方程解法被发现的故事。其中的费罗和塔尔塔利亚，他们试图把科学变成独占的成果，这是行不通的。今天绝大部分数学家，会知道卡尔达诺和费拉里对解方程的贡献，对费罗所知甚少。原因就是前者将这些方法告诉了世人。&emsp;&emsp;对于搞技术的人来讲，将科学变成改变世界的产品是他们所追求的，有可能带来财富。因此，技术是要独占的。虽然我们说科学无国界，但是技术从来就是有国界，不仅有国界，甚至有公司的边界。&emsp;&emsp;对于一个人来讲，他需要搞清楚的，就是自己想要什么。&emsp;&emsp;我学习微积分是三十多年前的事情了，很多具体的内容已经想不起来了，但是学习了之后，人的思维方式改变了。因此，从通识教育的目的来看，我应该算是达到了。今天借着复盘的机会，和你分享一下我从数学中得到的启发，希望能供你参考。&emsp;&emsp;也欢迎大家在留言区向我提问，我会在下一模块统一回答。下一模块我们会学习几何，看看一个公理体系是怎么建立起来的。我们下一讲再见。</details><h2><span id="mo-kuai-san-ji-he-xue-yi-qie-yuan-zi-gong-li-he-luo-ji">模块三 ｜ 几何学 一切源自公理和逻辑</span><a href="#mo-kuai-san-ji-he-xue-yi-qie-yuan-zi-gong-li-he-luo-ji" class="header-anchor">#</a></h2><h3><span id="20-ji-he-xue-wei-shi-me-shi-shu-xue-zhong-zui-gu-lao-de-fen-zhi">20 ｜ 几何学：为什么是数学中最古老的分支</span><a href="#20-ji-he-xue-wei-shi-me-shi-shu-xue-zhong-zui-gu-lao-de-fen-zhi" class="header-anchor">#</a></h3><!-- ![](/images/79.jpg) --><p>从这一讲开始，我们进入第三模块几何学的学习。</p><details><summary>...</summary>&emsp;&emsp;虽然几何学被认为是中学最难学的数学分支，但是它却是继算术之后，最初发展起来的数学分支，比相对简单的代数学要早上千年。&emsp;&emsp;那么人类为什么要先难后易发展几何学分支呢？简单地讲是实际需要。几何这个分支的发展过程，反映出人类认知的进步过程，因此我们有必要简明地回顾几何的发展史，看看人类是怎么样总结规律的。&emsp;&emsp;我把几何学早期的发展分为三个阶段。&emsp;&emsp;**第一阶段是从懵懂的感性认识上升到量化的感性认识的过程。**&emsp;&emsp;今天英语所说的“几何”一词geometry源于希腊语，它是由“土地”的词根（geo）和“丈量”（metry）一词合并而成。顾名思义，几何最初确实源于对土地的丈量。&emsp;&emsp;当然，几何学传到古希腊已经是很晚的事情了，它源于更早的古埃及文明的初期。早在6000年前，埃及人为了农业生产，就发明了天文学和几何学。&emsp;&emsp;我们知道文明的标志是城市、书写系统和冶金，在此之前，文明的标志则是农业。这部分内容，我在《科技史纲60讲》中介绍过，有兴趣的朋友可以回顾那门课的内容。&emsp;&emsp;无论是农耕还是建筑，都离不开土地丈量、基本图形尺寸的测量和计算，这方面知识积累多了，就形成了几何学的常识，注意我这里用的是“常识”，而不是“理论”。&emsp;&emsp;我们先来说说古埃及的农耕和几何学的关系。古埃及农业发达的基本条件有两个：- 完全依靠尼罗河洪水每年泛滥后带来的肥沃土地。它的农业生产过程是这样的：每年尼罗河洪水退去后，他们就在洪水淹过的土地上耕种，但是耕种之处又不能离河床太近。因此他们要计算河水在一年不同时间的边界。- 有明确的播种和收获时间。既不至于播种太早，洪水依然没有退却，又不至于播种太晚，以至于误了农时。这些事在今天看来是再容易不过的了。比如我们可以到了春分节气左右播种，到了夏至左右收获就可以了。至于河水涨落的边界，我们记下12个月它涨落的边界变化即可。但是这两件事在古埃及并不容易，因为在没有准确的计时工具之前，我们人是无法通过身体感受来体会一年四季具体的时间的。&emsp;&emsp;找到每一年开始的基准时间，对于古埃及人来讲就是一道几何学问题。当时没有钟，所以了解时间就要靠观测星象，看看新的一年是不是又开始了。古埃及人把太阳和天狼星同时升起的那个时间算成一个大年（天狼星年）的开始。&emsp;&emsp;这个方法也是非常有道理的。由于地球围绕太阳转，每天同一时刻从地球上看天狼星的角度，会有不同。但是当地球转回到去年的位置，看天狼星的角度就相同了。![](/images/80.jpg)&emsp;&emsp;在图中，地球回到了能同时看到太阳和天狼星升起的公转位置时，就被确认为一年的开始。&emsp;&emsp;之所以选天狼星，是因为它是天上除了太阳最亮的恒星，而且在天上的位置是固定不变的（其实也在非常缓慢地变化）。古埃及人就算出来这样一个周期是1461天，地球就又回到了原来的位置，也就是我们今天的四年时间。&emsp;&emsp;由于古埃及没有闰年，它无法每四年校正一天，于是便采用了每1460个阳历年增加一年的方式来校正。也就是说古埃及的1461年，等于今天的1460年。古埃及人把这个1461年的大循环周期，叫做一个天狼星年。然后，古埃及人就按照这个周期，编制了一个八万多年的大历法，有了这个历法，什么时候播种，什么时候收获就清楚了。&emsp;&emsp;**从这个例子可以看出古埃及人对几何学的角度和圆有了感性的认识。**&emsp;&emsp;促使古埃及几何学发展的是大规模的城市建设，包括建造大金字塔。在修建胡夫金字塔的年代（距今大约 4600 年），他们就知道了勾股定理，对圆周率也有了初步的了解，他们估算出的圆周率为3.16，和真实的值相差不到千分之一。&emsp;&emsp;他们在大金字塔上留下了很多几何关系，向我们表明他们的几何学成就。这可以认为是几何学发展的第一个阶段，从懵懂的感性认识上升到量化的感性认识。&emsp;&emsp;**几何学发展的第二个阶段和第一个几乎是平行的，就是生活在今天伊拉克境内的美索不达米亚人发明了角度量化的度量。**&emsp;&emsp;我们知道平面几何所需要度量的最主要的对象，一个是长度，另一个就是角度，前者比较直观容易，后者比较难。美索不达米亚对几何学最大的贡献在于发明了量化度量角度的方法，就是我们今天360度的原则和角度上的60进位。&emsp;&emsp;美索不达米亚人对几何学的研究，也源于占星或者天文学的目的。占星在早期可不是算个人的运势，而是和农业生产有关，星空不同位置和地球上一年某个特定时间有着一一对应的关系。而在地球上一年特定的时间，植物和动物都会处于类似的生长繁衍阶段，因此古代美索不达米亚人就把天上星星的位置和地上发生的事情联系起来了。&emsp;&emsp;那么美索不达米亚人又是怎么标记星星的呢？早在苏美尔人统治那里的时期，他们就发现每个月看到的星空会有十二分之一的差异，于是他们就把天空分成了12份，每一份用一个有代表性的星座来代表，这就是今天12星座的由来。&emsp;&emsp;由于一个月大约有30天，于是他们就把一年看到的天空，又分为了12x30=360份，每一份就是我们今天说的一度角。我们今天学习几何学时可能会有一个疑问，一个圆为什么有360度，而不简单定义为100度？原因就来源于美索不达米亚早期的几何学。&emsp;&emsp;当然，以360度作为进位的基本单位太大、太复杂，他们选用了它的1/6，即60为进位单位。60这个数在数学上特别漂亮，因为它可以同时被1，2，3，4，5，6，10，12，15，20，30和60整除，因此使用很方便。60进制也就这样产生了。&emsp;&emsp;**几何学发展的第三个阶段就是用书记录他们所发现的规律。这样知识就便于传播。**&emsp;&emsp;今天存世最早的几何书是古埃及的《莱茵德纸草书》，它成书于公元前1650年前后。不过该书的作者声称，书中的内容是抄自古埃及另一本更早的书，那本书写于公元前1860—公元前1814年之间。这样算下来，世界上最早的几何学文献应该在3800年前，这比殷墟甲骨文的历史都长。&emsp;&emsp;相比之下，代数的历史则短很多，到了古希腊时期才基本定型下来，相差了至少一千年。在人类的早期文明中，肯定有很多算术解决不了的问题，那么怎么办呢？说起来很有意思，古代文明的人会用几何学的方法来解决本该属于代数的问题。&emsp;&emsp;在美索不达米亚出土的泥板上，也记录了当时人们总结了非常多的几何学知识。比如在古巴比伦王国（公元前1894—公元前 1595年）留下来的大约 300 块泥板上，记载着有关各种几何图形的计算方法。&emsp;&emsp;比如在平面几何方面，他们掌握了各种正多边形边长与面积的关系。他们尤其对直角三角形和等腰三角形了解较多，并掌握了计算两者面积的方法，他们还知道相似直角三角形的对应边是成比例的，等腰三角形顶点垂线平分底边。&emsp;&emsp;值得一提的是，他们也知道了勾股定理，给出了很多组的勾股数，其中一组最大的勾股数是（18541，12709，13500），发现这么大的一组勾股数非常不容易。当然知道了勾股定理就有可能利用它来计算一个数的根号，美索不达米亚人也这么做了，他们算出根号2大约是1.41。此外，古巴比伦人还给出了一些角度的三角函数值。&emsp;&emsp;那么几何学又是怎么传到古希腊的呢？美索不达米亚有一个特别喜欢外出经商的民族——闪米特人，他们是今天犹太人和阿拉伯人的祖先。闪米特人的一支腓尼基人在地中海沿海和很多岛屿建立了殖民地，并且把美索不达米亚的科学传播到各地。&emsp;&emsp;直到毕达哥拉斯的时代，美索不达米亚人和腓尼基人建立的殖民城市，科学和艺术水平远高于希腊诸岛和本土。各地的人们都到那里学习数学、天文、科学和艺术，毕达哥拉斯也是留学生中的一员。受益于腓尼基人对知识的传播，数学，特别是几何学传到了希腊文明圈，并且在那里形成体系。&emsp;&emsp;在毕达哥拉斯学派的手中，几何学逐渐成为单纯基于逻辑推理的数学工具。到了公元前4世纪—公元前3世纪，古希腊数学家欧几里得等人完成了对几何学公理化体系的构建，并且写成了《几何原本》一书，关于这个公理化体系，我们明天再讲。&emsp;&emsp;通过早期几何学3000年的发展，我们可以看到它经历了三个阶段：首先，从懵懂的感性认识到量化的感性认识，其标志就是通过几何学确立了一年的长度。接下来，确立角度的单位。这两步都和天文学有关。&emsp;&emsp;最后，把知识总结记载下来。这个过程也是我们应该学会的认知过程。我们人通常缺的是第二步，对新的事物不知道如何定义度量单位，而没有这一步，总结出来的知识就难以准确描述，只能大概定量描述。&emsp;&emsp;当然，最后几何学变成一个公理化的知识体系，人类发现各种引理、定理和推论，主要是希腊人的功劳。这个过程反映出人类认识从具体到抽象，从简单事实，到完整理论的过程。&emsp;&emsp;那么为什么是古希腊人，而不是更早的古巴比伦人完成了几何学理论的构建呢？一般认为，希腊人对物质生活要求很低，把大部分时间用于了理性的思考和辩论，这让他们能够从知识点中抽象出概念，然后形成体系。&emsp;&emsp;另外，古希腊没有强权的政治，这让学者可以仁者见仁，智者见智，这才有利于科学的发展。这两点也给了我们一些启发。&emsp;&emsp;至于几何学公理化体系是如何建立的，有什么特点，它为什么特别重要，我们下一讲再讲。我们下一讲再见。</details><h3><span id="21-gong-li-ti-xi-ji-he-de-xi-tong-li-lun-cong-he-er-lai">21 ｜ 公理体系：几何的系统理论从何而来</span><a href="#21-gong-li-ti-xi-ji-he-de-xi-tong-li-lun-cong-he-er-lai" class="header-anchor">#</a></h3><!-- ![](/images/81.jpg) --><p>&emsp;&emsp;说到几何学，大家就会想到欧几里得几何，以及他那本影响至今的数学书《几何原本》。这本书的完整性和严密性令人叹为观止，2000多年后的今天依然有不少人将它作为数学教材使用。那么欧几里得把零散的几何学知识通过公理化系统统一起来有什么意义呢？我们不妨先看看这样一个实例。</p><details><summary>...</summary>&emsp;&emsp;在清朝末年，李善兰等人翻译了《几何原本》的全文之前，中国当时的数学家们估算圆周率还比不上1000多年前的祖冲之（祖冲之推算到小数点后7位）。类似的，同时期阿拉伯学者的水平，也未必能超过他们1000年前的祖先花拉子密。&emsp;&emsp;当然，你可以说祖冲之的方法失传了，不过失传本身就投射出那些学问很难学。其实类似的情况举不胜举，古代东方文明经常是后人不如前人，很多研究都得一遍遍从头再来，这导致了科学研究在上千年的时间里原地踏步。&emsp;&emsp;但是，《几何原本》传入中国之后，数学面貌就大为改观了。比如，曾纪鸿（曾国藩的小儿子）在李善兰的指导下，自己拿着这本书和入门的代数书学习之后，很快成为了数学大家，并一口气将圆周率推算出200位，这就是系统学习成体系的知识所带来的好处。同时也说明像《几何原本》这样的系统著作在传播知识上的便利性。&emsp;&emsp;那么为什么公理体系的数学理论那么厉害呢？简单地讲，再难的数学题，都可以通过一个个定理，不断地被拆解成一些比较简单的问题，并最终被拆解为几个基本的公理，只要把那些小问题解决了，难题就解决了。&emsp;&emsp;因此，掌握了这样一些基本方法，不仅各种应用难题都可以得到解决，而且还有可能推导出新的定理。具体到几何学，它就是建立在下面五条一般性的公理（也被称为一般性概念），和五条几何学公理（也被称为公设）之上的。其中五条一般性的公理分别是：- 如果a=b, b=c, 那么a=c；- 如果a=b，c=d，那么a+c=b+d;- 如果a=b，c=d，那么a-c=b-d;- 彼此能重合的物体（图形）是全等的;- 整体大于部分。看了这些公理，你可能会觉得它们都是大白话，但是在数学上，什么事情都不能想当然，都要有根据，如果一个结论实在找不到根据，它似乎又是符合事实的，只能称之为公理了。当然，如果是能够从其它公理推导出来的结论就不是公理，而是定理了。&emsp;&emsp;对于几何学来讲，它还需要一些和几何有关的公理支持它（它们也被称为公设，我在课中称之为几何公理），欧几里得给出了这样五条：- 由任意一点到另外任意一点可以画直线（也称为直线公理）；- 一条有限直线可以继续延长；- 以任意点为心，以任意的距离（半径）可以画圆（圆公理）；- 凡直角都彼此相等（垂直公理）；- 过直线外的一个点，可以做一条，而且仅可以做一条该直线的平行线（平行公理）。至于平行线，就是平面上永不相交的两条线。这五条公理读起来也是大白话，只有其中第五条是我根据它的含义用我的语言给你解释了一遍，原来的描述非常费解。对于前四条，数学家们都没有异议，对于第五条面对的挑战，我们后面讲。&emsp;&emsp;有了五条基本公理和五条几何公理，欧几里得又定义了一些基本的几何学概念，比如点、线、夹角等等，在这些基础之上，他把当时所知的所有几何学知识都装进了一个极为严密的知识体系。欧几里得构建公理化的几何学的过程是这样的：- 首先，遇到一个具体问题，要作相应的定义，比如什么是夹角；- 其次，从定义和公理出发，得到相关的定理；- 然后，再定义更多的概念，用公理和定理推导出更多的定理；这样，不断循环，几何学大厦就构成了。在构建几何学的体系中，逻辑是从一个结论通向另一个结论唯一的通道。接下来，我们用两个例子，来进一步说明上述思路。首先我们证明一个简单的定理——“对顶角相等”。这一个定理是这样说的：L1（即AB）和L2（即CD）是两条直线，它们相交于O点，∠1和∠2被称为对顶角（这句话其实是对顶角的定义）。结论：∠1等于∠2：![](/images/82.jpg)为了证明这个定理，我们先要证明一个引理：所有直线对应的角都相等，也就是我们所说的180度。大家看到这个引理可能会说，这不是显而易见的吗？在几何学中，除了公理之外，没有什么是显而易见的规律，所有的表述（statements）都需要证明。&emsp;&emsp;怎么证明这个引理呢？我们只能从定义和公理出发。我们要用到两个定义，即垂直的定义，以及直角的定义。垂直的定义是怎么说的？当一条直线L和另一条直线M相交后，左右两边的夹角相等，则称M和L垂直：&emsp;&emsp;在图中，L和M相交后，左右两个角都相等，于是M和L垂直。![](/images/83.jpg)那么直角是怎么定义的呢？如果直线L和M垂直，那么夹角就是直角。从这两个定义我们可以得到什么结论呢：就是一条直线自身的角度，等于左右两个直角相加，这是显而易见的。&emsp;&emsp;接下来我们就可以利用垂直公理了。因为任何直角都相等（都是90度），而任何一条线对应的角是两个直角相加，于是，所有直线对应的角都相等（当然，严格地讲，得到这个结论还需要用一次一般性公理2）。&emsp;&emsp;有了这个引理，我们再回去证明对顶角相等。&emsp;&emsp;我们先看图中直线L1，这条直线对应的角是∠1和∠3两个角相加，至于直线L2，它也是两个角相加，即∠2+∠3。&emsp;&emsp;这时我们就可以利用前面证明的引理了，由于任何直线对应的角都相等，因此，∠1+∠3=∠2+∠3。&emsp;&emsp;再接下来，我们利用一般性公理的第3条，等式的两边都减去一个相等的量，它们依然相等。于是，我们将上面的式子两边减去∠3，就得出∠1和∠2相等的结论。&emsp;&emsp;到此，对顶角相等这件事才算证明完，就成为一条定理了。为了方便你理解这个证明过程的逻辑性，我把这个过程中用到的定义和公理，以及它们的前后依赖性，总结成一张流程图：![](/images/84.jpg)看到我这个证明，你可能会说，真啰嗦，为什么不直接用量角器量一量∠1和∠2是否相等呢？正如我们在前面介绍毕达哥拉斯定理中所讲的，这样得到的结论不是数学的结论，最多算是实验科学的结论。&emsp;&emsp;在前面我们证明对顶角相等时，我们只用到了定义和几个基本的公理，没有加入任何主观的假设，也没有用到任何公理之外，看似是正确的客观假设。即使对于“凡直线对应的角都相等”这样直观的结论，我们也经过了严格的证明，这样我们得到的定理才坚实。&emsp;&emsp;对于上述定理的证明，我还要多说一句，无论在证明引理时，还是在证明后来的定理时，我都借助了和问题并不直接相关的媒介。在证明引理时，我采用了一条垂线，它在几何学上被称为辅助线；在证明定理时，我采用了一个辅助角（∠3）。&emsp;&emsp;它们都是我为了证明而虚构出来的东西，但是这些虚构的东西对证明实在的事情有帮助。大家如果回想一下我们之前讲到的虚数这个工具，结合今天使用的辅助线和辅助角，可能就更进一步理解数学中虚与实的关系了。&emsp;&emsp;接下来，我们再看看假如有了“对顶角相等”这个定理，还能得到什么其他的结论。我们用它来证明一个新的定理：内错角相等。当然，在证明这个定理之前，需要先证明另一个定理，被称为“同位角相等”。这个证明我就省略了。同位角和内错角是怎么回事，大家看图，很容易理解。![](/images/85.jpg)在图中，L1和L2是两条平行线，L3和它们相交，∠1和∠2是同位角。而∠2和∠3则被称为是内错角。我们要证明的定理说的是这两个角相等。&emsp;&emsp;现在我们有了“对顶角相等”，以及“同位角相等”这两个定理。从第一个定理出发，我们得知，∠1=∠3，从第二个定理出发，我们得知∠1=∠2。于是，我们应用一般性的公理中的第一条，得到∠2=∠3这个结论。这样我们就又证明了一个定理。&emsp;&emsp;通过上面这两个例子，我们可以看出那么复杂的几何学是如何一步步搭建起来的。这样构建一个知识体系有什么好处？对于很多具体的问题，古代东方文明直接解决具体问题的做法或许也行得通，但是问题和问题因为之间没有太强的逻辑关联，那些数学成就就无法形成体系，而且难以举一反三。&emsp;&emsp;古希腊人这种建立在公理和逻辑基础之上的学科体系，能够逐步通过定理建立起完整的理论大厦，后人可以不断在前人基础上进步，并且能够解决越来越多的具体问题，这就是为什么我们要学习几何的原因。&emsp;&emsp;在学习它的过程中，我们能体会一个公理系统的结构和构建过程，以便以后做事能事半功倍。事实上，现代的很多学科，包括人文学科，都受益于这种公理化体系的特点。**要点总结：**&emsp;&emsp;整个几何学的基础是十条非常简单的公理，它的发展依靠对新定理的发现和通过逻辑推理证明这些定理。这种严格缜密的思维方式，在古代是古希腊文明所独有的。&emsp;&emsp;在几何学的发展过程中，除了欧几里得，他之前的数学家恩诺皮德斯起了很大的作用，后者明确指出了一般性问题和定理的区别，一般性问题解决得再多，对体系建立的帮助也不大，定理则不同，它们是搭建体系的基石。此后，几何学走向了正轨。&emsp;&emsp;最后，我来分享两点我的体会。首先是如何学习几何，它不在于多做多少题，做练习的目的是理解这个体系中每一个定理的来龙去脉，这样脑子里就有了几何学的导图，遇到新的问题就可以用类似的方法解决。&emsp;&emsp;其次，在任何时候，除了那些客观的、被验证了的，或者不证自明的道理，我们作决定时，不要加上过多的主观假设。我们常说，未经审视的人生没有价值，其实未经逻辑检验的结论，价值也不大。&emsp;&emsp;当然，讲到公理的作用，大家可能会想，如果一开始使用了一个错误的前提作为了公理，会是什么结果呢？这个我们下一讲再讲。下一讲见。</details><h3><span id="22-fei-ou-ji-he-xiang-dui-lun-de-shu-xue-ji-chu-shi-shi-me">22 ｜ 非欧几何：相对论的数学基础是什么</span><a href="#22-fei-ou-ji-he-xiang-dui-lun-de-shu-xue-ji-chu-shi-shi-me" class="header-anchor">#</a></h3><!-- ![](/images/88.jpg) --><p>我们上一讲讲到，整个几何学就是建立在五条一般性公理和五条几何学公理之上的，那些公理都是不证自明的，或者说无法证明的。</p><details><summary>...</summary>&emsp;&emsp;那么万一公理有错，会是什么情况呢？这时会得到两种情况，首先如果某一条自己设定的新公理和现有的公理相矛盾，那么相应的知识体系就建立不起来。&emsp;&emsp;其次，如果那一条和现实世界并不相符的公理和其它的公理没有矛盾，那么就可以根据逻辑推出一个和之前不同的知识体系，这个体系也能自洽，但是可能和其它知识体系相矛盾。&emsp;&emsp;讲回到几何的那几条公理，对于那五条一般性公理，大家都没有疑问，对于几何公理（公设）的前四条，大家也都没有疑问，但是对于第五条，也就是“过直线外的一个点，可以做一条，而且仅可以做一条该直线的平行线。至于平行线，就是平面上永不相交的两条线。”这时就有人犯嘀咕了，会不会经过直线外的一点，能够做出很多条平行线，或者干脆一条也做不出来呢？&emsp;&emsp;当然，我们根据直觉会觉得，欧几里得的想法是对的，因为在现实生活中，我们对任意直线和线外的一点，不可能做不出一条平行线，更不可能做出两条来。但是，由于这个公理本身是无法验证的，又不算很直观，因此对它作其它的假设或许也有道理。&emsp;&emsp;在数学史上，有两个人就把几何学中的第五公理改了，然后依照逻辑，各自创立出一整套能够自洽的新的几何体系。&emsp;&emsp;第一个人叫做罗巴切夫斯基，他假定过直线外一个点，能够做该直线的任意多个平行线。如果我们承认他所作出的这个假设，并且应用由此而来的全部结论，那么空间就由我们平时熟悉的方方正正的形状，变成了马鞍形，也称为双曲面。&emsp;&emsp;在这样的空间里，三角形的三个角加起来就小于180度了。此外，很多欧几里得几何的结论在这个新的体系中都要修改，但需要指出的是，这个新的几何学体系本身是自洽的。今天它就以发明者罗巴切夫斯基的名字命名了，当然中国人为了简单起见，就称呼它为罗氏几何，类似的，欧几里得几何也被称为欧氏几何。&emsp;&emsp;第二个改变第五公理的人是著名数学家黎曼，他假定经过直线外任意一个点，一条平行线也做不出来，这样构建的几何学被称为黎曼几何。在黎曼几何中，空间被扭曲成椭圆球的形状。这个空间每一个切面是椭圆，因此它也被称为椭球空间。如果你在上面画一个三角形，它的三个角加起来大于180度。&emsp;&emsp;这个结论你其实在地球上很容易证实：你从北极出发往正南走100米，再往正西走100米，最后往正北走100米，你又回到了出发的原点，也就是北极点。你走过的这个三角形，三个角之和为270度。![](/images/87.jpg)&emsp;&emsp;此外，黎曼几何本身也是一个自洽的知识体系。黎曼几何和罗氏几何由于得出的很多结论都不符合欧氏几何，因此它们被统称为非欧几何。&emsp;&emsp;为什么数学家们要“吃饱了撑的”，把我们生活的三维扭曲成各种形状，这种虚构出来的几何学体系有用么？要知道，欧几里得所确定的公理已经经过了两千多年的实践检验。应该讲，罗巴切夫斯基和黎曼在构建各自的几何学体系时，也不知道它们有多少实际用途。&emsp;&emsp;不过，黎曼作为数学家，他希望一些涉及到曲面的数学问题在解决的时候简单一些。比如在一个三维的欧几里得空间，一个球面的方程是x^2+y^2+z^2=25，而在黎曼空间中，它就是R=5这么简单。虽然它们在数学上是等价的，但是形式上差异很大。黎曼就希望在解决球面和其它曲面的问题时，最好有形式上比较简单一致的表述方式。&emsp;&emsp;但是，在黎曼几何诞生之后的半个多世纪里，它也没有找到太多实际的用途，真正让它为世人知晓的并非其他数学家，而是著名的物理学家爱因斯坦。在爱因斯坦著名的广义相对论中，所采用的数学工具就是黎曼几何。&emsp;&emsp;根据爱因斯坦的理论，一个质量大的物体（比如恒星），会使得周围的时空弯曲，牛顿所说的万有引力被描述为弯曲时空的一种几何属性，即它的曲率。爱因斯坦用一组方程，把时空的曲率，其中的物质，能量和动量联系在一起。&emsp;&emsp;之所以采用黎曼几何这个工具，而不是欧氏几何来描述广义相对论，是因为时空和物质的分布是互相影响的，并不像牛顿力学里面所认为的时空是固定的。特别是在大质量星球的附近，空间被它的引力场弯曲了：![](/images/86.jpg)&emsp;&emsp;在这样扭曲的空间里，光线走的其实是曲线，而不是直线。1918年，爱丁顿爵士利用日食观察星光曲线的轨迹，证实了爱因斯坦的理论。这件事也让黎曼几何成为了理论物理学家们很常用的工具。&emsp;&emsp;比如，在过去30年中，物理学家对超弦的理论极度着迷，而黎曼几何（以及由它派生出的共形几何），则是这些理论的数学基础。此外黎曼几何在计算机图形学和三维地图绘制等领域有广泛的应用。特别是在计算机图形学中，今天计算机动画的生成离不开它。&emsp;&emsp;既然黎曼几何在很多应用中证实了它的“正确性”，而它的很多结论和欧几里得几何又不相同（比如三角形三个角之和大于180度），是否说明欧几里得几何是错的呢？如果不是，又该怎样理解这样两个不同的几何体系的共存呢？这个问题到了19世纪末已经被数学家们想清楚了。&emsp;&emsp;如果你重新看一遍欧几里得提出的那些公理，就会发现一个问题，他其实根本没有定义什么叫做平面。虽然我们在中学时把所学的欧几里得几何称为了平面几何，但是我们脑子里所想的平面其实是没有定义的，我不知道老师是出于什么原因，把这个问题一带而过了，可能是觉得十几岁的孩子不容易接受比较抽象的概念吧，干脆省略了。&emsp;&emsp;因此，学习了今天的内容后，我觉得大家应该有这样一种理性眼光，就是我们习以为常的事情，在没有明确说明之前，大家的认同其实会有误解。比如我们常常说深颜色，并不觉得这个概念不清晰，但是不同人理解的深颜色可能不同。&emsp;&emsp;事实上，对平面的认识也是如此。到了19世纪后，数学家们发现，如果对平面作如下明确的定义：满足平行公理的面被称为平面，那么欧氏几何的基础就更扎实了。&emsp;&emsp;罗巴切夫斯基等人一开始的工作，并不是想推翻平行公理，而是想看看它能否从其它四条几何公理中推导出来，结果这件事没做成，他们反而创造出了在双曲面上的几何，而黎曼则相反，创造出了椭球上的几何。&emsp;&emsp;需要指出的是，虽然非欧几何和欧氏几何在形式上很不相同，但却是殊途同归。同一个命题，可以在这三种系统的框架内相互转换，因此如果欧几里得几何没有矛盾，非欧几何也就自然没有矛盾。&emsp;&emsp;好了，现在有了三个等价的几何学“工具”，在解决具体问题时选用一个方便的工具，就成为了活学活用数学的技巧了。对于工具的差异，我们可以把它们理解成是一字改锥和十字改锥就可以了。并不是说使用十字改锥的工作一字改锥做不了，而是非常麻烦，而且做起来要非常精细，搞不好就会出错。&emsp;&emsp;当然，如果必须用一字改锥的地方，你用十字改锥，确实多有不便，不过你依然可以拿刀子把一字螺丝修成十字的，然后让十字改锥发挥作用，当然这种做法是多此一举。而爱因斯坦的过人之处在于他善于找到最方便的数学工具。&emsp;&emsp;数学的美妙之处在于它的逻辑自洽性和系统之间的和谐性。黎曼等人修改了一条平行公理，并没有破坏几何学大厦，而只是演绎出一个新的工具。不过，如果你胡乱修改其它的一条公理，比如你把垂直公理给改了，几何学大厦就崩塌了。&emsp;&emsp;事实上，罗巴切夫斯基和黎曼等人在考虑替换几何学公理时，不是随机乱找的，而是发现平行公理的描述比其他的都长很多，非常不直观，而且在整个几何学的公理和定理体系中，它很晚才被用到，也就是说，很多结论的获得并不需要这条公理，使用前面九条就够了。&emsp;&emsp;数学家们曾经怀疑它是否真的是一条独立的公理，或许它只是其它公理的推论而已呢？直到后来意大利数学家贝尔特拉米证明了平行公理和前四条几何公理一样是独立的。&emsp;&emsp;最后，和你分享一下这段历史对我在认知上的两点启发。&emsp;&emsp;首先，今天我们介绍的三种几何系统，其实它们90%的公理都是相同的，最后差出了一条看似最无关紧要的公理，但是，由此之后，发展出来的知识体系就完全不同了。&emsp;&emsp;我们时常在学习别人的经验时，觉得似乎自己学到了，但是做出来的东西就是不一样。大部分时候，这种差异来自于细节，可能就是10%。但是，我们常常会满足于90%的一致性，忽略了那一点差异，这就导致了结果完全不同。&emsp;&emsp;不过，话又说回来，当我们基于新的假设，创造出一个和别人不同的东西时，除非我们的假设很荒唐，否则那些与众不同的东西或许在特定场合有用。我非常喜欢李白的一句话，“天生我材必有用”，不必刻意强求和别人的一致性。作为人，基本的设定没问题，活出自己的精彩是对社会的贡献。&emsp;&emsp;其次，数学是工具，而这种工具可能有很多种，它们彼此甚至是等价的。在不同的应用场景中，有的工具好用，有的费劲，学数学关键是要学会在什么情况下，知道使用什么工具。&emsp;&emsp;下一讲，我们讲讲几何学在另一个维度的发展。我们下一讲再见。</details><h3><span id="23-jie-xi-ji-he-yong-dai-shu-fang-fa-jie-jue-geng-nan-de-ji-he-ti">23 ｜ 解析几何：用代数方法解决更难的几何题</span><a href="#23-jie-xi-ji-he-yong-dai-shu-fang-fa-jie-jue-geng-nan-de-ji-he-ti" class="header-anchor">#</a></h3><!-- ![](/images/89.jpg) --><p>这一讲我们学习解析几何，这是一种能解决几何难题的妙法。</p><details><summary>...</summary>&emsp;&emsp;我们前面说了几何是最早出现的数学分支之一，一般来讲，人类的知识体系是从易到难建立的，但是几何学似乎要比后来出现的代数学来得难，这可能是人类逻辑推理的能力反而不如套用公式的能力强的原因。&emsp;&emsp;那么能否使用代数的方法解决几何学问题呢？也就是写出相应的直线或者曲线的方程，然后再解方程，因为解方程比作几何推论简单。&emsp;&emsp;这是一个非常大胆、极具创造性的想法，可以用“伟大”来形容。我想，即便让我活十辈子，我也想不出这样好的想法。想到这种伟大想法的人，也是一位伟大的人，他是法国思想家和数学家笛卡尔。&emsp;&emsp;解析几何因为要用到坐标，因此你也会偶尔看到坐标几何的说法，它和解析几何是一回事。在西方，很多时候它被称为笛卡尔几何，这是为了纪念笛卡尔，但是在国内我们可能是为了刻意抹去一些外国的人名，你很少看到这样的说法。&emsp;&emsp;不过这样一来，学生们对解析几何的来龙去脉就缺乏了解了。特别是我们所谓的平面直角坐标在西方一律被称为笛卡尔坐标，没有“平面直角坐标”这个词。如果你将来去那里的大学读书，和人家说平面直角坐标，没有人懂。&emsp;&emsp;因此，在这里我给家长一个建议，对于那些教科书中缺失了的数学名词里的外国人名，家长辛苦一点，到网上查一下，给孩子补上。&emsp;&emsp;讲回到解析几何，为什么笛卡尔要设计一种平面坐标，然后将几何图形放到坐标中用代数的方法研究呢？他的目的当然是为了把几何问题变简单，尤其是那些曲线、圆相关的几何问题。&emsp;&emsp;如果你还对初中的数学有印象，就会发现几何在引进圆之后，变得特别难，无论是证明还是计算都是如此，甚至那些内切、外切等概念都很容易混。如果你遇到的是椭圆怎么办？那你的头真的要大了。&emsp;&emsp;其实在笛卡尔之前，已经有人开始研究代数和几何的关系了，但是那时人们除了研究圆的规律，没有太多的几何学问题非要使用坐标和代数不可，因此偶然出现一些零星的方法形成不了知识体系。&emsp;&emsp;到了笛卡尔的时代，情况就变了。开普勒已经提出了行星运动的三定律，这三个定律都是基于椭圆轨道的，而不是当初哥白尼和伽利略基于圆形轨道的。更难的是，当时科学家和仪器商人们开始利用玻璃透镜制造望远镜，就需要研究光在曲面上的折射和反射问题。&emsp;&emsp;这些问题使用传统的几何学工具都很难解决。笛卡尔就是在这个基础之上发明了笛卡尔坐标，以及解析几何的。>注：在笛卡尔之前，虽然有托勒密使用的球面坐标，也有了把平面按照水平和垂直线划分出区域的方法，但是没有人在平面上用两个彼此垂直的无限长的直线设定坐标的方法。因此后世就把这种坐标用他的名字命名了。&emsp;&emsp;笛卡尔发明解析几何的过程很传奇，他身体一直不好，经常躺在病床上，据说他是看到房顶上绕着弧线飞来飞去的苍蝇，想到了把房顶画上格子，来追踪苍蝇的轨迹。&emsp;&emsp;当然，笛卡尔并非是因为看到苍蝇飞就灵机一动地发明了解析几何，而是在脑子里先有构造了解析几何体系的完整想法，并且很清楚如何将平面几何中的图形用代数的公式来描绘。&emsp;&emsp;我们先来看看直线和方程的关系。在代数中有二元一次方程，比如AX+BY+C=0。在平面坐标上，它代表一根直线，这样的一次方程也因此被统称为线性方程。在一些特殊的情况下，比如A=0，它就变成了水平线，反之，如果B=0，就变成了垂直线。如果A=B，直线就和水平、垂直方向都有45度的夹角。![图一](/images/90.jpg)代数和几何被统一起来之后带来了很多好处。&emsp;&emsp;一方面，一些复杂的几何学问题可以变得很容易。比如在几何中有一个定理，三角形的三条中线交于一点，你要用单纯几何的办法证明它还得费点周章，但是用代数的方法在坐标系下证明它，就极为容易。这里限于篇幅的原因我就不给出推导的步骤了，大家记住这个结论就好。&emsp;&emsp;另一方面，解析几何也可以让很多原本看似抽象的代数问题变得很直观。比如我们前面在介绍鸡兔同笼和方程组问题时介绍了二元一次方程组，即每一个方程有两个未知数，方程中的未知数都只能是一次方，这样两个方程一组。但是，当时我们并没有讲这样两个方程所构成的方程组是否有解，事实上一些二元一次方程组无解。比如：- X-Y+3=0- 2X-2Y=0就无解。&emsp;&emsp;另外，有一些方程组却有无数解。比如：- X-Y+3=0- 2X-2Y+6=0接下来问题来了。什么时候方程组有一个解，有无数解，或者根本无解呢？在初中，老师会教给你一些判断标准，这些标准能不能学会并且体会其中的道理，就看各个学生的悟性和理解力了。如果悟性和理解力不够，就看记忆力了。&emsp;&emsp;但是，这些能力都很难复制，张三的悟性给不了李四，李四记住了一个数学知识点，未必能记住下一个。其实学好数学靠的是有一套系统性的方法，和能够帮助理解的工具。对于解方程来讲，解析几何就是理解它们含义的工具。&emsp;&emsp;我们知道，任给一组X和Y，它们其实对应于平面坐标上的一个点。而一个二元一次方程则代表一根直线，方程组中的两个方程就对应于两根直线。&emsp;&emsp;如果这两个方程所代表的直线相交，如下图2所示。那么就说明有一点既在直线1上，又在直线2上，这个交点所对应的X和Y，也就是方程组的解。&emsp;&emsp;如果两条直线平行，就不可能有交点。这就说明不可能有一个点既在直线1上，也在直线2上，那么方程组就无解。&emsp;&emsp;当然，如果两条直线完全重合，那么就有无数个点既在直线1上，也在直线2上，相应的方程就有无数解。&emsp;&emsp;我们把上述三种直线之间的关系画在下面的坐标中。前后三张图中的情形，分别代表有一个解、无解和有很多解的情况。![图二：一个解](/images/91.jpg)![图三：无解](/images/92.jpg)![图四：很多解](/images/93.jpg)当然，我们讲了，数学不能靠测量，解方程不能靠在图上画线，但是利用解析几何这个工具，我们可以很好地理解方程的本质，更好地学会解方程。&emsp;&emsp;接下来，我们就用解析几何这个工具，把之前讲到的一些知识点再串联起来。&emsp;&emsp;首先还要再说一次毕达哥拉斯定理，在笛卡尔坐标中，计算任何两个点之间的距离，必须要用到毕达哥拉斯定理。&emsp;&emsp;其次，我们把前面所说的一元二次方程和一元三次方程，同坐标系中的一些曲线对应起来。一元二次方程对应于抛物线，我在下图中画了三根抛物线。&emsp;&emsp;第一根抛物线和x轴，也就是横轴有两个交点，也就是说，有两个可能的x值，让方程等于零，这两个值就是相应方程的两个解。第二个则只有一个交点，因此相应的方程只有一个解，第三个干脆没有交点，因此对应的方程无解。![图五：两个解的二次方程](/images/94.jpg)![图六：一个解的二次方程](/images/95.jpg)![图七：没有解的二次方程](/images/96.jpg)和二次方程不同的是，三次方程对应的曲线总是一头往负无穷大走，另一头趋向正无穷大，是下面这个图的形状。![图八：三次方程曲线的形状](/images/97.jpg)当曲线从负无穷往正无穷变化时，它一定要经过零这个点。我们前面在介绍三次方程解法时留了一个未回答的问题，就是三次方程一定有实数解。今天我们用解析几何这个工具将它解决了。&emsp;&emsp;通过讲解解析几何发展的历史和它大致的内容，我们首先应该进一步深刻地理解为什么说数学是一种工具。解析几何这种工具在宇宙中是不存在的，完全是笛卡尔等人根据之前的数学理论，按照逻辑凭空构建出来的。&emsp;&emsp;但是它一旦出现，就能很方便地解决过去看似比较难的几何问题，也能解释为什么三次方程一定有实数解这样过去解释不了的问题。从这里，我希望大家能体会数学上的“虚”是可以为现实中的“实”服务这个普遍规律。&emsp;&emsp;接下来，我不知道你是否体会了“融会贯通”这四个字在学习数学过程中的含义。我们通过解析几何把之前很多知识点又串联了起来。学好数学，不是做很多超出自己理解能力的难题，而是把自己有能力理解的知识融会贯通起来。&emsp;&emsp;这样至少能保证数学考80分，而且以后想用的时候，还能把数学这个工具捡回来使用，否则刷再多的题，考试时遇到两道不会做的题，照样考不到80分，更糟糕的是考完试之后，收获几乎是零。&emsp;&emsp;当一个人40岁的时候，发现自己从6岁到大学毕业22岁这16年间，花了1/3的时间学的数学一点用没有，除了会算加减乘除全忘光了，岂不悲哀？早知是这样，何必要刷那些反正自己也理解不了的题呢？&emsp;&emsp;最后，还要强调学会使用工具的重要性，要把学习数学当成学习使用各种工具的练习。解析几何不但承前，而且启后，在它的基础上出现了微积分，笛卡尔也因此成为了牛顿所说的前面的巨人。这些内容，我们到了微积分模块再讲。&emsp;&emsp;下一讲，我们讨论一下几何学公理化体系的本质，以及如何使用构建公理化体系的思维方式。</details><h3><span id="24-wei-shi-me-ji-he-neng-wei-fa-lu-ti-gong-li-lun-ji-chu">24 ｜ 为什么几何能为法律提供理论基础？</span><a href="#24-wei-shi-me-ji-he-neng-wei-fa-lu-ti-gong-li-lun-ji-chu" class="header-anchor">#</a></h3><!-- ![](/images/102.jpg) --><p><strong>通过公理化系统建立起一个知识体系，体现出人类创造思想的最高水平，</strong>如果大家通过这50讲的通识课，在这个水平上有所提高，甚至能够在一定的范围内实践这件事情，则是人生一大成就。</p><details><summary>...</summary>&emsp;&emsp;我们前面讲了几何学是如何从知识点变成公理化系统的，并且讲述了它的好处，这个原则实际上适用于人类文明的各个方面。我们今天先讲两个和数学距离远一点的领域，然后讨论构建公理化知识体系的一般规律。&emsp;&emsp;我们讲的第一个例子是法律学。&emsp;&emsp;今天人们谈起罗马，会说罗马人一共三次征服了世界，第一次是靠武力，第二次是靠拉丁语， 而第三次则是靠罗马的法律体系，简称为罗马法。&emsp;&emsp;今天世界上大部分国家的法律体系都可以归根溯源到罗马法，或者和它有很大的相似性。比如法国著名的《拿破仑法典》，德国的宪法和民法典，日本的宪法和法律系统等等。&emsp;&emsp;那么罗马法和古代中国或者印度的法律有什么区别呢？其实在早期它们的区别并不大，罗马人留下来的最早的法律是“十二铜表法”（因写在12块牌子上而得名），它和古巴比伦《汉谟拉比法典》中的部分内容，以及后来汉朝萧何做的《九章律》等没有什么本质的区别。这就如同几个早期文明在几何学上的研究水平不相上下一样。&emsp;&emsp;但是，几百年后，经过从西塞罗到查士丁尼时期很多法学家的努力，他们为罗马法找到了最基本的根据。于是罗马法就脱胎换骨了，从此和古代文明中那些单纯反映统治者意愿的法律非常不同，成为了一种维持公平公正的系统性工具。&emsp;&emsp;在罗马法中，那些最基本的，不证自明的依据，就是自然法。著名法学家亨利·梅因说：“我找不出任何理由，为什么罗马法律会优于印度法律，假使不是有‘自然法’理论给了它一种与众不同的优秀典型。”&emsp;&emsp;而奠定罗马法学中自然法精神的西塞罗，则是这样明确而系统地阐述了自然法的哲学前提：“法律是自然的力量，是明理之人的智慧和理性，也是衡量合法与非法的尺度。”这句话其实就是我们今天说的一切都要以法律为准绳的另一种表述。&emsp;&emsp;西塞罗强调法律是理性和永恒的，这就如同我们所说的数学的定理是普遍实用的一样，他说：“法律乃是自然中固有的最高理性，它允许做应该做的事情，禁止相反的事情。当这种理性确立在人的心智之上并且得到实现，就是法律。”&emsp;&emsp;到了查士丁尼时期，法学家们在重要法学论著《法学阶梯》中，将自然法嵌入罗马法中的条文，并且从自然法的原则整理和构建了整个罗马法系统。&emsp;&emsp;那么什么是自然法呢？根据《法学阶梯》的描述，罗马法被明确地分为了：自然法、公民法和万民法（相当于国际法）三个部分。自然法是自然界“赋予”一切动物的法律，不论是天空、地上或海里的动物都适用，而不是人类所特有。&emsp;&emsp;比如说，自然法认为，传宗接代是自然赋予的权利，因此产生了男女的结合，这就是婚姻，为此引申出了婚姻法，从而也就有了抚养和教育子女的义务，这就如同母狮子要教小狮子捕食一样。今天大家所共有的动物保护意识和各国制定的动物保护法，就源于罗马法中的自然法原则。&emsp;&emsp;在公民法中，最基本的原则首先涉及到法律的主体是谁，他们的地位如何。根据自然的原则，万物皆平等，因此在罗马法中，凡是称得上是法律主体的“人”，都是平等的。当然在早期，罗马法律的主体只有自然人，而且不包括奴隶。&emsp;&emsp;到了共和时期，罗马出现了很多的社会团体。一些法学家认为：这些团体也应该像人一样具有独立的“人格”；团体中的个人和团体本身是两回事；个人财产和团体财产应该分开，团体的债务不应该转嫁给团体中的个人。这样一来，团体似乎应该和自然人一样，成为法律的主体。&emsp;&emsp;到了帝国时期，“法人”的概念在罗马法律中开始出现，上述的团体在法律上被赋予独立的“人格”。当然，随着越来越多的人获得自由，任何人都成为了法律的主体。到了近代，鉴于法律主体的平等性，妇女和少数族裔被授予了选举权。这些变化的理论基础，源于万物皆平等的自然法则。&emsp;&emsp;作为法律的主体，人自然要被赋予一些不可剥夺的基本权利，最初包括生命权和自由权（早期的法律主体都是自由民）等基本人权。&emsp;&emsp;此外在私有制出现之后，在西方的词汇里，除了有“我”、“你”、“他”这样的代词，还有了“我的”、“你的”、“他的”这些物主代词，���是个人对自己私有财产的所有权也成为了一条不可剥夺的权利，基于这些基本权利，逐渐演绎出后来的物权法、著作权法和专利法，等等。&emsp;&emsp;如果我们对比一下罗马法的体系和欧几里得的几何，就会发现它们的共性：都是建立在不证自明，而且符合自然原则的公理之上，通过自然的逻辑演绎创造出新的定理或者法律条文，并且在此基础之上不断扩展。这样的法律，就不会随着统治者的更换而改变，因此具有很强的生命力。&emsp;&emsp;在西罗马帝国和拜占廷帝国相继灭亡之后，罗马法却传了下来，并且在法国大革命后成为了欧洲各国现代法律的样本。在法国，虽然它的政体经常变化，至今已经是第五共和国了，但是它的民法典自拿破仑开始就没有什么变化，因为建立在罗马法基础之上的原则依然适用。德国在19世纪统一之后，第一部宪法和民法几乎就是直接将罗马法从拉丁语翻译成德语。&emsp;&emsp;我们知道几何是建立在公理之上的，而公理设定的细微差别会导致后来系统巨大的差异，在法律上这种现象也存在。&emsp;&emsp;美国建国的国父们，在《独立宣言》中特别把“追求幸福的权利”写进了这个带有宪法性质的文件。后来就出现了这样的情形，美国人一方面是清教徒，在上帝面前宣誓要对配偶一辈子忠诚和照顾，另一方面却随意离婚而毫无撒谎的羞愧，因为“追求幸福的权利”成了类似于公理的法则。至于法律的主体一开始如何定义，更是会影响到后面所有法律的内容和连带结果。&emsp;&emsp;1862年，美国南北战争时期，当时的总统林肯要说服国会通过《解放黑人奴隶宣言》，但是很多国会中的保守派议员反对，他们的理由是当初宪法并没有谈到废奴这一条。经过一系列的辩论，林肯也没有说服那些议员们。&emsp;&emsp;有一天，林肯想了一个新办法，他到国会讲演时，没有再带那些和法律有关的书籍文件，而是带了本欧几里得的《几何原本》。在国会里，林肯举起这本数学书讲，整个几何学的定理和推理都离不开其中一条公理，那就是所有的直角都相等。既然所有的直角都相等，那么为什么不能人人平等？&emsp;&emsp;当你否认了我们所说的直角公理，即使能构建出一个几何学体系，也是不完整，没有效用的。类似的，如果我们把人的不平等设定为法律的公理，那么构建出的社会也不会是平等的。就这样，林肯让反对《解放黑人奴隶宣言》的议员们语塞了，最终宣言被通过了。&emsp;&emsp;林肯找的这个关联是不是没有逻辑的瞎联系呢？不是的，他是告诉大家，一个好的体系，一定要构建在代表公平和正义的公理之上。&emsp;&emsp;接下来我们讲一个管理学的例子。&emsp;&emsp;我在给企业家们讲课时总是讲，创始人的任务一个是招人，另一个是树立企业文化和基因，包括价值观和做事的原则方法。关于招人的事情我们这里不讲，我们来讲讲后面一条。为什么创始人那么忙，还要做这些事情呢？&emsp;&emsp;如果我们把办公司看成是构建一个公理化的系统，那么创始人一开始确定的做事原则和价值观，就成为了企业立足的公理部分。那些公理一旦确立，后面的人就会演绎出各种不违背公理的行为规范。&emsp;&emsp;一开始设立什么样的公理，就有什么样的体系，这就好比欧几里得几何、罗氏几何以及黎曼几何后来差异很大一样。一个企业如果把客户放在第一位，那么当员工和客户有矛盾时，大家就要想想，是否必须牺牲掉一些自己的利益去满足客户？&emsp;&emsp;另一方面，如果把员工的利益放在第一位，那么即使再困难，也要保证员工的利益，当然，也可以把投资人的利益放在第一位。&emsp;&emsp;我在《谷歌方法论》中讲这三类公司之间并没有好坏之分，坚持做到一点，就是好公司，这就如同欧几里得几何、罗氏几何以及黎曼几何没有对错之分一样。&emsp;&emsp;我还举了三个例子，像阿里巴巴这样的公司就强调客户优先，你经常会看到它处分员工和高管的新闻，但是没有看到它怼客户的新闻。星巴克则正好相反，宁可怼顾客，也要对自己的员工好。至于苹果、微软等公司，则是优先对投资人负责，所以巴菲特很喜欢，而且这两家公司股价的表现确实好。&emsp;&emsp;在几何上，公理之间必须具有一致性，不能产生矛盾。我们不能把欧氏几何、罗氏几何和黎曼几何对平行公理的三种不同假设放在一起，去构建一个同时符合这三个公理的系统。&emsp;&emsp;类似的，在管理上，你也不可能定出三个彼此矛盾的原则，比如喊什么“顾客第一，员工第一和投资人第一”的口号，这种矛盾的价值观发展不出任何有意义的价值体系。最后的结果必然是，每一个无所适从的人都以“老子的利益天下第一”为原则去做事情。&emsp;&emsp;从今天的内容你可以看出，培养一种讲究数学逻辑的、理性的思维方式，可以让我们在很多地方受益。&emsp;&emsp;作为这一模块内容的总结，我最后想再讲两句学习数学的方法和目的。在学习方法上，要从靠悟性和理解力，靠刷题提高覆盖率，转变为靠系统性的方法，融会贯通地理解知识，要练习从基本的假设，也就是我们所说的已知条件出发，采用逻辑客观地推导出结论。要把数学从单纯的脑力练习，变成掌握工具的练习。&emsp;&emsp;下一讲，我会回答大家的一些典型提问。我们下一讲再见。</details><h3><span id="wen-da-shu-xue-de-ji-xian-he-sheng-huo-de-ji-xian-shi-yi-hui-shi-ma">问答 ｜ 数学的“极限”和生活的“极限”是一回事吗？</span><a href="#wen-da-shu-xue-de-ji-xian-he-sheng-huo-de-ji-xian-shi-yi-hui-shi-ma" class="header-anchor">#</a></h3><!-- ![](/images/98.jpg) --><p><em>吴军</em></p><blockquote><p>这一讲我来回答大家的几个典型问题，一起巩固学过的知识，加深对它们的理解。</p></blockquote><p><em>长梦之河</em></p><blockquote><p>老师好，既然工具很重要，那么为什么在小学不教授像二元一次方程[]这样的先进工具来解决鸡兔同笼的问题，还偏偏要用老工具呢？</p></blockquote><details><summary>...</summary>*吴军*&emsp;&emsp;这个问题其实在课程里说了。&emsp;&emsp;除了个别天才，小学生的接受能力其实非常有限。好的教学是根据学生们的接受能力讲授内容，如果明明知道很多学生的接受能力没有达到理解二元一次方程的水平，还硬要往多了教，往深了讲，学生们最好的情况是在不理解的情况下背下来一些方法，差一点的情况是完全蒙了。&emsp;&emsp;从我们很多读者在这门课的留言中可以看出，很多人都有这样痛苦而失败的经历。就算很多人背下来了，当时能做几道题，以后也都忘了，而且由于把数学学成了一门需要死记硬背和刷题的课程，会一辈子烦这门课。因此，不看对象过分拔高，害处远远大于好处。*杨进*>微积分中的极限与我们日常生活中说的极限有什么区别？用动态和极限的眼光看世界是怎样的一种视角？它们具体在生活中的表现方式又是怎样的？谢谢老师。*吴军*微积分中所说的极限和生活中所说的极限有两点是相同的，即：**1.都有不断逼近，或者趋近的含义。**&emsp;&emsp;比如说你健身时负重深蹲的极限是80公斤，不是说你一上来就能负重这么多，而是说你从50公斤开始练习，可能三个月后能够接近这个范围。因此，从动态看问题这方面讲，两者有相通的地方。**2.它们都有一定的预见性，比如知道事情发展下去，一定是某个结果。**&emsp;&emsp;但是它们又有这样两个不同之处。**1.在生活中我们有时说的“某某极限”其实并非数学上极限的概念，它们更像是数学中所说的上界，**或者下界，那才是无法突破的意思。比如我们刚才说的深蹲的极限是80公斤，但是如果你想越过它，可能腿或者腰就要受伤了，这其实是数学里上界的意思，也就是说，一个无法超越的边界。&emsp;&emsp;数学上的极限强调的是，在很长的时间，或者很远处，它最终的趋势并非不能突破，比如我们说斐波那契数列后面和前面两项的比值R，它在黄金分割1.618……附近浮动，有时会大于黄金分割值，有时又小于这个值，并没有无法突破的意思。&emsp;&emsp;在数学上，那些无法突破的边界被称为上界。有些时候，极限是一种上界，比如1/2+1/4+1/8+……= 1，1既是极限，也是上界。但是更多的时候，它们是两回事。**2.数学上的极限是绝对的、明确的，生活中却未必。**比如你以为你跑百米的极限是13秒，但是你可能后来发现其实是12.5秒。随着能力和见识的提高，原本的天花板可能就被突破了。在数学上可没有这么一说。关于这一点，你可以回顾我的《谷歌方法论》第8封信，关于做事情的三条边。&emsp;&emsp;数学上的很多概念和方法，可以帮助我们理解现实生活中的事情，但是它们并不一定能和现实问题划等号。毕竟，世界上有很多问题并非数学问题，这一点我们在课程中也强调过了。*春子*>说到无穷大，最近刚看到大栗博司在他的书《超弦理论》中提及欧拉的一个公式，1+2+3+4+……+∞=-1/12 ，并在书末附带了初等数学证明和高等数学证明，仍觉得难以认同。不知道吴老师是否有点开迷雾的理解方法？*吴军*&emsp;&emsp;这看似荒唐的结论，道出了数学和实验科学的区别。&emsp;&emsp;这个问题在2018年黎曼猜想乌龙事件时，我在《谷歌方法论》专栏里大致介绍了一下。（第196封信 | 黎曼猜想和认识的延展）&emsp;&emsp;当时大家缺乏对数学一些背景知识的了解，因此无法讲得很透。这回我们学了很多数学的道理，能够讲得比较清楚了。&emsp;&emsp;在上面的问题中，首先涉及到数学上一个被称为“延拓”的概念。什么是延拓呢？比如我们过去做减法，2-3的结果就不是自然数了，因此最早人们只能规定，减法必须是大数减去小数，不能反过来。&emsp;&emsp;但是，后来人们就在想，如果我维持减法的逻辑，能否扩展一下数的范围，看看在这样的逻辑下，得到什么结果呢？于是人们就拓展出负数，而且根据和大数减小数完全一样的逻辑，得到了-1这个结果。这就是将减法这种运算延拓到更大的定义空间。&emsp;&emsp;类似的，我们前面讲了，将-1的平方根定义为虚数i，也是对开方运算的“延拓”。注意，延拓的要求是计算的逻辑和原来完全相同。你可以简单地把延拓理解为在想象的世界里，一次合乎逻辑的认知升级。&emsp;&emsp;上面那个问题，其实也涉及到级数（也就是数列相加）这个运算的延拓。我们在前面讲过，一个等比级数，如果比值小于1，它最终的和就是一个有限的数。但是对于下面这个级数，即调和级数：<center>Z＝1/1＋1/2＋1/3＋1/4＋……</center>无限地加下去，结果等于多少呢？看似它后面的各项越来越小，但是总和并不会收敛到一个有限的数，而是无穷大。以后，人们发现，各种计算级数的方法，能够使用的前提就是，最终加起来需要是一个有限的数。如果是无穷大，那些方法算出来的结果没有意义，这就如同要规定被减数必须大于减数一样。&emsp;&emsp;对于上面这一类调和级数，欧拉发现稍微作一点调整，它就会收敛，比如我们计算：![](/images/99.jpg)欧拉发现，它是一个有限的数，恰巧等于圆周率π^2/6。&emsp;&emsp;再接下来，欧拉把这一类的级数再次推广，让级数中的每一项可以是任意的s次方。![](/images/100.jpg)即整数倒数的s次方之和，这里面s可以是任何数。这个函数后来被称为了黎曼Zeta函数（并没有用欧拉的名字命名），但是它通常的解法却被称为了欧拉乘积公式。&emsp;&emsp;欧拉发现只要s大于1，上面这个级数就是收敛的，存在有限的答案。如果s等于1，即前面的调和级数，级数和就是发散的，结果是无穷大。当然，如果s小于1，肯定更是发散的了，因为这时的数值比调和级数要大。于是，按照我们一般的做法，就是为这种Zeta函数画一个有意义的定义域，即s必须大于1。&emsp;&emsp;但是欧拉作为历史上有名的大数学家是很有想象力的。欧拉就想了，如果让s变成了负数，然后还是用s>1的逻辑来计算相应的级数，会是什么样的结果呢？&emsp;&emsp;这种想法在我们的现实世界里是很荒唐的。这就如同大家在小时候如果问老师2-3等于几，大部分老师都会说，别管它，只能是大数减小数，不能倒过来。&emsp;&emsp;但是，欧拉没有去管这件事有没有现实的意义，他只是按照过去的逻辑算了算，就得到一些有趣的结论，比如s＝-1，这个级数其实就是：&emsp;&emsp;Z（-1）= 1+2+3+4+……，即正整数之和，算出来的结果居然是-1/12。&emsp;&emsp;至于这个结论是如何产生的，你不用太关心，当我们把级数的定义范围从必须收敛，延拓到可以不收敛时，就能够得到上述这个符合逻辑，却不符合常识的结论。欧拉其实还得到很多荒唐的结论，我列出了几个：![](/images/101.jpg)从这件事我要强调两点：- 欧拉的这种做法符合逻辑。在数学上，一旦设定好了前提，不论通过什么逻辑得到什么结果，都是合理的，这是数学和自然科学本质的差别。- 但是，在我们通常讨论级数的定义域中，那些结论并不成立。因此大家使用那些结论要特别小心，要注意条件。在欧拉之后，对黎曼Zeta函数的定义又作了延拓，把定义域从实数的范围扩展到复数，并且提出了著名的黎曼猜想，也就是在复数的范围内，讨论Zeta函数在什么时候等于零。&emsp;&emsp;我们前面讲了，Z（-2）=0，其实Z（-4），Z（-6）都等于零。除此之外，还有什么情况可以让Zeta（s）=0呢？黎曼给出了他的想法，说这些让Zeta函数等于零的复数解，都在复数平面的一条直线上，这就是黎曼猜想。&emsp;&emsp;这个问题的细节大家不必关心，只要记住一个事实就可以了，即黎曼猜想和我们今天寻找大素数，改进加密有关。当然，人们认识到这一点，是在黎曼提出那个看似没有太多实际意义的猜想近一百年之后的事情。&emsp;&emsp;从这个例子可以看出数学和自然科学的差别。很多看似荒唐的，却完全符合逻辑的数学结论，并非一点用途没有，很多时候几十、几百年后，我们会发现它们的实际用途。从欧拉看似荒唐地将Zeta函数作延拓，到后来的黎曼猜想，一开始都是单纯的数学加逻辑的游戏，可是我们今天发现它们其实也有用。*吴军*>以上问答就是今天的全部内容，主要回答了最后一个问题，如果你之前听过我的《谷歌方法论》，是否对黎曼猜想的相关内容有新的认识呢？欢迎你继续提问和思考，坚持学习与留言。我们下一模块见！</details><h2><span id="mo-kuai-si-dai-shu-xue-yong-shu-liang-miao-hui-shi-jie">模块四 ｜ 代数学 用数量描绘世界</span><a href="#mo-kuai-si-dai-shu-xue-yong-shu-liang-miao-hui-shi-jie" class="header-anchor">#</a></h2><h3><span id="25-han-shu-shang-cong-jing-tai-dao-dong-tai-cong-ge-ti-dao-qu-shi">25 ｜ 函数（上）：从静态到动态，从个体到趋势</span><a href="#25-han-shu-shang-cong-jing-tai-dao-dong-tai-cong-ge-ti-dao-qu-shi" class="header-anchor">#</a></h3><!-- ![](/images/103.jpg) --><p>从这一讲起我们进入有关代数的模块。在这个模块里，我们还是要培养以动态视角看世界的能力，批量处理问题的能力，并且理解因果关系的本质。</p><details><summary>...</summary>&emsp;&emsp;代数的发展是从列方程和解方程开始的，那些内容我们已经在第二模块中介绍了，因此今天我们就从代数中第二个重要的概念和工具——函数讲起。这一讲的主题是拥有从静态到动态，从个别到趋势的视角。&emsp;&emsp;“函数”这个词我们经常听到，在初中数学里也讲过函数的概念，但是我不清楚你是否还记得它的定义。如果不记得了，并非你的水平不行，更可能是我们的教科书编写得有问题，不容易理解和记忆。我从初中数学书里摘录出了函数的定义，很绕口：&emsp;&emsp;在一个变化过程中，有两个变量x与y，如果对于x的每一个值，y都有唯一的值与它对应，那么就说x是自变量，y是x的函数（因变量）。&emsp;&emsp;这个定义虽然算不上十分严格，但还是比较准确的。不过我估计你如果原来不懂什么是函数，读了这句话后更糊涂了，因为它为了讲述一个概念，又引入了一堆新概念，比如“变化过程”、“自变量”、“对应”等等。&emsp;&emsp;这样的定义让我想起了费曼对一些物理学课本的批评，他的大意是这样的，那些看似严谨的定义，不过是用一些词解释另一些词，学生们就算把它们背得滚瓜烂熟，照样体会不了其中的含义。&emsp;&emsp;那么函数是什么？其实我们在前面已经讲到了很多函数。比如我们说到的抛物线，笛卡尔坐标系上的一根直线，在数列中位置和相应元素的关系，它们都是函数。此外我们前面还提到过指数函数、对数函数等等。&emsp;&emsp;在生活中，函数也是随处可在，比如在一个单位里，员工和他的工资之间，就是一种函数关系。函数的值也并非一定是数字，可以是其他的数据，比如单位里每一个人的父亲是谁，这也是一种函数。从这些例子中，我们可以发现函数的四个共性：&emsp;&emsp;**首先，这些函数里面都有变量，**函数讲的不是3+5，或者2x9这些具体确定的事情。像y=x^2这样的抛物线，x就是变量。像单位里每个人的工资这样的函数，人就是变量。&emsp;&emsp;**第二，它们都有一种对应关系。**比如一个等比数列1，2，4，8，16，……，2^n，……序号n，和相应的元素2^n，就是一种对应关系，2^n就是n的指数。&emsp;&emsp;再比如，我们在介绍解析几何时，讲过一个二元一次方程AX+BY+C=0，它代表一条直线，这也是一个函数，我们每设定一个X值，就能算出一个Y值，这就有了X和Y之间的对应关系。至于某某的父亲是谁，也是一种对应关系。&emsp;&emsp;**第三，上述的对应关系，都必须是确定的，**也就是说，在一个函数中，一个变量只能对应一个值，而不是多个值。比如在等比级数数列中，一个位置上只有一个数，第三个元素不能既是4，又是8。&emsp;&emsp;同样，一个人这一年的年薪不能既是10万，又是20万。当然你可以说我的工资比去年涨了，但是在一个特定的时间，它是确定的。&emsp;&emsp;**第四，也是最后一个特性，函数所对应的关系可以通过数学的方法，或者其它方法算出来。**比如，在二元一次方程里，给定一个X的值，就能算出一个Y值。在一个单位的档案里，给定人，就能查出他的工资。&emsp;&emsp;了解了函数的这四个特性，我们可以看出函数是一种特殊的对应关系，任何一个变量只能对应一个函数值，当一个变量对应了很多数值，这样的对应关系就不是函数。如果我要问你北纬二十度的城市是哪个，你可以找出一大堆，这就不是函数。&emsp;&emsp;虽然我们在前面举函数例子时，举了各种各样的函数，但是人们最初研究函数只是用它来描述数学上一些曲线的变化规律。提出函数这个概念的人就是著名数学家莱布尼茨。他在研究微积分时，常常要确定曲线上每一个点的一些性质，比如它附近的点是否连续，或者曲线在这里的斜率是多少。&emsp;&emsp;当时大家已经普遍利用坐标系（笛卡尔坐标系）这个工具，将曲线画在上面，坐标系的横轴是x轴，纵轴是y轴，因此，大家通常就把函数关系理解成y随着x变化的走势。&emsp;&emsp;比如说，在一个坐标系里，如果x每增加一个单位，y也增加一个或k个单位，那么这种函数关系就是线性的，因为这些点在坐标里画出来就是一条直线。如果x每增加一个单位，y就翻一番，这种函数关系就是指数的，画出来就是一条向上的曲线。&emsp;&emsp;在中文里，“函数”这个词是清末数学家和翻译家李善兰创造出来的。李善兰在翻译西方数学著作时，就根据函数的这种对应变化关系，发明了这个名词，他讲：“凡此变数中函（包含的意思）彼变数者，则此为彼之函数。”&emsp;&emsp;意思是说，凡是这个变量中包含另一个变量，这个变量就称为另一个变量的函数。也就是说，如果y随x变化，y就是x的函数。李善兰的解释并不准确，但是颇为形象。&emsp;&emsp;函数概念的提出在数学史上有划时代的意义。在此之前，人类最初是对一个个的数直接进行计算，后来虽然有了方程式这个工具，但是方程并没有用来表示变量之间的关系，而是作为解题的工具。&emsp;&emsp;到了科学启蒙时代，两件事对函数的出现起到了至关重要的作用，一个是解析几何，这让数学家们可以用曲线把一些方程式联系起来，从而大家可以看到一些变量变化的趋势；另一个是天文学和物理学的发展，需要用公式和曲线表示时间和运动轨迹之间的关系。&emsp;&emsp;莱布尼茨可以说是生逢其时，他出生得足够早，还没有人提出函数的概念，同时又足够晚，以至于各种准备工作都具备了。&emsp;&emsp;有了函数，人类在认识上有了三方面的进步。&emsp;&emsp;**首先，我们就很容易看出两个变量之间是怎样相互影响。**比如你看下面这张图，上面有两个长相差不多的西瓜，后一个的直径比前一个大1/4，从图片上看，它们的差别好像不是很大。&emsp;&emsp;我问过很多人，如果第一个西瓜卖30块钱，第二个你愿意出多少钱？大部分人给我的答案是，最多多出50%的钱吧。其实第二个的重量比前面一个多出了一倍，也就是说大约值60元。![](/images/104.jpg)这个例子说明，我们都知道圆的周长是半径的2π倍，这是一种线性关系，比较好理解。不过圆的面积和半径的关系就是平方关系，理解起来就要费点劲了。比如圆的半径从1变到2，面积就从原来的1倍变到4倍，如果半径再增加到3倍，面积就是原来的9倍。&emsp;&emsp;再往后，球的体积和半径的关系是三次方，半径从1变成2，体积就是原来的8倍，这就更难理解了。虽然人有时能够感觉立方关系的变化比线性的快，但是对于到底增长有多快没有概念。&emsp;&emsp;人对变量之间关系的感觉其实不准确，而函数帮我们弥补了这个先天不足。&emsp;&emsp;其次，函数的第二个意义是让我们从对具体事物、具体数的关注，变成了对趋势的关注，而且可以非常准确地度量变化趋势所带来的差异。&emsp;&emsp;比如我们说，过去几十年中国经济增长较快，经常在8%以上，即使是2017年，依然有6.9%。对于这些数据，其实老百姓没有概念。&emsp;&emsp;GDP的增长是时间的一个函数，我用世界银行公布的过去50多年的数据画了这样一张图，图中蓝线是中国经济增长率曲线，另外两条是印度和美国的。从图中你可以看出中国整体上增长不仅比美国快很多，而且大部分时候比快速增长的印度也高不少。这是横向对比。&emsp;&emsp;如果纵向对比，你会发现中国自从改革开放后，比以前也好不少，60年代初的三年困难时期，以及文革时期，中国是负增长。但是在改革开放后，这种情况就再没有发生了。&emsp;&emsp;很多人平时会对一件事过分敏感，要么因为一个好消息过分乐观，要么因为一个坏消息过分悲观，当我们对函数，而不是一个个具体的数有概念后，我们的见识就容易提高。![](/images/105.jpg)善于做报告的人都知道，在PPT中最好不要直接引用数据，而要把它们变成曲线或者直方图。曲线和直方图其实就是对函数的一种形象表示，它们可以让那些原本对趋势不敏感的听众，实实在在感受到变化。&emsp;&emsp;函数的第三个意义在于帮助我们通过学习几个例题，掌握解决一系列问题的方法。比如我们知道了投掷和抛射一个物体，当初速度一定时，最后它飞行的距离是抛射角度的函数，那么我们就能算出不同角度下，抛射的距离。&emsp;&emsp;了解了这个函数关系，无论是对从事投掷项目的运动员，还是炮兵或者狙击手，都有指导意义。特别是对后者，他们能够通过控制角度，决定落点。如果我们找不到这样的函数关系，靠做实验的方法达到目的，是不现实的。&emsp;&emsp;事实上，最初设计电子计算机的目的，就是根据弹道的函数，计算远程火炮弹道轨迹的，当然，这个函数中不只有角度一个变量，炮弹的速度、空气的阻力和风向等都是变量。**要点总结：**&emsp;&emsp;函数反映出两种变量之间的关系，其中一种变量随着另一种变化，因此在科学史上它提升了人类的认知，将我们从对单个数字、变量的关注，引向了趋势。没有函数，我们其实很难从个别数据样点，体会整体的变化。因此我们的思维方式要从常数思维到变量思维，再到函数思维。&emsp;&emsp;函数还为同一类问题提供了具有普遍性的答案。当我们对函数中不同的变量代入不同的数值时，就会得到相应的结果，这就让人们有了一通百通的可能性。&emsp;&emsp;下一讲，我们讲讲函数的决定性和变量之间的相关性，看看变量和函数之间的因果关系。</details><h3><span id="26-han-shu-xia-ru-he-tong-guo-gong-shi-li-jie-yin-guo-guan-xi">26 ｜ 函数（下）：如何通过公式理解因果关系</span><a href="#26-han-shu-xia-ru-he-tong-guo-gong-shi-li-jie-yin-guo-guan-xi" class="header-anchor">#</a></h3><!-- ![](/images/106.jpg) --><p>我们上一讲在讲函数时说，在函数中，一个变量先变化，另一个随着它变化。比如圆的半径R增加一倍，面积S增加到原来的4倍，后者随着前者变化。</p><details><summary>...</summary>&emsp;&emsp;如果我们把这个关系上升为抽象的逻辑关系，那么就是半径变化是因，面积变化是果。我们用这样一个箭头代表确定性的因果关系 R→S，用下面这样一个函数来表示：<center>S=πR^2</center>通常，我们称R是自变量，S是因变量，或是自变量R的函数，因变量和函数通常说的是一回事。&emsp;&emsp;如果把上面这种函数关系形象地用曲线表示下来，那么它就是半根抛物线：![注：这段曲线只有右半边，没有左半边，因为圆的半径不能是负数](/images/107.jpg)从这个例子可以看出，函数中的自变量，虽然从名称上来看，似乎自己怎么变都行，但其实它有一些特定的限制条件或者范围，比如圆的半径必须大于等于零就是限制条件。我们在之前讲到的几何数列中每一个数，可以表示成2^N（或者r^N），但是，这个N必须是整数，比如1，2，3，4等等，不能是半个，这就是限制条件。&emsp;&emsp;自变量的取值范围或者限制范围，我们称之为函数的定义域。这里面的域，就是疆域的意思，它表明一个函数所描述的变化规律是有范围限制的。当一个函数的定义域确定之后，因变量，也就是函数值也就受到了相应的限制。&emsp;&emsp;比如说几何数列2^N，取值只能是2，4，8，16……这些特定的整数，不可能是2.5这样的小数数字，甚至不可能是3。函数值的变化范围，我们称之为值域，这个名字顾名思义，也很好理解。&emsp;&emsp;类似的，我们上一讲所说的现实生活中遇到的各种函数，也能确定因果关系，定义域和值域。&emsp;&emsp;比如班上每一个人的身高，因果关系就是人决定身高，也就是说“人→身高”。函数的定义域是特指班上的人，不是所有的人，他们的身高也在有限范围之内，比如从1.5米到1.9米，而不是任何的高度。你如果算出一个人的身高是10米，说明一定是什么地方搞错了。&emsp;&emsp;对于函数，**很多人常犯的错误在于没有考虑定义域，滥用函数关系，**比如不能假设圆的半径是负数，然后套用S= πR^2这样的函数去计算面积。类似的，在生活中，很多函数使用起来也要考虑定义域。&emsp;&emsp;比如对于那些平时成绩在90分以上的学生，如果老师每多教10%的内容，他们就能多学会5%，这看似多教是有好处的。但这个函数是有定义域的，对于成绩70分以下的人，这个变化规律可能就不成立了，教得越多，成绩越差。因此，使用任何规律之前要看条件是否相符，不能错误地套用了公式。&emsp;&emsp;讲到函数中的因果关系，有两点需要明确指出。&emsp;&emsp;**首先，数学上的因果关系和生活中的可能不完全相同。**在物理学等自然科学上，因果关系常常是单方向的。&emsp;&emsp;比如你从比萨斜塔上坠下一个球，它就以自由落体的加速度往下坠落，落地时会有一个速度，这个速度是地球重力加速度导致的，因此加速度是速度的因，而不是反过来，这是非常明确的。再比如，张三在20米外观看这件事，那么你先扔了球，他才看见，这也是因果关系，不可能倒过来。&emsp;&emsp;但是数学函数中的因果关系未必如此。在一个函数中，自变量和因变量的角色是可以互换的。我们前面说，给定圆的半径，我们通过一个计算面积的函数S=πR^2，算出面积，因果关系是半径→面积。&emsp;&emsp;但是在现实生活中也有反过来的情况，比如一家四口人到必胜客吃午饭，需要先根据每一个人的饭量，确定面积是多大的披萨饼才够吃，然后根据R=√（S/π）再算出半径（直径），看看是买14寸的、16寸的，还是18寸的。这时面积就是自变量，半径就是因变量了。因果关系变成了面积→半径。&emsp;&emsp;我们同样可以用x坐标代表面积，y坐标代表半径，画一条曲线，就是下面这个形状，如果你对比前一图，会发现两条曲线形状相似，只是翻转了一下。更准确地讲，它和原来的曲线是相对45度角的对角线对称的。![](/images/108.jpg)为了更完整地描述和研究这种把因和果置换后的函数关系，数学家们提出了反函数的概念，比如y =√(x/π)和y=πx^2就是互为反函数。在笛卡尔坐标系中，反函数的图和原来函数的图就总是相对45度角的对角线对称。&emsp;&emsp;比如下图是对数函数（蓝线）和指数函数（绿线）的关系图，它们相对对角线红线是对称的。![](/images/109.jpg)为什么对数函数和指数函数会互为反函数呢？我们不妨从两个角度看同一件事情就知道了。&emsp;&emsp;比如你购买国库券10000元，以6%的年息复合增长，请问12年后你的本息一共是多少呢？我们知道X年后的本息Y是一个指数函数：Y=10000*(1.06)^X，代入X=12，大约是20122元。也就是说大约12年后投资翻了一番。&emsp;&emsp;如果我们倒过来问这个问题，今天买10000元国库券，多少年后才能本息翻一番，那么这就是对数函数的问题了，我们把X作为若干年后的本息总数，Y作为时间，这样 Y=log（X/10000），算出来大约是11.896年，也就是12年左右。因此，指数函数和对数函数互为反函数。&emsp;&emsp;说到投资，这里给大家讲一个计算回报的简单方法——72定律。假如你的投资回报率是每年R%，那么多少年投资才能翻一番呢？基本上是72/R年。刚才的情况是R=6，大约是12年，如果提高到8%，只要9年就够了。&emsp;&emsp;别看这2%的差异并不显大，如果我们把时间放大到36年，也就是一代人的时间，那么回报就是翻番三次和翻番四次的差异了。因此一个人善于理财，还是不善于理财，到退休的时候，财富很容易差出一倍。&emsp;&emsp;**接下来我们谈谈数学上因果关系的第二个注意事项，当一个函数的变化由两个，或者更多的变量决定时，单个变量和函数之间的因果关系，并不是函数值变化的必然原因。**&emsp;&emsp;比如说，我们要计算圆柱体的体积V，它和圆柱半径R的平方成正比，和圆柱的高度h成正比，即<center>V=πR^2*h</center>这时，如果高度增加一倍，体积一定增加一倍吗？我们只能说，有可能，但是前提是半径要保持不变。反过来从结果看，如果体积增加了一倍，我们也并不知道是否是高度变化所引起的。&emsp;&emsp;如果我们把体积V，半径R和高度h的关系画在一个三维的图中，那么大概是下面这张图的样子。从图中你可以看出，决定体积的因素很复杂。![](/images/110.jpg)在多变量的情况下，我们只能得到这样的结论，就是体积的变化和高度的变化是正相关的，而且相关性是100%，也就是说，在其它条件不变的前提下，一个变大，另一个也必然变大。类似的，体积变化和半径变化也是100%正相关的。&emsp;&emsp;在生活中，很多人经常把正相关性、因果关系和必然性相混淆。比如说，每年的平均投资回报率和最后拿回来的钱总数是正相关的，这点毫无疑问。但是在投资时，总是找那些回报率高的项目或者投资产品，20年后拿回来的钱一定多么？&emsp;&emsp;不一定，因为最后能拿回来多少钱，不仅看平均回报率，还要看投资风险，一些高回报的项目也是高风险的。也就是说，平均回报率高，和拿回来的钱多并不形成因果关系。&emsp;&emsp;很多人看到别人投资高风险、高回报的项目发了财，觉得这种好事情也能摊到自己身上，可是等自己真拿出真金白银投资时，高回报没有起作用，高风险却应验在自己身上了。了解了相关性和必然性的差别，能让我们少犯错误。&emsp;&emsp;在上面计算圆柱体积这个例子中，我们还只有两个变量，在很多实际问题中，影响结果的变量非常多。比如在经济学上，美国政府和研究机构公布的各种和经济有关的指标有上万个，试图根据几个指标就预测今后的趋势近乎不可能。&emsp;&emsp;在生物体中，情况更加复杂。经济学上的很多指标好歹还是明确的正相关或者负相关，而生物上很多体征和指标，同我们要找的疾病、遗传，或者新陈代谢的相关性是非常模糊的。在这种情况下，我们把相关性误解为有因果关系的必然性，是非常危险的。&emsp;&emsp;但是，我们也不能因为很难确定必然性，就放弃对相关性的探究。只有当我们发现了影响结果的各种变量，并且搞清楚它们和结果之间的相关性，才能对最后结果的走向有一个全面完整的了解。&emsp;&emsp;比如，当我们知道了决定圆柱体质量的三个因素，即它的半径、高度，以及材料的密度之后，虽然每一个因素都不构成质量增加的因果关系，但是在不同场合，我们就知道该如何调整尺寸和选取材料来达到目的。&emsp;&emsp;学术研究的主要目的，已经从过去那种寻找确定性，变成了挖掘尚未人知的，能影响结果的变量，并且寻找它们和结果之间的相关性。在研究某一个变量的影响时，我们通常要屏蔽其它变量的作用。&emsp;&emsp;比如我们研究体积和尺寸的关系，先要假定半径是不变的，才能知道高度的影响。但这样一来，绝大部分学术研究，特别是人文和社会学科的研究，都不得不集中在几个视角，搞清楚特定变量的影响。这并非研究人员缺乏全局观，而是整个学术界其实给他们的分工就是如此。&emsp;&emsp;今天很多学术专著，也是从特定视角看待问题。万维钢老师讲过一句话，人文和社会学科与自然科学领域的特点完全不同，前者更像是江湖，学者们彼此很难互相说服，这其实非常准确地描述了学术界的特点。&emsp;&emsp;了解了这个特点，我们在看学术专著时，就不要把它当作对某个结论全面的论述，而把它们当成是揭示某种相关性的著作就好。**要点总结：**&emsp;&emsp;只有一个变量的函数，自变量和函数值之间有因果关系，一个变化导致另一个变化。但是，函数的使用要考虑使用范围，对于任何规律其实都是如此。&emsp;&emsp;由多个变量决定函数值的函数，每个变量和函数值有相关性，有些还是百分之百的正相关，但是它们没有决定性，也没有必然的因果关系，切忌把相关性和因果关系混为一谈。今天的学术研究通常只能在几个维度研究相关性，因此对于研究的结论，我们要全面看待。&emsp;&emsp;函数的学习就告一段落，下一讲我们学代数模块的新内容“向量代数”。我们下一讲见！</details><h3><span id="27-xiang-liang-dai-shu-shang-fang-xiang-bi-nu-li-geng-chong-yao-shi-ji-tang-ma">27 ｜ 向量代数（上）：“方向比努力更重要”是鸡汤吗？</span><a href="#27-xiang-liang-dai-shu-shang-fang-xiang-bi-nu-li-geng-chong-yao-shi-ji-tang-ma" class="header-anchor">#</a></h3><!-- ![](/images/111.jpg) --><p>代数学除了给我们带来了方程和函数这两个工具，还揭示了世界上关于数字的另一个规律，就是数字的方向性。大家可能会说，数字怎么会有方向性，我们不妨先看两个例子。</p><details><summary>...</summary>&emsp;&emsp;**第一个例子。**假如你用40公斤的力来拉一个箱子，你的同事用30公斤的力来推，那么箱子受力是多少？你可能会说是70公斤啊，这是小学生学习完加法后给出的答案，但是如果他学习了减法，可能会想到如果两个人用力方向相反，那么就不是70公斤了，而是10公斤。&emsp;&emsp;但是如果两个人用力方向正好呈直角，或者120度角呢？这时合力既不是70公斤，也不是10公斤，具体是多少则取决于彼此用力的夹角。&emsp;&emsp;**第二个例子。**某个建筑工地要实施爆破，爆破的半径是120米，你要赶快逃离。当然能走的道路未必是一个笔直的方向，你有几种选择。&emsp;&emsp;一种是先向北跑了100米，又向东跑了50米，这时你能逃离到安全区吗？如果你只考虑自己跑的路程，你跑了100+50=150米，超过了120米，但是由于你跑动的方向并非一个方向，你其实离爆破中心只有118米，还在危险区内。&emsp;&emsp;在另一种情况下，你先往北跑了100米后，再往东北跑了50米，这时你就离爆破中心139米，你已经安全了。最后一种情况，你先往北跑100米，再往东南跑了150米，这时一共跑了250米，却只离开爆破中心106米，可以讲是吃力不讨好。&emsp;&emsp;我把这几个情况画在了一张图里，图中圆圈的半径是120米，三种情况分别用红线、蓝线和黑线表示了。可以看出，只有第二种情况，即先往北跑，再往东北跑能够跑出爆炸的范围。![](/images/112.jpg)这两个例子虽然是我虚构出来的，但在现实中类似的情况非常多见。我们常说，一个组织，必须形成合力，才能把事情做好，我们还说，一个人如果跑错了方向，再努力也没有用，就和上面两个例子所描述的情况相一致。&emsp;&emsp;因此，在这个世界上，对于大部分物理量和在生活中遇到的数量，我们不仅需要关心数值的大小，还需要关心方向。&emsp;&emsp;物理中的力是如此，生活中我们行驶的路径是如此，一个人、一个企业做事的目标和所投入的努力，也是如此。当我们的知识和阅历增加时，认识水平也要相应地提高，特别是如果我们读完了大学，**每次看到数字时就必须想一想，“是否考虑了方向？”否则我们就还是停留在小学生对数字的理解程度。**&emsp;&emsp;当然，相应的，在数学上也要有工具，来描述带有方向的数字，这种工具被称为向量。类似的，那些只需要关心数值，不关心方向的数量被称为标量。&emsp;&emsp;那么在数学上向量是怎么表示的呢？通常有两种表示法。第一种是用所谓的极坐标的表示方法，比如我们常说“前面100米，11点钟的方向”，这就是在极坐标中对向量的一种描述。100米代表向量的数值，我们通常称之为长度。11点钟的方向，我们通常称之为向量的方向。&emsp;&emsp;在没有参照系的空中或者海上，通常采用这种方法。在世界上一些自然发展起来的城市里，也经常使用这种方式来描述方位，比如在巴黎或者莫斯科，就会以凯旋门或者红场为中心，往某一个方向行进一定的距离。&emsp;&emsp;用这种极坐标表示向量的方式在一些城市就不那么方便了。比如在北京或者纽约这种完全是规划出来的城市，街道是横平竖直的，高楼也挡住了视线，没有人会说往10点钟的方向走400米，因为你要去的点根本没有直通的道路。&emsp;&emsp;实际上，北京和纽约横平竖直的街道本身就是一个笛卡尔坐标，人们通常会这样说：“往东300米见到红绿灯往南拐，再走200米就到了。”我们如果以所在地为原点，按照上北下南左西右东的概念来确定方位的话，往东300米，往南200米，目的地的坐标就是（300，-200），也就是说，我们直接用终点的坐标表示向量更有效。&emsp;&emsp;而那个目标点离我们的距离可以根据勾股定理算出来，是大约360米，和X轴的方位角是斜下方34度，这和我们用长度与角度的组合表示向量是一回事。我把这两种表示法画在了下面的图中。![](/images/113.jpg)通常我们在坐标系中用一个有长度、带箭头的线段表示一个向量。一般来讲，在笛卡尔坐标中我们喜欢将向量的起点放在原点，终点就是坐标系中的某个点，然后我们从原点往那个点画一根带有箭头的线段。不过向量的起始点不重要，重要的是起始点的相对坐标。&emsp;&emsp;比如从原点出发指向（a，b）点的向量，和从（10，10）这个点出发，指向（a+10，b+10）的向量，其实是一回事。&emsp;&emsp;接下来，在给定坐标后，向量的长度和方向怎么计算呢？从图中你可以看出，从原点出发指向（a，b）的向量，其实就是以a，b为直角边的直角三角形的斜边，因此根据毕达哥拉斯定理，我们很容易计算出这个向量的长度r是a的平方加b的平方后开根号。&emsp;&emsp;当然，还可以用余弦三角函数的定义，算出这个向量和X轴的夹角。这两个值我也体现在上图中。&emsp;&emsp;如果我们对比一下极坐标和直角坐标对向量的表示方法，你会发现它们其实是一回事。不过在多维空间中，直角坐标常常更方便。比如三维空间中的一个向量，我们把起点定为原点，它就应该对应一个三维坐标（a，b，c），如果是N维空间的向量，就会对应N个坐标，我们不妨假设为（k1,k2,k3,……,kn）。&emsp;&emsp;任何数量都可以做加减乘除的运算，向量也可以。向量的加法实际上很简单，如果一个向量是（k1,k2,k3,……,kn），另一个是（j1,j2,j3,……,jn），两个向量加起来，就是（k1+j1，k2+j2,k3+j3,……,kn+jn）。但是由于向量有方向性，向量的长度和角度，并不是原来长度和角度简单相加。&emsp;&emsp;下面我们就用二维空间的向量，说说向量相加后的长度。&emsp;&emsp;我们假定有两个向量V1和V2，它们相加后的向量是V3，即V3=V1+V2。那么V3的长度是多少呢？它遵循一个平行四边形法则，为了说明这个法则，我画了一个简单的图：&emsp;&emsp;在图中，V1和V2是两个向量，我们以它们为两条边画一个平行四边形，平行四边形的对角线就是这两个向量之和。![](/images/114.jpg)平行四边形对角线的长度，我们可以用余弦定理算出来，这里我们就把公式省略了，转而讨论几个特例情况，这样大家更容易有直观的认识。为了方便起见，我只给出V1和V2长度相等的情况，而且假设它们都是单位长度，这时当V1和V2有不同夹角时，V3的长度如下：- V1和V2方向相同，那么V3的长度正好是两个向量长度的总和，也就是2， 这是最长的情况。- V1和V2呈30度夹角，那么V3大约是1.93，也非常长。- V1和V2呈60度夹角，V3是1.73，就已经有点短了。- 如果V1和V2垂直，那么它们相加，V3的长度正好符合毕达哥拉斯定理，大约是1.4。- V1和V2呈120度夹角，那么V3的长度只有1，也就是说等于V1或者V2本身，这样两个向量叠加后在长度上并没有产生什么效果。- 如果V1和V2呈150度夹角，那么V3的长度只有大约0.5，也就是说等于原来V1或者V2的一半。- 最后，如果V1和V2方向相反，也就是呈180度夹角，V3等于零，也就是说V1和V2抵消掉了。从这个结果可以看出，要形成合力就必须方向一致，即便方向不能完全一样，彼此之间方向的夹角也需要尽可能地小。如果两个向量的夹角超过了120度，那么两个力加起来还不如一个力的作用。&emsp;&emsp;理解了数量的方向性，我们就可以得到一个自然的推论，那就是做事情要聚焦。如果不聚焦是什么结果？你往三个方向使劲，每一次努力其实都是有成本的，但是很多时候努力相互抵消掉了。&emsp;&emsp;一个单位里，特别是那些规模不大的创业公司，**如果什么事情都想做，力量不仅分散，而且彼此会产生矛盾，作用就抵消了。即使没有太多矛盾，只要用力的方向不一致，效率就低。**&emsp;&emsp;比如说如果两个人用力的方向是120度，也就是说有时候合作，有时候闹分歧，结果就是两个人工作只产生了一个人原来应有的产出。一些企业迷信把几个牛人堆到一起就能产生好的效果，这其实是小学生的思维方式。如果找来的人不能配合，有时越牛越有副作用。&emsp;&emsp;不仅多个人合作会因为方向不一致出问题，一个人自己努力，如果方向总是摇摆，也会出大问题，比如我们前面举的逃离爆破现场的例子中，方向来回换，特别是动不动拐大弯，其实最后是在兜圈子。&emsp;&emsp;既然向量之间的夹角这么重要，它们又是怎样计算的呢？其实也是用余弦定理。计算向量的夹角有一系列非常重要的应用，这些我们下一讲再讲。</details><h3><span id="28-xiang-liang-dai-shu-xia-ru-he-tong-guo-xiang-liang-jia-jiao-li-jie-wei-du">28 ｜ 向量代数（下）：如何通过向量夹角理解“维度”？</span><a href="#28-xiang-liang-dai-shu-xia-ru-he-tong-guo-xiang-liang-jia-jiao-li-jie-wei-du" class="header-anchor">#</a></h3><!-- ![](/images/116.jpg) --><p>上一讲我们讲到，要形成合力，就需要力的方向一致。类似的，要走得远，也需要前进的方向不经常出现偏差，这些都涉及到向量之间角度的计算。而这个计算是依靠余弦定理完成的。</p><details><summary>...</summary>&emsp;&emsp;余弦定理大家在中学都学过，但我估计绝大部分人都忘了，因为你恐怕一辈子也没有用一次。这也不能完全怪大家，因为在中学里，我们教余弦定理时，主要是为了让大家知道在三角形已知两条边的情况下，如何计算第三条边的长度，而这件事在我们生活中几乎用不到。我们的教科书中，对于余弦定理其它的应用根本没有讲。&emsp;&emsp;今天，我们就从毕达哥拉斯定理出发，给大家定性地讲讲余弦定理是怎么一回事，看看它除了算三角形的边长外，还有什么用。&emsp;&emsp;我们先来回顾一下毕达哥拉斯定理。假如三角形的两条直角边是a和b，那么斜边c²=a²+b²。为了加强你的感性认识，我把之前我们画的图又画了一遍，然后把这个公式写在了图的下方：![c²=a²+b²](/images/117.jpg)接下来我问大家一个问题，如果a和b的夹角是锐角，也就是比90度小，那么c²和a²+b²哪个更大？如果是钝角呢，也就是比90度大的角，情况又如何呢？这个问题其实我们画一下图就一目了然了。![](/images/118.jpg)&emsp;&emsp;从图中很容易看出，如果a和b的夹角超过90度，也就是图中蓝色的部分，所对应的斜边比较长，c²超过了a²+b²。如果不到90度，那么就比较短，c²<a²+b²。 10="" 20="" 40="" &emsp;&emsp;也就是说，对比一下c²，以及a²+b²，就知道夹角是什么样的角了。为了进一步方便起见，我们把毕达哥拉斯定理重新写一下，变成这样一种形式：a²+b²-c²="0，我们将等式左边的部分，也就是a²+b²-c²作为一个判定因子使用，我们用𝚫表示它。根据𝚫和0比较的大小，就可以判断夹角。具体的判别如下：判定因子小于0为钝角，等于0为直角，大于0为锐角。" ![](="" images="" 119.jpg)="" 如果我们回顾一下函数的概念，就会发现𝚫是a，b，c三个变量的函数。对于同样一个角，如果三角形边长都比较长，那么𝚫的动态范围很大。如果边长很短，𝚫的动态范围就很小。="" &emsp;&emsp;为了消除边长的影响，我们将𝚫再除以夹角的两个边长（a和b）的积，这样可以保证处理过的𝚫的动态范围就在-2到+2之间。="" &emsp;&emsp;如果𝚫="-2，那么夹角最大，就是180度。如果是0，就是90度。如果是2，就是0度角。当然我们还可以再除以2，将这个值的范围规整为-1到1之间，事实上它就等于夹角的余弦。" &emsp;&emsp;**这样一来，我们就从毕达哥拉斯定理出发，建立了角度判定因子𝚫和具体角度的关系，然后我们将这种关系称作余弦定理。**="" &emsp;&emsp;余弦定理的思想最初出现在欧几里得的《几何原本》中，但是由于当时并没有成体系的三角学，因此并没有把这个判定因子和角度的函数用余弦表示出来。到了15世纪，波斯数学家贾姆希德·阿尔卡西正式提出了余弦定理。="" &emsp;&emsp;今天，我们之所以花了不少篇幅讲解余弦定理的来龙去脉，是让你再次体会数学体系的重要性，因为它可以从已知的定理推导出新的定理。由此，我们可以体会各种数学概念之间的关联。当然这只是我们讲述余弦定理的附带目的，主要目的是介绍向量夹角的计算。="" &emsp;&emsp;回到向量夹角计算的问题，当两个向量确定之后，我们可以把它们的起点都挪到原点，它们各自的终点和原点之间，就构成一个三角形，如下图所示。这个三角形的三条边显然是确定的，由此我们可以算出判定因子𝚫，然后根据余弦定理计算两个向量的夹角。="" 120.jpg)="" **接下来的问题就是，算出两个向量的夹角有什么用？**它其实有很多的应用，比如可以对文本进行自动分类。这两件事情看似不相干，怎么会联系到一起呢？下面我们就大致介绍一下计算机进行文本自动分类的原理。="" &emsp;&emsp;我们知道一篇文章的主题和内容，其实是由它所使用的文字决定的，不同的文章使用的文字不同，但是主题相似的文章使用的文字有很大的相似性。比如讲金融的文章里面可能会经常出现“金融”、“股票”、“交易”、“经济”等词，讲计算机的则会经常出现“软件”、“互联网”、“半导体”等词。="" &emsp;&emsp;假如这两部分关键词没有重复，那么我们很容易把这两类文本分开。假如它们有重复怎么办？那么我们就要看这两类文章中，各个词的频率了。根据我们的经验，即使在金融类的文章中混有一些计算机类的词，那么它们的词频不会太高，反之亦然。="" &emsp;&emsp;为方便说明如何区分这两类文章，我们就假设汉语中只有“金融”、“股票”、“交易”、“经济”、“计算机”、“软件”、“互联网”和“半导体”这八个词。假设有一篇经济学的文章，这八个词出现的次数分别是（23，32，14，10，1，0，3，2），另一篇是计算机的文章，这八个词出现的次数是（3，2，4，0，41，30，31，12），这样它们就各自形成一个八维的向量，我们称之为v1和v2。="" &emsp;&emsp;如果我们能够在八维空间中将它们画出来，你就会发现它们之间的夹角非常大。我算了一下，大概是82度，近乎垂直，或者说正交。由于这些向量每一个维度都是正数，因此它们最大的夹角就是90度，不会更大了。这说明两类不同文章所对应的向量之间的夹角应该很大。="" &emsp;&emsp;如果我们再假设另有一篇文章，八个词的词频是v3="（1，3，0，2，25，23，14，10），那么它和上述第二篇文章对应的向量的夹角只有7.5度。我用二维的坐标将这三个向量的关系大致示意如下。" 121.jpg)="" 从图中可以看出第一个和第二个向量的角度很大，而第二个、第三个的夹角很小。由此，我们大致可以判定第三篇文章应该和第二篇主题相近，也属于计算机类的。="" &emsp;&emsp;接下来我们需要思考一个问题，什么样的向量之间夹角会比较小，什么样的会几乎正交呢？如果你对比上面三个向量，就会发现这样一个特点：当两个向量在同样的维度上的分量都比较大时，它们的夹角就很小。反之，当两个向量在不同维度上分量较大时，就近乎正交。="" &emsp;&emsp;比如第二个、第三个向量，它们在后四个维度分量值都较大，因此它们的夹角就小。而第一个向量在前四个维度的分量较大，在后四个很小，和第二个向量的情况正好错开，因此就近乎正交。关于向量的夹角，有两个特殊情况大家需要留心一下：="" -="" 如果两个向量在各个维度的分量成比例，则它们的夹角为零。="" 如果一个向量在所有的维度都相等，比如像（10，10，10，10，10，10，10，10）这样的向量，它可能和任何一个向量都不太接近。这个性质我们后面还要用到。="" 当然，在真实的文本分类中不止这8个词，有10万这个数量级的词汇，因此每一篇文章对应的向量大约有10万维左右，这些向量我们称之为特征向量。通过利用余弦定理计算特征向量之间的夹角，我们就能判断哪些文本比较接近，该属于同一类。="" &emsp;&emsp;向量不仅可以对文章进行分类，而且还可以对人进行分类。今天很多大公司在招聘员工时，由于简历特别多，会先用计算机自动筛选简历，其方法的本质，就是把人根据简历向量化，然后计算夹角。具体的做法常常是这样的：="" &emsp;&emsp;首先，它们会把各种技能和素质列成一张表，这就如同我们在做文本分类时会把词汇列成一张表一样，这个表有n个维度。="" &emsp;&emsp;对于不同岗位人员的要求，体现为某些维度权重很高，某些较低，一些无关的就可以是零。比如说对开发人员的要求主要是六个方面，权重如下:="" 编程能力="" 工程经验="" 沟通能力="" 学历和专业基础="" 领导力="" 和企业文化的融合度="" 对销售岗位的要求会有所不同。这样每个职位都对应一个n维的向量，我们假设是v。="" &emsp;&emsp;接下来计算机会对简历进行分析，把每一份简历变成一个n维的向量，我们假设是p。="" &emsp;&emsp;然后我们就计算p和v的夹角，如果夹角非常小，那说明某一份简历和某一个岗位可能比较匹配。这时简历才转到相应的hr部门，hr人员才开始看简历。="" &emsp;&emsp;如果某份简历和哪一个岗位都不太匹配，这份简历就石沉大海了。这种做法是否会有误差，让一些好的候选人永远进不了hr人员的视野呢？完全有可能，但是这种概率并不高，因为计算机做的只是初步筛选，标准是比较宽的。="" &emsp;&emsp;要知道今天像google、facebook或者微软这样的公司，一个职位常常有上百个求职者，最少也有十几个，合格的多则有十个、八个，少则有三五个，漏掉一两个合格的人，对公司来讲没什么损失。但是这对于求职者来讲，就是100%的损失。因此，除非有非常强的推荐，否则简历写得不好经常连第一关都过不了。="" &emsp;&emsp;很多人在写简历时常犯的一个毛病就是重点不突出，他们所对应的向量其实就是一种每个维度数值都差不多的向量。我们在前面讲了，这种向量和其它向量的匹配度都不高。="" &emsp;&emsp;很多人喜欢在简历中把自己有关或无关，所有的经历都写进去，然后把自己描绘成全能的人，其实在计算机匹配简历和工作时，这种简历常常一个职位都匹配不上，因为这就像我们前面说的每个分量都是10的向量，和谁的夹角都小不了一样。="" &emsp;&emsp;很多人觉得多写点东西没坏处，这种认识是错误的，这些画蛇添足的内容其实稀释了求职者的竞争力。="" &emsp;&emsp;那么好的简历应该是什么样的呢？如果你在求职单位有熟人，不妨问问他们对某个职位的要求，然后根据这个要求写简历，这样在他们看中的维度你的得分就高，在他们根本不在意的维度，你也不需要强调。="" &emsp;&emsp;今天我们讲了向量之间的夹角是如何计算的。通过它，我们回顾了毕达哥拉斯定理，介绍了余弦定理。然后我们用一些实例说明了向量的用途。下一讲我们看看，很多向量放到一起，会变成什么。="" <="" details=""><h3><span id="29-xian-xing-dai-shu-ju-zhen-dao-di-zen-me-yong">29 ｜ 线性代数：“矩阵”到底怎么用？</span><a href="#29-xian-xing-dai-shu-ju-zhen-dao-di-zen-me-yong" class="header-anchor">#</a></h3><!-- ![](/images/122.jpg) --><p>如果你问一个大学老师，什么是高等数学的基础课？他可能会和你说，微积分和线性代数。对于一个非理工专业的大学生来讲，如果在大学里只学两门数学课，恐怕就是这两门了。微积分主要是训练我们的思维方式，而线性代数，大家在工作和生活中真的用得上。</p><details><summary>...</summary>&emsp;&emsp;关于线性代数，我们其实已经讲了两讲了，只是我没有用这个名词罢了。我们讲的都是向量代数，它其实就是线性代数中最基本的内容。在线性代数中，用到的最多的概念是矩阵。矩阵是怎样一回事，它有什么用途呢？让我们先来看一个具体的矩阵：![](/images/123.jpg)从这个矩阵中你可以看出，它无非就是把数字按照横竖排起来，每一行、每一列数字的数量都相等。比如上面一个矩阵有3行，每行有4个数，我们称这种矩阵为3x4的矩阵。&emsp;&emsp;了解了矩阵的形态，你可能紧接着就有一个问题：把数字这么横平竖直地排列起来有什么用？事实上，把数字这么横平竖直地排列不是原因，而是结果，矩阵产生的原因是向量的扩展。&emsp;&emsp;我们在前面讲了，向量是横着的一排数字，每一个数字代表一个维度的分量。比如一个企业在招聘员工时把所有考核的项目总结为N个维度。每一个岗位对各种能力的侧重点就是一个N维向量，比如办公室部门对人的要求是能力、沟通、协作、健康四个维度，写成V1=（3，2，5，0）。&emsp;&emsp;我们上一讲讲了，可以用它来算算和某个候选人的相似性。当然公司不仅仅有办公室一个部门，还有比如销售部门、研发部门，等等。每一个部门可能又有不同的岗位，每一个岗位的要求就是一个向量。于是，我们就会有V2，V3，V4，……，VM。&emsp;&emsp;这么多向量如果把它们放在一起，怎么表示比较好呢？显然最直观的方式，就是把它们一行行排起来，这形成了一个有M行N列的矩阵。这就是矩阵的由来。&emsp;&emsp;今天“矩阵”这个词无论是在数学上还是生活中都经常用，但是它在数学史上出现的时间非常晚，直到1850年才由英国数学家西尔维斯特（James Joseph Sylvester）发明，而构成它的向量其实出现的时间也很晚，是1835年才被提出来的。&emsp;&emsp;当然，你如果读一些文章会提到早在3世纪的时候，中国数学家就发明了矩阵的原型，类似的话日本人、意大利人和阿拉伯人也都这么说，但是那些所谓的发明和今天的数学发展没有半点关系。&emsp;&emsp;因为对于一个矩阵，不仅仅是把数字一行一列地排起来，更重要的是每一行、每一列需要能够被赋予特殊的含义，而且需要发明出一系列相应的计算，让这个工具能够解决很多问题。西尔维斯特所提出的矩阵则满足了这些要求。关于矩阵的运算有很多，我们接下来就介绍两种最简单的，即加法和乘法。&emsp;&emsp;首先讲讲矩阵的加法。&emsp;&emsp;我们可以把一个M行N列，或者说MxN的矩阵想象成一个公司的M个岗位，每个岗位有N种技能。我们假设这个公司是一家跨国公司，它会对人员有一个总体上的要求，但是对于不同国家的员工在要求上也会有不同的调整，比如对英语水平的要求。&emsp;&emsp;我们把总体要求用矩阵A来表示，某个国家相应的调整用矩阵B来表示。那么矩阵A+B，就是在某个国家具体的要求。为了直观起见，我们就假设矩阵A是上面那个3x4的。矩阵B也需要是一个3x4的矩阵。我们随便写一个B矩阵，比如像下图这样：![](/images/124.jpg)当我们进行A+B时，只要把两个矩阵中相应位置的元素逐一相加即可，也就是说矩阵A加矩阵B，会得到下面的结果。![](/images/125.jpg)今天在生活和工作中，经常需要有相对固定的大的原则，以及针对各种情况的小的变动，这时候就需要有一个相对固定的核心，再加上一个增量，而不是复制一大堆，拷贝以后逐一修改。&emsp;&emsp;相比矩阵加法，用途更大的可能是矩阵乘法。我们先来说说一个矩阵和一个向量是如何相乘，然后再扩展到矩阵和矩阵的乘法。&emsp;&emsp;我们来看一个实际的例子，假如第一家投资银行的股票基金、债券基金和高风险基金的回报分别是：7%、3%和10%，第二家投资银行三类金融产品的回报分别是8%、2%、9%。当然，这些都是历史数据，只能作参考。&emsp;&emsp;你现在有1万元要投资，你是找第一家投行，还是第二家投行给你管钱呢？我们不妨把这两组数放到下面这个矩阵中：![](/images/126.jpg)然后我们根据自己对各种投资的喜爱和对风险的承受能力，分别测算在不同情况下的回报是多少。&emsp;&emsp;比如在第一种情况下，1万元按照上述投资类型的分配方式如下：7000、2000、1000。因为这1万元分到了三个维度中，我们把它写成一个向量，不过为了等会儿方便做乘法，我们将向量竖着写：![](/images/127.jpg)这时，如果把钱交给这两家公司，总的回报就是矩阵R和P1相乘的结果，我先把结果给大家看看，然后再说说是如何计算的。![](/images/128.jpg)我们可以看到，第二家投行带来的投资回报更高。那么这两个数是怎么计算的呢？抛开矩阵和向量，这个问题其实也能算清楚。&emsp;&emsp;就以第一家投行为例，7000元7%的回报是490元，2000元3%的回报是60元，1000元10%的回报是100元，加起来是650元。我们把这个式子列一下：<center>7%x7000+3%x2000+10%x1000=650</center>你如果注意一下上面的矩阵和向量，你会发现这就是矩阵第一行每一个数字，分别和向量的每一个数字相乘之后再相加。为了清楚起见，我把矩阵和向量中参与运算的数字用红颜色标了出来：![](/images/129.jpg)类似的，第二个结果690，就是矩阵第二行和向量各个元素相乘后再相加的结果。&emsp;&emsp;当然，可能有朋友会说，这不就是算术中加权相乘后的连加吗，为什么要搞出矩阵这样一个工具？如果只有三个维度，可能不需要用矩阵，但是如果是1万维、1百万维，人通常就想不清楚了，矩阵就非常直观，使用它既方便又不容易出错。&emsp;&emsp;我们可以这样理解矩阵和向量相乘，它是批处理解决问题的思路，而过去我们学的乘法和连加是单个解决问题的思路。&emsp;&emsp;接下来我们再看另一种情况，假如你这时对风险的承受力比较强，愿意将更多的钱放在高风险、高回报的基金中。比如你按照3000、2000、5000来分配投资，我们把这个向量称为P2，这时哪家的回报更高呢？&emsp;&emsp;我们再用矩阵和向量的乘法做一次，得到下面的结果。![](/images/130.jpg)你可以看出，这时第一家投行给的回报更高了。当然，你还可以尝试其它的投资方式，对应的向量就是P3，P4，P5……&emsp;&emsp;今天，你如果带着一大笔钱找到高盛或者摩根士丹利，问它们会打算怎么帮你投资，它们为你做的第一件事情就是根据历史数据，帮你推算出在不同的投资配比情况下，回报是多少，也就是做我们刚才做的事情。因此，如果你想在投行找工作，用到最多的数学工具就是线性代数中的矩阵运算。&emsp;&emsp;下面，我们把P1，P2, P3……这些向量一字排开，其实就得到一个矩阵P。我们可以写成下面的形式。![](/images/131.jpg)注意，矩阵P的每一列，就是一个个向量P1，P2, P3……&emsp;&emsp;接下来，我们就可以定义矩阵R和矩阵P的乘法了。我们把矩阵R和P中的第一列，也就是向量P1相乘的结果，放在结果矩阵的第一列，把矩阵R和P中第二列向量P2相乘的结果放在结果矩阵的第二列，以此类推。&emsp;&emsp;我们就得到了两个矩阵相乘的结果，它也是一个矩阵：![](/images/132.jpg)在图中，我特意标红了第一个矩阵的第二行，和第二个矩阵的第二列，以及结果矩阵第二行、第二列的数值，因为红色的行和红色的列，元素两两相乘再相加后，就是结果矩阵中的那个结果。对于一般的情况，第一个矩阵中的第i行，和第二个矩阵的第j列，相乘相加，结果就是结果矩阵中第i行、第j列位置的数值。&emsp;&emsp;那么从矩阵和向量相乘，到矩阵相乘有什么好处呢？前一种情形我们可以理解为小批量处理，后一种则是大批量处理。**要点总结：**&emsp;&emsp;我们讲了矩阵这个人们虚构出来的一种工具，利用这种工具，我们能够让计算从单个的，变成批处理的。矩阵有很多用途，我们只讲了一点点，从它的加法，我们可以理解核心矩阵和增量的关系；从它的乘法，我们看到了它在金融中的应用。&emsp;&emsp;要再次强调的是，将单个计算变成大批量处理，这是我们今天在信息时代要有的思维方式。&emsp;&emsp;在结束本模块之前，我们要回答最后一个问题。为什么讨论矩阵运算这样问题的数学分支被称为线性代数？我们回顾一下矩阵和向量的乘法就知道答案了。&emsp;&emsp;在运算时，左边的那个矩阵里的数字可以被看成是一组常数系数，右边竖着的向量中的数字则是未知数变量，这样矩阵和向量的乘法就变成了一组线性方程。如果把它们画在空间中，就是直线、平面或者立方体，都是线性的，不会有任何曲线。因此涉及到这一类的代数运算被称为线性代数。&emsp;&emsp;当然，自然界中很多数学问题并非线性的，但是我们在解决它们的时候经常将问题近似为线性的问题，这样可以利用很多线性代数的工具来解决。&emsp;&emsp;有了解析几何以及代数的基础，我们就可以正式开始讲高等数学中最为重要的微积分的问题了。也希望你把这一讲分享给你的朋友，帮助他们提高批处理问题的能力。我们下一讲再见。</details><h2><span id="mo-kuai-wu-wei-ji-fen">模块五 ｜ 微积分</span><a href="#mo-kuai-wu-wei-ji-fen" class="header-anchor">#</a></h2><h3><span id="30-wei-fen-shang-ru-he-cong-hong-guan-bian-hua-liao-jie-wei-guan-qu-shi">30 ｜ 微分（上）：如何从宏观变化了解微观趋势</span><a href="#30-wei-fen-shang-ru-he-cong-hong-guan-bian-hua-liao-jie-wei-guan-qu-shi" class="header-anchor">#</a></h3><!-- ![](/images/39.jpg) --><p>&emsp;&emsp;我们在前面讲到，线性代数和微积分是高等数学中最重要的两门课，前者有很强的实用价值，后者能提高思维水平，虽然大家平时在工作中未必有机会直接使用它。就拿我来说，工作后用线性代数的机会可能是微积分的100倍。</p><details><summary>...</summary>&emsp;&emsp;但是，学没学过微积分，思维方式会不同，眼中的世界也会有差别。因此，作为数学通识课，我们还是有必要解释微积分的思想，但是我们也就是停留在它的思想方法上，而非细节上。&emsp;&emsp;微积分有两位主要的发明人，牛顿和莱布尼茨。牛顿发明微积分的一个重要原因是，他需要一个数学工具解决力学问题，比如如何计算速度。可能有人会说，这还不容易，在小学我们就教了，就是距离除以时间。&emsp;&emsp;没有错，我们从小学到中学都是这么教的，但这只是一段时间𝛥t的平均速度。如果我要问你，在某一时刻的瞬间速度是多少？你就不知道了，或者只能拿平均速度来近似瞬间速度。或者说，拿宏观的规律近似微观的。&emsp;&emsp;但是在很多场合，我们要了解的是瞬间速度，而不是平均速度。比如一个警察抓超速，依据的就是驾驶者的瞬间速度，而不是他一路开过来的平均速度。对于瞬间速度，牛顿之前的科学家并没有太多的了解，当然也不会计算了。&emsp;&emsp;**那么牛顿是怎么解决这个问题的呢？他采用了无限逼近的方法。具体的想法是这样的：**&emsp;&emsp;首先我们回到速度的定义，就是一段时间里的位移量𝛥S除以相应的时间𝛥t，我们可以写成速度v=𝛥S/𝛥t。我把这种关系用一个示意图表示出来：![](/images/41.jpg)&emsp;&emsp;在左边的图中，横轴是时间轴，纵轴是位移，那条曲线是位移随着时间变化的函数S(t)。我在图中标记了从t0开始的一段时间𝛥t，以及相应的位移量𝛥S，它们构成一个直角三角形的两条直角边。位移量除以时间，就是斜边的斜率。&emsp;&emsp;当时间间隔𝛥t逐渐变小时，这个比值会变化，会越来越反映出在t0点附近的速度。我们在前面介绍了极限的概念，当𝛥t趋近于0时，那条反映速度的斜线，就是曲线在t0点的切线，牛顿就把那个切线的斜率，定义为在t0点的瞬间速度。我们不妨这么写，v(t0)=𝛥S/𝛥t，当𝛥t→0（趋近于0）时。&emsp;&emsp;通过上述方式，牛顿就从平均速度出发，定义了瞬间速度，也就是说，某个时刻的瞬间速度，是这个时刻附近一个无穷小的时间内的平均速度。&emsp;&emsp;如果我们用曲线来考察这种瞬间变化，那么瞬间速度就是距离函数曲线在某个点切线的斜率。由于在每一个时间点，切线的斜率是变化的，因此如果把各个点的切线斜率画出来，它也是一条函数曲线。&emsp;&emsp;牛顿把这个由每个点切线斜率构成的函数，称为原来函数的流数，我们今天称之为导数。通常我们用y=f(x)表示原函数，用y=f’(x)表示它的导数。在上面的例子中，位移的变化函数S(t)是原函数，速度变化的函数v(t)则是原函数的导数，我们可以写成v(t)=S’(t)。![](/images/40.jpg)&emsp;&emsp;正如同速度反映的是距离的变化速率，一个函数的导数所反映的也是原函数变化的速率，比如在上面的图中，我们可以看出原函数增长越来越慢，因此它的导数，也就是增速，是逐渐下降的。&emsp;&emsp;现在我们回顾一下函数这个概念，它反映的是一个变量随着另一个变量的变化，而导数这个概念，则反映函数变化的快慢。比如抛物线函数y=x^2，它在x=1这个点，导数是2，也就是说x增加一小份（无穷小），y要增加两小份。&emsp;&emsp;相比之下，直线y=x在同一个点的增速就要慢一点，它的导数是1，也就是说x增加一小份，y也增加一小份，因此我们说抛物线在x=1这个点的变化比直线更快。·&emsp;&emsp;对于同一根曲线，我们前后也能对比，比如抛物线在x=2这个点的导数是4，因此我们说，它在x=2时，比x=1时，变化更快。&emsp;&emsp;我们过去也会说，某个函数变化快，某个函数变化慢，但是这些都是宏观的描述，没有量化度量。导数解决了这个问题。我们还说，某个函数，越变越快，这也只是宏观的、定性的分析。&emsp;&emsp;有了导数的概念之后，我们就可以准确地度量任意一个函数在某一个点的变化。因此导数的本质是对变化快慢的准确量化度量。&emsp;&emsp;**导数是微积分中最重要的概念之一，从导数出发我们稍微往前走一小步，就进入到微积分的微分了。**&emsp;&emsp;什么是微分呢？它其实就是在前面有关速度的例子中，𝛥t趋近于零时，𝛥S的值。对此一般性的函数，我们用dx表示自变量趋于零的情况，用dy表示函数的微分。&emsp;&emsp;如果我们对比一下导数的定义f’(x) = 𝛥y/𝛥x，其中𝛥x趋近于零，以及微分的定义dy =f’(x)dx，就可以看出它们讲的其实是一回事，因为𝛥x和𝛥y趋近于零之后，就是dx和dy。有时人们直接将导数写成f’(x) =dy/dx。&emsp;&emsp;如果我们孤立地看微分dy，它是个无穷小，搞出这样一个新概念有什么必要呢？我们用一个具体的例子，也就是有关圆柱体积变化趋势的例子来说明。&emsp;&emsp;我们知道，圆柱体的体积：V=𝛑R^2 h，如果我要问，这个体积随半径变化快，还是随高度变化快？在没有微分这个概念时，一般人根据直觉，会觉得随半径变化快，因为是平方关系，而它随高度变化只是线性关系。&emsp;&emsp;但真实情况是什么样呢？我们可以把体积函数分别对半径和高度各做一次微分，得到下面两个结果：&emsp;&emsp;体积对半径R微分：dV/dR=2𝛑Rh&emsp;&emsp;体积对高度h微分：dV/dh=𝛑R^2 大家不必关心细节，了解一下这样两个结论：- 由于半径增加所带来的体积增量，和圆柱体当前的半径成正比，也和它的高度成正比。- 由于高度增加所带来的体积增量，和圆柱体当前半径的平方成正比，但和它的高度无关。&emsp;&emsp;这时，你如果对比一下两个微分函数就会发现，哪个变化的速率快，还真不好说。假如R等于10，h也等于10，体积就随半径变化快。如果R=10，h只有1，那就是随着高度变化快。&emsp;&emsp;假如你是一个工程师，要建造一个巨大的储油罐，无论你增大半径，还是增加高度，都有相当的工程难度。现在你的研发经费有限，只能在一个维度，增大储油罐的体积，你应该怎么做呢？&emsp;&emsp;如果你没有学过微积分，你可能会觉得该增加半径。但是听了今天的课程之后你就知道，在这个储油罐比较“扁平”时，应该增加高度。总的来讲，当高度没有达到半径的1/2时，都应该增加高度。&emsp;&emsp;我们在工作和生活中，其实经常遇到这样的问题，一个函数取决于很多变量，这时我们不知道该在哪个方向改变，怎样才能以最快的速度进步。微分这个工具，其实给解决这一类的问题提供了很好的方法。它引出了一个梯度的概念，利用梯度，我们就能解决这个问题了。&emsp;&emsp;梯度是微分的一个扩展。在上面的圆柱体问题中，对圆柱体函数，我们可以针对半径求微分dV/dR，也可以针对高度求微分dV/dh。如果我们把这两个微分的结果放到一起，就是梯度，也就是说圆柱体积函数的梯度是（2𝛑Rh，𝛑R^2）。&emsp;&emsp;梯度的物理含义可以这样理解，如果你去登山，怎样沿着最陡的方向，最快地爬到山顶呢？梯度函数告诉你在任意一点，往不同方向走的上升速度是不一样的，因此你很容易找到前进的目标。在圆柱体函数中的梯度是上面那个式子，我们在前面得到的结论是，只要高度小于1/2的半径，就应该优先增加高度。&emsp;&emsp;如果是一个长方体，情况又如何呢？我们先把体积函数写出来，体积等于长乘以宽乘以高度，即 V=L*W*H。接下来，我们可以用微分计算出它的梯度函数。&emsp;&emsp;这里面过程我就省略了，我直接给出答案。这时体积的梯度为 （宽度乘以高度，长度乘以高度，长度乘以宽度），一共三个分量。这时你会发现，长宽高，哪个最小，就应该优先增加哪一个。&emsp;&emsp;比如说，长为10，宽和高分别是4和6，这时梯度函数为（24，60，40），你应该增加宽度。这其实和我们的直觉是一致的，如果我们这样不断优化，最后的结果是长方体变成立方体时，体积达到最大。&emsp;&emsp;不只是数学问题，其实很多时候，我们都面临在限制要素中作选择的问题。很多时候，我们总想全方位改进自己，但是人的精力和资源有限，因此在某一时刻，可能只能向一个方向努力。&emsp;&emsp;希望梯度这个概念在你选择方向时能够给你启发。很多人从直觉出发，觉得该补短板，另一些人则觉得，该把长板变得更长。第一类人会和你讲木桶理论，第二类人会和你讲长板理论，每一类都有很多成功的例子，也有很多失败的教训。&emsp;&emsp;于是很多人就不知道该用哪一个理论了。事实上你今天学了梯度理论后，就很容易作决断了，那就是在任何时刻算出梯度，然后沿着最陡，但是收益最大的路径前进就好。&emsp;&emsp;在增加长方体体积时，显然是在采用补短板的策略，但是在增加圆柱体体积时，就看情况而定了，如果高度太低，它是严重的短板，需要弥补，但是只要它超过圆柱体半径的一半时，就要增加长板（半径）的优势了。&emsp;&emsp;如果说你有一个目标函数，它可能受到多个变量的影响，那是你长期进步的趋势，但是在每一个时刻，你需要计算一下那个函数针对各个变量的微分，也就是梯度函数，找到进步最显著的方向去努力。这就是通过宏观趋势把握微观变化。**要点总结：**&emsp;&emsp;我们从导数出发，介绍了微分的概念，它是我们从函数的宏观趋势，把握每一个点细节变化的工具。然后我们介绍了多变量函数的微分，也就是梯度的概念，并且说明了如何在有大量不确定性，或者说大量的变量中找到前进方向的方法，具体讲就是往坡度最高的方向努力。因此，微积分给我们的第一个思维提升就是练习从宏观趋势中把握微观变化的趋势，让我们认清每一步的方向。&emsp;&emsp;下一讲，我们还讲微积分，透过微积分讨论企业增长里的奇点和连续性。我们下一讲再见。</details><h3><span id="31-wei-fen-xia-gao-dong-qi-dian-li-jie-lian-xu-xing">31 ｜ 微分（下）：搞懂“奇点”，理解“连续性”</span><a href="#31-wei-fen-xia-gao-dong-qi-dian-li-jie-lian-xu-xing" class="header-anchor">#</a></h3><!-- ![](/images/133.jpg) --><p>我们上一讲讲了导数是反映函数在某个点的变化速率，不知你是否会想到这种定义的一个可能的“bug”，对于那些不光滑甚至不连续的阶梯函数，其实在跳跃点是无法计算导数的，因为当𝛥x趋近于零时，𝛥y不是无穷小，而是一个常数。</p><details><summary>...</summary>&emsp;&emsp;对于这种情况，**我们说相应的函数在那个跳跃点不可导。**比如像下面这张图中的曲线，那么那个不连续的点被称为奇点。它是从英语Singular这个词翻译出来的，原意是单独的。**我们常常说的奇点临近，就是指出现了这种不连续的情况。**![](/images/134.jpg)![](/images/135.jpg)那么什么函数是可导的呢？这个问题直到柯西那个年代，数学家们还没有完全搞明白，他们觉得一个函数只要连续，除了有个别的尖尖，绝大部分区域都应该是可导的。&emsp;&emsp;后来魏尔斯特拉斯，就是我们前面讲到的严格定义极限的那位数学家，他提出了一个反例，给出了一种函数，处处连续，但是处处不可导，人们才明白连续和可导是两回事。&emsp;&emsp;关于函数的可导性，大家记住一个简单的结论就可以了，一个连续的、光滑的曲线就可导，这也很好理解，因为函数曲线中的尖尖点是不可导之处，曲线光滑就不会有尖尖点。反过来，今天人们常常用可导性本身来衡量一根曲线是否光滑，有多么光滑。&emsp;&emsp;一个函数的曲线光滑或者不光滑有什么用呢？我可以先把结论告诉你，导数在数学上更本质的意义，在于它是对于连续性的一种测度，光滑、连续的导数曲线，可以成为判断未来走势的依据。&emsp;&emsp;在绝大部分应用中，我们都希望导数曲线是光滑的，因为这意味着变化不会太突然。比如你管理着一家几千人的大公司，你希望它的收入增长曲线是光滑的。假设它的收入S是随着时间t线性增加的，也就是一条直线。&emsp;&emsp;这种公司每一个时间点收入增加的速率是一个常数，这就比较好，因为它的商业活动完全可以预测，管理层作出决策是有依据的，他们知道该怎样扩张生产和招聘人员。&emsp;&emsp;如果一家企业的营收不可导会怎么样？我们先看看它连续不连续，如果不连续，时高时低，这样的公司就完全无法预测，即便是从长远来看它还是增加的，但是你恐怕不太愿意去这样的公司，如果已经呆在里面了，恐怕要随时准备找下一份工作。&emsp;&emsp;如果一个企业的销售是连续变化的，但变化不是可导的，比如增长曲线如下，会有什么问题呢？![](/images/136.jpg)在曲线中我们可以看出，它有三个点不可导，这种公司也很危险。有人可能会说它的变化是连续的，有什么危险？&emsp;&emsp;要知道一个企业无论是生产还是销售，都要提前备料备货，提前雇人。在第一个不可导的尖尖点，企业原本是按照一个直线上涨的速率扩张的，谁知业务逐渐开始萎缩，人员可能不得不裁撤掉一些，备的货也得廉价出售。&emsp;&emsp;到了第二个不可导的点，情况也是如此，原本估计会按照不断加速的情况发展，谁知一下子变成匀速增长了，而且速率还比较低，虽然可能不至于裁员清仓，但企业要花很长时间消化快速扩张的后遗症。&emsp;&emsp;图中还有第三个不可导的地方，就是销售突然加速上升，这是否是好事呢？也不是。为了说明这一点，我给你讲一个我自己经历的商业上的案例。&emsp;&emsp;2008年汶川地震后，很多企业都慷慨捐助，这里面包括知名的饮料公司王老吉。由于它捐助了上亿元（包括产品），并且配合这次慈善行动，进行了大强度的市场推广，喊出口号，大意是说喝饮料就喝王老吉，因此市场反应非常好。&emsp;&emsp;我的一位朋友是商学院教授，我们一起到一个二线城市，在一家还不算太小的饭馆里吃饭时，我的朋友就说，咱们就喝王老吉怎么样？我说好，就让服务员拿两瓶王老吉。谁知服务员说，几天前就卖完了，我就问，为什么不补货？她说不知道，得问经理。&emsp;&emsp;我的朋友也不和她啰嗦，掏出20元，对她说，对面有一个小卖店，你去给我们买两瓶。服务员跑出去不久又回来了，说小店也没有。我的朋友又掏出两百块钱，说，你到周围一公里内帮我们买两瓶，服务员还真去了，过了半天回来说，整条街都没的卖。&emsp;&emsp;我的朋友就讲了，他们这次市场运营，“空中轰炸”做得不错，全国都知道了，但是，“地面挺进”跟不上，他们经理不补货，肯定是批发站都没货了。我们把他们的经理叫来一问，果然如此。&emsp;&emsp;从这件事，我就学到一个营销的策略，“空中轰炸”之前，“地面挺进”要准备好。但是，一家企业的产能是有限的，即使增产，也有滞后（这一点我们在下一讲讲到积分时再讲），因此遇到销售不可导的点，其实对企业发展伤害很大。&emsp;&emsp;如果你兴冲冲地要去喝一种饮料而没有喝到，你就得到一个印象，这东西不知道什么时候有货。这样来几次，你对它的兴趣就没了。无独有偶，2017年特斯拉推出廉价的模型3电动汽车后，订单量暴涨，但是产能跟不上，于是一些不愿意排长队的人就开始退货。事实上特斯拉在过去的5年里，业绩就是这样忽上忽下。&emsp;&emsp;在股市上，如果一家公司的业绩表现总是不平滑变化的，它的股价常常好不了，因为投资人无法预期它的表现。于是稳妥的基金经理人会远离这样的股票。我们常说巴菲特选股票时会选那些市场表现平稳的股票，所谓平稳，就是业绩变化的曲线是光滑的。&emsp;&emsp;接下来我们用导数知识来验证，上面那个曲线图中第二阶段拐了弧线大弯但是可导的点，对企业造成伤害更小这个结论。为了更直观，我们把这个函数的导数也画一遍，你就会发现这其中的原因了。![](/images/137.jpg)从销售情况S的曲线形状来看，它被分为了四段，对应的导数曲线也是四段。第一段是一个大于零的常数，说明它的销售按照固定的速率在上涨，这体现为销售直线上涨。&emsp;&emsp;但是在第一阶段结束时，销售突然从上升到下降，因此那一点不可导，反映在导数曲线上，就是导数曲线不连续，从尖点左边的正值，一下子变成了右边的负值。&emsp;&emsp;在第二段，S的导数一开始处于负值区间，因为对应的销售在不断下滑。但是在这个阶段，销售负增长的速率逐渐放缓，体现在导数曲线上，就是从负值区间逐渐向零靠近。&emsp;&emsp;在箭头这个时间点，导数等于零。也就是说在那个时刻，销售停止了下降趋势，再往后，导数大于零，说明销售情况开始好转，而且增幅在不断加速。&emsp;&emsp;在第二阶段的过程中，所有的趋势是可以预测的，销售虽然出现过下降，但是下降的速率在放缓，直到停止下降趋势，并开始进入增长区间。如果你是这家公司的领导，就会有信心了，并且在销售下降趋势快停止的时候，开始招人准备新的一轮扩张。&emsp;&emsp;对比上述两根曲线，我们总结一下光滑性和连续性之间的关系。- 如果一个函数的导数存在，这个函数一定是连续的，但是反过来却未必正确。- 如果导数大于零，则原函数是增加的，导数越大，增幅越快；如果小于零，则原函数变化的趋势是递减的。如果原函数等于零，则说明在那一个点，原函数不增不减。- 如果导数在某个点不连续，则说明原函数在那个点不可导，要么是出现不连续情况，要么是出现尖尖点。**因此，导数的性质，很好地反映了总量变化的趋势。正是因为有这层关系，“向前看”的人通常更喜欢看一个函数导数的性质，而不是盯着总量。**&emsp;&emsp;比如你经常看到媒体上讨论中国经济增长率是多少，而很少谈论经济总量。事实上大部分中国人都能说出前一个数字，而很少有人知道第二个。前一个数字是导数，后一个是原函数，只要我们能够确认导数是一个比较高的正值，对经济就会有信心。&emsp;&emsp;当然，对于经济增长率，我们希望它是连续变化的，而不是像上图中那样是中断的。如果经济增长率，突然从很高降到很低，那就是所谓的硬着陆，对照上面的图中，就是第二个不可导的点。&emsp;&emsp;相反，如果导数突然上跳，那就是经济过热，对应图中第三个不可导的点。无论是哪一种情况，都会带来很多问题。如果经济增长的曲线是连续的，那么对应经济总量的变化就是光滑的，这是我们所喜欢的。&emsp;&emsp;那么什么样的公司营收容易出现不光滑的波动，也就是不可导的情况？如果一家公司的营收过于单一，那么一旦有点风吹草动，收入就会大幅度波动。&emsp;&emsp;因此，如果两家上市公司的收入都是10亿元，利润也差不多，第一家公司的收入来自很多顾客，第二家来自两个大客户，在这种情况下，第一家公司的估值会比第二家高很多。其中的道理大家不妨自己想，这里可以给大家一个提示，就是从曲线的光滑程度考虑一下。&emsp;&emsp;类似的，一个国家，如果经济结构非常单一，而且产业只有很少几种，它抵抗风险的能力就非常弱。比如世界上很多资源型的国家，当全球经济好的时候，大家都需要购买资源和原材料，它们的经济就欣欣向荣，但是一旦全球的需求稍微有一点变化，或者国际关系出现紧张，它们就陷入危机。&emsp;&emsp;很多人不理解，那些国家抱着金饭碗，为什么不能长期稳定发展？其实你如果看看这个国家的GDP走势，就会发现那根曲线是不可导的。不可导的趋势靠不住。**要点总结：**&emsp;&emsp;我们讲了函数的光滑程度和可导之间的关系，并且通过理论上和实际生活中的各种例证，说明我们追求的目标是拿下光滑的变化趋势，而不是到处是奇点和不可导的尖点的情况。&emsp;&emsp;欢迎你把这篇文章转发给那些正在创业或者负责销售的朋友，看看能否给他们一些启发。我们下一讲再见。</details><h3><span id="32-ji-fen-ru-he-cong-wei-guan-qu-shi-liao-jie-hong-guan-bian-hua">32 ｜ 积分：如何从微观趋势了解宏观变化</span><a href="#32-ji-fen-ru-he-cong-wei-guan-qu-shi-liao-jie-hong-guan-bian-hua" class="header-anchor">#</a></h3><!-- ![](/images/138.jpg) --><p>前两节课，我们讲了微分，它解决的问题是：如何从宏观变化了解微观趋势？今天我们讲积分，它和微分刚好相反，是从微观去看宏观变化。</p><details><summary>...</summary>我们还是先从两个例子入手。**例一：闯红灯的算术题**&emsp;&emsp;假如你开车在大街上按照每小时36公里的速度前进，道路的限速是每小时72公里（虽然70公里的限速更常见，但是为了方便计算，我假设是72公里）。&emsp;&emsp;当你离红绿灯还有70米时，变为黄灯了，黄灯会持续4秒钟变成红灯。这时你前面没有车，或者前面的车正在加速，不会成为你加速的障碍，那么是否该迅速加速闯过去？还是干脆减速停下来等绿灯？&emsp;&emsp;现在我们就来计算一下是否能够在不超过限速的情况下在4秒以内行驶完70米。我们先把时速换成每秒的速度，每小时36公里就是每秒钟10米，这大约是百米运动员的冲刺速度。类似的，每小时72公里，就等同于每秒钟20米。&emsp;&emsp;如果我们不加速，4秒钟只能走过40米，肯定是过不去了。如果我们能瞬间提速到每小时72公里，那么4秒钟可以走完80米，就能合法地在交通灯变红之前经过路口。那么接下来的问题是，我们需要加速多快才能行？&emsp;&emsp;我们假定是匀加速的，每秒能加速a米/秒，也就是说一秒钟后你的速度能够从10米/秒提升到（10+a）米每秒。由于最终的速度是20米/秒，因此加速的时间是10/a秒。我把速度和加速度的关系用下面的图表示出来。![](/images/139.jpg)在图中上方的折线代表速度函数，它和时间相关，是时间的函数，我们用V（t）表示。一开始是每秒10米，后来，也就是经过10/a秒钟之后，提升到每秒20米，然后是匀速。&emsp;&emsp;在这样变速的行进过程中，4秒钟走过多少距离呢？我们从上面的图中可以看出，这个距离就是阴影中所画的多边形的面积（因为时间也就是横坐标，乘以速度也就是纵坐标，就是距离），它等于80-50/a。&emsp;&emsp;如果我们想要它大于70，那么a就必须大于5米/秒^2的加速度，也就是0.5G的加速度，非常高。今天性能好的汽车可以做到这一点，但并不是所有的汽车都能做到。因此从安全考虑，大家在红绿灯处就不要抢最后的几秒钟了。&emsp;&emsp;这个例子里给定一个曲线，求它下方直到x轴之间的面积，这就是积分。对于一般速度曲线，它下面到x轴的面积就是按照这个速度走过的距离。因此，我们可以讲距离是速度的积分。此前我们还讲过速度是距离变化的微分，由此可见微分和积分是互为逆运算的。&emsp;&emsp;那么积分是怎么计算的呢？我们还是以速度和距离的关系为例来说明。&emsp;&emsp;下图是一个具有一般性的速度曲线图。我要算曲线下方到x轴之间的面积不容易直接计算。于是我们就把这条曲线的面积分为很多份，每一份对应一个长方形，然后我们算出每一个长方形的面积，再把它们加起来就可以了。&emsp;&emsp;当然这么计算一定有误差，不过没有关系，当我们把每一份分得非常非常小，小到无穷小，那么这个误差就趋近于零了。我们在前面学习了极限的概念，应该不难理解这一点。![](/images/140.jpg)那么积分思想的本质是什么？它是要从动态变化来看累积效应。比如对于速度来讲，累积效应就是走过的距离。如果我们做匀速运动，速度是个常数，它的曲线就是在坐标轴上和横轴平行的直线，因此走过的距离是速度乘以时间，是个长方形。&emsp;&emsp;但事实上，速度是一个随着时间不断变化的函数，忽快忽慢，那么在这样的速度下走过的距离就需要考虑每一时刻的动态变化了，积分就是提供这样的工具。在没有积分这个工具之前，人们只能通过平均值，大致了解累积效应，但是估计得非常不准确。有了积分，就能把握每一个细节对最后整体的影响了。这是它的第一个意义。&emsp;&emsp;积分的第二个意义是从微观上每一时刻动态的变化理解宏观上积累的效果。**例二：公司利润问题**&emsp;&emsp;我们假设有两家上市公司，上市时利润水平差不多，假定两家公司都是每个季度盈利一亿元。接下来第一家公司的季度盈利情况这样的，1.2亿、1.4亿、1.6亿、1.8亿……换句话说，每个季度的盈利是0.2亿，我们把它们写成一个公式，就是1亿x（1+0.2N），其中N是代表第N个季度。&emsp;&emsp;第二家公司的盈利情况是1.1亿、1.21亿、1.331亿……也就是每次增长前一个季度的0.1倍，我们也可以把它写成一个公式，即1亿x1.1^N。接下来我们就来算算哪家公司5年内挣钱多。&emsp;&emsp;大家可以自己算一下，可能很多人会直接算第五年最后一个季度是多少，觉得第一家公司的利润是线性增长，直到第五年最后一季度才达到5亿元，而第二家公司的利润呈指数增长，第五年最后一个季度是6.7亿元，而它们起步都差不多，因此一定是第二家公司五年累积得多得多。&emsp;&emsp;这个想法非常合乎直觉，但是对不对呢？我们需要算一算。&emsp;&emsp;我们可以把利润理解为刚才讲的速度，也就是纵坐标，那么利润随着横坐标时间的积累就是距离，因此利润的积累实际上是利润函数的积分。我把这两家公司的利润函数画在了下面同一张图中。![](/images/141.jpg)我们对上述两家公司的利润函数求一下积分，这两个公司5年里20个季度累积下来，可能远不像很多人想象的差距大。建议你亲自算一下看看分别是多少。&emsp;&emsp;事实上如果我们把题目稍微改一点，对比到第19个季度，反而是第一家公司累积的利润多，虽然那个季度第二家公司的利润已经高达6.12亿，而同季度第一家只有4.8亿，差距明显。&emsp;&emsp;为什么会是这样的结果呢？这和指数增长快过线性增长是否矛盾呢？一点也不矛盾，因为指数增长的优势需要比较后面才看得出来。在这个例子中，第二家公司的利润在第14季度才赶上第一家，虽然后来它增长快，但是毕竟它超过前者的时间短，在2/3的时间里，都是第一家公司利润高。&emsp;&emsp;从这里面我们得到一个非常重要的结论，就是滞后效应，它包含两个要点：- 凡是需要通过积分获得的数量，它的结果会滞后于瞬间变化，有时还要经过相当长的时间滞后才能看到。- 这种由积分获得的数量，一旦大到被大家都观察到之后，要逆转这个趋势是非常难的。我们有时候也把这种效应称为飞轮效应，因为如果我们在飞轮上匀速用力，根据牛顿第二定律，它的加速度也是匀速的。而速度是加速度的积分，是一个需要积累才能看到的量，因此具有滞后效应。下面我们不妨用积分的原理，量化分析一下飞轮加速为什么很缓慢。&emsp;&emsp;我们假设飞轮的质量是100千克，从边缘到轴心之间，质量的中心大约在离轴心0.32米，转动的手柄也安在那个位置，这样转一圈相当于是2米。&emsp;&emsp;我们用200牛顿的力转这个飞轮，这是一个不算太小的力，根据牛顿第二定律，算下来飞轮有一个恒定的线加速度，即2米/秒^2，如果我们转化成角加速度，就是1周/秒^2，或者说，一秒钟我们可以把飞轮的角速度从零提升到每秒一圈，再过一秒，达到每秒两圈。&emsp;&emsp;接下来我们来分析一下加速度、速度和转动距离（圈数）的关系。只要开始用力，瞬间就获得了加速度，是1米/秒的平方。接下来，经过1秒钟的加速，它的转速达到每秒一转，但这时已经过去了1秒钟，这就是积分的滞后效应。&emsp;&emsp;这时再看它走过的距离，是0.5圈，这也是滞后效应引起的。事实上，它完成一圈的时间大约是1.4秒。也就是说，速度比加速度有滞后，距离比速度有滞后。接下来，在第二秒，它达到每秒两圈的速度，这时飞轮恰好转两圈，此后飞轮会越转越快，累积转过的圈数会以更快的速率提升。&emsp;&emsp;我把上面三者的关系画了一张图，相应的公式和数据也列了出来：a=F/m=2m/s^21、2秒速度是：v=at=2m/s 4m/s 1、2秒时走过的距离是：s=1/2at^2=1m、 4m 手柄距中心0.32米，手柄转一圈2m转换成圈数是0.5、2![](/images/142.jpg)图中的黑线是加速度，它没有延时，红线是速度，它有滞后效应，但是不大。蓝线是距离，是加速度两次积分的结果，滞后效应很大。但是一旦飞轮飞快地转动，如果有一个人想往相反方向用力，让它减速并且扭转，也是非常困难的，需要一段时间，才能将速度降为零，然后再经过一段时间才能逆转，并抵消掉一开始转过的圈数。&emsp;&emsp;我在《谷歌方法论》的206封信谈过“J曲线和滞后效应”，其更本质的原理就在于此。**怎么用？**其实在生活和工作中，我们的努力，就如同用力，你今天晚上努力了，你是知道的，但是得积累一段时间，才会提升你的能力；你的能力积累一段时间，才会变成你的成绩和业绩；而你有一次好成绩，并不会马上得到领导的赏识和同事的认可，要再过一段时间，才会有赏识和认可，才能获得自身利益。&emsp;&emsp;因此我们每一个人都应该记住，从努力，到能力，到成绩，到被赏识，是一级级积分的结果。**反过来也一样，当我们开始觉得自己了不起了，停止努力时，你就会发现，一段时间后，能力就不适应新的工作了，再过一段时间就会做砸几件事情，几次累积下来，在单位的处境就危险了。**这时要扭转局面，为时已晚。&emsp;&emsp;人有一个很大的弱点就在于，他在开始努力的一瞬间，就指望能力马上提升，然后周围的人马上肯定自己，忘记了积累效应。如果别人不肯定他，他就觉得世界对他不公平。而当人开始放松，一开始并没有出问题，但是会逐渐出问题，这时大部分人只会想自己这件事情没有做好，而不是反思自己的问题很早以前就被种下种子。&emsp;&emsp;我们讲微积分，不是学那一个知识点，而是通过积分效应，提升我们的认识水平，同时能用一些工具分析和理解我们生活中的现象。**思考题：**飞轮在第三秒时的速度是多少？&emsp;&emsp;下一讲，我们继续讨论如何换一种动态的眼光去找问题的最优解。我们下一讲再见。</details><h3><span id="33-yong-bian-hua-de-yan-guang-kan-zui-da-zhi-he-zui-xiao-zhi">33 ｜ 用变化的眼光看最大值和最小值</span><a href="#33-yong-bian-hua-de-yan-guang-kan-zui-da-zhi-he-zui-xiao-zhi" class="header-anchor">#</a></h3><!-- ![](/images/144.jpg) --><p>今天高等数学最常见的一个应用是对这种现实的问题实现最优化，比如炙手可热的机器学习，其实就是对一个目标函数实现最优化的过程。此外，金融上的结构化投资产品，商业上的博弈论，企业管理中的各种规划，其实也都是不同形式的最优化。</p><details><summary>...</summary>&emsp;&emsp;那么什么是最优化？其实它最简单的形态大家都不陌生，就是求一个函数的最大值或最小值。由于这两个问题是对称的，解法类似，因此我们就以求最大值为例来说明。&emsp;&emsp;对于一个有限的集合，求最大值是一件很容易的事情，比如在计算机计算问题中就有很多寻找最大值的算法。所有那些算法的一个核心思想，就是比较大小。如果有一个元素在直接或者间接地和其它的元素对比后，它比谁都多，它就是最大值。&emsp;&emsp;这是一种寻找最大值的思想，但在一个有无限集合的函数中就不大灵了，因为你不可能穷尽所有的可能性。那么怎么办呢？这时我们在中学里就要开始学习解题技巧了。**一般人如何求解最大值？**&emsp;&emsp;最著名的解题技巧就是计算抛物线的最大值。比如一个抛物线函数是：y =-x^2+4x，它的最大值是多少？&emsp;&emsp;从直觉我们可以猜出来这个函数的最大值是存在的，因为我们至少有两个理由：- 无论x是一个什么样有限的数，y都不可能是正的无穷大，而是一个有限的数；- 当x趋于正无穷，或者负无穷时，y都是负无穷大。因此我们猜想这个函数应该是两头小，中间大，而且中间是有最大值存在的，但是真让我们找到那个最大值，又无从下手。&emsp;&emsp;很多人会代入几个数字试一试，比如让x=0，我们知道y 也等于零。如果x=1，那么y=3，增加了一些。如果x再增加到2，y会增加到4，但是再往后，y似乎就要往下走了。那么我们能说y的最大值就是4吗？把这个函数对应的曲线画在坐标上，能看出最大值就是4附近：![](/images/145.jpg)但是我们前面说了，在数学上我们不能通过测量得到结论，是要证明的。那么怎么证明呢？在中学里，老师会讲这样一个技巧，我把步骤放在文稿中了，大家有兴趣可以看一下：- 我们把y=-x^2+4x重新组织一下，就得到y=-（x-2）^2+4。推导的过程我就省略了。- 在这个式子里，我们知道（x-2）^2只可能大于零，或者等于零，因此乘以-1之后，-（x-2）^2只可能小于零，或者等于零。后面的4是个常数，不影响y的取值。- 于是y的最大值就是当-（x-2）^2=0的时候，这时y=4。总之，老师教的这个技巧能解决一批同类的抛物线的问题，但是遇到其它的问题，这种技巧还是无能为力。比如要问下面这个函数y=x^3-12x^2+4x+8在0到15之间有没有最大值或者最小值，上面的方法就不灵了。![](/images/146.jpg)因此，靠这样掌握了某个技巧考了高分，也不值得沾沾自喜，因为那种经验很难推广用来解决一般性问题。&emsp;&emsp;在伽利略之前，人类其实没有太多的最优化问题要解决。但是到了伽利略和开普勒那个年代，人们就在物理学和天文学中遇到很多最优化问题了，比如计算行星运动的近日点和远日点距离、弹道的距离、望远镜透镜曲率和放大倍数的关系等等。这时就需要系统地解决最优化问题，而不能单靠一些技巧。这个难题就留给了牛顿。**牛顿怎么求解最大值？**牛顿是怎么考虑这个问题的呢？他的伟大之处在于，他不像前人那样，将最优化问题看成是若干数量比较大小的问题，而看成是研究函数动态变化趋势的问题。这一点很重要。&emsp;&emsp;怎么理解牛顿这个思想呢？我们还是从前面那个求抛物线最高点的问题讲起。为了方便起见，我们把关注点放在最高点附近的位置上，我把上面的曲线又放大画了一遍。&emsp;&emsp;我们在前面的课程讲到过，曲线瞬间变化的速率就是那一点切线的斜率，也就是它的导数。为了强化你对这个要点的理解，我特别将抛物线在最高点附近的斜率变化画出来，给你看一下：![](/images/147.jpg)在图中，上半部分就是前面说的抛物线，只是我为了让大家把曲线变化的细节看得更清楚，将它的横轴拉长了一倍。图中各种颜色的曲线，是一些点的切线。你可以看出，从左到右，抛物线的变化是由快到慢，到平缓，再到下降。而这些切线也是由陡峭变得平缓，在最高点变成了水平线，然后斜率就往下走了。&emsp;&emsp;如果量化地度量它们，在x=0这个点，切线的斜率，也就是相应点的导数是4。到x=0.5时，斜率或者说导数变成了3，然后变成了2，1，0，-1，-2，等等。因此如果我们把导数函数也画在图中，就是那根直的虚线。&emsp;&emsp;**对比抛物线和它的导数（虚的直线），你是否发现了，曲线达到最高点的位置，就是切线变成水平的位置，或者说导数变为0的位置呢？**&emsp;&emsp;如果你看到了这一点，恭喜你，说明你的目光很敏锐。那么这种现象是巧合么？不是！如果我们回到最大值的定义，对应导数的定义，就很容易理解这两件事情的一致性了。&emsp;&emsp;最大值的含义是说某个点a的函数值f(a)比周围点的数值都大，因此，如果我们从最大值的点往四周走一点点距离，就会发现那些点的函数值要比它小一点。在二维图上，就是和左右的点比较。&emsp;&emsp;左边的比它小，说明左边的点变化的趋势是向上，导数大于零，右边的也比它小，说明右边的点变化趋势向下，导数小于零。从大于零的数变成小于零的，中间经过导数为零的点，就是最大值所在。&emsp;&emsp;于是，寻找一个函数f(x)的最大值，就变成了一个寻找该函数的导数f’(x)等于零的问题。而后一个过程其实就是解方程，比前一个问题要容易。&emsp;&emsp;上面这种思路，就是牛顿在寻找最大值这件事情上，和前人所不同的地方。**他不是直接解决那些很难的问题，而是把比较数大小的问题，变成了寻找函数变化拐点的问题，后一个问题要比前一个好解决。但是，将这两个问题等同起来，需要发明一种工具，叫做导数。**有了导数这个工具，求最大值问题就变成了解方程的问题。这个方法的好处在于，它适用于任何函数。因此，我们不再需要针对每一种特定的函数，寻找一种解题技巧了。这也是为什么微积分是一种很强大的数学工具的原因。**还是没有彻底解决？**&emsp;&emsp;当然，我们昨天讲了，一个新的方法出来之后，常常免不了有一些破绽，用导数求最大值的方法也是如此。&emsp;&emsp;比如一个立方函数，f(x) = x^3，它的导数是f’(x) = 3x^2，显然当x=0时，它的导数变为了零。但是x=0这一点显然不是x^3最大值的点，因为我们知道立方函数的最大值最后是趋近于无穷大。&emsp;&emsp;为什么上述方法对于立方函数不管用了呢？我画一个图，大家就清楚了。&emsp;&emsp;在图中你会发现，立方函数一开始上升的斜率很大，然后逐渐变小，并且变为零。但是，在变为零以后，它没有再进一步变小进入负数的区间，而是又逐渐变大了。原因找到了，问题就好补救。&emsp;&emsp;我们只要在找到导数等于零那个点之后，看看它前后的点，是否发生了导数符号从正的到负的反转，如果发生了，它就是最大值的点，否则就不是最大值的点。这样就补救了一个漏洞。![](/images/148.jpg)用导数求最大值的方法还有其它的漏洞，比如下面这个函数。它有左右两个点，都满足导数等于零的条件，而且也都满足导数从正变成零，再变成负这个条件，但是最大值只能有一个。由于左边的那个点比右边的要高一些，因此左边的是真正的最大值，右边的是假的。![](/images/149.jpg)对于这种情况怎么办？首先，数学家们要更准确地定义什么是最大值。他们把最大值分成了两种，第一种被称为极大值，或者局部最大值，就是说只要一个点的函数值比周围都高就可以了。另一种才是我们原来理解的整个函数的最大值。&emsp;&emsp;因此，一个函数可以有多个极大值，但是只能有一个最大值。这样，谁是最大值的定义就没有矛盾了。&emsp;&emsp;但是接下来，数学家们需要给出，如何在很多的那个局部的极大值中找到最大值的方法。很遗憾，目前依然没有很好的方法系统性地解决这个问题，只能一个个比较。&emsp;&emsp;事实上，这也是今天计算机进行机器学习时遇到的一个很大的、尚未解决的问题，因为在很多时候，我们觉得经过计算机长期的训练，找到了最大值，但是后来发现所找到的不过是很多局部极大值中的一个而已。人们对于这一点的认知，后来给企业管理和创新带来了很多思考和启发。这个内容我们在最后一个模块会讲到。&emsp;&emsp;最后总结一下今天的内容。在过去，找最大值就是一个个地比较数字的大小，这就把数字变化看成是孤立的事件了，因此很难找到通用的求最大值的方法。&emsp;&emsp;牛顿等人通过考察函数变化趋势，发明了一种通过跟踪函数从低到高，再到平稳，最后再下降的变化，而求最大值的方法。这就让人类对事物的理解从静态，到动态了。这种方法的好处是，它是通用的，而不是针对具体问题的技巧。当然，这种方法有一些漏洞，因此我们要一一补上。&emsp;&emsp;到目前为止，我们关于微积分的主要思想就介绍完了，希望你通过这个工具，对世界的认识能够上到一个崭新的高度。下一讲我们会讲讲有关微积分的发明权之争，看看你从中会得到哪些启发。我们下一讲再见。</details><h3><span id="34-wei-ji-fen-dao-di-shi-shui-fa-ming-de">34 ｜ 微积分到底是谁发明的</span><a href="#34-wei-ji-fen-dao-di-shi-shui-fa-ming-de" class="header-anchor">#</a></h3><!-- ![](/images/143.jpg) --><p>这是我们微积分模块的最后一讲。我们讨论一个长期悬而未决的问题，那就是到底是谁发明了微积分？</p><details><summary>...</summary>&emsp;&emsp;微积分是从初等数学到高等数学的界碑，今天人们会讲，牛顿和莱布尼茨各自独立地发明了微积分，但是这个含糊其辞的说法并没有回答问题。&emsp;&emsp;在牛顿和莱布尼茨的时代，他们有很多来往，莱布尼茨还专门到英国去访问了很长时间，了解了牛顿有关微积分的思想。因此他们的工作并不独立，这也是后来牛顿讲，对方剽窃了自己的微积分成果的主要依据。&emsp;&emsp;接下来，我们就从微积分发明和完善的过程，看看不同人从不同视角是如何看待同一个问题，以及一个学科体系是如何建立起来的。了解了这些，**我们今后如果要参与到一件前无古人的事情中，就清楚该如何确立自己的位置和角色了。****牛顿的工作**&emsp;&emsp;我们先说说牛顿的工作，他很早就有了微积分的最初想法，这大约是17世纪60年代的事情，那时他才20岁出头，就写出了题为《论用无限项方程所作的分析》的长篇手稿，系统地总结了他过去关于流数，也就是我们所说的导数的工作，这是微积分发展早期的重要文献。&emsp;&emsp;1669年6月，他把这篇论文手稿提交给了他的老师巴罗，巴罗又把它转给当时另一位数学家，也是当时皇家学会图书馆负责人约翰·考林斯，并盛赞这是一个伟大的发现。随后，考林斯将牛顿的手稿又转给了欧洲的许多朋友。&emsp;&emsp;这在后来就留下了一个数学史上的谜案，即莱布尼茨是否看到了考林斯的抄本？当时，巴罗和考林斯建议牛顿将这篇手稿作为巴罗《光学讲义》的附件发表，但是牛顿觉得还不成熟，还需要进行修改和补充。&emsp;&emsp;牛顿虽然一直在完善他的理论，并且也写了一些关于微积分的论文，比如《流数法与无穷级数》等等，但是却一直不公开发表他在微积分方面的核心成就，这让莱布尼茨后来抢在了前面。否则，也就没有后来的微积分发明权之争了。**莱布尼茨的工作**&emsp;&emsp;接下来我们说说莱布尼茨的工作。1673年他访问了伦敦 , 和英国的数学同行进行了交谈，并且随后一直有通信来往。特别是他与皇家学会秘书奥登伯格的来往信件中，了解到牛顿的流数法的细节及其部分应用。而莱布尼茨在给奥登伯格的信中，也确认了他从牛顿那里受到了启发：&emsp;&emsp;“贵国了不起的牛顿提出了一个求解各种形状面积、各种曲线（所包围）的面积 及其旋成体的体积和重心的方法。这是用逼近的过程求出的，而这也正是我要推导的。这一方法如果能被简化并且推广的话，是非常了不起的贡献，毫无疑问这将证明他是天才的发明者。”&emsp;&emsp;那封信说明莱布尼茨早就承认牛顿的积分法在他之前，并且大加称赞。次年，莱布尼茨搞出微分和积分的新表示法。牛顿得知此事后，写信给奥登伯格，说明自己的方法，以便转给莱布尼茨。&emsp;&emsp;莱布尼茨看到牛顿的来信后要求进一步说明细节，牛顿给莱布尼茨写了后来的信，系统地阐述了二项式定理、无穷级数展开法、用流数求一般曲线的面积等原理，并且比较全面地介绍了自己的微积分。&emsp;&emsp;1676 年，莱布尼茨第二次访问伦敦时，经过考林斯同意，抄录了牛顿的手稿《论用无限项方程所作的分析》以及牛顿的级数展开方法、例子和一些补充说明，这样他对牛顿的工作有了全面的了解。&emsp;&emsp;莱布尼茨的微分原理论文和积分原理论文分别发表在1684年和1686 年，这时已经比牛顿的《流数法与无穷级数》成稿晚了15年，而里面没有提及牛顿的作用。当时，大家就想知道莱布尼茨关于微积分的想法，是完全受到牛顿的启发，还是说有大量的独立思考，只是在一些地方受到牛顿启发而已。&emsp;&emsp;在牛顿那个时代，一致的意见是莱布尼茨完全照搬了牛顿的想法，因为牛顿控制了当时世界上最有权威的学术组织——英国皇家学会，于是就由皇家学会出面声讨莱布尼茨的抄袭行为。&emsp;&emsp;但是，公平地讲，在和牛顿交流以前，莱布尼茨也有了对微积分的初步想法，特别是他看待微积分的角度和牛顿不同，这一点不可能抄袭牛顿。因此今天数学界认为他和牛顿共同发明了微积分，并不是和稀泥，而是因为他们各自有自己的贡献。**牛顿从物理力学出发**&emsp;&emsp;我们先说说牛顿的贡献。牛顿除了是数学家，还是物理学家，他研究微积分，在很大程度上是为了解决力学问题，特别是这样三个问题。&emsp;&emsp;第一个就是有关加速度、速度和距离的关系。这三者的关系只能通过微积分来描述，也就是说，加速度是速度的导数，速度又是距离的导数。第二个是动量和动能，以及撞击力的关系。动量是动能的导数，撞击力是动量的导数。第三个是天体运行的向心加速度问题，它是速度的导数，而万有引力则是向心加速度的来源。&emsp;&emsp;从这里可以看出，牛顿最初微积分的思想，特别是关于导数的部分，是直接服务于物理学的，虽然后来他也将微积分普遍化，但是他采用的符号，还有导数的痕迹，不方便表达微积分的特点，因此今天我们已经不用那些符号了。对于微积分中的一些概念，他讲得也不是很清晰。**莱布尼茨从哲学出发**莱布尼茨则不同，他除了是数学家，还是一个哲学家和逻辑学家。他的哲学思想和逻辑思想概括起来有两点：&emsp;&emsp;首先，我们所有的概念都是由非常小的、简单的概念复合而成，它们如同字母或者数字，形成了人类思维的基本单位。这在微积分上反映出他提出了微分dx、dy这样无穷小的概念。&emsp;&emsp;其次，简单的概念复合成复杂概念的过程是计算。比如在计算曲线和坐标轴之间的面积时，莱布尼茨的思想是把这个不规则形状拆分成很小的单元，然后通过加法计算把它们组合起来。&emsp;&emsp;基于这样的哲学思想，莱布尼茨把微积分看成是一种纯数学的公具——这个工具把宏观的数量，拆解为微观的单元，再把微观的单元，合并成宏观的积累。因此，可以讲，他是从另一个角度解读微积分。我们今天使用的微积分的符号，大部分是莱布尼茨留下的。&emsp;&emsp;在数学上，莱布尼茨不仅致力于微积分的研究，而且还发明了二进制，这样他给人类贡献了另一套便于计算的进制。此外，他还致力于改进机械计算机。&emsp;&emsp;从他一生所做的诸多和数学相关的工作，我们可以发现他实际上是把计算看成是由简单世界到复杂世界的必经之路。正是因为在哲学层面对数学的探索，使得莱布尼茨的微积分要比牛顿的更严格一些。&emsp;&emsp;很多时候，对于一项发明，简单追溯最早的发明人是没有意义的，而要看谁做出了具体的贡献。在这方面，莱布尼茨当之无愧是微积分的发明人之一。&emsp;&emsp;至于他为什么没有提到牛顿的贡献，这除了他个人的作风和习惯，还因为在宗教观点上的分歧使得他不认可牛顿在物理学上的很多理论。不过，莱布尼茨私下里对牛顿的评价极高。&emsp;&emsp;1701年，也就是在双方就微积分的发明权开始论战后，当普鲁士国王腓特烈大帝询问对牛顿的看法时，莱布尼茨讲：“在从世界开始到牛顿生活的时代的全部数学中，牛顿的工作超过了一半。”可以讲，这是一种高得无以复加的评价。**莱布尼茨为什么要争？**&emsp;&emsp;莱布尼茨和牛顿不对付很重要的一个原因是两人的宗教信仰不同。牛顿虽然也信教，但总的来讲属于自然神论者，这些人认为上帝创造了世界，然后就什么都不管了。但是莱布尼茨是神学家，虔诚的上帝维护者，因此在莱布尼茨看来，牛顿的很多研究成果是大逆不道的。比如他对牛顿的工作有这样一些评价：- 唯物主义的原理和方法的谬误是对上帝不虔诚。《原理》的作者与唯物主义者一样，是错误的。- （牛顿等人）承认原子和虚空，等于在说上帝创造的世界不完美。- （牛顿等人）认为时间和空间是绝对的，这就将时空和上帝等同了。在上帝之外是不可能有其它绝对和永恒的东西。- 不可能有万有引力，因为没有媒介的作用力是超自然的， 只有上帝才能做到， 不可能存在于自然界。莱布尼茨针对牛顿的万有引力学说还发表了《关于上帝善行的自然神学论著》一书，反对牛顿的引力理论。听到这些观点，你可能会觉得莱布尼茨怎么这么愚昧，但为什么在数学上又有这么大的贡献？事实上，莱布尼茨不是自然科学家，他的自然观基本上都是凭直觉产生的，用今天的话说有点反科学。但是，这并不妨碍他从逻辑出发，发明数学上最伟大的工具。&emsp;&emsp;从这里你可以看出，自然科学可以给数学以启发，但并不是完全必须的，数学暂时离开了自然科学，也能发展，只要从正确的前提出发，根据逻辑就能构建起一个体系的大厦。&emsp;&emsp;当然，对于微积分来讲，体系的构建不仅在牛顿和莱布尼茨手里没有完成，在我们前面讲到的柯西和魏尔斯特拉斯手里也没有得到完善，后来再经由黎曼和勒贝格等人的工作，才算将微积分的大厦基本构建完成，这离牛顿和莱布尼茨的时代已经过去两个多世纪了。&emsp;&emsp;从微积分的建立过程，我们可以看出很多事情是水到渠成的结果，牛顿从力学出发，莱布尼茨从哲学出发，几乎同时都发明了类似的工具。因此缺了他们中的一人，微积分依然会在那个时代出现。其实在任何重大发明的过程中，时间早可能远没有我们想象的重要。&emsp;&emsp;具体到微积分，最原始的思想，牛顿的老师巴罗就已经考虑过，但是那不能算是微积分，至于埃及、希腊、中国、印度、伊拉克、波斯和日本今天都声称自己的国家更早发明了微积分的雏形，你当笑话听听就好了。&emsp;&emsp;我们在这一个模块中，是从牛顿的视角引入微积分，因为它比较直观，但是它和今天教科书里的内容已经相去甚远。今天的微积分和莱布尼茨的版本有更多的继承关系，但是我们今天学的依然不是他的版本，而是后来柯西等人完善的版本。&emsp;&emsp;很多人都醉心于从零到一的发现，但是真正伟大的发明需要走完从0到N的全过程，这中间有很长的路，任何时候进入相关的领域都不晚。&emsp;&emsp;好，我们微积分模块的学习就结束了，以前你可能只是会算算题，现在你算是拥有了动态看世界的眼光。我们下一讲开启新模块，概率论、统计学和博弈论。</details><h2><span id="mo-kuai-liu-gai-lu-tong-ji-bo-yi-lun">模块六 ｜ 概率、统计、博弈论</span><a href="#mo-kuai-liu-gai-lu-tong-ji-bo-yi-lun" class="header-anchor">#</a></h2><h3><span id="35-gai-lu-jian-shi-yi-men-lai-zi-du-tu-de-xue-wen">35 ｜ 概率简史：一门来自赌徒的学问</span><a href="#35-gai-lu-jian-shi-yi-men-lai-zi-du-tu-de-xue-wen" class="header-anchor">#</a></h3><!-- ![](/images/150.jpg) --><p>你好，欢迎来到我的《数学通识50讲》，我们进入新模块概率论、统计学和博弈论的学习。课程进行到这里，其实遵循着一个暗含的线索，从不确定到确定，再到不确定。</p><details><summary>...</summary>&emsp;&emsp;比如前面的几何学、代数学和微积分，我把它们作为数学通识课的内容，因为它们能帮助我们在第一阶段提高认识，几何学通过几个公理和逻辑推演，让我们认识到很多定理，这是从不确定到确定的过程。在代数学中，求出方程的解，显然也是把不确定的未知数确定下来。至于函数则是把变量之间的关系确定下来。&emsp;&emsp;在微积分中，我们对确定性的理解从宏观进入到了微观，当然也可以从微观来确定宏观。微积分的出现，使得人类有了空前的自信，觉得那么细微、短暂的规律都能把握，那么还有什么不能把握的呢？&emsp;&emsp;到了麦克斯韦的时代，他通过几个非常确定的方程，把看不见、摸不着的电磁场描绘得清清楚楚。这样一来，世界上不存在不确定的事情了，以至于大物理学家普朗克在选择专业时，一度考虑要学习物理以外的学科，因为那个时代的科学家们觉得物理规律都被发现完了，剩下的只是修修补补。&emsp;&emsp;我们知道，后来普朗克恰恰成了带有不确定性物理学，也就是量子力学的开山鼻祖。与此同时，数学的发展也开始注重对不确定性的研究了。从这一讲开始，我们就来讲述揭示不确定性世界规律的数学分支——概率论。**概率论起源**&emsp;&emsp;最早从数学的角度研究不确定性，寻找随机性背后的规律的人既不是数学家，也不是科学家们，而是赌徒。他们经常需要了解赌局中什么情况更可能出现，以至于好下注挣钱。我在年轻的时候一度痴迷于桥牌，打桥牌就要算牌，算算某张牌可能在谁的手里。&emsp;&emsp;比如黑桃有13张牌，你和你的搭档有9张，对方有4张。最大的两张A和K都在你手里，但是第三大的Q在对方手里。这时你要作一个判断，对方手中的四张黑桃，2-2分布的可能性有多大？如果超过50%，你直接打出A和K，将对方手里的Q砸死即可。但是如果1-3分配的可能性很大，而Q恰好在有三张黑桃的人的手里，你就不能这么打了。&emsp;&emsp;事实上，打桥牌的人基本上背下了主要牌型分布的概率，在打牌时是靠概率趋势，而不是运气。需要说明的是，各种牌型的概率通常和人们的直觉相违背，比如在刚才说的4张牌的分布中，1-3分布要比2-2分布的概率大不少，这就和我们的常识相违背。&emsp;&emsp;在没有概率论之前，算清楚牌型的概率不是很容易，而且绝大多数赌徒会因为凭直觉判断而出错。庄家虽然也算不清，但是因为经验多，他们在长期设赌局的生涯中会不知不觉地统计出来概率分布，因此通常会占到玩家的便宜。&emsp;&emsp;在历史上有明确记载的最早研究随机性的数学家是帕斯卡和费马。帕斯卡就是最早发明机械计算机的那位数学家，他并不是赌徒，但是他有些赌徒朋友，那些人常常玩一种掷骰子游戏，游戏规则是由玩家连续掷4次骰子，如果其中没有6点出现，玩家赢，如果出现一次6点，则庄家赢。&emsp;&emsp;在这个赌局中，由于双方的赢面差不多，不是大家能够凭直觉判断准的，因此玩家并不觉得吃亏，甚至还觉得赢面大一些。但是，只要时间一长，庄家总是赢家，玩家注定是输家。1654年，一位赌徒朋友就向帕斯卡请教，是否能证明庄家的赢面更大？&emsp;&emsp;帕斯卡经过计算，发现庄家的赢面还真是稍微大一点，大约是52%vs48%。大家不要小看这多出来的四个百分点，累积起来，能聚敛很多财富。在研究赌局概率的过程中，帕斯卡和费马有很多通信，今天一般认为他们二人创立了概率论。&emsp;&emsp;他们二人的工作表明，虽然各种不确定性问题无法找到一个确定的答案，但是背后依然是有规律可循的。至于“52%vs48%”的结果是怎么算出来的，就是这讲我留给你的思考题。**概率论的发展**&emsp;&emsp;到了18世纪启蒙时代，法国政府债台高筑，不得不经常发一些彩票补贴财政。但是由于当时人们的数学水平普遍不高，发彩票的人其实也搞不清该如何奖励中彩者。&emsp;&emsp;著名的启蒙学者伏尔泰是当时最精通数学的人之一，他算出了法国政府彩票的漏洞，找到了一些只赚不赔的买彩票的方法，赚了一辈子也花不完的钱。伏尔泰一生没有担任任何公职，或者做生意，但是从来没有为钱发过愁。这让他能够专心写作，研究学问。&emsp;&emsp;从18世纪末到19世纪，数学家们对概率论产生了浓厚的兴趣，像法国的伯努利、拉普拉斯和泊松等人，德国的高斯，以及俄罗斯的切比雪夫和马尔可夫等人，都对概率论的发展有很大的贡献。经过他们共同的努力，概率论的基础理论逐渐建立起来，很多实际的问题也得到了解决。&emsp;&emsp;在这些人中，划时代的人物是拉普拉斯。拉普拉斯是一位了不起的科学家，但是却又热衷于当官。他有一个著名的学生叫做拿破仑，靠这层关系他后来当上了政府的部长。不过，他的政绩不太好，因此拿破仑讲，他是一个伟大的数学家，但却是一个不太称职的部长。不过，拉普拉斯一生在科学上的贡献还是非常大的，比如关于宇宙构成的星云说，就是由他完成的。&emsp;&emsp;当然他最为人所知的是以他的名字命名的拉普拉斯变换。在概率论方面，拉普拉斯定义了什么是概率，以及它该如何计算。在拉普拉斯之前，人们对“有可能”和“概率大”是分不清的。其实你今天问一些人，买彩票中彩的概率是多少？他依然会说50%，因为只有中彩和不中彩两种情况。&emsp;&emsp;拉普拉斯是如何定义概率的呢?他先定义了一种可能性相同的基本随机事件，也称为单位事件。&emsp;&emsp;比如我们同时掷两个骰子，两个骰子的点加起来可以是从2到12之间的任何正数。那么我问你，这些数出现的概率相等吗？很多人会认为相等，因为从2到12一共有11种情况，每一种情况的概率就是1/11。但是，这11种情况并非基本的随机事件，而是可以拆分为更小的单位事件。比如两个骰子加起来是5点，里面包含了四种单位事件，即第一个骰子的点数是1，2，3，4，第二个的点数是4，3，2，1。基于单位事件的概念，拉普拉斯定义了古典的概率公式，即![](/images/151.jpg)在上面掷骰子的问题中，两个骰子点数的组合有36种，即当第一个骰子是1点时，第二个骰子为1～6点六种情况。当第一个骰子是两点时，第二个骰子为1～6点六种情况，等等，算下来一共是36种。每一种不可再分，都是单位事件。单位事件的概率称为原子概率，在这个例子中，原子概率就是1/36。&emsp;&emsp;如果我们要计算两个骰子加起来是5点的情况，只要数数里面包括了多少单位事件，它里面有4个单位事件，然后我们用4除以总数36即可，这样算下来，两个骰子加起来为5点的概率是1/9。用这种方法我们会发现2点和12点的概率最小，是1/36，中间7点的概率最大，是1/6。因此这11种情况并不是等概率。&emsp;&emsp;根据拉普拉斯对概率的定义，所有可能发生的情况放在一起，构成了一个随机事件总的集合（也称为概率空间）。任何一个随机事件，都是随机事件总集合里的一个子集。&emsp;&emsp;比如掷两个骰子，随机事件总的集合就包含那36种情况。而某个随机事件，比如“两个骰子总点数大于10”，就是其中的一个子集，这个子集包含三个单位事件，即第一个骰子是5点，第二个骰子是6点，或者反过来，两个骰子都是六点。&emsp;&emsp;如果一个随机事件，包含了随机事件空间中所有的单位事件，那么这个事件必然会发生，它被称为必然事件，概率就是1。另一方面，如果一个随机事件不包括随机事件空间中任何一个单位事件，它就不可能发生，被称为不可能事件，概率为零。剩下来的随机事件，概率都在0和1之间，里面包含的单位事件越多，概率就越大，用通俗的话讲，就是发生的可能性越大。&emsp;&emsp;拉普拉斯对于概率论的描述其实有不少漏洞，比如在现实中是否存在着可能性完全相等的单位事件，这本身就是一个大问号。我们知道，没有骰子是完美对称的，因此和骰子相关的概率问题似乎就不存在单位事件了。当然，这还不是拉普拉斯定义中最大的缺陷，他给出的定义本身有循环定义的嫌疑。&emsp;&emsp;拉普拉斯为了说明一个随机事件A的概率，用了等可能性的单位事件这个说法。但是在没有概率的定义之前，等可能性又从何谈起？此外，根据拉普拉斯的定义，要先已知随机事件空间，或者说各种可能性总的集合，比如掷骰子我们需要知道一个骰子有六种结果。&emsp;&emsp;但是对于未来的预测，常常无法把各种随机性都列举出来。比如医疗保险公司无法确定一个60岁的人在接下来的3年里得大病的概率，因为无法知道都可能发生什么意外。不过由于拉普拉斯这种定义大家都能理解，也就暂时不追究其严密性了。**要点总结：**&emsp;&emsp;随机性是一种自然的属性，我们无法否认它的存在，它导致很多结果变得不确定。但是对于特定的随机试验，它得到什么结果，还是有规律可循的，于是数学家们用了一个概率的概念来描述这种不确定性。虽然人类最初的动机和金钱相关，但是一旦掌握了不确定性背后的规律，就从自发状态进入了自由状态。&emsp;&emsp;下一讲我们就来了解一下有关随机性的规律是什么样的，它们又是怎样被一步步地了解的。我们下一讲再见。</details><h3><span id="36-bo-nu-li-shi-yan-dao-di-ru-he-li-jie-sui-ji-xing">36 ｜ 伯努利实验：到底如何理解随机性</span><a href="#36-bo-nu-li-shi-yan-dao-di-ru-he-li-jie-sui-ji-xing" class="header-anchor">#</a></h3><!-- ![](/images/152.jpg) --><p>我们上一讲讲到随机性是有规律可循的，于是才有了概率论。</p><details><summary>...</summary>**扔十次硬币，真的会有五次朝上？**&emsp;&emsp;但是它的规律性其实和我们直觉想象的不一样，以至于在生活中大部分人会误读概率。比如说，我们知道抛硬币正反两面朝上的概率各一半，但你现在去抛十次硬币，真的有5次正面朝上么？其实这种可能性只有1/4左右，显然和大多数人的直觉完全不同了。&emsp;&emsp;再比如有一个赌局，赢面是10%，你玩十次是否就能保证赢一次呢？如果不能，需要多少次才有很高的把握赢一次呢？这个结果其实是26次，这可能也颠覆了你的认知。因此我们这一讲就要正本清源，通过一些例子讲清楚随机性到底意味着什么，我们该如何得到正确的统计规律，而不是主观偏见。&emsp;&emsp;我们都知道，统计学的规律只有经过了大量随机试验才能得出，也才有意义。**但是随机试验得到的结果，和我们用古典概率算出来的结论可能是两回事。**不仅你掷10次硬币大部分时候不可能得到五次正面朝上的结果，你做其它随机试验也是如此。&emsp;&emsp;比如你掷12次骰子，大约只有30%的情况它正好有两次六点朝上。这时你是否能讲，有70%的可能性要否定六点朝上的概率是1/6这个结论呢？似乎也不应该这么武断。&emsp;&emsp;这里面到底哪里出了问题？这其中的关键是，如何解释真实情况和理想中的概率之间的偏差。**为什么现实概率和理想概率总有偏差？**&emsp;&emsp;几百年前，法国数学家伯努利等人为了回答这个问题，就开始做一些最简单的随机试验，这种试验简单到只有两种结果，非A即B，没有第三种状态，而且在同样条件下重复这种试验，A和B发生的概率需要一致。&emsp;&emsp;比如抛硬币，每次正面朝上的概率是1/2；掷骰子，事件A是“六点朝上”，它出现的概率每次也是1/6。当然事件B就是其它点朝上，每次的概率是5/6。在一般情况下，出现A的概率是p，B的概率是1-p。这类试验后来被称为伯努利试验。&emsp;&emsp;好了，基本的设定讲清楚了。我们来分析一下掷硬币的问题。照理讲，我们掷10次硬币，正面朝上的次数应该是5次。但是如果你真的拿一个硬币去试试，你会发现可能只有三次正面朝上，也可能四次正面朝上，甚至会出现没有一次正面朝上的情况。&emsp;&emsp;如果我们把从0次正面朝上，也就是说全部是背面朝上，到10次全是正面朝上的可能性都算出来，画成一个折线图，就是一个中间鼓起的曲线：&emsp;&emsp;从图中可以看出，虽然5次正面朝上的可能性最大，但是只有1/4左右。![](/images/153.jpg)造成试验结果和理论值不一致的原因，是试验十次数量太少，统计的规律性被试验的随机性掩盖了。如果我们做更多的随机试验，规律性是否会更清晰一点呢？&emsp;&emsp;比如我们做100次试验，这时你会发现，80%的情况下，正面朝上出现了40～60次。如果我们继续放大试验的次数，你会发现绝大多数情况正面朝上的次数在一半左右浮动，那种正面朝上占比特别少或者特别多的可能性几乎不会出现，而不是像一开始那样，什么情况都有可能。&emsp;&emsp;当然，如果你做1000次试验，在99.9%的情况下正面朝上的次数在400～600之间。即使你把浮动的范围缩小到450～550，99.7%的情况下正面朝上落在这个范围内。&emsp;&emsp;在一般情况下，如果进行N次这种简单的伯努利试验，那么事件A会发生多少次呢？虽然我们感觉应该是总次数N乘以每次发生的概率p，但是实际上事件A发生多少次都是有可能的。当然发生N*p次的可能性最大，接下来发生N*p+1或者N*p-1次的可能性次之，然后向两头逐渐递减。&emsp;&emsp;如果我们将它画成一条曲线，就是中间高两头低的曲线。顺便说一下，满足这种曲线的概率分布，被称为伯努利分布，也称为二项式分布，因为每一次试验的结果有两种。&emsp;&emsp;我们还看这个实验，事实上，如果试验次数N比较大，那中间就是一个大鼓包，然后快速下降，两旁几乎是零，这也就是说事件A发生的次数在N*p左右的可能性极大，其它的可能性极小。相反，如果总次数N比较小，中间的鼓包就比较平缓，两头的值虽然小，但不会是零，其实难以判定事件A到底发生了多少次。&emsp;&emsp;于是，我们就得到这样一个结论：有关不确定性的规律，只有在大量随机试验时才显现出来，当试验的次数不足，它则显现出偶然性和随意性。**如何找出这个偏差的本质？**&emsp;&emsp;当然，在数学上我们不能用“曲线比较鼓”，或者“比较平”之类不严格的语言来描述一种规律。我们需要用两个非常准确的概念来定量描述“鼓”和“平”的差别。这第一个概念就是平均值或者叫做数学期望值，也就是N*p，因为概率是p的事件进行N次试验后，平均发生的次数，也是最可能发生的次数，好，这是N*p。接下来我们再用平方差（简称方差）这个概念来描述曲线的“鼓”与“平”。“方差”这个词你可能并不陌生，那么什么是方差，它是如何计算的呢？我们下面就简单地说一说。&emsp;&emsp;**方差其实是对误差的一种度量，既然是误差，就要有可对比的基点，在概率中，这个基准点就是数学期望值（简称期望值），也就是我们通常说的平均值。**比如说，做10次抛硬币的试验，平均值就是5次正面朝上，5就是基点。&emsp;&emsp;如果我们做10次试验只出现4次正面朝上的情况，就有了误差，误差是1。如果9次正面朝上，那么误差就大了，就是4。好了，接下来我们就把各种误差，和产生那些误差的可能性一起考虑，做一个加权平均，算出来的“误差”就是平方差。&emsp;&emsp;之所以使用“平方”这个词，是因为计算方差这种误差时用到了平方，为了进一步方便误差和平均值的比较，我们通常会对方差开根号一次，这样得到的结果被称为标准差（严格来讲，方差开根号后和标准差还是略有差别，但是这个差别很小，为了便于理解，我们就假定标准差是方差开根号的结果）。&emsp;&emsp;关于方差和标准差的公式我们就省略了，大家只要记住下面这个结论就可以了，那就是伯努利试验或者其它类似的试验，试验的次数越多，方差和标准差越小，概率的分布越往平均值N*p的位置集中。显然，在这种情况下，你用A发生的次数，除以试验次数N，当作A发生的概率，就比较准确。&emsp;&emsp;反之，试验的次数越少，概率分布的曲线就越平，也就是说A发生多少次的可能性都存在，这时你用A发生的次数，除以试验次数N，当作A发生的概率，误差可能会很大。&emsp;&emsp;具体到抛硬币的试验，进行100次试验，标准差大约是5次，也就是误差相比平均值50，大约是10%。但是如果我们做10000次试验，标准差大约只有50，因此和平均值相比，降到了1%左右。**理想与现实：成功需要更多准备**&emsp;&emsp;有了方差的概念，我们就能定量分析“理想”和现实的差距了。**什么是理想呢？我们进行N次伯努利试验，每一次事件A发生的概率为p，N次下来发生了N*p次，这就是理想。那么什么是现实呢？由于标准差的影响，使得实际发生的次数严重偏离N*p，这就是现实。**&emsp;&emsp;比如，在生活中，很多人觉得某件事有1/N发生的概率，只要他做N次，就会有一次发生，这只是理想。事实上，越是小概率事件，理想和现实的差距越大。比如说一件事发生的概率为1%，虽然进行100次试验后它的数学期望值达到了1，但是这时它的标准差大约也是1，也就是说误差大约是100%，因此试了100次下来，可能一次也没有成功。&emsp;&emsp;如果你想确保获得一次成功怎么办呢？你大约要做260次左右的试验，而不是100次。这里面的数学细节我们就不讲了，大家记住这个结论就好，就是越是小概率事件，你如果想确保它发生，需要试验的次数比理想的次数越要多得多。&emsp;&emsp;比如买彩票这种事情。你中奖的概率是一百万分之一，你如果要想确保成功一次，恐怕要买260万次彩票。你即使中一回大奖，花的钱要远比获得的多得多。因此，了解了标准差，就该懂得人为什么不要去赌。这算是我们今天在认知方面要了解的第一个知识点。&emsp;&emsp;我们要了解的第二个知识点是，提高单次成功率要远比多做试验更重要。假如你有50%的成功可能性，你基本上尝试4次，就能确保成功一次，当然理想状态是尝试两次。为了保险起见，要多做100%的工作。但是如果你只有5%的成功可能性，大约需要50次才能确保成功一次，而不是理想状态中的20次。为了保险起见，要多做150%的工作。&emsp;&emsp;很多人喜欢赌小概率事件，觉得它成本低，大不了多来几次，其实由于误差的作用，要确保小概率事件发生，成本要比确保大概率事件的发生高得多。&emsp;&emsp;关于概率论和统计学的规律，还有很多和大家直觉不相符的地方。比如我们前面所说的各种大量的随机试验，需要在相同条件下进行，而且前后各次试验是彼此不会相互影响的。这两件事在现实中，还真不容易满足。&emsp;&emsp;就拿掷骰子来说吧，看似掷N次不过是掷一次的多次重复，但实际上掷的次数多了骰子会磨损，桌面也会砸出坑，这些细微的差异累积下来就会产生不同的结果，我们原以为试几次就能发生的事情，可能没有发生，这就要我们事先考虑更多的余量。**要点总结：**&emsp;&emsp;我们从概率论上证明了，凡事做好充足的准备，争取一次性成功，这要远比不断尝试小概率事件靠谱得多。同时涉及到随机性的问题时，只有通过大量可重复性的试验，才能看到规律性，而数量较少的试验，更多地体现出来的是随意性和偶然性，而非规律性。&emsp;&emsp;欢迎你把文章转发给你的家人朋友，帮他们正确理解随机性。我们下一讲增加一个维度，还讨论这个问题。下一讲见。</details><h3><span id="37-bo-song-fen-bu-wei-shi-me-bao-xian-gong-si-de-ke-hu-qun-du-hen-da">37 ｜ 泊松分布：为什么保险公司的客户群都很大？</span><a href="#37-bo-song-fen-bu-wei-shi-me-bao-xian-gong-si-de-ke-hu-qun-du-hen-da" class="header-anchor">#</a></h3><!-- ![](/images/154.jpg) --><p>我们上一讲解释了随机事件的发生概率在理论和现实中的差距，用到的是伯努利试验。</p><details><summary>...</summary>&emsp;&emsp;今天我们从另一类特殊的伯努利试验说起，进一步完善你对随机性的认识，特别是对风险防范的认识。&emsp;&emsp;在这一类伯努利试验里，随机事件A发生的概率通常很小，但是试验的次数n很大，比如发生车祸的情况便是如此，这种分布被称为泊松分布。当然，为了比较容易说明问题，我们用一个不算太小的概率，这样比较好理解。**什么是泊松分布？**&emsp;&emsp;假如说公司门口有10个停车位，公司有100个上班的员工，每个员工早上8点钟之前开车来上班的概率是10%。当然，正如我们昨天所说，他们每天什么时候来公司不仅是随机的，而且彼此无关，不存在两个人商量之后一起到的情况，而且也不存在头一天来晚了没抢到停车位，第二天早到的可能性。&emsp;&emsp;现在，你是这家公司的新员工，早上8点整开车到了公司，请问停车场还有车位的概率是多大？我们知道，如果当时停车场里汽车的数量小于9辆或者等于9辆，那么你就有车位可以使用，因此我们就要计算出这个概率，它可以直接用泊松分布来计算。&emsp;&emsp;泊松分布是这样定义的：如果随机事件A发生的概率是p，进行n次独立的试验，恰巧发生了k次，则相应的概率可以用这样一个公式来计算：![](/images/155.jpg)在这个公式中，𝞴是试验次数n乘以每次试验出现情况的可能性p的乘积，即𝞴 = n*p。在上述停车场的例子中，𝞴等于10，因为员工的数量100乘以概率10%得到10。至于泊松分布的这个公式是怎么来的，大家不用太操心，我们用一些例子来说明它的性质，大家记住一些结论就好。&emsp;&emsp;我们先来算算在上面例子中，我们能够抢到车位的概率。在我用这个公式揭晓答案之前，大家不妨思考一下，至少猜一下这个概率大概是多少。&emsp;&emsp;这个问题我问过一些不了解泊松分布的人，他们给我的答案通常有两种，一种是10%左右，一种是90%左右。他们给出的答案对不对，我们先按照公式算一算，就能判别了。&emsp;&emsp;首先我们用上面的公式，计算一下k小于或等于9的概率。我们需要把k=0，1，2……9全部代进那个公式中，一个个计算。非常遗憾，没有更好的方法。我把k等于0到10的情况计算出来，放到了下面的表格中：![](/images/156.jpg)从这个表格中你可以看出，概率是随着k的增加而逐渐增加的。也就是说，8点以前，停车场有1辆车的概率比没有车大，有两辆车的概率比有1辆车大。但是在k=9和10这两个点，概率达到峰值，如果k再增加，超过𝞴时，概率其实要往下走。这种现象对任何𝞴都是成立的。&emsp;&emsp;由于表格画得太大，大家不方便查看，我就用曲线把k一直到20的情况画了出来，上面例子中的情况，对应于下图中平缓的灰色曲线。![](/images/157.jpg)算完了k等于不同值的概率，我们就把表格中k=从0到9的各个概率加起来，就得到k小于等于9的总概率，我们称之为累积概率，放在了第三行。在这个问题中，它是0.46左右，也就是说你有将近一半的可能性能够获得车位。从表格的第三行累积概率的变化你可以看出，它一开始增长很慢，在k接近𝞴时就增长较快，再往后其实增长也很慢。&emsp;&emsp;对于0.46这样的一个概率，其实很少有人能猜到。前面说的那些回答10%的人是这样想的：既然有10个车位，有100个员工，大家也是根据10%的概率去占车位，因此8点左右应该把车位正好填满，我8点到，估计只能占到最后一个位子，也就是说占到了停车场最后的10%，因此概率是10%。&emsp;&emsp;而认为可能性是90%的人是这样想的：100个员工的10%就是10，因此8点到的人应该是人人有车位，我现在掐着点到了，应该有九成的把握拿到一个车位。这两种想法都来自直觉，它们和真实情况相去甚远。很多人投资总是失败，判定一件事发生的可能性总是有很大的误差，一个重要的原因就是靠直觉和有严重漏洞的逻辑，而不是靠严密的数学逻辑和推导。&emsp;&emsp;接下来，我们再从这个例子出发，看看公司员工数量是不同数值时的情况，这样你对泊松分布就有感性的认识了。**员工减少了，你成功停车的概率会提高吗？**我们假设公司的人数降到了40人（除你之外），每个人8点钟之前开车到公司的可能性依然是10%，但是公司的车位也减少到四个车位，请问你找到停车位的可能性是一样大吗？&emsp;&emsp;虽然从感觉上讲，8点整点时候到了4辆车的情况和前一种情况下有10辆车到达的可能性差不多，但是这时你找到车位的概率只剩下40%左右了，比之前降低了。如果公司再缩减到10个人，只有一个车位，这时你八点到公司，能得到车位的可能性只有1/3左右。&emsp;&emsp;相反，如果公司扩大到200人，有20个车位，其它情况不变，你得到车位的可能性会增加到50%左右。也就是说，如果我们的“池子”变大，随机事件出现的概率不变，那么得到车位的可能性会增加，但是50%是一个上限。如果想保证8点到的员工能有车位怎么办呢？那就需要增加一点余量了，也就是多准备几个车位。&emsp;&emsp;在最开始的例子中，即公司有100个人的情况，如果准备13个车位，就能保证8点到公司时，大约有85%的可能性可以获得车位。你可以把这30%看成是冗余，它增加的数量并不是很多，但是却能解决大问题。**应对随机性，需要的冗余比你想的要大**在现实中，电话公司通常要多准备一些线路，以免大家打电话时总是占线。根据前面的分析我们可以得知，如果电话公司准备的线路数量正好是𝞴，也就是打电话人数的平均值，那么有一半的时间大家在打电话时会遇到占线的情况，这个比例是非常高的，这时你肯定抱怨不止。&emsp;&emsp;但是如果电话公司多准备了20%的线路容量，占线的概率可能就会下降到1/4甚至更低，如果多准备50%的线路，占线的概率就会占到5%以下。事实上，电话公司为了应付节假日或者其它高峰情况，通常都要准备好几倍的线路容量。&emsp;&emsp;因此，我们今天的第一个结论就是，由于随机性的作用，我们在准备资源时，达到平均值还是不够的，需要准备一些冗余量。**池子越大，越能抵消随机性带来的误差**&emsp;&emsp;接下来我们谈谈今天的第二个结论：池子越大，越能抵消随机性带来的误差。&emsp;&emsp;这个原理其实就是大家购买保险的数学基础。一般来讲，我们出事的概率并不高，但是一旦出事可能损失很大，因此每一个人放一点钱到池子中，谁不幸出了事情，就由保险公司理赔，但是每个人放多少钱在保险公司的池子里，就有讲究了。&emsp;&emsp;比如每一次理赔的金额是10000元，每年出事的概率是10%，有200人投保。从理论上讲，平均每个人收理赔金额的10%，也就是1000元即可，这样一年可以赔偿20人（次）。&emsp;&emsp;但是根据前面的分析我们知道，由于出事是随机的，总是存在超过20个人出事的可能性。如果这一年你非常不幸，等你申请赔偿时，前面已经赔过了20人，你就得不到赔偿了。事实上如果按照上述方式设计保险产品，你即使投保了，能够获得赔偿的可能性只有一半左右。如果保险公司这么办，恐怕就没有人有投保的意愿了。&emsp;&emsp;那么怎么办呢？我们前面讲了，就是每个人多交点保费，比如每个人交1500元，这样你获得赔偿的可能性就增加到98%了。但是这样一来很多人就会觉得不合算，因为他们觉得自己多交了50%，于是就选择不买保险。&emsp;&emsp;为了解决这个问题，保险公司就必须把池子搞得更大。比如我们把投保的人数增加到2000人，这样只要稍微多交15%的钱，即1150元，就能保证98%的情况获得赔偿。当池子特别大时，每个人只要比1000元多交一点点就可以了。这样，大家就有投保的意愿。&emsp;&emsp;从这个例子我们可以看出，在管理水平和效率相当的情况下，保险这个行业是池子越大风险越小。因此，对于个人来讲，应该优先考虑找那些大保险公司投保。很多人觉得小公司服务好，而且承诺同样的赔偿，于是使用小保险公司，但事实上真的遇到需要索赔时，很多小保险公司是赔不出来的。&emsp;&emsp;此外，根据我们前面计算的结果，即使大保险公司也有很小的可能性赔不出来，那么怎么办呢？显然不可能把池子做到无限大。于是在保险行业，就出现了再保险或者保险公司之间互相保险的情况。&emsp;&emsp;这其实就是许多保险公司们联合，把几个已经很大的池子，合并成一个超级规模的池子。这样，除非遇到2008年金融危机这样的情况，否则不会出现支付不起赔偿金的情况。**要点总结：**- 通过介绍泊松分布，大家应该体会到随机性和我们想象的可能不一样，为了预防不测，需要留有一些冗余。- 在防范不经常发生的小概率事件时，大家不妨联合起来，把应付不测的资源放到一起。&emsp;&emsp;讲完了小概率事件，下一讲，我们讲讲大概率事件。</details><h3><span id="zui-xin-jie-du-shu-ju-zi-chan-ni-de-shu-ju-dao-di-shu-yu-shui-you-gai-zen-me-yong">最新解读 ｜ 数据资产：你的数据到底属于谁，又该怎么用？</span><a href="#zui-xin-jie-du-shu-ju-zi-chan-ni-de-shu-ju-dao-di-shu-yu-shui-you-gai-zen-me-yong" class="header-anchor">#</a></h3><!-- ![](/images/158.jpg) --><p>你好，欢迎来到我的《数学通识50讲》，最近我做了一些关于数据资产方面的讲座，刚好最近邵恒也问了我相关问题，我就把自己的思考整理出来，分享给大家。</p><details><summary>...</summary>**你要钱，还是要数据？**数据在今天是个时髦的词，大家都说数据像钱一样重要。但是你如果问一个人，他是要钱还是要数据，恐怕大家还是要钱。&emsp;&emsp;在最近的两年里（从2018年到2019年），我对我的学生们（大约100多名创业者和EMBA的学员）进行过多次调查，问他们是愿意接受100万元真金白银的投资，还是淘宝上10万人的数据作为替代投资，95%的人都选择前者。&emsp;&emsp;这些调查虽然样本数不算太大，但多少能说明一些问题，那就是在他们看来，数据虽然有用，但是似乎还不能算是资产，至少不是很值钱的资产。&emsp;&emsp;那么是什么原因妨碍了数据成为资产的呢？从法律上讲，所有权不清晰，从技术上讲，无法防止数据无成本地复制，是两个最主要的原因。**数据到底是谁的？**&emsp;&emsp;**我们先来看看所有权问题。**今天几乎所有的数据都存放在大公司的服务器上。虽然像谷歌和亚马逊这些公司明确表示数据的使用权归用户，它们只是使用数据改进产品和服务，但是实际上用户并不真正拥有数据，拥有和使用数据的都是那些公司。至于国内一些拥有大数据的平台公司，甚至宣称它们才是数据的所有者。&emsp;&emsp;在这种所有权都说不清的情况下，如果非要说数据是资产，显然言过其实。用户自然没法把数据拿来当做资产，而那些大数据公司虽然嘴硬，显然也不敢将用户的数据拿到银行去抵押贷款，因此它不具有资产的特性。&emsp;&emsp;2016年，欧盟率先制定了《通用数据保护条例》（General Data Protection Regulation，简称GDPR），在法律上为鉴定数据所有权和保护个人在数据上的权益迈出了重要的一步。&emsp;&emsp;欧盟在GDPR中明确规定，数据的所有权属于数据的提供者，比如大家在Google上搜索，在阿里巴巴买东西，就是在不断提供数据。目前那些大的数据公司，是数据的管理者，而谁使用数据受益，谁就是使用者，既包括阿里巴巴、腾讯这样的公司，也包括阿里巴巴旗下受益于那些数据的电商。&emsp;&emsp;此外，欧盟还表明要像管理银行那样管理大数据平台公司，这意味着什么呢？今天你把1万元存进银行，银行是可以告诉你这笔钱是如何在金融系统中流动的，最后用于了什么地方，产生了多少利息。一家银行如果做不到这一点，各国类似银监会的组织是不会让它开业的。&emsp;&emsp;但是今天，各大数据公司完全说不清数据的流向，**没有人知道某个人的数据是如何具体被使用的，用于了哪些产品，是否真像数据公司所说的那样提高了用户体验。**总之，目前是一笔糊涂账。&emsp;&emsp;根据GDPR的规定，以后数据公司必须要说得清楚这些事情，并且要自己开发这样追踪数据使用的工具，以便于数据的所有者和监管部门，能够了解数据的使用情况。这项规定，已经开始在逐步实施。这就是像管理银行一样管理数据公司。&emsp;&emsp;在欧盟之后，美国加州也通过了《加州消费者隐私法案》（CCPA），并将于2020年开始实施。CCPA的原则和GDPR是一致的。由于加州不仅是全球第五大经济体，而且也是除亚马逊和微软之外美国所有大型互联网公司的所在地，因此这个条例被认为是美国版的GDPR。&emsp;&emsp;GDPR和CCPA明确了数据所有者、管理者和使用者之间的关系，接下来还要有相应的办法让三方受益。**为了理解将来数据如何使用而获利，我们不妨看看其它资产是如何实现获利的：**&emsp;&emsp;今天，你在银行里存了1万元，它的产权属于你，银行是它的管理者，它会把很多人的钱放到一起，贷款给一家建筑公司。建筑公司就是使用者，它要支付相应的贷款利息。银行在扣除了你的资产的保管费（也就是利息差价）之后，也要把余下来的利息所得支付给你。这样，各方都有利可图，未来的数据，也将是这样使用。&emsp;&emsp;当然，有人可能会问，这样使用数据的公司的成本是否会上升？如果大家不担心贷款的公司成本上升，就没必要为此担忧。如果一家公司只能靠零利率贷款才能生存，它本身就没有必要存在，因为它破坏了资源的有效性。&emsp;&emsp;类似的，如果一家企业使用了数据，只获得少得可怜的利润，也没有存在的必要了。如果它获得了超额的利润，拿出一部分收益给数据的所有者和管理者也是应该的。&emsp;&emsp;GDPR和CCPA排除了数据资产化的法律障碍。但是，这还远远不够，如果没有技术的保障，它们不过是一纸空文。&emsp;&emsp;比如，在今天的技术条件下，即使腾讯把每个人微信的数据还给了个人，阿里巴巴把每个人的交易数据也交到个人手中，大家在哪里存储这些数据，如何使用它们，都是问题。总不能每一个人都将数据存到自己家里，上网购物时再上传到服务器中。更麻烦的是，几乎没有人能够看得懂自己的数据，因为里面的结构太复杂了。最后的结果是，数据烂在手里，什么作用也发挥不出来。**如何通过技术保障数据安全？**&emsp;&emsp;因此，**在法律上明确了数据的所有权之后，还需要有技术手段让数据在不损害所有权的情况下发挥作用。**由于篇幅的原因，我们这里就跳过技术细节了，值得一提的是，区块链可能会在这方面发挥巨大的作用，因为区块链可以防止数据无成本地被拷贝复制。世界上任何能够拷贝的东西都没有价值，而越是稀缺的越有价值。&emsp;&emsp;英国皇家工程院院士郭毅可教授和我讲过这样一个案例，某著名的制药公司几年前以百万英镑的高价，购买了一个罕见的癌症患者的数据。制药公司之所以愿意花这么多钱，是因为该患者患有6种癌症，他的数据在世界上几乎有独一无二的价值。&emsp;&emsp;相反，如果一种数据随处可见，唾手可得，价值就近乎为零，即便它再有使用价值，我们天天呼吸的空气就是如此。无法确定数据的价值，才是那些创业者宁可要100万元的投资，而不要100G数据的原因。&emsp;&emsp;阿里巴巴如果真拿出100万元支持某家电商A，这笔钱就不可能再用到电商B的身上，这是由金钱的不可复制性决定的。但是它给了电商A，100G的数据，同样的数据还可以复制任意多份，还可以给电商B、电商C……&emsp;&emsp;数据要想成为资产，就要做到不能够随便被复制。而做到这一点，不是像有些大数据公司讲的那样，把数据都放在它们的数据中心锁起来就可以了，因为那些公司谁也信不过，而需要其他的技术保护手段。&emsp;&emsp;解决数据被随意拷贝的问题，要堵住两个源头，一个是监守自盗，一个是外贼入侵。事实上，卖数据给第三方的恰恰是Facebook这样的公司，防止监守自盗，就是防止这样的行为。今天看似安全的银行数据中心，会隔三差五地丢失数据，这是外贼入侵的结果。&emsp;&emsp;为了解决这两个问题，区块链的价值就体现出来了。最初对这个问题有深刻理解的是Google前CEO施密特，他在2014年就指出：“区块链是一项了不起的加密成就，它能创建数字世界中不可复制的内容，具有巨大的价值。”&emsp;&emsp;显然，**区块链的这种作用远不只是在各种加密货币上，而且可以适用于任何数据。**当然，有人可能会担心，如果数据不能够被随意拷贝，是否会影响它的利用？实际上，区块链对此也已经给出了解决方案，就是它能够做到验证、使用数据和拥有数据分开。&emsp;&emsp;在过去，个人的病例属于医院，患者自己常常反而拿不到，其它的医院也无法利用这个数据进行研究，这无论对于个人还是对医学研究都不是好事。&emsp;&emsp;在区块链兴起之后，一些统计学家和生物信息专家就在思考一件事：能否利用区块链中查看信息和验证信息分离的特点，把个人的病例还给个人，然后让患者授权医生使用那些信息进行统计研究？&emsp;&emsp;这些医疗信息本身会加密，只有患者本人和被授权查看的医生才能打开查看，一般做研究的人看不到这种病，但是在得到一定的使用授权后，可以通过提问的方式从病例中获得答案。&emsp;&emsp;根据斯坦福大学统计系和医学院的教授王永雄院士介绍，美国大部分医生愿意花钱查询他们之前接触不到的病例，每一次查询支付10~15美元。如果这件事能够做成，那些患有疑难杂症的病人，一年据估计可以收获1 万到2 万美元的信息费（对于普通患者，大部分医生可能没有兴趣），这些钱可以帮助他们支付医药费。更重要的是，当那些疑难杂症患者的病例被大量医生查看后，有可能为他们找到医治的方法。&emsp;&emsp;据约翰·霍普金斯大学生物医学工程系主任米勒教授讲，在美国，一些疑难杂症，其实5年前在某家医院就有了有效医治的方法，但是遇到类似患者的医生通常不知道，因为信息流通不畅。而医疗数据涉及人最隐私的信息，难以共享。如果能够通过区块链解决医疗信息的查询和验证，对于疑难病症，乃至所有病症的医治有巨大的帮助。&emsp;&emsp;对于大部分人来讲，未必有医生们所关心的数据，但是他们的数据依然有价值，并且能够为自己带来利益。这当然也要依赖于区块链技术，或者类似的能够将所有权和使用权严格分开的技术。&emsp;&emsp;**在这样的技术保障下，数据可以真正交还给个人（等数据的制造者），他们授权各种大数据平台来管理数据并且将数据的价值变现，然后再从使用者的利润中获得自己的一部分，**这就如同你存钱时也就授权了银行替你放贷谋利。&emsp;&emsp;那时，一个人在互联网上的活动越多，积累的数据量越大，他的数据越值钱，收益也越大，而不是像今天这样，一个人买东西越多，越受到价格歧视。&emsp;&emsp;如果我们真的能往这个方向共同努力，**全社会就能够形成巨大的数据资产。再往后，就可能使用数据资产进行投资，那时数据资产就变成了数据资本。**&emsp;&emsp;当然，我所描绘的前景不可能一夜之间实现，因为今天的区块链技术还非常不成熟，而GDPR和CCPA等法律的实施也需要比较长的时间。而同时做到区块链在逻辑上的去中心化，和物理的中心化，以兼顾效率和安全性，依然还有很多技术问题要解决。&emsp;&emsp;但是，将数据资产化，进而资本化，对数据的所有者、管理者和使用者，都会产生巨大的利益。目前我国将发展区块链技术作为国策，是很有道理的。&emsp;&emsp;好，今天给大家的加餐分享就到这里，关于数据资产，你还有哪些自己的想法，欢迎给我留言。</details><h3><span id="38-gao-si-fen-bu-da-gai-lu-shi-jian-yi-wei-zhao-shi-me">38 ｜ 高斯分布：大概率事件意味着什么？</span><a href="#38-gao-si-fen-bu-da-gai-lu-shi-jian-yi-wei-zhao-shi-me" class="header-anchor">#</a></h3><!-- ![](/images/159.jpg) --><p>我们前面讲到，泊松分布描述的是概率非常小的情况下的统计规律性。这一讲我们通过学习高斯分布，也就是正态分布来正确认识大概率事件。</p><details><summary>...</summary>**高斯分布也叫正态分布**与泊松分布那样的小概率事件相对，如果一个事件A发生的概率非常大，等于或者接近1/2（当p大于1/2时，1-p小于1/2，我们把p和1-p互换，依然只要研究p小于1/2的情况），同时试验次数n也非常大，会是什么结果呢？&emsp;&emsp;我们假定事件A经过n次试验后发生了k次，把k的概率分布图画一下，就得到了一个中间鼓起，像倒扣的钟一样的对称图形。![](/images/160.jpg)这个图形你一定很熟悉，18世纪，数学家棣莫弗和拉普拉斯把这种中间大，两头小的分布称为正态分布。不过，**高斯对正态分布的误差（也就是标准差𝞼）作出了更严格的分析，于是正态分布今天就被命名为高斯分布。**&emsp;&emsp;我经常讲，发明的荣誉常常是授予最后一个发明者，高斯分布也是如此，因为是高斯为这项发现画了句号。&emsp;&emsp;高斯对正态分布的主要贡献在于，他利用概率分布的平均值和标准差（高斯实际使用的是方差，但是方差和标准差是完全相关的，今天我们用到更多的是标准差），来定义了正态分布，这种定义更具有普遍意义。&emsp;&emsp;**我们用一个大家并不陌生的例子来说明均值、标准差，和发生概率三者之间的关系。**![](/images/161.jpg)**哪个班的成绩更优秀？**假如有两个班，一班的考试成绩在60～100分之间变化，均值（平均分）为80分。二班的成绩在70～100分之间变化，均值为85分。那我们能说二班比一班成绩好吗？这个问题没有那么简单。&emsp;&emsp;根据我们的经验，同学们的成绩通常分布在平均分附近的比较多，特别好或者特别差的很少，对于这种情况，我们就可以用正态分布来刻画两个班成绩的分布，并且对它们进行比较。&emsp;&emsp;图左边标注了80的曲线是一班的，右边标注了85的曲线是二班的。从这两条曲线可以看出，一班的成绩有一个很小的可能性超过90分。如果一班真实的平均分应该是90分，而二班依然是85分，我们得说一班反而比二班强了。只不过，这种情况的可能性并不大。&emsp;&emsp;我把这个可能性用蓝色画在了图中。类似的，二班虽然平均分为85分，但是也存在一个小概率的可能性，它的平均分不到75分，我用绿色在图中画出来了。&emsp;&emsp;那么我们有多大把握说明平均分85分的二班一定比80分的一班强呢？这就要看两个班成绩的平均浮动范围了，这就是我们所说的标准差。这个数值其实就类似方便面包装袋上标的净重60克，后面还会标一个“+-1”克，这个1就是标准差。&emsp;&emsp;如果两个班的标准差都是5分，一班的真实成绩也+-5，大致就是在75到85分的范围内浮动，二班的成绩是在80到90分的范围浮动。在这两个浮动范围重叠的部分，我们无法判断哪个班成绩更好。这个重叠区域，即图中红色的区域，表示我们无法作出判断的情况，这个区域的面积，就是我们无法作出判断的概率。&emsp;&emsp;具体到这个图中，红色区域的面积占了两条曲线所覆盖面积的65%。也就是说，有65%的可能性，我们没法说哪一个班的成绩好。或者说，我们只有大约35%的信心，证明第二个班的成绩比第一个班好。这种信心通常被称为置信度。关于置信度，你也可以回顾我的《信息论40讲》中第16讲的课程。&emsp;&emsp;从这个例子中我们可以看出，两个班平均分差五分，如果标准差也是5分，我们并没有足够的证据说明哪个班成绩更好。那么在什么情况下能证明，平均分85分的二班，就比平均分80分的一班学得好呢？&emsp;&emsp;那就是减少标准差。当标准差𝞼降低到只有1时，这两个班成绩的概率分布大致如下图，重叠的部分只占面积的5%。这时我们大约有95%的信心说二班比一班好。其实这个很好理解，从分布图来看,标准差越大,分布图越扁平，重合面积就越大; 标准差越小,分布越 "瘦高"，两部分的重合面积就越小，我们就越有把握判断哪个在横轴上的分数越高。![](/images/162.jpg)**如何减小标准差？**&emsp;&emsp;接下来大家可能会问，怎样才能减小标准差呢？&emsp;&emsp;如果同学们的成绩分布情况不变，提高25倍的统计人数（虽然学校里没有这么大的班），标准差就会从5降低到1左右。&emsp;&emsp;2019年10月份，医学界发生了一件轰动世界的事情。美国百健公司（Biogen）宣布他们所研制的治疗阿尔茨海默病的药品Aducanumab在大规模临床试验中被证明有效，全世界都为此欢呼。但是仅仅在半年前，他们进行的小规模试验后的结果却是药效不明显。这又是怎么一回事呢？&emsp;&emsp;其实半年前的试验就是因为样本数量比较少，巨大的标准差掩盖了药物相比安慰剂在疗效上的差异。而当样本数量增加后，方差降低了，药效就看出来了。&emsp;&emsp;可以对比图中的几条曲线：绿色的是参照组，黄色的是小样本试验的结果，蓝色的是大样本试验的结果。你可以看出样本数大了，结果曲线和参照组的重合度就减少了。![](/images/163.jpg)大家可能会讲，标准差𝞼和置信度这些东西我也不会算，能不能告诉我几个简单的数字，我在生活中直接用就好了。答案是有的！&emsp;&emsp;如果一个随机变量的取值符合高斯分布，它有大约68%的可能性，动态范围不超过平均值加减标准差𝞼。这时我们说，在一个标准差之内，我们对平均值的置信度为68%。&emsp;&emsp;比如在上面的例子中，一班的平均成绩为80分，标准差为5分，于是我们有68%的置信度说，考虑到随机性的影响，这个班的平均成绩应该落在75～85分之间，而不是之外。&emsp;&emsp;如果我们把允许的误差的范围放大一点，放大到正负两倍的标准差，那么有大约95%的情况，这个随机变量的动态范围不超出平均值加减两倍的标准差，或者说，我们有95%的置信度相信这一点。&emsp;&emsp;做科学实验时，通常需要有95%的置信度，否则大家觉得不踏实。当然，如果我们进一步扩大误差范围到三倍的𝞼，那么置信度就提高到99.7%。在要求极高的实验中，我们甚至会要求更高。&emsp;&emsp;这个规则适合于任何高斯分布，我们通常称之为“三𝞼原则”或者“68-95-99.7原则”。平时大家记住带有随机性质的结论，需要有95%的置信度就好了。我把上述三种情况画在了下面的图中，可以看一眼下面下图，获得一个感性的认识。![](/images/164.jpg)大家同时也注意一下，**图中曲线和x轴之间的面积，就是曲线的积分，面积的大小就代表了高斯分布在某个范围内的概率。****举例应用：**&emsp;&emsp;了解了标准差和置信度的关系，我们就拿它来分析一个例子。这个例子是关于股票投资的，我们以美国的股市为例来说明。&emsp;&emsp;在过去的半个世纪里，标准普尔500指数的增长率大约是每年7%～8%左右，但是你知道它的标准差有多大么？高达16%左右。这说明股市的波动性特别大。有人可能会问为什么标准差会大于回报率，因为在不少年头，回报率是负的。&emsp;&emsp;可以看下图，你会发现7%～8%的平均回报完全被淹没在巨大的正负误差波动中了。通常，金融领域的人会将这种标准差直接称为风险。![](/images/165.jpg)这个事实说明，其实我们对于大概率事件，往往是视而不见的，而风险其实就存在其间，我有三点结论要详细说明。&emsp;&emsp;首先是股市的风险要远远高出大部分人的想象，这不用多说了，一张图胜过千言万语。美国的标准普尔500指数，是世界风险最低，回报最高的投资工具，而且是500个表现很好的股票的平均值，收益和风险之比尚且如此，其它的投资风险就更高得多了。因此，大家在投资时如何小心都不为过。&emsp;&emsp;其次，由于任何一种投资都有标准差（风险），因此对比投资回报时要把它考虑进去，不能只考虑回报不考虑风险。&emsp;&emsp;比如投资A的回报是10%，风险是20%，投资B的回报是5%，风险是3%。不能光看10%比5%高，就认定投资A比B好，要橘子和橘子对比，苹果和苹果对比，在相同风险条件下对比。事实上在做投资时，A、B这两种投资恰恰是很好的具有互补性的工具。&emsp;&emsp;当然，对于回报总是大于零的债券和存款（先不考虑欧洲的负利率），很多人会觉得是零风险的，其实这种看法也是错的。因为那些投资在计算回报时没有考虑通货膨胀的因素，如果你存款的回报是3%，而通货膨胀可能达到5%，这就是风险。&emsp;&emsp;事实上，全世界所有的国家都刻意低报通货膨胀率，因为房价的上涨是不算在通货膨胀内的，而它恰恰可能是造成通胀的重要原因。&emsp;&emsp;最后，如果有一只股票连续三年的回报是10%，另一只只有5%，你能说第一只比第二只好吗？不能，因为5%的差异，要远比16%的标准差小很多，事实上个股的方差比股指更大。换句话说，这5%的差异更可能是市场浮动的随机性造成的。&emsp;&emsp;事实上，美国每年涨幅最好的10只股票、10个基金到了第二年表现都会跌出前十名。因此，不要以为自己的投资回报在几年里超过了股市大盘，就觉得自己是股神。**要点总结：**&emsp;&emsp;我们通过介绍高斯分布，说明了两个随机变量均值的差异和偶然性之间的关系。由于偶然性的存在，如果只有很小的均值差异，那可能说明不了什么问题。我们还介绍了著名的3𝞼法则，大家记住有随机性的结论，需要有95%的置信度就好。&emsp;&emsp;下一讲，我们一起研究一下贝叶斯公式，下一讲见。</details><h3><span id="39-tiao-jian-gai-lu-he-bei-xie-si-gong-shi-ji-qi-fan-yi-shi-ru-he-gong-zuo-de">39 ｜ 条件概率和贝叶斯公式：机器翻译是如何工作的？</span><a href="#39-tiao-jian-gai-lu-he-bei-xie-si-gong-shi-ji-qi-fan-yi-shi-ru-he-gong-zuo-de" class="header-anchor">#</a></h3><!-- ![](/images/166.jpg) --><p>到目前为止，我们讲的和概率有关的随机试验都是独立的，前后不相关。但是世界上很多随机事件的发生是彼此相关的，比如今天的天气就和昨天的天气有关，在一句话中，某个词是否出现，和上一个词其实也有关。今天我们就来看看，如果前后相关，利用相关性，能够创造什么样的奇迹。</p><details><summary>...</summary>**“条件概率”和“本身概率”有什么区别？**&emsp;&emsp;我们先来看看汉语中同音词出现的概率，比如汉语拼音tian qi，在不考虑音调时，可以是“天气”，也可以是中药“田七”。如果没有上下文，“天气”出现的可能性恐怕是中药“田七”的上千倍。但是如果我特别强调它前面一个词汇是“中药”，那么后面这个词汇是“田七”的可能性就比“天气”大得多。&emsp;&emsp;可见，在一个特定条件下，某个随机事件发生的概率，和通常它发生的概率有很大区别，这种在某个特定条件下发生的概率，就是条件概率。**对于几乎所有的随机事件来讲，条件概率由于条件的存在，它通常不等于本身的概率。**&emsp;&emsp;比如说，“天气”这个词在汉语中出现的概率，用P（天气）来表示，可能是千分之一（0.1%），而“田七”的概率P（田七）只有百万分之一（0.0001%），但是如果前面一个词是“中药”，“天气”的概率就降低到十万分之一了，而“田七”的概率则上升到百分之一了。&emsp;&emsp;**这时候的概率我们称之为条件概率，“中药”这个词就是后面出现什么词的条件。一般我们把条件概率写成P（天气|中药）的形式。**&emsp;&emsp;条件概率在认知上有非常重要的意义。你从上面的例子中可以看出，考虑不考虑条件，两个随机事件发生的概率可以差出很多数量级，原来不可能发生的事情，就极可能会发生，原来以为是大概率的事情，可能根本就不会发生。&emsp;&emsp;很多人学习别人的经验，用到自己身上就不灵了，原因就是没有搞清楚条件。另一方面，有些原来大家认为不可能做成的事情，一旦条件具备，就成为了大概率事件。**条件概率怎么计算？**&emsp;&emsp;那么条件概率是怎么计算的呢？为了简单起见，我们这里先不从严格的数学公式讲起，先从经验出发讲一下近似的计算方法，以便于理解。我们先来说说无条件的概率是如何估算的。&emsp;&emsp;我们在前面讲了，当一个随机试验在同等条件下进行很多次时，我们就把它发生的次数，除以试验的总次数，作为近似的概率。在计算语言中词汇出现的概率时也是如此。&emsp;&emsp;比如，我们假定一个词X在非常多的汉语文本，比如一年的人民日报中出现了4000次，而一年人民日报所有的文章有四百万个词。于是，我们就用4000除以总词数400万，得到X的词频是千分之一，我们用f(X)来表示。&emsp;&emsp;当然我们根据前面课程中的讲解，大家知道词频f(X)和实际概率P(X)之间其实是有偏差的，这件事我们下一讲再讨论，今天我们权且认为它们相等，这样问题讲起来比较简单了。&emsp;&emsp;好了，我们假定统计的文本量非常非常大，各种词共出现了10亿次。注意我们这里说的是所有词加起来出现的次数，不是字典中词汇的数量。假如“天气”这个词出现了100万次，概率就是千分之一，“田七”出现了1000次，因此概率是百万分之一。&emsp;&emsp;接下来我们就可以讨论如何计算条件概率了。我们假定“中药”这个词出现了10万次，它后面可能跟随着很多种不同的词，比如“黄芪”、“田七”、“麝香”等等。那么一个词X，在给定前一个词是“中药”的条件下出现的概率是多少呢？应该就是“中药+X”出现的次数，除以中药出现的次数。&emsp;&emsp;比如，“中药田七”四个字出现了1000次，于是中药条件下“田七”的概率就是1000/100000=1%，类似的，如果，“中药天气”这四个字只出现了1次，那就是说，在中药条件下“天气”的概率就是十万分之一。&emsp;&emsp;你可以看出，一个随机事件发生的条件概率，取决于两个因素，一个是这个条件本身出现的次数，在上面的问题中就是“中药”出现的那10万次；另一个是，这个条件和这个随机事件一同出现的次数，在上面的问题中，就是“中药田七”这四个字出现的那1000次。条件概率就是后者加了条件后的“中药田七”对前者“中药”这个词本身的概率比值。在这个例子中，比值就是百分之一。&emsp;&emsp;讲了这么多条件概率的计算，关键要让大家掌握一个公式：P(Y|X)=P(X,Y)/P(X)>【注：一件事Y在条件X下发生的条件概率P（Y|X），等于条件X，和这件事Y一同发生的联合概率P（X，Y），除以条件X的概率P（X）。】**如何把式子变形就是贝叶斯公式？**现在我们把这个式子变形，写成：<center>P(X,Y)=P(Y|X)*P(X)</center>>（注：可以理解成X和Y一同发生的概率，就是X发生的概率，乘以在X条件下Y发生的概率。）&emsp;&emsp;我们在前面讲过，**在数学上的因果关系不像在物理上是单方向的，它可以是条件和结果互为因果。在概率上也有这样一个特点，就是条件和结果可以互换，**比如在文本中的两个词X和Y，我们可以说，如果知道前面一个词是“中药”，请问后面一个词是什么？那么前面的词就是后面的词的条件。&emsp;&emsp;我们也可以反过来说，如果知道了后面的词是“田七”，请问前面有可能是什么词？这时上面计算条件概率的算法依然适用，只是把X和Y调一个个儿就可以了，我们可以写成：<center>P(X|Y)*P（Y）=P(X,Y)</center>&emsp;&emsp;对比这个式子和前面的式子，我们发现它们都等于X和Y的联合概率分布P(X,Y) ，因此两个等式的左边也必然相等。于是，我们就可以得到一个重要的公式P(X|Y)*P（Y）=P(Y|X)*P（X）。&emsp;&emsp;在这个公式中，如果我们知道了其中三个因子，就能求出第四个。通常来讲，两个条件概率P(X)和P(Y)是容易求的。另外两个条件概率，一个是X条件下Y的概率，一个是Y条件下X的概率，常常一个比较容易得到，另一个比较难得到。所以，我们常常从容易得到的条件概率，推导出难得到的概率。这就是著名的贝叶斯公式。<center>P(X|Y)=P(Y|X)*P（X）/ P（Y）</center>在这个公式中，**我们假定Y条件下X的条件概率比较难得到，我们放在了等式的左边，而X条件下Y的条件概率容易得到，我们放在了等式的右边。****贝叶斯公式有什么用？**&emsp;&emsp;数学比较好的同学们可能已经看出来了，这不过是一个小的数学把戏，它真的会很有用吗？&emsp;&emsp;接下来，我们就来看一个例子，看看如何利用条件概率和贝叶斯公式实现计算机自动翻译。&emsp;&emsp;我们假定有一个英语句子Y，想要翻译成中文句子X，那么怎么翻译呢？很多人将它想象成语言学问题，其实这是一个数学问题，或者更准确地说，是一个概率的问题。&emsp;&emsp;假定英语句子Y有很多种翻译方法X1，X2，X3……XN，我们只要挑一种翻译X，使得在已知英语句子Y的条件下，X的概率P（X|Y）超过其它所有可能的句子的条件概率即可。&emsp;&emsp;比如说，这句话有10种翻译方法，它们的条件概率分别是0.1，0.5，0.01，0.02……你会发现第二种翻译方法X2的条件概率是0.5，是最大的，因此就认为Y应该被翻译成X2，或者说X=X2。&emsp;&emsp;你看，这其实又是一个我们之前讲到过的最优化问题了。那么P（X|Y）这个概率该怎么计算呢？>（注：我们无法通过直接统计获得，因为我们前面讲了，你要想直接计算这个概率，就需要恰巧遇到一个英文句子Y，对应一个中文句子X，还在文本中一同出现了很多次。）&emsp;&emsp;这个条件概率的计算，就要用到贝叶斯公式了。我们将它展开成<center>P（X|Y）=P(Y|X)*P（X）/ P（Y）</center>&emsp;&emsp;这个式子中有三个因子。第一个因子P(Y|X) 是给定中文的句子，对应的英文句子的概率，它可以通过一个马尔可夫模型计算出来，当然你也可以把它想象成通过查字典得到所有相应的汉语词和英语词的对应。这里面的细节我们省略了，有兴趣的同学可以去读读我的《数学之美》一书。&emsp;&emsp;接下来的第二个因子P（X）是所谓的语言模型，它计算的是哪个句子在语法上更合理，这个也可以通过一个马尔可夫模型计算，这里细节我也省略了。第三个因子P（Y）是一个常数，因为你要翻译句子Y，它是个确定的事情，你把它的概率想象成1就可以了（其实不是1）。&emsp;&emsp;于是原来的一个无法直接计算的条件概率，经过贝叶斯公式，变成了三个可以计算的概率。这样，就能够判断给定一个句子，任何翻译出来的中文句子的可能性，然后我们找出最大的那个即可。这便是机器翻译的原理。**要点总结：**&emsp;&emsp;首先我们介绍了条件概率的含义，大家可以看出，有没有条件存在，一个随机事件的概率可以相差很大。凡事讲究条件，这是一个重要的知识点。&emsp;&emsp;随后我们介绍了条件概率的计算方法。它的本质是什么呢？概括来讲有两个，首先在数学上条件和结果可以互换，这是它的前提。其次，通过这种互换，可以把一个复杂的问题变成三个简单的问题。这就是贝叶斯公式的本质。利用它，就解决了机器翻译的难题。&emsp;&emsp;在数学上经常要用这样的思路解决问题，看似绕了一个弯，实则是架起了几个桥梁，让本来没有直接通路的两个点，绕几段路能够联通。我们在前面讲到虚数的作用，其实也是绕一个弯之后，把原来不通的道路走通。希望通过这一点，我们能了解远和近的辩证关系。&emsp;&emsp;顺便说一句，在生活中有很多类似机器翻译的问题，看似是智能问题，实际上是数学问题。而学好数学，就是掌握一个工具更好地解决现实问题。我知道这一讲听起来可能有些烧脑，建议你对照文稿再读一遍，我们下一讲再见。</details><h3><span id="40-gai-lu-gong-li-hua-yi-ge-bi-xu-bu-shang-de-li-lun-lou-dong">40 ｜ 概率公理化：一个必须补上的理论漏洞</span><a href="#40-gai-lu-gong-li-hua-yi-ge-bi-xu-bu-shang-de-li-lun-lou-dong" class="header-anchor">#</a></h3><!-- ![](/images/167.jpg) --><p>到目前为止，我们讲了概率论的很多用途和思想方法，但是大多数结论和方法都是从经验出发得到的。这和我们前面讲的，数学并不依赖于经验这个特点似乎是矛盾的。事实上，这也是早期概率论所面临的一种尴尬局面。</p><details><summary>...</summary>&emsp;&emsp;一方面，包括拉普拉斯和高斯等人在内的一部分数学家在概率论上有了很多的成就，这些成就甚至已经被派上了用场；但另一方面，很多数学家则拒绝承认概率论是数学的一部分。&emsp;&emsp;今天你在一些大学的数学系里，依然能体会到这种鄙视的意味。比如学纯数学的人会说：“他们是概率统计系的，我们是数学系的。”言外之意，那些利用统计做事情的人要比研究纯数学的人低一个档次。&emsp;&emsp;这些当然是对概率论的误解。今天的概率论，早已不是那种基于经验，支离破碎的理论，而是建立在公理之上的，非常严格的数学体系了。**这在很大程度上要感谢前苏联伟大的数学家柯尔莫哥洛夫，他完成了概率论的公理化过程，因此很多数学家觉得他是20世纪最伟大的数学家。****定义是概率论的最大漏洞**&emsp;&emsp;不过，在讲他的贡献之前，我们先要讲讲19世纪概率论的最大难题，就是对“概率”定义的不清晰。&emsp;&emsp;我们在前面介绍拉普拉斯的古典概率论时讲到，他对概率定义的方法是有漏洞的，发生了循环定义，在介绍随机事件A的概率时，用了等可能性的单位事件这样的说法。但是概率还没定义清楚，怎么能用等可能性的单位事件呢？在此基础上定义概率就是循环定义。&emsp;&emsp;为了弥补拉普拉斯古典概率论的漏洞，英国的逻辑学家约翰·维恩和奥地利数学家理查德·冯·米泽斯提出建立在统计基础上的统计概率。这就回避了所谓的等可能性的单位事件存在性的问题。&emsp;&emsp;维恩和理查德的想法就是我们上一讲讲的，将相对频率极限等同于概率。这是什么意思呢？比如，要确认一个骰子六点朝上的概率是否为1/6，就要进行大量独立的试验，看看最后六点朝上发生的次数和试验次数的比值是否等于1/6。但是我们在前面讲了，由于掷骰子的结果具有随机性，只试验几次，并不能保证骰子的六点那个面每六次就必然有一次朝上。&emsp;&emsp;所幸的是，如果这个随机事件真的存在一个确定的概率，随着试验次数的增加，六点朝上的比例会在一个特定的值上下浮动，并且趋近于某个极限值。这个极限值被称为统计概率，如果试验次数足够多，六点朝上的频率最终就会趋近于1/6。这时我们说它的概率是1/6就没有错。&emsp;&emsp;以上是维恩等人对概率新的定义方式，这不仅弥补了古典定义的一些不足之处，也让我们能够通过大量的试验算出概率。比如，计算一个词出现的概率，就没有什么等概率的原子概率，也就是说，它不能像骰子那样每个数字出现的概率都是1/6那样确定，但是却可以通过试验得到。&emsp;&emsp;不过维恩等人有一个问题还没有回答，那就是要进行多少次试验，我们统计得到的概率才算准确？我们前面在讲高斯分布时，讲了3西格玛的置信度，但是置信度要高到多少我们才认为统计的结果就是概率本身呢？回答了这个问题，才能让概率的定义更清晰明确。&emsp;&emsp;要回答这个置信度的问题，就需要问一个更本质的问题，就是拉普拉斯的古典定义方法，和维恩等人统计概率的定义方法，得到的是否是同一个东西？如果是，我们才有可能经过大量的试验，得到准确的概率，否则你再做试验也没有用，因为可能两者之间总有一个无法弥补的误差。&emsp;&emsp;这就如同我们说，0.99999……无限循环下去等于1，置信度是100%，因为它们在本质上是一回事。但是0.99999……再增加，它和2之间的误差还是无法弥补，因为它们根本不是一回事。&emsp;&emsp;最早的时候，伯努利证明了，假如一件事的概率P真的存在，进行N次试验，每次试验的条件完全相同，那么当N趋近于无穷大时，A发生的次数M除以试验总次数N，即M/N，和它真实的概率P之间的误差是无穷小。这就是我们常说的“大数定理”中的伯努利版本。&emsp;&emsp;伯努利版本在数学上其实并不是很严格，因为它在无形中引入了一个假设前提，就是概率P本身是存在的。&emsp;&emsp;19世纪中期，俄罗斯著名的数学家切比雪夫提出了一个更严格的关于大数定理的版本，在他的版本中，不需要概率P预先存在，他只要求一个随机变量X，进行大量的随机试验后，结果的平均值和方差是恒定的就可以了。而那个平均值，就可以作为它的概率。这被称为切比雪夫版本的大数定理。它不仅在数学上说明了维恩等人对概率定义的合理性，而且也是今天我们采用大数据方法解决问题的理论基础。&emsp;&emsp;应该讲，概率论发展到切比雪夫的年代，已经比较严格了，他所提出的大数定理，都是经过严格证明的。但是，它在形式上依然不漂亮，或者说完全没有数学本身的美感。如果你回顾一下几何学和微积分，就会发现它们都很漂亮，因为只要定义几个公理、几个基本概念，就能构成一个完整的数学分支。**概率论依然不够漂亮**&emsp;&emsp;**概率论讲来讲去，总是让人觉得有点别扭，很多道理要用自然语言，而不是数学的语言来解释。因此到19世纪末的概率论，依然只能被称为初等概率论。**&emsp;&emsp;和初等概率论相对应的，是现代概率论，它是建立在公理和一个被称为“测度”的概念基础之上的，而完成建造现代概率论大厦的主要是柯尔莫哥洛夫，它让概率论能有今天崇高的地位。&emsp;&emsp;柯尔莫哥洛夫和历史上的牛顿、高斯、欧拉等人一样，是历史上少有的全能型的数学家，而且也是少年得志。柯尔莫哥洛夫在22岁的时候（1925年）就发表了概率论领域的第一篇论文，30岁时出版了《概率论基础》一书，将概率论建立在严格的公理基础上，从此概率论正式成为了一个严格的数学分支。&emsp;&emsp;同年，柯尔莫哥洛夫发表了在统计学和随机过程方面具有划时代意义的论文《概率论中的分析方法》，它奠定了马尔可夫随机过程的理论基础，从此，马尔可夫过程成为后来信息论、人工智能和机器学习强有力的科学工具。没有柯尔莫哥洛夫奠定的这些数学基础，今天的人工智能就缺乏理论依据。&emsp;&emsp;柯尔莫哥洛夫一生在数学之外的贡献也极大，他的成果如果要列出来，一张纸都写不下，我们这里就省略了。总之，今天很多数学家把柯尔莫哥洛夫誉为20世纪数学上的第一人，并非过誉。接下来我们就说说柯尔莫哥洛夫是怎样用公理来漂亮地描述概率论的。&emsp;&emsp;首先，我们需要定义一个样本空间，它包含我们要讨论的随机事件所有可能的结果。比如抛硬币的样本空间就包括正面朝上和背面朝上两种情况，掷骰子就有六种情况。&emsp;&emsp;接下来，我们需要定义一个集合，它包含我们所要讨论的所有随机事件，比如掷骰子不超过4点的情况是一个随机事件，掷骰子结果为偶数点的情况也是，或者干脆就是得到5点的情况，所有这些随机事件自然可以构成一个集合。&emsp;&emsp;接下来，我们需要定义一个函数（也被称为测度），使集合中任何一个随机事件对应一个数值。只要这个函数满足下面三个公理，它就被称为概率函数。**基于三个简单公理**这三个公理是：- 公理一：任何事件的概率是在0和1之间（包含0与1）的一个实数。- 公理二：样本空间的概率为1，比如掷骰子，那么从1点朝上，到6点朝上加在一起构成样本空间，这六种情况放到一起的概率为1。- 公理三：如果两个随机事件A和B是互斥的，也就是说A发生的话B一定不会发生，那么，这件事发生的概率，就是A单独发生的概率，加上B单独发生的概率。这也被称为互斥事件的加法法则。很好理解，比如掷骰子一点朝上和两点朝上显然是互斥事件，一点或两点任意一种情况发生的概率，就等于只有一点朝上的概率，加上只有两点朝上的概率。基于这样三个公理，整个概率论所有的定理，包括我们前面讨论的所有内容，都可以推导出来。可以看出，这三个公理非常简单，符合我们的经验，而且不难理解。你可能会猜想，在这么简单的基础上，就能构造出概率论？确实如此，我们不妨看几个最基本的概率论定理，是如何从这三个公理中推导出来的。**定理一，互补事件的概率之和等于1。**所谓互补事件，就是A发生和A不发生。比如，整个样本空间是S，A发生之外的全部就是A不发生。由公理二和公理三，可以直接得到这个结论。![](/images/168.jpg)**定理二，不可能事件的概率为零。**&emsp;&emsp;从上一个定理可以得知，两个互补事件合在一起就是必然事件，因此必然事件的概率为1。而必然事件和不可能事件形成互补，于是不可能事件的概率必须为零。&emsp;&emsp;类似的，我们可以证明拉普拉斯对概率的定义方法，其实可以由这三个公理推导出来，而统计概率的所有理论，以及我们上一讲讲的条件概率的公式，和贝叶斯公式，也都可以由这三个公理推导出来。&emsp;&emsp;自此，**概率论才从一个根据经验总结出来的应用工具，变成了一个在逻辑上非常严密的数学分支。它的三个公理非常直观，而且和我们现实的世界完全吻合。****要点总结：**&emsp;&emsp;我们通过讲述概率论发展的过程，揭示了数学家们修补一个理论漏洞的过程和思考方法。最终，只有建立在公理化基础上的概率论，才站得住脚，而之前的理论，不过是在公理化系统中的一个知识点。&emsp;&emsp;我们还特别介绍了大数定理，说明了理论计算出的概率，同大量统计得到的结果是一致的。也正是因为有这种一致性，今天的大数据方法也才有了理论基础。&emsp;&emsp;下一讲，我们就说说为什么大多数公司都用不好大数据。我们下一讲再见。</details><h3><span id="41-tong-ji-xue-he-da-shu-ju-wei-shi-me-da-duo-shu-gong-si-yong-bu-hao-shu-ju">41 ｜ 统计学和大数据：为什么大多数公司用不好数据？</span><a href="#41-tong-ji-xue-he-da-shu-ju-wei-shi-me-da-duo-shu-gong-si-yong-bu-hao-shu-ju" class="header-anchor">#</a></h3><!-- ![](/images/169.jpg) --><p>我们上一讲讲到了估算概率通常使用的一种方法，就是依靠大数定理，根据统计得到概率。比如我们前面讲到，要了解一个汉语单词的概率，可以在很多语料中数一数它出现了多少次，然后将这个次数除以语料库中所有汉语词的次数即可。</p><details><summary>...</summary>&emsp;&emsp;只要统计量足够多，这个概率估计就是准确的。但是，什么算是足够多呢？&emsp;&emsp;我们学习了方差的概念，就知道统计量应该达到某一个程度，使得方差足够小。正是因为有这一套理论支持，统计出来的结论才是可信的。我们今天很多企业使用数据决策，却失败了，就是因为所用的大数据，离开了这样的数学基础，得到的结论就不足以说服人。&emsp;&emsp;**今天我们就重点谈谈大数据方法的基础，也就是统计学，只有搞定其中的意义、方法和使用时的注意事项，在使用数据时，才算有了基本的行动指南。****用好大数据，你得先明白统计学**&emsp;&emsp;使用数据方法离不开统计学，那什么是统计学，它是否就是概率论的应用，是否是数学的一个分支？这些概念和关系很多人是一知半解。&emsp;&emsp;**统计学严格来讲是一门独立的科学，它是关于收集、分析、解释、陈述数据的科学。**统计学的数学基础是概率论，在分析和解释数据时，要大量地使用概率论和其它数学工具，同时它也是概率论最大的用武之地，因此我们将它放在数学课中来讲。&emsp;&emsp;但是，大家心里要清楚，统计学远不只是设计一个样本，然后用加减乘除算算概率那么单纯，它里面还有很多非数学的工作，比如如何陈述数据让大家接受你的结论，这也属于统计学的范畴。也正是为了这个目的，人们才发明了各种统计图表，因为人类对图表的敏感度要远远高于对数字的敏感度。&emsp;&emsp;在统计学中，还专门有一个分支，叫做描述统计学，就是研究如何让统计的结果更有说服力。除此之外，统计学还有很多问题，比如如何保存和整理数据，其实也和数学没有太多的关系。&emsp;&emsp;如果说概率论最初是赌徒们所研究的雕虫小技，登不上大雅之堂的话，那么统计学从一开始就是高大上的学问。统计学的英语单词statistics是源于拉丁语“国会”或者“国民政治家”的意思，最早是特指对国家的数据进行分析的学问。&emsp;&emsp;18世纪德国的学者戈特弗里德·阿亨瓦尔（Gottfried Achenwall）发明了德语版的这个词，特指“研究国家的科学”，即根据数据了解情况，制定国策。后来这个词被翻译成各国的语言，但是含义却远远超出了原来特指研究国家的科学这一层含义。&emsp;&emsp;统计学研究的目的，通常是从大量数据寻找规律性，不同因素之间的相关性，以及可能存在的因果关系。不过，后一种关系，即因果关系通常未必能找到，这一点我们后面要专门讲。在找到相应的规律之后，我们就可以利用它来建立数学模型，预估未来数据的发展和变化。&emsp;&emsp;比如我们前面讲到，可以统计出汉语词之间的关联性，也就是条件概率，这样，如果遇到像“天气”和“田七”，“北京”和“背景”这样的同音近音词，我们就可以通过上下文，计算它们的条件概率，从而在语音识别，或者拼音输入中，确定到底是哪一个词。&emsp;&emsp;比如，前面一个词是“中药”，我们就知道后面是“田七”的可能性比“天气”大。而见到“天气”这个词，我们也就知道前面是“北京”比“背景”的可能性大。这就是统计的目的。**数据没用好的第一个原因：**&emsp;&emsp;近年来，由于数据量的剧增，一个企业要是不谈大数据都不好意思，但是你可能发现了，大数据谈了十年之后，也用了很多年，并非所有使用大数据的企业都在受益，很多企业使用它的效果不明显。这里面主要的原因是使用方法不对。&emsp;&emsp;我们知道，今天使用大数据，主要是为了寻找一些变量之间的关联性，从而达到准确预测的目的。但是在实际问题中找准相关联的两个变量这件事本身并不容易。在前面讲到的利用前一个词预测后一个词，两个相关的变量就是前面的词和后面的词，当然也可以反过来。&emsp;&emsp;今天我们知道可以这么使用之后，看似很容易想到，但是在语音识别诞生后的20多年里，科学家们并没有想到这个办法。因此虽然今天数据量不再是问题，但如何选定可能有关联的变量，则体现了人类的智慧。&emsp;&emsp;特别是，当我们研究人类行为的时候，那些可能影响我们行为的客观变量或者说条件，更是不容易找到，即使找到，我们的行为又可能反过来改变条件。这里面最出名的例子就是上个世纪初，心理学家们在美国西屋电气公司位于霍桑市的工厂所进行的霍桑实验了。&emsp;&emsp;霍桑实验的最初目的，是找到一些影响工人生产效率的因素（变量），然后加以改进，以提高生产率。心理学家们考虑的因素包括薪酬、照明条件、工间休息等等。&emsp;&emsp;他们通过大量的统计发现，这些因素似乎和劳动效率有关，于是厂家就改善了相应的条件，比如增加照明亮度。但是，在这些改进中，一些因素并未达到对生产效率的明显提升，和想象的不一样，另一些改进虽然开始起到了一定的效果，但是很快又回到初始的状况。&emsp;&emsp;对于这个现象，心理学家们后来进行了很多研究，比如发现当时很多实验并不是双盲的，那些对比在今天看来没有太多统计的意义，再比如当实验的设计者提高照明亮度开始测试生产效率时，工人似乎提高了效率，但这不是照明引起的，而是因为他们觉得自己被围观了，因此特别有干劲。&emsp;&emsp;这一类的情况在早期的药品有效性的试验中也特别明显，只要病人从医生的口中觉察到他所服用的是真药而不是安慰剂，效果就好，但这无法判定是药的原因，还是心理作用。于是就有了“霍桑效应”这个名词，它是指当被观察者知道自己成为被观察对象而改变行为倾向的反应。&emsp;&emsp;霍桑效应不仅体现在个人身上，也体现为群体的反应。比如一个国家将原本3%的GDP增长，按照5%公布于众，民众对经济前景有了信心，开始增加消费和扩大生产，反而可能导致GDP的上涨。&emsp;&emsp;反过来，城市道路的拥堵信息一发布并显示在地图上之后，大家为了避免拥堵，都挤到地图上显示的绿色的道路中，反而造成了往哪里走，哪里就堵的死循环。此外，今天很多推荐系统见你读什么，买什么，就继续推荐什么，但你一点兴趣也没有，这就是陷入了霍桑效应的陷阱。**数据没用好的第二个原因：**&emsp;&emsp;今天大家在使用大数据时失效的另一个原因，就是低估了数据的稀疏性所带来的副作用。我们在前面讲了，利用统计得到结论，需要足够的统计量。今天看似大数据的数据量是足够的，但是如果你把它分为了很多维度，其实还是很稀疏的。&emsp;&emsp;我们就以利用上下文预测后面的单词为例来说明，假如我们使用两个词Y和Z来预测第三个词X，汉语的词汇量按照10万来计算，这看上去并不是一个复杂的数学模型，但是这个统计模型有1000万亿个条件概率值需要估算，整个互联网上的内容都翻译成中文，文字的总长度也超不过100万亿个词，因此，数据量显然是不够的。关于如何解决稀疏性的问题，我们明天会专门讲。**数据没用好的第三个原因：**&emsp;&emsp;大数据方法失效的第三个原因，就是把原因和结果搞反了。我们在前面介绍条件概率时讲到，X和Y这两个随机变量，你既可以把X看成是Y的条件，也可以反过来看。当你拿到原始数据，看到X和Y同时出现时，你其实很难搞清楚谁是原因，谁是结果。&emsp;&emsp;事实上很多研究人文社会科学的学者也经常把原因和结果搞反，因为你会同时读到把X当作Y原因的论著，以及把Y当作X原因的论著，它们甚至发表在同一本期刊上。&emsp;&emsp;今天很多公司在使用大数据时，完全不去分析因果关系。比如我上网寻找过酒店，并非接下来就是要买飞机票，而是可能有一张用里程兑现的飞机票要到期了，必须用掉。从找酒店推断出要买机票就是搞反了因果关系。**想用好数据的五个步骤：**从这些例子可以看出，利用统计结果指导工作，远不像想象的那么容易。不过，使用统计的方法解决问题，通常还是有章可循的，我把它总结成下面五个步骤：**1.设立研究目标，**比如我们利用数据来证实什么假说，或者得到什么样的相关性。有了目标，才能够避免盲目使用数据的情况，并且能够有意识地过滤数据中的噪音。通常，使用数据驱动的方法除了要准备一个待证实的假说，还要准备一个可对比的备用假说，比如你在证实药品有效性时，备用的假说就是安慰剂同样有效。统计的目的就是确认你的假说，同时否定掉备用假说。比如你要证明个人信息对推荐机票有效，就要证明不使用个人信息时，推荐机票无效，而不是同样有效。**2.设计实验，选取数据。**这些数据需要能够方便量化处理。比如你要识别图像，就需要将图像信息数字化，便于计算机处理。**3.根据实验方案进行统计和实验，分析方差。**很多人只是关注结果的均值，而忽略方差。比如你要想了解一种投资回报是否更高，光看回报率是不够的，还要衡量风险，就是方差。**4.通过分析进一步了解数据，提出新假说。**很多时候，统计的结果不是证明你的假说有效，而是证明它无效，这时就要提出新假说，重新验证。**5.使用研究结果。**这包括将你的统计结果用于产品，也包括报告给别人。对于后者来讲，怎么报告其实很有讲究。**要点总结：**&emsp;&emsp;我们介绍了统计学的来龙去脉，特别强调了它非数学的一面。然后我们从统计学的特点出发，讲了使用统计学的一些误区，特别是使用大数据方法的误区。最后介绍了使用统计学大致的方法。希望这些经验对你有所帮助。&emsp;&emsp;欢迎大家在留言中提问，我在模块结束时会进行一次问答，期待你问出好问题。我们下一讲见。</details><h3><span id="42-gu-de-tu-ling-zhe-kou-gu-ji-hei-tian-e-shi-jian-ke-yi-fang-fan-ma">42 ｜ 古德-图灵折扣估计：黑天鹅事件可以防范吗？</span><a href="#42-gu-de-tu-ling-zhe-kou-gu-ji-hei-tian-e-shi-jian-ke-yi-fang-fan-ma" class="header-anchor">#</a></h3><!-- ![](/images/170.jpg) --><p><strong>“黑天鹅”是怎么产生的？</strong></p><p><strong>我们先来看看所谓黑天鹅事件是怎么产生的。</strong></p><details><summary>...</summary>&emsp;&emsp;我们前面讲了通过对文本进行统计，实现通过上下文来预测句子中某个位置单词的例子。在那个例子中，被统计的数据量哪怕再大，相比要产生的条件概率的数量来讲，也显得太小，这种特点我们称之为数据的稀疏性或者干脆称之为数据量不足。&emsp;&emsp;这种情况即使在今天大数据的时代，依然非常严重。就以腾讯为例，虽然它微信上的数据看似很多，但是如果你真要了解某个人在某个时间段的想法，是无法通过直接的统计做到的。因为某个人在一个时间段可能只发送了几百条微信（这已经很多了），从几百条微信的几千个字里，得不到什么可靠的统计信息。&emsp;&emsp;我们根据前面的经验知道，通常要获得95%以上置信度的统计结果，需要被统计的对象出现上千次，但是如果整个样本只有几千字，被统计的对象能出现几次就不错了。这样得到的数据可能和真实的概率相差很远。&emsp;&emsp;造成这个结果的原因是，当我们要进行多个维度的分析时，几个维度变量的组合可能会有太多的情况，以至于每一种组合摊下来的数据都很小。&emsp;&emsp;那么怎么解决这个问题呢？**我们有两个方法。先讲第一个，古德-图灵折扣估计法，它主要是解决一种被称为零概率的事件。**&emsp;&emsp;我们还是先来看看计算上下文相关性时遇到的零概率问题。我们在前面讲到，“中药”这个词后面跟着“田七”这个词的可能性比较大，如果我们统计足够多的文本，可能会看到成百上千次，于是可以准确估计它的条件概率。&emsp;&emsp;但是“中药”后面跟着“天气”的可能性很小，可能我们统计了10亿词的文本，一次也没有见过，那么我们是否敢说在“中药”条件下，“天气”的条件概率就是零呢？我们并不敢说。过去，人们以为大家讲出来的话，写出来的文字，都符合一些规范，因此有些词的组合就不应该存在。&emsp;&emsp;但是后来人们发现，语言的演变，恰恰是靠将过去认为不可能的组合使用起来所驱动的，比如说今天的很多网络用语过去根本不存在。当它第一次出现时，你不应该将它的概率设置为零。&emsp;&emsp;事实上，如果你把一个10亿词的语料库一分为二，变成A和B两个子集，就会发现很多在A子集中出现的词的前后组合，在B中根本没有遇到，反之亦然。因此我们不能说这种小概率事件的概率等于零。事实上，将小概率事件的概率强制设定为零，结果就是早晚会遇到黑天鹅事件。&emsp;&emsp;这就是黑天鹅事件产生的原因，总的来说，就是我们把那些小概率事件，默认为是零概率事件。**应对办法一：古德-图灵折扣估计法**&emsp;&emsp;那么我们该如何考虑到这些不容易被想到的事件呢？也就是说，如果一个随机事件，我们在统计中没有见到，该如何设置它的概率呢？我们先要来分析一下小概率事件的特点。&emsp;&emsp;我们大家都听说过一个80/20定律，**就是说80%的总量常常是由20%高频率的元素构成的。反过来，80%低频率的元素，或者说长尾的元素，只构成20%的总量。**这个规律，其实是齐普夫定律（Zipf’s Law）的一个特例。&emsp;&emsp;齐普夫（George Kingsley Zipf）是美国20世纪初的语言学家，他经过对各种语言中词频的统计发现，一个词的排位，和它词频的乘积，近乎是一个常数。&emsp;&emsp;比如在汉语中，“的”是最常见的字，排位第一，它的字频大约是6%，于是1x6%=6%。第二高频字是“是”这个字，排位第二，而它的字频大约是3%，恰好2x3%=6%。字频排位第三的字是“一”，它的字频是2%多一点，3x2%也是6%。&emsp;&emsp;后来经济学家和社会学家发现齐普夫定律在他们的学科中也成立，比如你如果把世界上每一个人的财富排一个序，让序号乘以财富的数量，就会发现有类似的规律。今天，齐普夫定律被认为是自然界的普遍规律。我们每一个人都需要牢记齐普夫定律，这样就不会相信所有人都能够通过创业成为富翁这样的鸡汤观点了，因为它违背齐普夫定律。&emsp;&emsp;不仅如此，齐普夫定律在低频词上也有一个出乎意料的特点，就是词频乘以那个频率的词的数量，也近乎是一个常数。比如在一个词汇表中，大量的词只出现一次，但是这些词的总数甚至占到了词汇表的一半左右，然后还有大量的出现两三次的词，总数也不少。&emsp;&emsp;如果我们假定只出现一次的词有N1个，出现两次的词有N2个，出现三次的词有N3个，那么1xN1，和2xN2，3xN3，都差不太多，因为大多数词其实只出现一次。&emsp;&emsp;图灵的一个学生古德，他就想利用这个特点，设计一个办法，把那些黑天鹅事件也考虑到。于是设计了一种对低频随机事件，特别是统计中没有见过的随机事件分配概率的方法。&emsp;&emsp;古德的想法是这样的。假如出现r次的单词有Nr个，那么一个语料库文本中所有单词的总次数就是：<center>C=1xN1+2xN2+3xN3+…..+KxNK</center>其中K是最高的词频。&emsp;&emsp;当然在这个统计中，更重要的是考虑那些原本没被考虑进来的词，这些词在之前的统计中出现0次，其实根本没有被统计进来，我们现在假定这些单词有N0个。这并非代表这些词的频率就该是零，而是统计量不够多，要知道统计量和统计量之外的总量还是有区别的。&emsp;&emsp;古德根据经验，假设N0>N1，也就是说假设那些没被统计进来的词，也可能出现了至少一次，这个假设在计算语言学中是符合实际情况的。&emsp;&emsp;接下来古德就调整不同词的词频。他是这么做的，一个单词如果原来出现了0次，他就把出现的次数调整为 N1/N0次。注意，这是一个0到1之间的数，不再是0了。一个单词如果原来出现了1次，他就把出现的次数调整为 2xN2/N1次，通常这是一个1到2之间的数。&emsp;&emsp;对于一般情况，如果原来出现了r次，就调整为（r+1）xNr+1/Nr次。&emsp;&emsp;古德的做法实际上就是把出现1次的单词的总量，给了出现0次的，出现2次单词的总量给了出现1次的，以此类推。这样，对于低频词，它的频率会被提高一点，对于高频词，会降低一点。用我们过去在微积分中的术语来讲，这样让所有词的概率分布变得更光滑了。&emsp;&emsp;古德的这种做法被称为“古德-图灵折扣估计”，因为它实际上是把高频词的词频打了一个折，多出来的词频分配给了低频词。后来人们对这种分配频率的方法作了一些改进，但是原理和古德的做法大同小异。今天在各种统计中，要想避免零概率事件带来的灾难，都会对统计结果作一次类似的处理。**应对办法二：插值法**&emsp;&emsp;古德的这种方法虽然解决了零概率的问题，但是依然没有解决数据稀疏时，对于小概率事件，概率估计不准确的问题。&emsp;&emsp;**最初解决这个问题的是我的导师贾里尼克，他发明了一种被称为“删除插值”的方法，我们简称“插值法”。**&emsp;&emsp;贾里尼克在对文本统计时发现，当我们在计算条件概率时加入太多的条件，统计的结果就非常稀疏不可靠。这也很好理解，如果我们不考虑任何条件，只统计词频，每个词X其实会出现很多次，统计的结果就比较可靠。&emsp;&emsp;但是，如果我们考虑了上下文信息，比如前面的一个词，我们要计算条件概率P(X|Y)，我们就要按照X和Y所有可能的组合进行统计，由于组合的数量巨大，因此每一种情况看到的次数就少很多。对于频率较低的（X，Y）组合，计算出的概率P(X|Y)肯定不准确。那么怎么办呢？&emsp;&emsp;贾里尼克讲，我把条件概率和非条件概率加起来，得到一个新的概率。当然在相加之前，要分别给这两个概率权重。比如条件概率的权重是0.7，非条件概率的权重是0.3。&emsp;&emsp;这样一来，如果条件P(X|Y)本身比较大，它在新的概率估计中会占主导地位。如果P(X|Y)本身比较小，说明它反正也不太可靠，而这时非条件概率，即P(X)本身则占了主导地位，因为X本身出现的次数会比较多，统计结果可信度会高一些。比如计算“中药”条件下“天气”这个词的概率时，统计的结果就不可靠，我们就降低它的权重，然后用“天气”本身的概率去弥补这一点不足。&emsp;&emsp;插值法的精髓在于，相信那些见到次数比较多的统计结果，如果遇到统计数量不足时，就设法找一个可靠的统计结果来近似。后来又有人进一步改进了插值法，提出了备用法（Back-off）。这里面的细节大家就不用关注了，理解它解决不可靠统计问题的精髓就好。&emsp;&emsp;顺便说一句，**在数学上和信息论上可以证明，无论是插值法还是备用法，都比单纯依靠统计结果直接产生概率模型更准确。****要点总结：**&emsp;&emsp;我们说防范黑天鹅事件，不是停留在嘴上的，数学家们会发明一些方法，让得到的数学模型能够预防黑天鹅事件的发生。比如古德是通过将高频事件的概率分配给低频事件，而贾里尼克则是设计一种组合，让那些更可靠的统计发挥更大的作用，同时降低不可靠的统计结果的影响力。&emsp;&emsp;这两点无论是在科学研究还是在生活中，都是很有效的方法论。很多时候，我们需要像古德那样预防不测，当然凡事都有成本，预防不测的成本在于要降低一些高收益项目的利润。同时，我们也要像贾里尼克那样，永远更多地依赖可靠的统计结果。&emsp;&emsp;到此为止，我们关于概率论和统计的内容就基本上讲完了，在接下来的两讲，我们讲一下从概率论延伸出来的课题——博弈论。我们下一讲再见。</details><h3><span id="43-ling-he-bo-yi-an-dian-li-lun-ru-he-zhao-dao-shuang-fang-de-ping-heng-dian">43 ｜ 零和博弈（鞍点理论）：如何找到双方的平衡点？</span><a href="#43-ling-he-bo-yi-an-dian-li-lun-ru-he-zhao-dao-shuang-fang-de-ping-heng-dian" class="header-anchor">#</a></h3><!-- ![](/images/171.jpg) --><p>你好，欢迎来到我的《数学通识50讲》。接下来两讲，我们通过博弈论中最典型的两大类博弈，也就是“零和博弈”与“非零和博弈”来学习博弈论。</p><details><summary>...</summary>&emsp;&emsp;博弈论也被称为对策论。从它的名称你能猜想到，它应该是研究在竞争中采用什么样的好策略的理论，但是从本质上讲，它是一套解决最优化问题的方法。&emsp;&emsp;但是，它和传统的最优化问题还不一样，那些问题都有着明确的目标函数或者优化对象，而博弈论所研究的最优化问题有两方甚至多方参与，因此最优化的策略要考虑对方的行为。比如下棋时，你不能总想着吃人家的棋子，还要考虑自己是否会被将死。&emsp;&emsp;博弈论通常被认为是冯·诺依曼发明的。他被认为是比同时代的爱因斯坦还聪明的天才。&emsp;&emsp;尽管如此，冯·诺依曼还是没有能完成对博弈论中非零和博弈的分析，是他的学生纳什解决了这一类问题，纳什并因此获得了诺贝尔经济学奖。关于非零和博弈这个难题，我们下一讲再说，这讲先看零和博弈。**零和博弈如何计算？**&emsp;&emsp;所谓零和博弈，就是博弈过程中，一方获利就意味着另一方损失，比如你和朋友吃一张披萨，你多吃一口，他就少吃一口。接下来我们就来看看博弈论是如何解决这类问题的。&emsp;&emsp;我们拿围棋举例说明。为了简单起见，我们就假定X、Y两人下围棋，该X走下一步棋了，他有3种可选的下法。X一方的下法为x1、x2、x3，Y一方的下法也有三种，分别是y1、y2和y3。&emsp;&emsp;在围棋中，一方的所得必然是另一方所失，因此这是一个零和游戏，比如说X走了x1这步棋后，在盘面上的胜率所得是7点，那么Y的胜率损失也是7点。在这样的情形下，我们只要考虑X的胜率变化即可，因为X赢了多少就是Y输的。&emsp;&emsp;我们知道当X采用了x1、x2、x3之中的一种策略后，Y也有相应的三种策略y1、y2和y3，因此它们的组合就有9种结果，就构成了一个3x3的矩阵。在每一个组合中，X有一个胜率的变化，这些变化就构成了矩阵的值：（我们假设这9个结果对应了X能获得的9个分数。）![](/images/172.jpg)在这个矩阵中，你可以看到，当X采用x1策略时，他最好的情况是碰上Y采用y1，这时X的胜率就增加7点，但是如果Y是一个高手，他采用了y3策略应对，你可以看到X的胜率就小了10点。因此X如果考虑到Y可能的应对策略，他就应该知道，x1其实不能算是一步好棋。&emsp;&emsp;相比之下，采用x2策略就稳健得多，因为无论Y如何应对，他至少可以让自己的胜率增加一点。至于x3，因为有胜率减少一点的可能性，也没有x2好。因此，在制定策略时，如果我们不考虑对方的应对，显然x1是最好的，x2是最差的，但是考虑到对方应对的情况，可能最好和最差的策略就反过来了。&emsp;&emsp;具体到博弈这件事，特别是计算机博弈，最通用的策略是，“在对方给我们造成最糟糕的局面里，选择相对最好的”。也就是说，我们要把x1、x2和x3所有策略算出来后，在可能得到的最糟糕结果中进行比较，具体到这个问题，就是-10、1，和-1这三个结果，然后排序找到最大的，那就是1。在计算机算法中，这种策略被称为最小值中的最大值策略。&emsp;&emsp;接下来我们站在Y的角度来看看他的选择。我们假设他先行棋后，胜率变化的矩阵还是上面那个，当然负值表示他的胜率上升。如果他选择y3，虽然可能让胜率增加10点（对应-10那个值），但是，也冒着损失4点的风险。相比之下，y2的选择就比较好，因为最不济也不过让胜率损失1个点。类似的，可以分析出来y1也不如y2。**找到平衡点**&emsp;&emsp;在很多博弈中，比如谈判中，其实是双方同时选择，并非你出完牌以后，我再出牌，这种情况被称为静态博弈。和它相对的是动态博弈，也就是类似刚才说的下围棋的情况，大家交替出招。&emsp;&emsp;**关于静态博弈，我们就可以用上面的矩阵来度量双方的得失。**只要X和Y是理性的人，他们就都会发现，其实矩阵中（2，2）位置的那个点对双方来讲都是可以接受的，因为谁都不敢保证自己得到的结果比选择那个点更好。&emsp;&emsp;如果我们把上面的矩阵画在一个三维的图中，就会发现它是一个马鞍形，而位置为（2，2）的这个点，正好是马鞍点。也就是说，这个点从X的角度看，它是所有最低点中的最高点。从Y的角度看，它是所有最高点中的最低点。X追求数值最大，Y追求数值最小，于是这个马鞍点就是一个平衡点（equilibrium）。&emsp;&emsp;上面矩阵的三维视图不好画，我画一个简单的马鞍图，注意一下上面的红点，那就是马鞍点，或者说平衡点。![](/images/172.jpg)在两方的博弈中，大家其实就是在寻找马鞍点这样一个平衡点，因为大家都知道，如果自己走出了这个平衡点，试图扩大自己的利益，对方就会有反制手段，让自己的利益受损。&emsp;&emsp;当然并非所有的问题里这样的平衡点都在。比如前面那个对弈的胜率矩阵，如果里面的数字都是些很大的正值，也就是说X的实力可以秒杀Y，采用什么策略可能Y都无法应对，这种情况其实不用担心。但是当参与方的水平势均力敌，不相上下时，很多时候寻找最小值中的最大值才是最好的出路，或者说其实双方必然会被锁死在那个平衡点上。&emsp;&emsp;但是，我要特别提醒你的是，在上述的对弈问题中，还有两点需要说明。- 首先我们其实作了一个隐含的假定，就是双方下棋的策略都是透明公开的，即X和Y都知道对方所有可能的选择，也就是说一切是阳谋，不是阴谋。双方所不知道的，无非是对方最终采取的策略。- 其次，双方都足够精明，能够判断出该采用什么策略。不过在真的下棋时，更可能是另一种场景，一个臭棋篓子看不出隐藏得比较深的好棋，会采用比较糟糕的策略，而高手在掂量出对方水平之后，会采用比较激进的下法，每一步占最大的便宜。这种情况，其实就是将对方采用各种策略的概率考虑进去了。&emsp;&emsp;我们还是以上面例子的胜率矩阵来说明问题。假定X知道自己行棋后，Y采用y1、y2和y3策略的概率分别是70%、20%和10%，这时他采用x1的下法反而是最好的。当然，如果是Y先行棋，他可能也会根据X采用不同策略的概率，制定自己的策略。&emsp;&emsp;在静态博弈中有一种非常有趣的情况，那就是双方都知道对方采用各种策略的可能性，这时双方要重新计算平衡点，而这个平衡点和矩阵中的马鞍点未必相同。**多人博弈的投篮问题**&emsp;&emsp;由于人们通常在讲博弈论时所举的例子，都是两个人博弈，各自寻找最佳策略的场景，因此很多人误以为博弈论所要解决的只是这一类问题。**其实，博弈论研究的问题有很多种类型，比如我们来看看下面这个问题，它也被称为投篮问题。**&emsp;&emsp;我们假定有10个选手投篮，投篮的准确性和投手到篮筐的距离有关，离得越近投中的概率越大，最后如果站到篮下，命中率是100%。&emsp;&emsp;比赛的规则是这样的。第一个选手站的位置离篮筐9米，如果他投进去了，比赛结束，他就是赢家；如果没有投进去，第二个人在8米处投篮，如果他投进去就赢得比赛，否则就由第三个人在7米处投篮，这样投下去，直到有一人投中成为赢家。&emsp;&emsp;现在的问题是，你如果参加比赛，该第几个出场？这也是一个博弈论的问题，至于该第几个出场，其实是要看命中率和距离之间的关系。&emsp;&emsp;比如，我们假设它们的关系是这样的：投篮的命中率就是距离加1的倒数，比如第一个人站在9米处，他投中的概率就是1/（9+1）=1/10，第二个人站得更近，所以投中的概率就是1/（8+1）=1/9。类似的，第三个人是1/8，最后一个人是1。你如果这么单纯比较命中率，似乎是最后一个人占便宜。但其实在这种条件下，所有人命中赢球的可能性都相等，都是0.1。&emsp;&emsp;计算这个问题，就要用到我们前面讲到的条件概率了。我们以第二个人为例，他获胜的可能性是：首先第一个人没有投中，其次，他投中了。因此，计算获胜的概率=他的命中率*第一个人失败的概率，即1/9x0.9，还是1/10。类似的，大家可以算出来每个人获胜的概率都是1/10。&emsp;&emsp;这个问题的一个典型例子就是抽签。很多人觉得，如果10个人抽一个大奖，先抽签的人吃亏，因为抽中的概率很小，等到前面那些人没有抽中出局了，我再抽，就不是10抽1，可能是5抽1，甚至是3抽1了。但是这些人只考虑了别人没抽中的情况，忽视了可能奖品已经被抽走的可能性。&emsp;&emsp;当然，在另一些距离和命中率的关系里，结果可能就不同了，比如命中率是距离加1的倒数的平方，这时可以证明，最后一个出场的人获胜的概率最大。&emsp;&emsp;在职场中，什么时候站出来讲话，什么时候站出来接受任务，其实也是有讲究的。站出来太早，可能会失败，站出来太晚，可能别人已经把事情做好了。对我们来讲，最好的情况是，前面有几个人做失败了，而我们临危受命成功了。这其实就是投篮问题的具体应用。**要点总结：**&emsp;&emsp;首先，虽然每一个人都希望最大化自己的利益，但是更有意义，更能保证自己利益的，是达成各方面的平衡。在选择策略时，不要老考虑对自己有利的情况，而低估对手可能的策略，要多考虑下行风险，要在所有的最小值中，寻找最大值。在出手做事情时，包括创业时，要根据任务的难度，把握好承担任务的时间。开始的时候失败率高，太晚的时候已经没有了机会。&emsp;&emsp;在有博弈论之前，很多人对这些道理有感性的认识，但是不准确。有了博弈论，将上述问题量化建立数学模型，就有了理性的指导，这便是博弈论的意义。&emsp;&emsp;下一讲，我们来讲博弈论中的大难题，非零和博弈。</details><h3><span id="44-fei-ling-he-bo-yi-na-shi-jun-heng-zhen-de-cun-zai-gong-ying-ma">44 ｜ 非零和博弈（纳什均衡）：真的存在共赢吗？</span><a href="#44-fei-ling-he-bo-yi-na-shi-jun-heng-zhen-de-cun-zai-gong-ying-ma" class="header-anchor">#</a></h3><!-- ![](/images/174.jpg) --><p>&emsp;&emsp;我们上一讲讲了零和的博弈，其核心就是找到平衡点。今天我们来谈谈更难的一类博弈，非零和博弈。</p><details><summary>...</summary>&emsp;&emsp;很多人觉得，如果两个人分10000元的利润，各自拿了5000元就是双赢，这是一个对零和博弈的误解，也是对双赢的误解。&emsp;&emsp;事实上，所有零和博弈，都没有双赢的可能性，只有平衡的可能性。今天媒体上常常喜欢用“双赢”这个词，其实它们所说的双赢，90%以上的情形都是达到平衡而已。但是，非零和博弈则可能实现双赢。**双赢到底存在吗？****那么什么是非零和博弈呢？就是双方的得失加起来不是零，也不是个常数的博弈，**我们先来看一个著名的例子——囚徒问题。&emsp;&emsp;囚徒问题讲的是这样一件事，假设有两个罪犯X和Y，他们一起做案被抓住，接下来要定他们的罪。为了防止两个人串供，警方将两人分开审讯。如果两个罪犯都认罪，那么由于认罪态度好，刑期不重，只有5年。如果一个罪犯认罪，另一个抵赖，认罪的那个检举有功，无罪释放，而后者态度恶劣，判10年。还有最后一种情况就是，如果两个人都不认罪，两人都判一年。&emsp;&emsp;下表给出了在这个博弈中双方的收益矩阵。由于他们的“收益”是刑期，因此我都用负数来表示。接下来的问题是，X和Y应该选择认罪还是抵赖？![](/images/175.jpg)&emsp;&emsp;根据我们上一讲的分析，每一个人要找出对方给自己造成最糟糕情况里的相对好的情况，也就是最小值中的最大值。&emsp;&emsp;以X为例，他要考虑Y可能的策略。如果Y选择认罪，那X最好的情况是判5年，最坏的情况是判10年。如果Y选择抵赖，X不管怎么选择，最坏的情况不过是被判一年，比前一种情况好。因此，根据挑选最坏中的最好的原则，就是考虑到Y会认罪，而他的策略就是也认罪。类似的，Y也应该这么思考，于是他也会选择认罪。这样，双方都认罪就是上一讲提到的平衡点，都被判刑5年。&emsp;&emsp;由于非零和博弈的平衡点问题最早是被纳什解决的，因此它也被称为“纳什均衡点”，它就相当于我们上一讲在零和博弈中讲到的马鞍点。在这种非零和博弈难题中，找到纳什均衡点就是最安全的解决办法。&emsp;&emsp;讲到这里，你可能会说，不对啊，这个问题不是还有双赢的结果么？两个人都抵赖，不就是双赢么？这个说法没有错，但前提是双方要有默契，相互配合。如果一方不配合，对方就会有很大的损失。&emsp;&emsp;因此，双赢点是大家主观上想达成的目标，但现实中客观的结局常常是纳什均衡点，也就是双输的结果。实现双赢的前提是彼此有信任，这种情况下的博弈，也被称为合作型博弈，而之前纳什解决的是非合作博弈。&emsp;&emsp;囚徒问题在冷战时被战略家们用来说服美苏双方裁减核武器。我们可以看这样一个场景，如果一方发展核武，对方不发展，发展核武的一方虽然花点钱，损失是1，但是对方受到制约，损失是10。如果双方都发展核武搞军备竞赛，那么成本高，损失大，都损失5，但是这时双方形成了一种均衡。&emsp;&emsp;在冷战时，美苏双方采用的就是这种策略。但是，如果双方能有信任，一同销毁核武，那么就会形成双赢。冷战最后的结局也是如此，美苏双方都不再建造新的核武器了。因此，囚徒问题一直被用来证明双赢的可能性。&emsp;&emsp;想在现实中找均衡点，你得记住这五条：&emsp;&emsp;但是，在现实生活中，双赢的可能性远比大家想象的小很多，因为双赢点在数学上根本不是均衡点，它严重依赖于玩家的表现，玩家通常做不到相互信赖。这里面重要的原因至少有下面五个：- 博弈通常不是一次性的，而是反复进行的，长期坚持信任几乎做不到，而一旦一方开始采用不合作的策略，给对方造成巨大损失，对方也会马上调整策略。- 博弈论讲的都是阳谋的策略，但是很多时候双方博弈使用的是阴谋。使用阴谋就无法让双方产生信任，而没有信任，均衡点就是双输。一战后美国总统威尔逊在总结大战爆发的原因时发现，秘密外交，搞阴谋是个重要的原因，因此他努力推动国际联盟，目的就是把阴谋变成阳谋。- 人类还处于文明的初级阶段，人的道德水准不容高估，很多人并非在主观上想做违反规则的事情，也懂得双赢的道理，但是就是看不惯别人和自己一样好，更不能容忍别人比自己好，于是当他们看到能够在自己损失1，让对方损失10的情况发生，完全干得出这种事。- 乌合之众效应。如果是两个人博弈，很容易达成双赢的结果。如果是两个由帮主说了算的帮会，或者独裁国家，这种事也不难做到。但是在两个民主国家之间，或者两个权力分散的机构之间，这种事情就很难达成。世界上有些重大事情，大家都很清楚双赢的点在哪里，比如全球贸易、均衡发展、消除贫困和疾病，但是在这方面很难达成一致，而且就算短期达成一致，各方也很难遵守。原因是博弈的各方不是一个人，而是每一方自身内部有各种利益冲突。比如说经济全球化，就意味着一些国家必须放弃一些产业，而那些相关的产业工人就会牵引政客们偏离共赢点。- 很多时候看似是双赢，其实是在更大范围内通过零和博弈获利。信息时代针对员工的期权制度便是如此。在之前分配利润的工业时代，劳资双方是零和博弈，因为一方多拿点，另一方就要少一点。但是当下很多企业，通过给员工发放股票期权，只要把企业业绩做上去，期权会自动给员工带来巨大的收益，不用分配利润。这看上去是一个双赢的结果。但实际上它们和资本市场，包括股民，玩的依然是零和博弈。**我是怎么用博弈论的？**&emsp;&emsp;理解了零和博弈的这些特点，特别是双赢极其难以达成，并且长期遵守这个事实，我们就可以制定自己感觉舒服，利益得到保障的策略了。大家看我给双赢泼了这么多的冷水，可能会怀疑我是否相信双赢的存在，并且以达成双赢为目的。事实上我是非常喜欢双赢的，并且经常能够和周围人达成双赢。接下来我就分享一下我的体会。&emsp;&emsp;**首先，也是最关键的，就是找好你博弈的对象，这里面我说的博弈更多的是合作，不是竞争。**我在《硅谷来信》以及在给女儿们的信中反复讲，我对任何人第一次都会相信他们是诚实的，也就是说愿意合作。但是对方只要做一次不诚信的事情，我会永久性地将这个人删除，因为只有在一个合作的环境中才有双赢的可能性。我们不能保证每一个人都是能够达成双赢的对象，但是我们可以选择和谁玩。&emsp;&emsp;很多人会说，如果在某个特定情况下，那个不诚信的人会在某次给你输送巨大的利益，或者提供很多帮助呢？我的结论是，依然不要来往，因为轻易破坏自己的原则，就如同破坏几何学公理一样问题严重。&emsp;&emsp;我从个人生活，到工作，再到这种活动，与合作者通常都是十几年甚至几十年的关系，他们并非完美，但是满足我能达成双赢的条件。很多人找上我，说我们能提供更好的条件，我都一一回绝，背地里的原因是，我在验证了那些人是可以达成双赢的人之前，不会把他们请进我的牌局。&emsp;&emsp;**其次，永远不要玩难以达成双赢的游戏，因为出来混总是要还的，人不可能永远在零和博弈中占别人的便宜。**&emsp;&emsp;大家听了我这段评论，可能会觉得这是我过去《硅谷来信》的风格，不像是在讲数学。实际上我们以通识为目的讲数学，就是要学习用主人的态度掌握里面的方法精髓，加以利用。**智猪博弈给我们哪些启示？**&emsp;&emsp;事实上博弈论对大部分人来讲就是明白博弈和合作的道理，而不是解数学题。博弈论也是一个工具，它能够解释我们看到的很多现象，比如用纳什“智猪博弈”的例子，就能解释为什么一个落后地区的起步总是先要从模仿做起。当初的日本、韩国和台湾地区，以及最近几十年的中国，都是如此。“智猪博弈”讲的是就是这样一种情形：&emsp;&emsp;假设猪圈里有一只大猪和一只小猪。在猪圈的一头有猪食槽，另一头有一个按钮。按一下按钮，机器立刻会往食槽里倒进10磅猪食。但是，猪每按一次按钮，就要付出消耗2磅食物的成本，而且如果一只猪跑去按按钮，转身再去食槽，一些猪食就会被另一只猪抢先吃掉。&emsp;&emsp;如果大猪去按按钮，因为小猪会等在食槽，它只能吃到6磅食物，小猪吃到4磅；反之，如果小猪去按按钮，等它转身回来时，大猪会吃掉9磅食物，小猪只吃到1磅；当然，两只猪可以同时按，然后转身去吃，这时大小猪各能吃到7磅和3磅。那么两只猪的策略应该是什么样的呢？我们之所以称这两只猪为智猪，是假设它们能算得清账。那结果是怎么样的呢？![](/images/176.jpg)&emsp;&emsp;「我们把大猪和小猪采用不同策略后的收益总结在下面的表格中，听音频的朋友可以扫一眼文稿中的表格。在表格中，竖着的是大猪的策略，横着的是小猪的策略，每个单元里第一个数值是大猪的收益，第二个是小猪的。&emsp;&emsp;从表格中可以看出，如果大猪去按按钮，小猪如果也去按，那么它能吃到7磅，扣除了两磅的成本，净赚5磅。类似的，小猪在扣除成本后，净赚1磅。这就是第一个单元里两个数值的含义。从第一行的数值可以看出，不讨论小猪采用什么策略，它至少可以获得4磅的收益。&emsp;&emsp;相反，如果它在食槽旁等待，虽然有可能获得9磅的收益，但是可能小猪也在等，结果双方所得都是零，时间一长就会因为吃不到东西而饿死。因此，大猪的最小值中最大值的策略是按按钮。相反，你仔细分析一下，小猪的策略则是应该在食槽旁等待。这样的结果能达到一种双赢，而且恰好是双方博弈的均衡点，因此它是稳定的。这就和前面讲的囚徒问题有所不同了。」&emsp;&emsp;智猪博弈的结论就是，小猪应该等在食槽旁静静等待，如果用在管理学和商业上，就是鼓励小企业和后来者采用搭便车式的跟随策略，而不是投入大量的金钱进行研发。因为如果小企业投入大量资金得到新技术，而大企业也享用技术并利用体量优势竞争，小企业就要垮台。&emsp;&emsp;因此，强调知识产权和专利保护的人，常常用这个例子说明问题，因为没有对知识产权的保护，小企业就不会有活力，从长远来讲，就永远是大企业垄断。&emsp;&emsp;到此为止，我们关于博弈论的内容就讲完了。这些理论可以成为我们的行动指南，但是大家在使用时，千万记住不要生搬硬套，毕竟现实世界的博弈比那几张表格复杂得多。&emsp;&emsp;下一讲，我来回答大家在这个模块的疑问，同时依旧放出五道测试题，率先给出全部正确答案的5位同学，可以得到99元得到贝的奖励，正确答案会在课程结束时公布。我们下一讲见。</details><h3><span id="wen-da-dao-di-ru-he-you-xiao-shai-xuan-shu-ju">问答 ｜ 到底如何有效筛选数据？</span><a href="#wen-da-dao-di-ru-he-you-xiao-shai-xuan-shu-ju" class="header-anchor">#</a></h3><!-- ![](/images/177.jpg) --><p>这一讲回答概率、统计和博弈论模块，大家提出的问题以及再发布五道测试题。</p><details><summary>...</summary>**周周**>吴老师，博弈论好像有个前提，博弈的双方必须是理性人或者是聪明人。但是您讲，现实中很可能是一个高手和一个臭棋篓子下棋，然后每一步都占便宜。那这种一方不聪明的情况，还算博弈吗？现实中该怎么考虑这种对手非理性的情况呢？**吴军**&emsp;&emsp;严格来讲，这也算是博弈。&emsp;&emsp;我们在课程中重点讲了对方能够看出好棋的情况，而没有花太多时间讨论如果对方是臭棋篓子的情况。在后一种情况下，我们做更多一点的说明。&emsp;&emsp;我们不妨假定对方有10种策略，从1排到10。&emsp;&emsp;如果你知道对方最好的情况，也就是想到从1到5这五种情况，6到10以他的水平想不到。假定你有两类策略，一种是在对方采用1到5的情况下你会打赢，而万一对方想到了6到10的走法，就会吃亏。第二种是无论对方采用1到10哪种策略，自己既不会大赚，也不会吃大亏。&emsp;&emsp;一个职业棋手遇到业余棋手，可能就采用第一类策略了，三下五除二解决问题。但是他遇到一个同样水平的职业棋手，就不敢这样了。这类的情况在体育比赛中很常见，比如乒乓球、网球或者羽毛球比赛，前两轮种子选手只进攻不防守，以最短的时间拿下比赛，节省体力。&emsp;&emsp;但是无论是下棋，还是竞技场上的比赛，这种行为常常是被爆冷门的原因。&emsp;&emsp;从数学上分析，制定最好的策略，是要考虑到对方采用每一种策略的概率，而不是简单考虑对方一定会采用对自己最不利的策略。**小白**>吴老师好，您在讲零和博弈时，讲了两方博弈比如下围棋，也讲了多方博弈，比如打篮球。那么这两种博弈之间又有什么区别与联系呢？谢谢老师。**吴军**&emsp;&emsp;从数学上讲，它们是等价的。我们把多个人投篮球的例子简化为抽签，每个人中签的概率都是1/N，这时你有两种考虑问题的方式。一个是把每一个人当作博弈的一方考虑，这就是一个多方游戏。你的策略有N种。分别是选择在第一个，第二个，直到第N个时刻出场。第二个，是直到第N个时刻出场，每一种情况，都会涉及到其它N-1个人具体谁在哪个时刻出场了，这种情况极为复杂。&emsp;&emsp;当然你可以单独计算其他N-1个对手放在一个大篮子里，只要他们中有一个人中签了，那个大篮子就中签了。在这种情况下，你来制定你的策略，这就相当于两个人的博弈。至于哪些人之间的博弈，你可以用同样的方式进一步拆分。&emsp;&emsp;但是由于在博弈论中很多结果有发生的概率，而概率这件事只是估计出来的，并不准确。因此，一旦加入博弈的选手多了之后，不确定性会大大增加，严重影响结果。&emsp;&emsp;另外要注意的是，在非零和博弈中，两个人的博弈和多个人的完全不同。最典型的例子就是，两个人闭门谈利益，能够谈成，但是你如果想先说服一些同盟者，然后再一起和对手去谈判，几乎永远达不成协议。**Allelujah 朱磊**>老师好。请问通过增加试验次数统计出概率，和老师之前讲到的“数学不能测量”有矛盾的地方吗？**吴军**&emsp;&emsp;不矛盾，因为它们讲的不是同一回事。&emsp;&emsp;切比雪夫大数定理讲的是这样一回事，如果通过“很多次”试验，得到的统计结果，即一件事发生的次数除以总的试验次数，不断地收敛，我们把每次试验后得到的这个比值看成一个序列。&emsp;&emsp;在数学中，一个序列收敛，是指它最后会趋向于一个有限的数字，这个有限的数字是客观存在的。在概率论中，显然这个数是局部和整体的比值，在0到1之间。既然存在这样一个数，我们就可以用这个数作为相应的随机事件的概率。&emsp;&emsp;从切比雪夫定理的表述你可以看出：1.最后的极限存在；2.试验次数多了之后，结果趋近于那个极限。如果你回想我们在前面介绍的序列的极限的定义，就会发现它们讲的是一回事。这里面并不涉及如何做试验，测定概率。**日积月累**>吴老师，以前人们做试验，受到资金技术等限制，样本量都太小，方差（误差）很大。而现在，我们已进入了网络时代，数据规模出现了井喷，采集各类信息就变得唾手可得。可新问题也随之出现：民众的网上行为普遍更极端、更随性，与他们在真实社会中的言行是大相径庭的。我想请教吴老师的是：到底应该如何有效筛选数据呢？**吴军**&emsp;&emsp;以前使用数据有两个问题，一个是数据量不够，另一个是用于寻找统计规律的数据不具有代表性，比如我在《智能时代》一书中所举的盖洛普和《文学文摘》预测美国总统大选结果的例子，后者虽然数据量大，但是选择的数据不具有代表性，结果就有很大的问题。大数据显然解决了第一个问题，对于第二个问题，则要分具体问题来看待。&emsp;&emsp;大数据除了数据量大以外，还有两个重要特征，一个是数据的完备性，也就是说反映你所有寻找的统计规律的数据是存在的；另一个是非刻意收集的自然数据，比如你在社交网络上发表的意见就是这一类的，而接受电视采访时讲的话就不是了。&emsp;&emsp;从理论上讲，有了这两条保障，使用大数据时不需要作太多的筛选，它能得到什么规律，就反映什么规律。但是，在现实中，第二条未必能做到，这就是你说的人在真实生活中的言行，和他们清楚了自己的言行会受到关注时的表现明显不同。&emsp;&emsp;在大数据出现的早几年，大家并没有意识到这些问题，以为数据量大必然有很多具有代表性的数据。但是近年来大家发现问题远没有那么简单，比如美国发现社交网络上的意见常常被机器大量产生的帖子所左右（类似中国所说的“水军”）。&emsp;&emsp;这是人为有意的干扰，还有很多干扰是无意的，比如Google的AlphaZero（阿尔法元）发现，人类几千年来下的围棋在方法上就错了，那些对弈的数据其实没有什么价值，不用那些数据，由计算机自己产生数据，反而更好。有效筛选数据有三个原则：- 过滤噪音，提高信噪比，甚至干脆丢弃信噪比较低的数据。- 舍弃那些可信度不高的信息源。比如我们在Google做计算机自动问答时，就发现那些八卦杂志，比如著名的《人物》杂志，内容的可信度就极低。判断信息源的可信度，常常要看谁来使用（引用）那些数据，比如我们在寻找医疗数据时，就要看那些医学院教授们引用谁的数据。- 一致性验证，就拿你说的社交网络上的言论来讲，如果一个人在不同场合说的话颠三倒四，你可以认为他是在胡说，这种数据就要删除。阿里巴巴等公司利用人在不同场合的行为，发现了很多不一致性，它们会认为这些人所表现出来的信用不具有说服力。&emsp;&emsp;总的来讲，虽然有了大数据，目前大家发现依然需要像过去那样把控数据的质量，否则就是垃圾进去，垃圾出来。**涂防晒霜的番薯叶**>我有一事一直不明白，有关数学的公理化。比如概率的三条公理，几何的五条公理，为什么选择这几条而不是别的几条作为公理？如何保证这三条能把概率这个数学分支体系所有应该“公认的理”都表达清楚？**吴军**&emsp;&emsp;这是一个很有趣的问题。简单地讲，几何学为什么选择那五条公理，而不是别的，是因为欧几里得等人发现选了这五条，之前发现的所有几何学规律都能够用逻辑推导出来，如果选了别的，就不能。这个过程当然不是一天完成的，甚至可能不是欧几里得一个人完成的，而是很多代数学家不断尝试，最后在欧几里得手里完成的。&emsp;&emsp;如果我们换一个角度来看这个问题，我们站在上帝的角度，要想构造一个数学体系，我们该怎么办？我们一定要选定一些互相不重复，也不会矛盾的公理作为基础。当然，既然是公理，就不能由其它的结论推导出来。满足了这些条件，上帝就选了一些公理，也就构造出了某个数学体系。当然，我们通常是先看到数学规律，再试图还原上帝的想法。对这个问题，我还需要补充两点。- 如果胡乱构造一些所谓的数学公理，可能什么有价值的结论都得不到。- 在一些数学体系中，一些很基础的结论有很多种等价的表示方法，其中一个作为了公理，就能推导出所有其他的。但是必须要确定一个作为公理。&emsp;&emsp;不同的数学家会有不同的看法。最典型的就是所谓实数连续性（也称为完备性）公理，它有很多种表述，每一个其实都可以作为公理，但是通常我们把戴德金的表述作为公理，剩下来的七个等价的表述作为定理（即确界存在定理、单调有界定理、有限覆盖定理、聚点定理、致密性定理、闭区间套定理和柯西收敛准则）。&emsp;&emsp;好，以上就是我对这一模块问题的回答。**吴军**&emsp;&emsp;最后，我又给大家出了五道测试题，和上次一样，率先全部答对并给出简要解题过程的五名同学，将得到99元得到贝充值奖励。答案和中奖名单，在课程结束时公布。祝答题顺利，也欢迎转发给你的好友，一起答题。**测试题**前1~5题回顾：34｜微积分到底是谁发明的？**问题6（三门问题）：**三扇关闭的门后面一扇有一辆汽车，另外两扇门后面则各有一只山羊。你可以选定一扇门，门后的礼物就是你的了，当然由于汽车比山羊值钱，你希望获得汽车。在你开启选定的门之前，主持人开启剩下两扇门的其中一扇，露出其中一只山羊。然后，主持人问你，要不要换另一扇仍然关上的门。你应该如何选择？**问题7（Google的面试题）：**有一个餐馆，每天给就餐的顾客随机发12星座纪念卡，收集齐全部12张，就可以获得500元就餐代金券，小明每次去吃饭花100元。请回答：平均来讲，他要去多少次，才能把12张不同的纪念卡收集齐（也就是天数的数学期望值）？如果要保证99%的可能性把所有的卡收集齐，大约需要去多少次？**问题8（线性规划问题，线性代数+最优化）：** A公司有100名员工，年底要给每人发一个纪念品。有两种选择，保温杯和充电宝，价格分别是120元和100元。公司规定拿充电宝的人数必须大于拿保温杯的人数的两倍减去十人。这个公司在礼品上最多花多少钱就足够了？**问题9：**小明想了一个在赌场肯定能赢钱的方法。我们假设赌局很简单，就是猜大小，猜中了就赢回一倍的赌注，赌局是公平的，而且赌场不收手续费。小明的策略是这样的：&emsp;&emsp;第一次押1块钱，如果赢了，结束赌局走人。如果输了，第二次押两块钱，如果赢了，他将获得2元，扣除第一次输的1元，还赢1元，这时离开。如果再输了，第三次押4元。总之如果输了每次翻番下注，直到赢钱的那一次（即只要赢钱就离开）。由于庄家总是赢钱的概率是1/2*1/2*1/2 *……是趋近于零的，因此小明必定有一次赢钱，并且赢得最终的赌局。这种方法可行吗？请分析原因。**问题10：**给你一副牌，随意抽五张，是同一种花色的概率是多少？如果你手上有四张是同一种花色，另一张是其它的花色，扔掉那一张，再抽一张能够凑成同花的概率是多少？</details><h2><span id="mo-kuai-qi-shu-xue-de-ji-chu-zuo-yong">模块七 ｜ 数学的基础作用</span><a href="#mo-kuai-qi-shu-xue-de-ji-chu-zuo-yong" class="header-anchor">#</a></h2><h3><span id="45-shu-xue-he-zhe-xue-yi-tou-yi-wei-de-liang-men-xue-ke">45 ｜ 数学和哲学：一头一尾的两门学科</span><a href="#45-shu-xue-he-zhe-xue-yi-tou-yi-wei-de-liang-men-xue-ke" class="header-anchor">#</a></h3><!-- ![](/images/178.jpg) --><p>在最后一个模块里，我们讲述数学和其它知识体系的关系，看看如何通过学习数学帮助我们了解其它学科和知识体系。</p><details><summary>...</summary>**为什么数学是“有底”的学问？**&emsp;&emsp;我们常常讲科学是没有穷尽的，这有两方面的含义。一方面，我们对科学的了解是越来越多，因此认知没有穷尽；另一方面，无论是在物理、化学还是在生物，随着我们了解的深入，这些学科的基础也越挖越深，往下的研究也越精深。&emsp;&emsp;比如，人类通过布朗运动了解了分子之后，又了解了原子、夸克，希格斯玻色子等等，这些是不断往下的过程。&emsp;&emsp;但是数学则不同，我们对它的了解也是越来越多，但它的基础却并不会越挖越深。一个数学的分支，其基础一旦建立起来，就几乎不会改变了。比如，今天，我们不可能在几何公理之下，再建立更深的基础。也就是说，数学已经到底了。&emsp;&emsp;数学的这个特点，我们称之为“止于公理”，你可以把公理理解为“上帝的禁区”，公理就是最底层的基础，在公理之上，数学完全是理性的。但有趣的是，理性的数学家们对公理的态度，更像是一种信仰。&emsp;&emsp;这一点反倒是和哲学有很大的相似性，因为哲学也是建立在对世界本原认识的基础之上的，可以说是高高在上的学科，数学如果是最基础的学科，哲学就是最顶头的学科，我们这讲就看看这一头一尾两门学科的互动关系。&emsp;&emsp;数学如何影响哲学？&emsp;&emsp;今天世界上完善的、能够自洽的哲学体系，大多诞生在科学启蒙时代之后，而这不得不感谢使用了数学的思维，其中最有代表性的人物是笛卡尔和莱布尼茨，他们的哲学体系，虽然大家未必赞同，但是都不得不佩服其完备而前后自洽之处。&emsp;&emsp;事实上，这两位学问大家在哲学上的名气一点不亚于他们在数学上的。他们的思想，特别是笛卡尔，在今天对人类都依然有巨大的影响。我本人也自觉地从笛卡尔那里得到了很多的智慧。接下来我们就来说说他们的哲学思想，特别是如何受益于数学的思维。&emsp;&emsp;我们先来说说笛卡尔。笛卡尔最有名的著作是《谈谈方法》，我在《科技史纲60讲》中讲了他的科学方法论对人类科学进步所产生的重大影响，这里就不再赘述了。在认知层面，笛卡尔回答了两个问题，首先是人是如何获得知识的，其次是人能否通过自身努力获得知识。&emsp;&emsp;在笛卡尔的时代，人们通常认为知识来源于上帝的启示，或者生活的经验。前者我们今天都知道听起来就很荒唐，今天已经没人相信了，我们就不多说了。对于后者，这其实是我们今天所说的直接经验的来源。&emsp;&emsp;但是，靠经验的积累有两大问题，一个是来得太慢，这还不是最要命的，更糟糕的是直接经验常常是不可靠的。&emsp;&emsp;比如你看到太阳东升西落，直接的经验就告诉你它是围绕地球转动的。你看到鸟振动翅膀可以飞翔，就本能地要设计能够振翼的飞机。你想到人通过推理下围棋，就试图模仿人建构人工智能。今天我们知道这些都是很荒唐的。但是直接经验常常会得出这样的结论。&emsp;&emsp;那么怎么解决这个问题呢？笛卡尔的贡献在于，告诉人类要通过理性过滤直接经验，然后才能获得知识。这句话的另一种表述就是通过理性的推理，实现去伪存真。&emsp;&emsp;笛卡尔所说的理性可以分为两个层面，第一个层面是今天所谓的实证，这是今天科学研究的基础方法。但是，笛卡尔认为这还很不够，因为实验看到的可能只是表象，因此还需要有第二个层面的理性，就是要用符合逻辑的数学的方法，代替依靠测量的物理的方法，获得真知。我们前面讲到，不能用测量的方法证明勾股定理，这便符合笛卡尔的思想。&emsp;&emsp;当然，依靠理性获得新知的前提是人能够具有理性。笛卡尔在哲学上的另一大贡献在于他肯定了人生而具有理性，并且有能力利用逻辑进行推理。因此，笛卡尔认为，人只要把自己的工作方法由简单的依靠经验，上升到理性思考，就能创造出新知。&emsp;&emsp;后来，亚当·斯密把这个假设又推广到了经济学领域，它最基础的假设就是，人能够通过计算和推理，清楚自己的利益所在。&emsp;&emsp;虽然笛卡尔自己没有发现多少自然科学的新知，但是后人遵循他这种哲学思想做事情，就使得科学获得了极大的发展。我们下一讲在讲数学和自然科学关系时还会讲到，牛顿和麦克斯韦等人在物理学上的成就，更多地依赖于数学上的推导，而不是单纯的实验。&emsp;&emsp;这种依靠理性或者说数学逻辑获得自然科学知识的做法影响深远。当然，今天有了大数据，我们有可能通过不同维度回望一个事物，起到去伪存真的作用，而不是仅仅靠人的理性。&emsp;&emsp;接下来再讲讲莱布尼茨的哲学思想。如果说笛卡尔的哲学思想是介于唯物论和唯心论之间的，那么莱布尼茨的思想则是彻底唯心的。因此，我们不多介绍他的哲学思想，只介绍他的哲学思想中和我们数学课程相关的两个要点。&emsp;&emsp;第一个是相对的因果时空观。在莱布尼茨之前的伽利略，以及和他同时代的牛顿，都认为时间和空间是绝对的。但是莱布尼茨却认为只有上帝是绝对的，时间不可能有绝对的先后，但是有前后的因果关系。&emsp;&emsp;比如你不可能穿越回清朝，这样就会出现先有你还是先有你爸爸的矛盾。只要不违反因果关系，时间是可以拉长或者缩短的。这其实是把数学上的因果关系拓展到了哲学层面，当然后来爱因斯坦提出相对论，证明相对的因果时空观，要比伽利略和牛顿的绝对时空观更合理一些。&emsp;&emsp;第二个是对离散的世界的理解。虽然莱布尼茨同牛顿一起发明了微积分，他承认世界的连续性，但是，他一生致力于用离散的方法来解决问题和解释世界，从二进制，到他的符号学，再到他的物质四特征（即不可分割性、封闭性、统一性和道德性），都说明他对世界离散，不连续的看法。&emsp;&emsp;从世界的离散性假设，利用数学上的逻辑，莱布尼茨得到了很多有趣的结论。他的这些思想启发人们发明了离散数学和量子力学。&emsp;&emsp;无论是笛卡尔，还是莱布尼茨（以及很多大学问家），其实都是用到了数学中建立公理化体系的方法，建立自己的哲学体系，而那些数学方法，一旦上升到哲学层面，就成为了在认知上通用的方法，并且对世界形成了更大的影响力。&emsp;&emsp;莱布尼茨讲：“精炼我们的推理的唯一方式是使它们同数学一样切实，这样我们能一眼就找出我们的错误，并且在人们有争议的时候，我们可以简单地说，让我们计算，而无须进一步地忙乱，就能看出谁是正确的。”&emsp;&emsp;从笛卡尔和莱布尼茨开始，就进入到了理性时代，这种趋势，直到19世纪末，叔本华和尼采等人在哲学上开始质疑纯粹理性为止。因此，如果我们说数学透露了一种哲学之道，是不过分的。&emsp;&emsp;哲学对数学的影响是什么？&emsp;&emsp;讲完了数学对哲学的影响，我们再说说哲学对数学的影响。&emsp;&emsp;在历史上，缺乏哲学修养的人，学习数学最好的结果，也只能成为一般的数学工作者，成不了数学大家。我在《文明之光》中花了整整一章的篇幅介绍牛顿对思想的贡献，今天又讲了作为哲学家的笛卡尔和莱布尼茨。&emsp;&emsp;此外，像费马、希尔伯特等在历史上占有重要地位的数学家，都是有着深厚哲学修养的人。虽然他们并没有专门的哲学著作，但他们的哲学理念已经深深地烙入其数学成果之中。&emsp;&emsp;为什么哲学对数学（和自然科学）这么重要呢？因为哲学讲的是关于宇宙万物的本质，它们之间最普遍、最一般的规律，以及整个宇宙的统一。套用《西方哲学史》一书的作者罗素的观点，整个德国古典哲学，就是试图构建位于科学和其他知识之上的大一统体系，形成一个没有矛盾的知识体系。&emsp;&emsp;这一点深深影响了从希尔伯特到爱因斯坦的一批顶级数学家和科学家。前者试图构建一个大一统的数学体系，后者则致力于构建完美的物理学体系。虽然希尔伯特的努力被哥德尔证明是徒劳的，而爱因斯坦的设想至今也还没有实现，但是，数学和科学各个分支之间在方法上却具有相通性和普适性，这些通用的方法常常让很多学科同时受益。&emsp;&emsp;当然，对于一个平庸的数学家，思考不思考哲学问题影响并不大，反正从事的都是补足数学中知识点的工作，并不需要进行高层次的创作与研究。&emsp;&emsp;类似的，如果我们仅仅像古希腊奴隶那样为了谋生而学习，掌握一点技能也就够了。但是如果我们是像苏格拉底那样把自己看成主人，以这个态度来学习，来做事情，我们就需要在认知层面有所提高，了解数学和哲学都可以帮助我们做到这一点。&emsp;&emsp;一头一尾两门学科&emsp;&emsp;如果我们把自然科学、数学和哲学的层次简化成一张图的话，应该是下面这样一个结构，数学是基础，上面有各种自然科学，最顶上则又有哲学。![](/images/179.jpg)&emsp;&emsp;我们通常会觉得这一头一尾的数学和哲学是没有实际用途的，中间可以实用的自然科学才值得我们去学习。但是，无用之用，方为大用。一个人只有在深刻理解了人类知识的普遍性原理之后，才能站在一个制高点往下俯视。这也是数学和哲学的共同之处。&emsp;&emsp;到此为止，我们今天所有的内容都是针对大多数不去当数学家的人。如果哪位读者想当数学家，我倒有一个建议给他，就是需要具有一颗自由而炽热的心，去追求很高的、比较纯洁的精神生活，并且能够站在哲学的高度去研究数学。&emsp;&emsp;讲完了一头一尾，我们下一讲讲讲中间部分，也就是数学和自然科学的关系。我们下一讲再见。</details><h3><span id="46-shu-xue-yu-zi-ran-ke-xue-shu-xue-ru-he-gai-zao-zi-ran-ke-xue">46 ｜ 数学与自然科学：数学如何改造自然科学？</span><a href="#46-shu-xue-yu-zi-ran-ke-xue-shu-xue-ru-he-gai-zao-zi-ran-ke-xue" class="header-anchor">#</a></h3><!-- ![](/images/180.jpg) --><p>&emsp;&emsp;我们总是说，数学是自然科学的基础。这不仅是因为在自然科学中要用到数学，而且只有采用了数学的方法，才让自然科学从“前科学”，或者说带有巫术性质的知识体系，变成我们今天意义上的科学体系。</p><details><summary>...</summary>&emsp;&emsp;因此，马克思这样来描述数学和自然科学的关系：“一种科学只有在成功地运用数学时，才算达到了真正完善的地步。”这个论断可以被看成是对笛卡尔理性主义的另一种描述方式，也可以被认为是对从伽利略到19世纪中期自然科学发展过程的总结。**为什么早期的自然科学也叫自然哲学？**&emsp;&emsp;自然科学早期被称为自然哲学，包括牛顿的名著《自然哲学的数学原理》也是用的这种提法，因为那时人们普遍把所有的学问统称为哲学，而涉及到自然界和宇宙的规律，就是自然哲学。后来到了19世纪初，英国人才把那种采用实验的方法，系统地构造和组织知识，解释和预测自然的学问称为科学。&emsp;&emsp;自然科学中最典型的特征则是其自然属性，当年，亚里士多德把它笼统地称为Physics，今天直接翻译过来就是物理学，但是由于它真实的含义是包括所有的自然哲学，因此被翻译成“形而下学”，相对应的是在它之上的“形而上学”（MetaPhysics），即今天意义上的哲学。&emsp;&emsp;根据科学的自然属性，它研究的是自然现象和自然现象产生的规律。因此从这个定义来讲，数学显然不属于自然科学，因为它是人为制造出来的。制造数学的目的在很大程度上是为了发展自然科学，而非数学本身，这就如同牛顿为了研究运动学而发明了微积分一样。&emsp;&emsp;但是，相应的数学理论一旦出现，并反过头来作用于原来的学科时，原来的学科便脱胎换骨了。这就如同我们今天经常讲的“+互联网”，什么产业一旦利用互联网进行改造，就会使得效率倍增。自然科学各个学科的形成和发展，其实就是一个“+数学”的过程。接下来我们就来看看这个过程。**自然科学“+数学”的进程**&emsp;&emsp;**第一个被数学改造的学科是天文学。**古代文明为了推算历法和预测地上发生的各种现象，发明了占星术。但是，占星术的预测是极为不准确的，因为它措辞含混，而且缺乏量化度量。&emsp;&emsp;从占星术到天文学的转变源于古希腊时期，特别是靠喜帕恰斯和托勒密的工作，他们利用数学这个工具，建立起天体运动的模型，于是就能比较准确地预测天体的运动了。其中最著名的是托勒密利用几何学建立起来的地心说模型。&emsp;&emsp;**第二个被改造的学科是博物学**，亚里士多德使用分门别类的方法，对他那个时代所了解的世界万物进行分类，这和今天数学的集合论以及函数的概念有很高的一致性。由于篇幅的原因，我们不多讲了。&emsp;&emsp;**第三个被改造的学科是物理学**，这个过程始于阿基米德，成熟于伽利略，并且在后面不断地被发扬光大。&emsp;&emsp;阿基米德最为人熟知的贡献是发现了浮力定律和杠杆原理。浮力定律并非是从大量实验中总结出来的，而是他受到洗澡时的灵感，运用逻辑得到的。至于杠杆原理，虽然比阿基米德早2000多年的古埃及人就知晓了，但是将它用数学公式描述出来的是阿基米德。&emsp;&emsp;在阿基米德之后，希腊化地区不再有这个级别的科学家，因此建立物理学大厦的任务就落在了伽利略身上。伽利略的伟大之处在于，他把数学方法和实验方法结合起来研究自然界的现象，使物理学摆脱了经院哲学的束缚。杨振宁说，数学和物理是两片生长在同一根管茎上的叶子，这非常形象化地说明了数学与物理之间的关系。&emsp;&emsp;在伽利略以后，物理学的数学化加快了步伐，牛顿的工作我在之前的《科技史纲60讲》中已经介绍了，这里就不多说了。在牛顿之后，最重要的物理学家是麦克斯韦，他对电磁学的贡献，堪比牛顿在经典力学上的贡献。&emsp;&emsp;在麦克斯韦之前，库仑、安培、伏特、焦耳、法拉第等人都通过实验发现了电学的一些规律。但是，这些理论缺乏系统性，没有完全道出电和磁的本质。麦克斯韦和这些物理学家都不同，它是从数学出发，把前人的理论，特别是把法拉第有关电磁场的想法归纳成几个简单的方程式，使得电学和磁学统一为电磁学。&emsp;&emsp;麦克斯韦的理论了不起的地方在于他预见到了当时大家还观察不到的现象，比如他在数学上推导出电磁波的方程式，预测出电磁波的存在，而电磁波在真空中的速度与当时所知的光速相近，因此他预测光也是一种电磁波，只是可见频谱波段特殊的电磁波而已。&emsp;&emsp;后来赫兹等人发现了无线电波，证明麦克斯韦的预测。对于麦克斯韦的贡献，赫兹是这样说的：“我们不得不承认，这些数学公式不是完全人造的，它们本身是有智慧的，它们比我们还聪明，甚至比发现者更聪明，我们从这些公式所得到的，比当初放到这些公式中的还多。”&emsp;&emsp;后来，人们发现从数学上得到的麦克斯韦方程，和牛顿的经典力学方程在高速的情况下出现了矛盾。我们在前面的课程中讲过，如果这种事情发生，而推理又没有问题，可能说明我们最初的一些基本假设出了错误。&emsp;&emsp;事实上正是这个矛盾的结果导致了相对论的诞生，而最初，距离和时间绝对性的这个假设其实错了，也就是说，在高速的状态下，测量到的时间和距离会变化。这和我们前面讲到的发现暗能量的道理很相似。在20世纪，另一个物理学成就就是量子力学，也几乎完全是建立在数学基础之上的。&emsp;&emsp;在历史上，数学水平不够的物理学家，地位都不会太高，比如法拉第，他虽然发现了电学上的很多定律，但是在科学上的地位和另一位电学大家麦克斯韦无法相比。直到今天，依然如此。数学对物理学的重要性，可以通过一个人的经历来说明。这个人就是以傅里叶变换而出名的法国物理学家傅里叶。&emsp;&emsp;1807年，傅里叶将自己关于热传导的论文提交给法兰西科学院，但是被拒绝了，理由不是物理研究不好，而是数学不严谨。1811年的另一篇关于热传导的论文再次被科学院的学报拒绝发表，理由还是因为数学上的缺陷。&emsp;&emsp;在此之后，傅里叶恶补数学，终于在1822年发布了《热的分析理论》一文，里面的数学推导极为严谨，不仅被科学家接受，而且成为了今天热传导学的经典理论。&emsp;&emsp;今天，理论物理学家通常是半个数学家，在物理学方面有很多粒子，其实都是在推导数学公式时，为了让等式平衡而假设出来的，当然很多在后面被实验证实了。在宇观层面，像黑洞这种无法直接观测到的天体，以及引力波这种长期测不到的现象，也是靠数学预测的。&emsp;&emsp;**第四个被改造的学科是化学**，实验和逻辑使得化学完成了从炼金术到科学的华丽转身。在这个过程中，“化学之父”拉瓦锡为后人确立了化学研究的方法，简单讲，就是逻辑和量化。&emsp;&emsp;拉瓦锡的一大贡献是提出了氧化学说，推翻了过去的燃素说，这个成就来自于逻辑的判断。&emsp;&emsp;拉瓦锡是这么考虑的，如果燃烧是因为燃料里的燃素被烧掉，那么燃烧剩余物的质量应该减少。但是，经过他的测定，燃烧后剩余物的质量却是增加的。这说明燃素说在逻辑上有问题，而能够让剩余物质量增加唯一的可能性，就是空气中的一些元素和燃料结合了，这就是氧化说。&emsp;&emsp;当然，得到这个结论需要精确地度量实验结果，因此拉瓦锡留下一句名言，“没有天平就没有真理”。为了方便量化度量，拉瓦锡等人还制定了今天我们使用的公制度量衡系统。&emsp;&emsp;受到数学影响比较少的行业其实是生物学和医学，这也是它们让人们感觉不太严格的原因。但是医药学要用到大量的逻辑，到了近代，还要用到大量的统计。没有统计，就没有今天的医药学。&emsp;&emsp;**数学方法的意义在哪里？**&emsp;&emsp;从上面这些例子可以看出，数学对自然科学的帮助，主要体现在工具和方法两方面。数学作为工具很容易理解，比如微积分是今天很多自然科学研究的基础，离散数学是计算机科学的基础，而这在物理学中特别明显。但是，对大家更有借鉴意义的可能是在方法上。&emsp;&emsp;我们从各种自然科学的升华过程可以看出，它们有这样三个共同点：- 从简单的观察上升到理性的分析。今天我们观察到一个现象是一件很容易的事情，大部分人都能做到，但是能够对现象进行理性分析的人很少。这是每一个人都需要锻炼和提高的。- 从给出原则性结论到量化的结论，虽然我们不需要像拉瓦锡那样随身带着天平，但是需要明白很多事情必须量化度量才能得到准确的结论。从我们前面所讲到的计算利息的内容，你就能体会量化的重要性了。- 将自然科学公式化，或者说用数学的语言来描述自然科学。今天，不论是哪个国家的人，看到了F=ma，都知道是牛顿第二定律，看到E=mc^2，都知道是爱因斯坦的质能方程，看到H₂O，都知道是水。&emsp;&emsp;古代很多科学手稿，采用的是自然语言，而非数学语言来描述物理学的规律，这种做法不仅不形象，而且里面有一些彼此矛盾的地方难以发现。在采用了数学公式描述自然科学规律之后，由于公式的严谨性，一旦有矛盾之处，就很容易被发现。&emsp;&emsp;了解了自然科学的发展在很大程度上就是“+数学”的过程，我们在自己的工作中，也不妨试试用一用这种“+数学”的方法。养成理性和量化地处理我们日常工作的习惯，建立和他人的沟通基础，是我们通识课的一个目的。希望你在留言区说说自己在这方面的例子。&emsp;&emsp;下一讲，我们再看看数学与逻辑学的关系。我们下一讲再见。</details><h3><span id="47-shu-xue-yu-luo-ji-xue-wei-shi-me-luo-ji-shi-yi-qie-de-ji-chu">47 ｜ 数学与逻辑学：为什么逻辑是一切的基础？</span><a href="#47-shu-xue-yu-luo-ji-xue-wei-shi-me-luo-ji-shi-yi-qie-de-ji-chu" class="header-anchor">#</a></h3><!-- ![](/images/181.jpg) --><p>我们在课程中多次讲到，数学结论的正确性，取决于公理的正确性，以及逻辑的严密性，因此数学和逻辑是密不可分的，特别是像欧几里得几何这种数学体系，完全依赖于逻辑。但是，数学和逻辑又是完全独立的两门学问，不能混为一谈。</p><details><summary>...</summary>&emsp;&emsp;一般认为，逻辑是人类理性的体现，它的基本原理其实都是大白话，但是仔细琢磨起来很有道理，更关键的是，只有少数人能够坚持那些看似大白话的基本原理。因此，我们就从逻辑学的基本原理，以及和数学的关系讲起。**同一律：苹果就是苹果，不是橘子**&emsp;&emsp;首先要说的是同一律，它通常的表述是，一个事物只能是其本身。这句大白话背后的含义是，世界上任何一个个体都是独一无二的。注意这里说的是个体，不是群体。一个事物只能是其本身，而不能是其他什么事物。苹果就是苹果，不会是橘子或者香蕉。&emsp;&emsp;因为有同一律，我们才可以识别出每一个个体，这在数学上可以用A=A这样的公式表示，而且当一个个体从一个地方移到另一个地方去之后，它就不会在原来的地方，而会出现在新的地方。&emsp;&emsp;比如我们有一个等式X+5=7，当我们把5从等式的左边移到右边去之后，就变成了X=7-5，等式的左边只有X，不可能再有5这个数字了。&emsp;&emsp;很多孩子解方程，把数字从一边移到另一边的同时，忘记了把原来的数字消去，最后题做错了，自己还有家长只是觉得粗心了而已。其实在每一次粗心的背后，都有概念不熟悉的深层次原因。具体到这个问题，就是根本不理解同一律。&emsp;&emsp;同一律在集合论中特别重要，集合中的所有元素必须都是独一无二的。比如我们说整数的集合，里面只能有一个3，不能有两个，如果有两个，就出错了，这一点很容易理解。但是，在生活中，很多人自觉不自觉地在违反同一律，一个最典型的情况就是偷换概念，具体讲就是把不同含义的概念使用了同一个名称，达到瞒天过海的目的。&emsp;&emsp;人有些时候偷换概念是不自觉的，比如很多词的含义有二义性，他搞不清楚，造成了自己头脑的混乱，或者把一个个体和一个集合等价起来，以偏概全。比如有些人会讲，股市都是骗局，他们的经验是来自一部分股票，是个体，但是讲这句话的时候，就把股票换成了集合，也就是股市。&emsp;&emsp;自己不懂的逻辑，头脑不清，讲出的话违反了同一律后，就会造成别人的误解，甚至自己也会被绕进去，很多人缺乏好的沟通能力，可以溯源到讲话经常违反同一律上。&emsp;&emsp;另一方面，也有人是故意违反同一律，比如悄悄改变某个概念的内涵和外延，把它变成了另外一个概念，或者将似是而非的概念混在一起讲。比如商家常常用“限量版”这个词对外宣传，让人感觉数量非常有限。其实世界上任何商品的数量都是有限的，只是多和少而已。&emsp;&emsp;很多商品，并没有限量版一说，但其实数量比同类的限量版要少很多。比如说施坦威钢琴一年一共生产2000台左右，大型的Model D只有上百台，但是施坦威从来不说限量版。相反，日本限量版的钢琴数量常常比施坦威相应型号的总数量多很多了，但是一说限量版，大家就有高大上的感觉，这其实是偷换了限量版这个概念的外延。&emsp;&emsp;再举一个例子，你会发现美国的左派和右派都在喊平等，但是总是在吵架，因为他们一个说的是结果平等，一个说的是机会平等，这是因为把很多相混淆的概念装进了一个名词中，违反了同一律。&emsp;&emsp;在数学上，要严格遵守同一律。为了防止出现违反同一律的情况，就需要把概念定义得极为精确，在法律上也是如此。在生活中，我和别人沟通时，我常常会用我的语言复述一下对方的话，明确我们是在讨论同一件事情，这一点很重要。很多时候，我们和别人沟通中的误解，就来源于忽视了同一律。**矛盾律：不可能既是A又不是A**&emsp;&emsp;接下来要说的是矛盾律。它通常的表述是：在某个事物的某一个方面（在同一时刻），不可能既是A又不是A。我们前面介绍的数学中的反证法，就是基于矛盾律。&emsp;&emsp;矛盾律“contradiction”一词是由两个词根组合而成的，前一个词根“contra”是“相反”的意思，第二个词根“dicti”是“讲话”的意思，顾名思义，它就是指讲话的意思相对立。&emsp;&emsp;也有人把矛盾律看作是同一律的延伸，因为“是A”和“不是A”是两个不同的个体，自然不可能相同。我之所以强调事物的某一个方面，因为事物本身可能是多方面的，不同方面可能有不同的表现。比如在前面的课程中，有同学问，光的波粒二象性是否违反矛盾律？这其实不违反，因为它讲的是一个事物的不同方面。&emsp;&emsp;类似的，有人会讲，我人在某处，心却在你身边，这也不违反矛盾律。但是，如果说，某时某刻，我人在北京，人又不在北京，这就违反了矛盾律。在办案中，我们说的不在场证据，之所以能成立，是因为有矛盾律作保证。&emsp;&emsp;在数学和自然科学中，很多重大的发现都是源于矛盾律的使用。比如在前面提到的毕达哥拉斯定理和无理数的内容中，这个定理和有理数性质的矛盾，就导致了无理数的被发现。在物理学上，麦克斯韦方程组和经典力学方程的矛盾，就导致了后来相对论的提出。&emsp;&emsp;在生活中，有人会挑战矛盾律，比如有人说：“我是一个矛盾的人，既慷慨大方，又斤斤计较。对于教育我总是慷慨解囊，对自己的生活非常节省。”这种说法看似没有违反矛盾律，其实已经违反了前面讲的同一律，因为偷换了概念。&emsp;&emsp;为了防止大家在使用矛盾律时偷换概念，逻辑学家们一般强调四个“同一”，即同一时间、同一方面、同一属性、同一对象，总之强调的是独一无二的事件。**排中律：“是非”明确**&emsp;&emsp;最后，我们来说说排中律，它通常的表述是，任何事物在明确的条件下，都要有明确的“是”或“非”的判断，不存在中间状态。&emsp;&emsp;比如在数学上，一个数字，要么大于零，要么不大于零，没有中间状态。有人可能会说，等于零不就是中间状态么？其实大于零的反面并非小于零，而是不大于零或者说小于等于零，因此等于零的情况其实就是不大于零的一种。&emsp;&emsp;排中律保证了数学的明确性，通常我们在数学上使用排中律原则最多的时候，就是在所谓的排除法或者枚举法中。当我们排除了一种情况时，和它相反的情况就一定会发生。如果有多于两种对立的情况，我们可以先把所有可能的情况二分，然后再不断二分，直到每一个彼此不重复的情况为止。&emsp;&emsp;在计算机科学中，任何和二分相关的算法，其逻辑基础都是排中律。在这种思路的指导下，1976年，美国数学家阿佩尔和哈肯借助电子计算机，证明了四色（地图）定理。这是图论中一个非常著名的难题，它说的是在任何地图上，只要用四种颜色就能够给所有的国家（或者地域）染色，保证相邻的地域颜色不同。&emsp;&emsp;这个问题的难度在于情况太多、太复杂，因此数学家们努力了100多年也没有结果。阿佩尔和哈肯的高明之处在于，他们用计算机穷举了所有的情况，然后借助计算机一一证明了各种情况。而这种证明方法的正确性，是靠排中律保障的。&emsp;&emsp;讲到排中律，就不得不讲西方人和东方人在思维上的一种差异。在美国的大学和研究生升学考试SAT和GRE中，都要写作文，作文题目通常是就一个观点发表赞同或者反对的意见。&emsp;&emsp;中国学生的思维方式，常常是“既要……又要……”，比如让他分析是否要禁烟草，他会说：“因为吸烟对人体有害，因此我赞成禁烟，但是来自烟草的税收在国家的总税收里占很大的比例，所以，也不赞成完全禁烟。”&emsp;&emsp;这种作文或许在中国的高考中能得到不错的分数，但是在SAT和GRE的考试中，都会是不及格的分数，因为它首先违反了排中律。这不是文学写作水平的问题，是逻辑上的问题。&emsp;&emsp;通常，稍微有一点逻辑的人在讲话时，会注意不违反排中律。但是不少人在不注意的时候，还是会被人设套。比如一个检察官问犯罪嫌疑人：“你收受的贿赂中有没有奔驰汽车？”这其实就有一个圈套，因为问话包含了一个预设，即对方已经有了收受贿赂的行为。&emsp;&emsp;对此问题，如果简单地回答没有，其实等于变相承认了自己有受贿行为。有经验的辩方律师这时候需要向法官提出抗议，抗议检方这种设有圈套的问法。当然，作为被告方，好的回答是否定对方的大前提，即直接回答，我根本没有接受过贿赂。**充分条件律：有果必有因**&emsp;&emsp;此外，很多逻辑学家也把“充分条件律”和上述三个基本原则等同起来，一同称为逻辑的四个基本原则。所谓“充分条件律”，讲的是任何结论都要有充足的理由，这也就是我们常说的因果原理。任何数学的推理，都离不开充分条件律。&emsp;&emsp;充分条件律成立的原因，在于宇宙中任何事物不能自我解释，或者说不依赖于其它事物而存在。&emsp;&emsp;比如逻辑学家们经常会讲，为什么有我呢？不是天生就有我，而是因为有我的父母存在。再比如说，为什么张三数学成绩好？是因为他聪明，老师好，学校条件好，或者学习努力而且方法好，等等，而不是毫无条件的，天生数学就好。当然，很多时候仅仅一个或几个条件本身还够不成充分条件，需要上述条件都满足才行。&emsp;&emsp;数学正是因为有内在的逻辑性，才避免了可能的自相矛盾之处。&emsp;&emsp;这一讲我想告诉大家的是：人们通常会身陷矛盾而不自知，因为缺乏逻辑性。人们有时也会对某个重要的事物想不清楚，不知道该如何作判断，其实运用逻辑，把事实分析一遍，真相就清楚了。这应该是逻辑学和数学给我们的启发。而学习逻辑很好的方法就是学习好数学。&emsp;&emsp;下一讲，我们学习数学与其他学科的关系。下一讲见。</details><h3><span id="48-shu-xue-yu-qi-ta-ke-xue-wei-shi-me-shu-xue-shi-geng-di-ceng-de-gong-ju">48 ｜ 数学与其它科学：为什么数学是更底层的工具？</span><a href="#48-shu-xue-yu-qi-ta-ke-xue-wei-shi-me-shu-xue-shi-geng-di-ceng-de-gong-ju" class="header-anchor">#</a></h3><!-- ![](/images/182.jpg) --><p>&emsp;&emsp;数学和自然科学、哲学的关系是浑然天成的，但是和人文科学、社会科学和管理学的关系似乎就远了一点，也比较难找到，但是它们确实存在。我们在前面讲了林肯用《几何原本》说服国会的例子，这其实就是很好地利用了数学思想和法律的关系。今天，我们就说说这些关系。</p><details><summary>...</summary>**作为运筹学底层原理的数学**&emsp;&emsp;先说说数学和管理学的关系，我们还是从工具和思维方式两方面来解释。先说数学作为工具的一面。&emsp;&emsp;你可能听说过运筹学。我最初的运筹学启蒙来自我的父亲。我小时候是脖子上挂钥匙的孩子，放学回家就要给家里人煮米饭，如果我做完功课再做饭，等做好了饭就没有时间玩耍了，于是我常常把饭煮上就出去玩，当然经常会玩得高兴回家晚了，把饭煮糊。&emsp;&emsp;后来父亲启发我回家先煮饭，同时在旁边做功课，饭煮好了，功课也写完了，再出去玩，什么都不耽误。父亲告诉我这叫做运筹学，从此我就知道了这个名词。&emsp;&emsp;当然，我对里面的方法其实不是很了解，直到后来在大学里学习了图论之后，才有比较清晰的了解，到了美国才算完整地学完这门课。今天我举一个简单的例子，叫做关键路径，来说明运筹学和管理的关系。&emsp;&emsp;假如我们要制造一辆汽车，要经过很多环节，它们之间是环环相扣的，每一个环节所需要的时间我用下面的图表示。&emsp;&emsp;在图中，S点是起始点，你可以把它理解为开始造车的状态。E点是终点，你可以把它认为是汽车下线的状态。每一条路径是一个流程，上面有时间。![](/images/183.jpg)&emsp;&emsp;在生产线上，需要前面的工序都完成后，下一个才能开始。因此如果前面有三个工序，两个已经完成，我们不得不等待第三个完成，那么这时前两个工序上的工人其实就出现了所谓的“窝工”状态，劳动生产率就受到影响。&emsp;&emsp;一辆汽车，在生产线上制造的时间，最终取决于最后的那个工序完成的时间，而不是完成时间最早的那个工序。如果我从起点到终点，把持续的时间最长的各个工序连接起来，就得到一条耗时最长的路径，就是图中红色的路径，它被称为关键路径。&emsp;&emsp;在图中这条关键路径上的耗时是43个单位。如果我们提高某一个工序的效率，缩短其时间，比如我们发现蓝色的那个工序占了15个单位的时间，似乎太长了，我们缩短它，对汽车下线的时间有帮助吗？答案是没有，因为耗费时间的瓶颈在关键路径上，而不在那条看似很花时间的工序上。&emsp;&emsp;我们要想缩短整个的生产时间，就需要缩短关键路径上的时间，这就是运筹学的思想。具体到这个问题中，比如我们缩短了深红色路径的时间，从8缩短到4，这时候总的时间是否缩短了4个单位呢？也不是，因为这时粗的黑色的工序（路径）就成了关键路径，如果我们对比一下前后两种情况，发现它其实只是缩短了1个单位的时间。&emsp;&emsp;运筹学其实就是利用图论、线性代数等数学工具，从整体上改进现有系统的效率。通过这个问题，我也希望大家能够理解我经常说的，在一个复杂的系统中，整体不等于部分之和的原因。&emsp;&emsp;另外，顺便说一句，虽然在大工业时代运筹学的原理已经被用于了企业管理，但是它真正成为一门交叉科学是在二战时候的事情，英美两国为了更高效率地进行战争，找了一群数学家作规划，合理调度和使用各种战争资源。这些数学家对二战的胜利功不可没。**作为管理学方法论的数学**&emsp;&emsp;接下来讲讲数学作为方法论在管理中的意义。这是我和刘润老师共同总结出来的。有一次我们讨论决定企业命运的本源问题，在分析了很多企业后，我们决定依照欧几里得构建几何学公理系统的方式来总结企业形成和发展的共性。这里顺便说一句，刘润老师是数学专业科班出身的，虽然大家了解他是在得到上的很多管理学的课程。&emsp;&emsp;刘润老师和我发现，一个企业最重要的是它的愿景和使命，价值观和文化。一个卓越的企业在这些方面都做得很好，相反一个平庸的企业可能到关门都没有考虑清楚这些问题。&emsp;&emsp;愿景和使命是一家企业需要存在的理由。比如，Google一直以“整合全球信息，使人人都能访问并从中受益”为自己的使命，阿里巴巴以“让天下没有难做的生意”为使命，微软的盖茨以“让家家都有电脑”为使命（在那个年代电脑还没有进入家庭）。使命体现了企业和社会的关系。&emsp;&emsp;接下来是价值观，这其实体现了企业中的人和外界各种人的关系，比如是服务客户优先，还是回报社会优先，还是让投资人的收益优先。最后企业文化则反映了企业中人和人的关系。这三条，相当于几何学上的公理，我们不妨称之为“企业的三公理”。&emsp;&emsp;这三公理决定了企业的规章制度和市场定位，比如哪些事情可以做，哪些不能做，该怎么做，不该怎么做，就被决定了。这些规章制度相当于几何学中的定理。再接下来会逐渐产生并优化出很多做事情的流程、方法和习惯，它们可以被看成是定理的推论。&emsp;&emsp;这些制度、流程、方法和习惯一旦确立，市场定位便确定了。创始人管理公司其实是很轻松的。如果一个企业形不成制度，没有明确的市场定位，做事情没有章法可循，什么事情都要具体问题具体分析，需要靠创始人或者CEO的权力来解决，这样的企业就整天忙着救火，事情还做不好。即使高层人士经验丰富，解决的一个个问题也不过是个案，很难通过一件事把其它的事情做好。&emsp;&emsp;当然，三个公理一旦确定，公司的基因也就定了，发展也就不同。这就如同在几何中，平行公理不同的设定方式，就得到了不同的几何学体系。当然，世界上不止一种公理体系，因此也不止一种好的公司。&emsp;&emsp;但是，就像任何公理体系不会试图将所有的公理都纳入进来一样，一家企业也不应该把自己的使命愿景、价值观和企业文化变成一堆大杂烩。不仅企业如此，我们每一个人立足于社会，也应该有自己心中的公理、定理和推论。康德讲的头顶的星空和内心的道德律，就是他的公理。&emsp;&emsp;关于刘润老师在企业管理上的更多真知灼见，大家可以回顾他的课程。**历史怎么用到数学思维？**&emsp;&emsp;再接下来，我们谈谈历史和数学的关系。这里我们重点谈谈西方的大历史研究方法。&emsp;&emsp;大历史的英文原文是“macro history”，可能翻译成“宏观历史”更直观一些，它是将一个历史事件放到非常大的时间范围和非常大的空间场景中去考察。这种研究历史方法的代表人物是著名史学家费正清等人。你如果去读《剑桥中国史》和《哈佛中国史》，就能清晰地看到这种痕迹。&emsp;&emsp;在国内近年来，史学家们也从考据，考古，探求历史真相，发展到用大历史的方法分析问题了。施展老师的《枢纽》就是典型的用大历史研究中国史的代表作。在大历史的研究中，很多素材放到一起，怎么组织和研究呢？&emsp;&emsp;首先，需要用数学的思路，也就是归纳和演绎的方法，构建出一个能够自洽的知识体系。这样对一件事的评判，就不是历史上某个专家的观点了，不是“司马光认为如何如何”，或者“欧阳修认为如何如何”，而是史实自然演绎的必然结果。&emsp;&emsp;在这样的研究方法指导下，就不会有什么世界史方面的欧洲中心论，或者中国史方面的中原中心论。这也是今天那些大历史的史书受到欢迎的原因，因为它们让人耳目一新。&emsp;&emsp;当然，每一个人的视角不同，能够接触到的史料也不同，因此就会形成不同的，甚至截然相反的结论。但是，在历史学研究中，不强调所谓的正确性或者正统观点，而强调逻辑的自洽。任何从客观出发，逻辑上能自洽的结论都是有意义的。&emsp;&emsp;比如我在《文明之光》和《全球科技通史》中，使用科技和文明为线索来还原历史，科技和文明就是这个体系中的公理。费正清先生习惯于用经济学为线索看待世界，这是他的体系中最基本的公理。于是他就得到和钱穆先生完全不同的结论，钱穆先生认为宋朝是“积贫积弱”，而费正清先生则认为宋朝是中国历史上最辉煌的时代。&emsp;&emsp;今天非常热门的一本历史书是赫拉利的《人类简史》，这本书其实也有一些与众不同却合理的假设，基于那些假设，经过逻辑推理和史实验证，就得到了全新的结果。&emsp;&emsp;因此，在历史学研究中，不会像数学那样有对有错，但是却会有好有坏，有合理和荒诞的分别。而评判的标准就是其假设前提，也就是公理的客观性，以及论证的逻辑性。&emsp;&emsp;类似的，数学的方法在今天社会学的研究中也经常被采用，这里我们就不赘述了。&emsp;&emsp;通过这几天的内容，我希望大家理解人类知识底层的相通性，理解方法和逻辑的重要性，这是我们通识教育的目的。&emsp;&emsp;从下一讲开始，我们讲讲数学难题以及它们的意义，让你了解数学的另一个侧面。我们下一讲再见。</details><h3><span id="49-jia-luo-wa-he-gu-dian-shu-xue-nan-ti-nan-ti-gei-wo-men-de-qi-fa">49 ｜ 伽罗瓦和古典数学难题：难题给我们的启发</span><a href="#49-jia-luo-wa-he-gu-dian-shu-xue-nan-ti-nan-ti-gei-wo-men-de-qi-fa" class="header-anchor">#</a></h3><!-- ![](/images/184.jpg) --><p>我们接下来两讲说说那些数学史上的难题，体会数学这个工具的具体作用。</p><details><summary>...</summary>&emsp;&emsp;在几何学中，有几个古典的难题，它们都是作图题。这几个问题看上去很容易，但是几千年也没有人能解决，即便以高斯等人的天才，对它们也是无能为力。但是，19世纪的两位法国天才少年却发明了一种数学工具，让这些问题瞬间得到解决。&emsp;&emsp;我们先从这些问题说起，通常讲的古典数学难题有这样三个：- 三等分任意的已知角；- 做一个体积是已知立方体两倍的立方体（也被称为倍立方问题）；- 做一个面积等于已知正方形的圆，或者反过来（也被称为方圆问题）。&emsp;&emsp;当然这些几何作图题只能使用圆规和直尺为工具。&emsp;&emsp;通过前面课程的学习，你可能已经看出第二个问题和第三个问题有些相似性，就是用圆规和直尺作出一个无理数的长度，它们分别是2的立方根，以及圆周率𝛑，如果我们能作出这些长度，这两个问题就迎刃而解。反之，如果我们能证明这是作不出的，则说明上述问题无解，也算是把问题解决了。&emsp;&emsp;至于第一个问题，如果大家学了三角函数就会发现，它其实等价于算出1/3个角的任何一种三角函数，相应的公式并不难写出，而它的解析解其实也包含了立方根，因此它和第二个问题一样，它也是一个用圆规和直尺做立方根无理数的问题。&emsp;&emsp;在长达上千年的时间里，很多数学家都是靠拿着圆规和直尺不断尝试做这些几何作图题。由于每一个轨距尺作图的难题解法之间没有什么规律可以遵循，因此能否解决一道题，其实就是靠经验和运气。但是，即便运气好，发现了一个问题的解法，得到了一种解题技巧，这种技巧其实无法推广，对其他问题的解决帮助不大。&emsp;&emsp;比如说，了解数学趣闻的读者都知道高斯用直尺和圆规作图解决正十七边形画法的问题，这个问题的解决除了高斯聪明以外，主要是他的运气好，因为恰巧正十七边形的边长计算出来只有平方根，不涉及到立方根或者五次方根，而任何自然数的平方根都可以用圆规和直尺作出来。![](/images/185.jpg)&emsp;&emsp;至于为什么自然数的平方根都很容易做出来，这其实是靠毕达哥拉斯定理做保障的。但是高斯所用的相应的技巧到正七边形那里，或者正十九边形那里，就不管用了。上述例子说明两点：- 在19世纪之前，当没有关于几何作图的系统性数学工具之前，那些所谓的难题都是孤立的。- 似乎用直尺和圆规作不出来的几何图形，都涉及到立方根。&emsp;&emsp;这两个现象19世纪初的数学家们应该已经注意到了，但是没有人知道如何解决。而系统地解决上述问题的不世天才叫做伽罗瓦。当然还有另一位也有不少相关的发明，他叫做阿贝尔，阿贝尔的故事我们今天不讲，重点说说伽罗瓦。**天才数学家伽罗瓦**&emsp;&emsp;伽罗瓦生于1811年，死于1832年，只活了21岁。他是近代数学的一个重要分支，群论的奠基人。伽罗瓦属于智商极高的人，这种人其实非常难培养，我举一个例子大家就明白了。&emsp;&emsp;假如我们普通人的智商是100，我们看那些智商是50的人就觉得他们是白痴，我们会觉得这么简单的问题，你们怎么就搞不懂呢？甚至觉得他们的行为很傻。同样，那些智商在160以上的人看我们也是白痴，觉得我们的行为很傻，并且可能会时不时地捉弄我们，以显示他们的不同。&emsp;&emsp;但遗憾的是，我们这样的人在世界上占大多数，智商160的人很少，因此我们看他们就觉得他们非常乖张，与众不同。在历史上，像奥本海默、图灵都被大众认为是这样的人，伽罗瓦也不例外。&emsp;&emsp;伽罗瓦在中学时得到的评语是“奇特、怪异、有原创力却封闭”，你如果考虑到他的智商，就可以理解他得到这样的评语完全是意料之中的。伽罗瓦11岁时成绩很好，但是他觉得学的内容太简单，于是就对学校的学习开始厌烦了。&emsp;&emsp;所幸的是，他14岁的时候爱上了数学，并疯狂地学习数学，在15岁就能阅读大数学家拉格朗日的原著。当然从此他对其他学科再也提不起任何兴趣了。因此，伽罗瓦得到这样的评语并不奇怪。&emsp;&emsp;伽罗瓦接下来投考大学也不顺利，他1828年两次投考著名的巴黎综合理工大学，都在口试中落榜，一般认为伽罗瓦过于狂傲，根本不把考试当回事，甚至有传言说他觉得考官的题目太简单了，将擦黑板的抹布直接扔在了考官的头上。总之他没有考上。&emsp;&emsp;不过，伽罗瓦随后却考上了法国最著名的巴黎高师，这是今天全世界基础数学研究的圣地，也是出菲尔兹奖最多的地方。关于这两所极具特色的精英学院的特点，大家可以回顾我在《Google方法论》中介绍法国高等教育的来信。在巴黎高师，老师们评价他是，想法古怪，但是十分聪明，并体现出了非凡的学术精神。&emsp;&emsp;伽罗瓦最初重要的数学成就完成于他在大学读书期间。1829年3月，还只有17岁的伽罗瓦发表了第一篇数学论文，几乎同时他将两篇重要的论文寄给了大数学家柯西，但是从此就没有下文了。&emsp;&emsp;关于这件事有各种猜测，包括一些阴谋论的猜测，比如说伽罗瓦是激进的革命派，而柯西则是保皇派，因此不准许前者的论文发表，我过去在国内读到的关于这件数学公案的说法大致如此。另外一种说法是，柯西对这个不知名的年轻人的论文根本不重视，放到一边了。&emsp;&emsp;当然，还有一种截然相反的说法，说柯西认识到了这两篇文章的重要性，建议把它们合并起来参加数学学术大奖的竞争，而当时发表过的论文是不能参赛的，因此，柯西没有建议发表它们。但不管是什么原因，这些论文没有发表。&emsp;&emsp;伽罗瓦随后参加了1830年法国爆发的七月革命，他在校报上抨击校长，并且因政治原因两次下狱，也曾企图自杀。关于伽罗瓦之死也是众说纷纭，通常的说法是死于决斗，据说自知必死的伽罗瓦在决斗前天将自己的所有数学成果奋笔疾书写了出来。他的朋友后来遵照伽罗瓦的遗愿，将它们寄给数学泰斗高斯与德国著名数学家雅可比。但是也都石沉大海了。&emsp;&emsp;十几年后，法国数学家刘维尔发现了伽罗瓦独创而具有前瞻性的工作，在1846年将它们整理，作序并发表。从此伽罗瓦被确认为群论的开创者，这个理论的基础部分也被称为伽罗瓦理论。这是当代代数、数论和计算机科学的重要支柱之一。&emsp;&emsp;关于群论我们就不详细介绍了，它是一个非常有力的工具，利用这个工具，我们可以直接证明三大古典数学难题无解。此外，它还可以证明几个今天在数学上被称为常识的结论，比如：- 5次和5次以上的方程式没有解析解，而4次以下的一定有解析解。- 什么样的正多边形可以用直尺和圆规作出来，什么样的不能。&emsp;&emsp;另外，怀尔斯在复证费马大定理的时候，也用到了伽罗瓦理论。**数学难题带来的启发**&emsp;&emsp;今天讲这些内容的目的是什么呢？除了介绍数学家与众不同之处，我主要是传递下面三个知识点。&emsp;&emsp;首先，绝大多数知识体系都不可能做到绝对的完备性和一致性的统一。在数学上，希尔伯特一直想做到这一点，但是后来哥德尔证明这是办不到的。这带来一个结果，也就是说，如果我们在数学内划定一个区域，这个区域里很可能出现仅仅依靠区域内的知识无法解决的问题。三大古典数学难题就是如此。&emsp;&emsp;解决这些问题，就需要更大区域的知识。打一个比方，我们在小学，可能遇到所学内容无法解决的问题，需要到中学扩大知识范围后，回过头来解决。这也就是为什么我们要不断学习的原因。&emsp;&emsp;其次，进一步体会工具的作用。数学中的每一种工具，都可以解决很多问题，并且将很多看似并不相关的难题的共性找出来。如果没有这些工具，那些难题即便能解决，也是靠特定的技巧，而那些技巧几乎无法用于解决其它问题。&emsp;&emsp;伽罗瓦其实是发明了一套新的工具，这样一劳永逸地解决了很多问题。因此，学习工具，善用工具，是学好数学的秘诀，也是我们平时做其他事情需要具有的能力。&emsp;&emsp;最后，要跳出圈外。在一个时代，某些问题之所以显得很难，是因为它们看似属于当时的知识体系中的问题，但其实这只是表象。比如三等分已知角这种问题，看似和二等分已知角一样，是一个简单的几何作图题，但是它其实不是一个在欧几里得几何范围内能够解决的问题。&emsp;&emsp;后来高斯等人虽然意识到它们都是代数题，但是却也不是初等代数能够解决的问题，而属于我们今天所说的近世代数才能解决的问题。这就如同我们在没有阳光的森林里要辨清方位是很难的事情，但是如果我们能够飞越到500米高的上空，一切就看得一清二楚了。&emsp;&emsp;希望大家通过今天的内容，深刻体会善用工具和跳出圈外。如果说有什么数学思维，其实就是这讲的内容，当然我们在课程里贯穿进去了。</details><h3><span id="50-dang-jin-de-qi-da-shu-xue-qian-xi-nan-ti">50 ｜ 当今的七大数学千禧难题</span><a href="#50-dang-jin-de-qi-da-shu-xue-qian-xi-nan-ti" class="header-anchor">#</a></h3><!-- ![](/images/186.jpg) --><p>&emsp;&emsp;这一讲我们帮助大家了解今天的数学，特别是看看那些看似极高深的、纯理论的问题和我们的生活有什么关系。</p><details><summary>...</summary>&emsp;&emsp;1900年德国数学家大卫·希尔伯特提出了23个历史性的数学难题，它们反映出当时数学家们对数学的思考。经过一百年，大约有17个难题得到了解决，或者已被部分解决，它们对科学的发展帮助极大。&emsp;&emsp;2000年，美国克雷数学研究所（Clay Mathematics Institute）公布了当今的七道数学难题，作为对100年前希尔伯特的回应。&emsp;&emsp;在2000年的数学家大会上，宣布这些问题前，会议首先播放了1930年希尔伯特退休时演讲的录音，包括他的名言：“我们必须知道，我们必将知道。”反映了人类对未知孜孜不倦的探索。由于那一年是千年的整年，这七个问题也被称为千禧年问题。克雷数学研究所还对这些问题设立了奖金，每一个为100万美元。由于这些问题证明的过程不可能简单，因此一旦有人宣布证明了某道题，就要由一个专家小组花两年时间审核，通过审核才能获得奖金。&emsp;&emsp;需要指出的是，千禧问题不是随便确定的，它们所关注的领域，则和今天的科技发展密切相关，它们的破解，极有可能带来物理学的大统一理论，计算机科学、密码学、通讯等的突破性进展。&emsp;&emsp;在确定这些问题的过程中，克雷数学研究所咨询了世界上其他顶尖数学家，包括解决了费马大定理的怀尔斯等人。它设立奖金的目的是为了引起大众对数学研究的关注，特别是激发人们寻找解决难题的答案。这一讲我们就一起看看这七大难题。**1.庞加莱猜想**这是一个拓扑学问题，它的讲法有点绕口。![](/images/187.jpg)&emsp;&emsp;庞加莱猜想讲的是任何一个单连通的、封闭的三维形体，等价于一个三维的球。所谓连通、封闭就是形体表面任何两个点可以沿着表面的一条线连起来，所谓单连通，就是指不像甜甜圈那样中间被掏空。&emsp;&emsp;我们日常生活中遇到的大部分三维形体都是这样的，比如球、圆柱、长方体、三棱锥、没有把的杯子、馒头、棒球棒等等。当然，甜甜圈、铁环、拧成了八字形的麻花，都不是。&emsp;&emsp;庞加莱猜想说的是，这些单连通的封闭三维形体，你把它揉揉捏捏，就成了一个球。这就是图中前五个形状到球的对应。但是像甜甜圈，你怎么揉也揉不成球，因为中间的“缝”捏不掉。因此，图中后面两个形状对应不到球上。&emsp;&emsp;庞加莱猜想在我们看来显然是很正确的，但是在数学上，只有公理是显然的，其他任何结论都要经过证明得出，有些时候，越是显然的结论越难证明。在庞加莱猜想被提出之后的几十年里，世界上有很多数学家试图解决这个结论看似明确的猜想，但是都一无所获。&emsp;&emsp;直到上个世纪60年代，才由美国数学家斯梅尔解决了这个问题的高维（5维）变种，这个变种比原来的问题要容易很多，但是对这些简单却相似问题的研究还是给后人带来了启发。斯梅尔因此获得了1966年的菲尔兹奖和随后的沃尔夫奖。1&emsp;&emsp;983年，美国数学家弗里德曼证明了庞加莱猜想的4维变种，并且也获得了菲尔兹奖。在证明这个猜想的过程中，还有数名数学家做出了很大的贡献，获得了菲尔兹奖，但是他们其实离猜想的证明还有很长的距离。&emsp;&emsp;2003年，俄罗斯数学家格里戈里·佩雷尔曼完成了对庞加莱猜想的证明。佩雷尔曼可以讲是这个世纪数学界的神人。他在俄罗斯接受的教育，后来在美国的几所大学里做博士后，大约攒下了10万美元，他觉得这点钱他一辈子就够花了，于是就回到俄罗斯去证明庞加莱猜想了。他住在妈妈的福利公寓里，每月只花400美元吃饭，然后就把所有的时间用来研究数学了。&emsp;&emsp;2003年，他在一个叫arXiv的网站上贴出了自己对这个定理的完整证明，这个网站是科学家们提交预发表论文的地方。由于佩雷尔曼的文字极为简略，数学界经过近三年才完成校验。2006年，多组研究者先后发表论文阐释了佩雷尔曼的成果，并认定其无误。&emsp;&emsp;当然，很多数学家还是没有看懂，质疑他证明过程的正确性，佩雷尔曼从来不解释他的证明，只是直接怼回去，说你们这些人水平太低。凡是被他怼的数学家，后来都不得不离开了数学界。&emsp;&emsp;由于佩雷尔曼解决了这个百年数学难题，国际数学家大会决定授予他菲尔兹奖，但他却表示拒绝领奖。当时的国际数学家大会主席约翰·波尔爵士为了说服他接受这个奖，专门飞到圣彼得堡，花了两天时间和他谈了十个小时，最后也没能说服他。&emsp;&emsp;通常得到菲尔兹奖就很牛了，但是敢于拒绝领奖更牛，不过国际数学家大会还是给了他这个奖。2010年3月18日，千禧年大奖正式颁发给佩雷尔曼，但是几乎身无分文的他又一次拒绝领取克雷数学研究所的百万奖金。根据俄罗斯国际文传电讯社的消息，佩雷尔曼认为美国数学家理查德·汉密尔顿对这一问题的贡献丝毫不逊于自己，因此不愿意独占这个奖项。&emsp;&emsp;总之，佩雷尔曼以他天才的头脑，巨大的数学成就和乖张的行为，成为了当今数学家一道风景线。不过，我倒认为，在佩雷尔曼心中，解决那些数学难题比得奖和获得金钱要重要得多。&emsp;&emsp;那么庞加莱猜想有什么意义呢？简单地讲，它可以让我们更好地理解三维世界。比如我们如何在不到达外太空的情况下证明地球是圆形的呢？有人说麦哲伦的船队航海一周又回到了原点，说明它是圆的。其实这不一定，因为如果地球是甜甜圈的形状，航海一周也会回到原点。&emsp;&emsp;庞加莱猜想是拓扑学发展的一个拦路虎，这个问题解决了，就相当于给数学奠定了一块重要的基石，往上能建立起一个个大房子。&emsp;&emsp;庞加莱猜想是迄今为止唯一被解决的千禧问题，接下来我们说说其它千禧问题。**2.NP问题**&emsp;&emsp;这个问题对于搞计算机的人来讲非常熟悉，它其实反映出解决一个问题的难度和验证一个答案的难度之间的差别。我们知道，通常前者要比后者难很多。正是因为这种不对称性，才使得我们在得到密码后，解密要比不知道密码时破译容易得多。&emsp;&emsp;NP这两个字母代表非多项式的意思，在计算机科学中，有很多问题至今没有找到不超过多项式复杂度（即O(N^k)）的算法，但是如果你给出答案，我们有算法可以在多项式复杂度的时间内验证答案的正确性。&emsp;&emsp;因此，人们就不禁要问自己，这些问题是不存在多项式复杂度的算法呢，还是说仅仅是我们现在没有找到？&emsp;&emsp;你如果回顾我们前面讲到过的希尔伯特第十问题，会发现它们在表述上的相似性。如果NP问题的答案是否定的，即那些问题不存在多项式复杂度的算法，那么今天基于公开密钥的所有加密算法从原理上讲都是安全的，不会因为出现什么量子计算而变得不安全，因为验证总是比破解来得简单，道高一尺，魔总是高一丈。但如果答案是肯定的，那就糟糕了，因为人们可能找到和验证密码同等难度的破译算法。&emsp;&emsp;2001年，一项针对100名数学和计算机科学家的调查结果显示，有61人相信答案是否定的。2012年重复这个调查，结果是84%的受访人相信答案是否定的。我本人也是持这种观点。&emsp;&emsp;我的算法老师古德里奇教授是一位极富天赋的学者，他告诫我们不要花时间在这个问题上，因为世界上已经有太多聪明的头脑在这上面花了一辈子时间而一无所获。可能我们目前的数学工具还不足以证明或者证伪这个问题。&emsp;&emsp;（注：2010年，惠普实验室的一位印度科学家提交了一篇长达100页的论文，宣称解决了这个问题，随后计算机科学家和数学家们对此进行了一番审核和讨论，发现他的证明是错误的。）**3.霍奇猜想**在七大千禧难题中，它也被认为是对非专业人士而言最难理解的一个，大家知道这个名词即可。**4.黎曼猜想**&emsp;&emsp;这也是一个尚未被解决的希尔伯特问题，2017年，英国著名数学家阿蒂亚爵士宣称解决了黎曼猜想，后来被证明是一个大乌龙。关于这个问题以及那次事件的细节，我在《谷歌方法论》的第195封信中有详细的描述。&emsp;&emsp;黎曼猜想的主题是研究素数分布的问题，这对我们今天的加密有很大的意义。**5.杨-米尔斯存在性与质量间隙**&emsp;&emsp;大家对这个问题的含义不必太在意。对于这个问题需要强调两点：&emsp;&emsp;首先，这是由杨振宁先生和他的学生米尔斯共同提出的，今天它又被称为杨-米尔斯理论，它是对狄拉克电动力学理论的完善。经典的杨-米尔斯理论的核心是一组非线性偏微分方程，也被称为杨-米尔斯方程。上述千禧问题是要证明杨-米尔斯方程组有唯一解。而这个问题的解决，关乎到理论物理学的数学基础，或者说能否有一个在数学上完整的量子规范场论。&emsp;&emsp;其次，物理学家们普遍相信这个问题的答案是肯定的，而且已经有物理学家基于这个理论开展工作获得了诺贝尔奖。但是这个问题的解决前景非常不乐观，数学界普遍认为这个问题太难了。杨振宁先生的这个理论，重要性其实一点不亚于他获得诺贝尔奖的工作。这个问题如果在杨先生有生之年被证明，他有大概率再次获得诺贝尔奖。**6.纳维-斯托克斯存在性与光滑性**&emsp;&emsp;这是一个流体力学的问题。它的意义也就不言而喻了。**7.贝赫和斯维讷通-戴尔猜想**&emsp;&emsp;这其实是一个椭圆曲线问题，椭圆曲线是数论研究的重要领域，我们前面讲到的安德鲁·怀尔斯对费马大定理的证明用到的主要工具就是椭圆曲线。事实上，贝赫和斯维讷通-戴尔猜想的官方陈述就是由怀尔斯写的。今天的比特币加密，也是利用椭圆曲线验证解和求解在时间上的不对称性实现的。因此，这个问题有非常明确的应用场景。**总结：**&emsp;&emsp;从这七个问题我们可以看出，今天即使是最理论的纯数学研究，其实和当前人类面临的很多实际问题是相关的，比如有三个问题直接和计算机加密有关。其它的和宇宙学、力学等相关。因此，那些看似无用的智力游戏，其实有大用场。&emsp;&emsp;此外，通过佩雷尔曼这个人，我们能够理解一个真正的数学家所追求的目标是什么，在他身上体现出人类对未知的好奇和探索精神。&emsp;&emsp;到此为止，我们简短地讲述了数学和其它知识体系的关系，你如果在工作中知道自己的专业和数学的关系，不妨在留言区分享给大家。下一讲，我对这门课程做一个课程小结。下一讲见。</details><h2><span id="shu-xue-jie-ke-zhi-shi-kai-shi-tong-shi-ke-xi-lie-di-yi-men-wan-zheng-shang-xian">数学结课 ｜ 只是开始：通识课系列第一门，完整上线</span><a href="#shu-xue-jie-ke-zhi-shi-kai-shi-tong-shi-ke-xi-lie-di-yi-men-wan-zheng-shang-xian" class="header-anchor">#</a></h2><p><img src="/images/188.jpg" alt=""></p><p>到这讲为止，我们已经讲完了数学通识课的内容，现在来对课程作一个小结。</p><details><summary>...</summary>&emsp;&emsp;我们将初中、高中和大学10年的数学课内容浓缩到这50讲大约10个小时之中。&emsp;&emsp;如果你一路跟下来，学完了课程内容，祝贺你，也希望你把这门课推荐给你的朋友。对于还没有完成课程的同学，也不用着急，你可以在新年假期花点时间慢慢学习和理解一下，毕竟这10个小时浓缩了10年的课程，消化起来需要些时间，特别是对于那些没有学过高等数学的人。&emsp;&emsp;如果你掌握了这50讲的内容，就大致了解了直到大学数学教育的精髓，因此在上面花点时间还是值得的。&emsp;&emsp;当然，可能有人会讲，你就这么有自信，说这10个小时的内容就是10年数学学习的精髓了？我这么说，是有些理由的。**50讲都学了哪些知识点？**&emsp;&emsp;这一方面是因为50讲中的知识点是我们现代人通常需要了解的数学知识。我们讲了代数学、几何学、微积分、高等代数、概率论，以及简单的数论、最优化、实变函数和博弈论，这构成了理工科学生直到大学的数学基础。&emsp;&emsp;另一方面，通过理解这些知识点，我们深刻地理解了数学是什么，它和其它知识体系的关系，以及区别。在这方面，我们特别强调了数学是一个公理化的体系，这既是数学的特点，也是数学的方法，还是数学对其它知识体系有启发的地方。&emsp;&emsp;比如，在课程中，我们举了几何学和概率论公理化的例子，让大家体会什么是公理化的数学。那公理化这点，在其他数学分支上，也有体现吗？答案是肯定的。我们在课程中唯一没有涉及到的主要分支是近代数学，它里面包括集合论、离散数学和拓扑学等。**集合论如何公理化？**&emsp;&emsp;今天，我们就用集合论再给大家举一个例子，看看集合论的公理化过程。&emsp;&emsp;有趣的是，人类数学最早接触到的自然数，要融入到成公理化的体系中，却需要公理化的集合论。&emsp;&emsp;说到自然数，大家会想，这不就是我们平时数数，从0，1，2，3，……一直数下去吗？难道这也要公理化么？是的，我们在课程中讲了，数学上没有什么“显然”、“必然”之类的词，只有建立在定义和公理上的结论。因此，要构建自然数的体系，我们也要这么来。&emsp;&emsp;那怎么用构建公理化体系的思路来构建自然数呢？&emsp;&emsp;首先我们要定义一个最基本的自然数，其它的自然数都从这一个衍生出来，因此我们作如下的定义：0是自然数。&emsp;&emsp;有了0的定义，我们才方便定义其它的自然数。可以讲，世界上所有的数都源于0，这和中国道家所说的万物源于“道”有点相似性。当然有人可能会问，为什么不先定义1呢？原因是定义了1，就无法定义回0了，很多运算极不方便，这一点我们等会儿会看到。&emsp;&emsp;接下来我们要给出几个公理，一共有5个，我们只介绍前4个。- 公理一：即0的定义。- 公理二：任何自然数，都有一个后继的自然数。&emsp;&emsp;从这条公理，我们知道0有一个后继的自然数，我们可以称之为1，那么1也可以有一个后继的自然数，我们称之为2……- 公理三：0不是任何自然数的后继自然数。&emsp;&emsp;这条公理说明：自然数是一个有开头，没有结尾的集合。因此我们只能往后扩展，不能往前扩展，这也是我们要从0开始定义的原因。- 公理四：如果b和c都是a的后继自然数，那么b=c。&emsp;&emsp;第五条解释起来有点费时间，我们就省略了。&emsp;&emsp;这五条也被称为皮亚诺公理，后来被进一步完善，形成了自然数的结构。然后人们从自然数出发，可以定义出包括负数的整数以及有理数，然后再从有理数出发，定义了实数，最后从实数出发，又定义出包含虚数的复数。到此为止，关于数的理论才非常完备。&emsp;&emsp;我们之所以讲这个例子，是为了进一步加深大家对数学体系公理化这一点的理解。任何数学分支，都必须从基本公理去建立自己的理论体系。&emsp;&emsp;接下来我们说说自然数和集合的关系，这样大家更能体会数学不同分支之间相通的特性。我们先说说集合是什么。&emsp;&emsp;集合的概念其实过去也没有严格的定义，人们把一堆东西放到一起，就称之为集合了。数学的很多理论都要依靠集合，比如函数的定义。&emsp;&emsp;后来数学家们就希望对集合有一个精确的定义方法，以便能够把和集合相关的各种运算讲清楚。于是数学家就发明了一个从无到有构建集合的方法，他们是这样做的：&emsp;&emsp;首先，我们定义一个没有任何元素的集合，称之为空集，通常写成Φ={ }。&emsp;&emsp;然后我们把这个空集Φ看成是另一个集合唯一的元素，就得到第二个集合= {Φ}，它里面只有一个元素，就是空集 。接下来我们构建第三个集合，它有两个元素，即空集，以及第一个集合。&emsp;&emsp;为了便于你理解，我把这三个集合用下面的图表示一下。左边的就是空集，中间的集合有一个元素，那个元素是空集，右边的有两个元素，空集，和包含一个元素的集合。![](/images/189.jpg)&emsp;&emsp;这样不断地构建下去，我们就可以构造出包含N个元素的集合，N其实就是自然数。于是，我们可以用从空集构建集合的方式，构建自然数。具体的定义方法如下：&emsp;&emsp;0=Φ={ }；1={Φ}；2={Φ,{Φ}}；3={Φ,{Φ},{Φ,{Φ}}}；N={Φ,{Φ},……,{Φ,{Φ},……}}。&emsp;&emsp;这样一来集合和自然数，继而和所有的数统一了起来，从上面的例子，我们想说明数学的各个分支是相通的。&emsp;&emsp;当然，19世纪数学家们在构建集合的理论时忽略了一个“小问题”，就是能否有一个集合，它由那些不包含自身的集合构成？&emsp;&emsp;这句话有点绕口，我们用一个通俗的例子来解释一下。是否有一个理发师，他只给那些不给自己理发的人理发？学习了我们前面课程内容的同学应该马上想到，在数学上，很多时候，看似是小问题的问题其实都不小。&emsp;&emsp;事实上，上述问题并非一个数学家提出来的，而是精通逻辑的哲学家和学者罗素提出的，因此也被称为罗素悖论，这个悖论引发了第三次数学危机。因为如果理发师张三不给自己理发，那么他就符合当张三客户的条件，因此张三就应该给他自己理发，但是这样一来，他又不符合当自己客户的条件了，又不该被理发。&emsp;&emsp;后来，数学家策梅洛和弗兰克尔定义了严密的公理化集合论，才算解决了这个问题。&emsp;&emsp;通过上面的例子，我一方面想把课程中一些没讲到的内容给大家补上，让大家了解一下近代数学家们关心的问题，比如集合论。另一方面再次提醒大家，悖论在数学发展中的作用。&emsp;&emsp;最后要总结一下数学的思维方式，我把它概括为这样简单的四点：- 不轻易相信没有根据的结论，一切要从公理出发，用逻辑得到结论；- 在解决问题之前先要搞清楚问题，特别是搞清楚问题的定义；- 各种知识体系是相通的；- 用动态、发展的眼光看待世界。&emsp;&emsp;数学课是我们通识教育的第一门课。通过这门课，大家已经体会了我对通识教育的理解，以及接受通识教育应该学什么，怎样学了。**为什么下一门通识课我要讲语文？**&emsp;&emsp;今天，很多中国人经过一代人的努力，已经解决了温饱问题，进入到中产阶层。他们接下来就希望自己能更上一层楼，或者自己的下一代能够超越自己。但是他们遇到一个困境，就是在职业发展上有所谓的天花板，在社会地位提升上有所谓的阶层壁垒。&emsp;&emsp;这些人首先需要的还不是具体的知识，而是具备自己作为社会主人所应有的完整的知识体系，以及解决没有答案的问题的方法。这种能力，就是通过各种通识教育的课程来掌握的。事实上，通识教育Liberal Arts一词，就是源于古希腊“自由民”和“知识”这两个词，合在一起的意思是“作为社会主人所需要掌握的知识”。&emsp;&emsp;我们通过50讲10个小时的数学课，不可能就能做好高考题，或者考研题，但是在工作中，掌握好这10个小时的内容，在思想方法上的收获应该和在大学学不少数学课差不多了。真要用到数学，大家可以再看参考书，或者找现成的工具。做到这一点，这门课就算学好了。&emsp;&emsp;很多同学每次在听完我们的课程或者专栏之后都有意犹未尽的感觉，询问接下来的课程什么时候开始。在数学课之后，我们还会逐渐开设多门通识课程，基本上会涵盖数、理、化、文、史、地、政治、经管、艺术、音乐等等。这将是得到区别于任何知识服务平台的地方。&emsp;&emsp;很多人都有名校情结，其实世界上顶级的名牌大学，专业课讲得相比二流大学并没有太多的亮点，关键是通识教育做得好。大家有了好的通识教育的基础，在职业上就能走得很远。&emsp;&emsp;在数学课之后，我们会在2020年上半年开设语文通识课。语文课对于很多理工科同学来讲，显得枯燥，而且很多人会想，那些文学欣赏和我有什么关系？读一些名著也不能帮助我们涨工资。另外，语文本身显得很杂乱，如何组织内容也是个问题。因此，我们的通识课，会和数学一样找到一些主线，这样大家学习时会有一个抓手。&emsp;&emsp;这个抓手其实就是语文学习的最基本目的，即“理解他人，表达自己”。所谓理解他人，像文学欣赏、阅读理解，都属于这一类。&emsp;&emsp;你能欣赏托尔斯泰的小说，说明你能理解他。你能读懂一篇科学论文，理解作者的本意，而不是字面意思，说明能理解他了。类似的，你能读懂一道数学题，说明理解出题人的意思了。很多人高考考不好，托福、雅思考不好，都是因为不理解对方。&emsp;&emsp;表达自己的用途就更直接了，口头的表达能力、写作能力、辩论能力，都属于表达自己，至于在修辞、文法、语义表达上的修养，则体现一个人表达自己的水平，或者说，是人的修养。这些是通识教育的目的。&emsp;&emsp;希望大家结合我们已经讲过的数学，和我还没有开讲的语文，从为自己作为社会主人的目的出发，思考一下通识教育。当然，如果可能，把这门课再复习一下。</details><h2><span id="ke-wai-yue-du-zhu-ming-shu-xue-jia-xi-er-bo-te-tui-xiu-qian-de-yan-jiang">课外阅读 ｜ 著名数学家希尔伯特退休前的演讲</span><a href="#ke-wai-yue-du-zhu-ming-shu-xue-jia-xi-er-bo-te-tui-xiu-qian-de-yan-jiang" class="header-anchor">#</a></h2><p><img src="/images/190.jpg" alt=""></p><p>我们在第50讲《当今数学七大难题》中介绍了2000年在公布七个千禧年问题的大会上，人们播放了100年前著名数学家希尔伯特的退休演讲。这段讲演非常值得一读。今天我就把它的背景为你简单介绍，并将他的讲演内容翻译过来，分享给大家。</p><details><summary>...</summary>**希尔伯特的生平**&emsp;&emsp;先要多说几句希尔伯特。希尔伯特是历史上少有的全能型数学家。他于1862年出生于东普鲁士的柯尼斯堡，这个城市在历史上有两件非常著名的事情。一件事就是出了大哲学家康德，而且康德一生几乎就没有离开这座城市。&emsp;&emsp;另一件事是在18世纪的时候，它是“七桥问题”的诞生地。当地居民喜欢尝试一次走过城里的七座桥，而不走重复路，但是没有人能走通。后来大数学家欧拉到此，研究了这个问题，提出解法，并且从此开创了数学中图论的研究。二战后这座城市已经被划归了俄罗斯，被称为加里宁格勒。&emsp;&emsp;希尔伯特一生致力于将数学的各个分支，特别是几何学，实现非常严密的公理化，进而将数学变成一个大一统的体系。希尔伯特因此发明了大量的思想观念，并且在许多数学分支都做出了重大的贡献。&emsp;&emsp;20世纪很多量子力学和相对论专家，都是他的学生，或者徒孙，其中很有名的一位是冯·诺依曼。1926年，海森堡来到哥廷根做了一个物理学的讲座，讲了他和薛定谔在量子论中的分歧。&emsp;&emsp;当时希尔伯特已经60多岁了，他向助手诺德海姆了解海森堡的讲座内容，诺德海姆拿来了一篇论文，但是希尔伯特没有看懂。冯·诺依曼得知此事后，用了几天时间把论文改写成了希尔伯特喜闻乐见的数学语言和公理化的组织形式，令希尔伯特大喜。&emsp;&emsp;不过，就在希尔伯特退休的那一年，令他感到沮丧的是，25岁的数学家哥德尔证明了数学的完备性和一致性之间会有矛盾，让他这种数学大一统的想法破灭。&emsp;&emsp;希尔伯特还是一位著名的教育家，他后来接替菲利克斯·克莱因（因为克莱因瓶而出名）将哥廷根大学建设为世界数学中心。在纳粹上台之后，哥廷根大学人才大量流失，失去了往日的荣光。1943年，忧郁的希尔伯特在德国哥廷根逝世。**希尔伯特演说背景**&emsp;&emsp;1930年，德国著名数学家希尔伯特到了退休的年龄（68岁）。他欣然接受了故乡柯尼斯堡的“荣誉市民”称号，回到故乡，并在授予仪式上作了题为《自然科学（知识）和逻辑》的演讲；然后应当地广播电台的邀请，将演讲最后涉及到数学的部分再次作了一个短暂的广播演说。&emsp;&emsp;这段广播演说从理论意义和实际价值两方面深刻阐释了数学对于人类知识体系和工业成就的重要性，反驳了当时的“文化衰落”与“不可知论”的观点。这篇四分多钟的演讲洋溢着乐观主义的激情，最后那句“我们必须知道， 我们必将知道！”的名言掷地有声，至今听起来依然让人动容。&emsp;&emsp;在中译本的《希尔伯特传》中，对这次演讲有非常生动的描述（袁向东、李文林译，《希尔伯特——数学世界的亚历山大》，上海科学技术出版社，2006年）。在美国数学会的网站上有希尔伯特的演讲英文版全文。我将它翻译成了中文，分享给你。**演说正文**&emsp;&emsp;促成理论与实践、思想与观察之间调解的工具，是数学；它建起连接双方的桥梁并将其塑造得越来越坚固。因此，我们整个当今的文化，对理性的洞察与对自然的利用，都是建立在数学基础之上的。伽利略曾经说过：一个人只有学会了自然界用于和我们沟通的语言和标记时，才能理解自然；而这种语言就是数学，它的标记就是数学符号。康德有句名言：“我断言，在任何一门自然科学中，只有数学是完全由纯粹真理构成的。”事实上，我们直到能够把一门自然科学的数学内核剥出并完全地揭示出来，才能够掌握它。没有数学，就不可能有今天的天文学与物理学；这些学科的理论部分，几乎完全融入数学之中。这些使得数学在人们心目中享有崇高的地位，就如同很多应用科学被大家赞誉一样。&emsp;&emsp;尽管如此，所有数学家都拒绝把具体应用作为数学的价值尺度。高斯在谈到数论时讲，它之所以成为第一流数学家最喜爱研究的科学，是在于它魔幻般的吸引力，这种吸引力是无穷无尽的，超过数学其它的分支。克罗内克把数论研究者比作吃过忘忧果的人——一旦吃过这种果子，就再也离不开它了。&emsp;&emsp;托尔斯泰曾声称追求“为科学而科学”是愚蠢的，而伟大的数学家庞加莱则措辞尖锐地反驳这种观点。如果只有实用主义的头脑，而缺了那些不为利益所动的“傻瓜”，就永远不会有今天工业的成就。 著名的柯尼斯堡数学家雅可比曾经说过：“人类精神的荣耀，是所有科学的唯一目的。”&emsp;&emsp;今天有的人带着一副深思熟虑的表情，以自命不凡的语调预言文化衰落，并且陶醉于不可知论。我们对此并不认同。对我们而言没有什么是不可知的，并且在我看来，对于自然科学也根本不是如此。相反，代替那愚蠢的不可知论的，是我们的口号&emsp;&emsp;我们必须知道，&emsp;&emsp;我们必将知道！**英文原文**The instrument that mediates between theory and practice, between thought and observation, is mathematics; it builds the connecting bridge and makes it stronger and stronger. Thus it happens that our entire present-day culture, insofar as it rests on intellectual insight into and harnessing of nature, is founded on mathematics. Already, GALILEO said: Only he can understand nature who has learned the language and signs by which it speaks to us; but this language is mathematics and its signs are mathematical figures. KANT declared, “I maintain that in each particular natural science there is only as much true science as there is mathematics.” In fact, we do not master a theory in natural science until we have extracted its mathematical kernel and laid it completely bare. Without mathematics today’s astronomy and physics would be impossible; in their theoretical parts, these sciences unfold directly into mathematics. These, like numerous other applications, give mathematics whatever authority it enjoys with the general public.Nevertheless, all mathematicians have refused to let applications serve as the standard of value for mathematics. GAUSS spoke of the magical attraction that made number theory the favorite science for the first mathematicians, not to mention its inexhaustible richness, in which it so far surpasses all other parts of mathematics. KRONECKER compared number theorists with the Lotus Eaters, who, once they had sampled that delicacy, could never do without it.David HilbertDavid Hilbert in 1932(Courtesy of the Archives of the MathematischesForschungsinstitut Oberwolfach)With astonishing sharpness, the great mathematician POINCARÉ once attacked TOLSTOY, who had suggested that pursuing “science for science’s sake” is foolish. The achievements of industry, for example, would never have seen the light of day had the practical-minded existed alone and had not these advances been pursued by disinterested fools.The glory of the human spirit, so said the famous Königsberg mathematician JACOBI, is the single purpose of all science.We must not believe those, who today with philosophical bearing and a tone of superiority prophesy the downfall of culture and accept the ignorabimus. For us there is no ignorabimus, and in my opinion even none whatever in natural science. In place of the foolish ignorabimus let stand our slogan:We must know,We will know.你现在听到的这段录音，就是当时他的德语讲演。美国数学会关于这次讲演的网页网址，里面这段希尔伯特录音的链接：https://www.maa.org/press/periodicals/convergence/david-hilberts-radio-address-english-translation</details><h2><span id="re-dian-jie-du-tuo-yuan-qu-xian-jia-mi-bi-te-bi-jia-mi-de-shu-xue-ji-chu">热点解读 ｜ 椭圆曲线加密：比特币加密的数学基础</span><a href="#re-dian-jie-du-tuo-yuan-qu-xian-jia-mi-bi-te-bi-jia-mi-de-shu-xue-ji-chu" class="header-anchor">#</a></h2><p><img src="/images/191.jpg" alt=""></p><p>&emsp;&emsp;这次的内容大家可以和上一次谈论数据资产的加餐一起学习，那一次主要是从法律和商业的角度谈如何将数据变成资产，这一次我们谈谈这里面的一些技术问题。我们以区块链最广泛的应用，也就是比特币来说明。</p><details><summary>...</summary>&emsp;&emsp;比特币大家已经不陌生了，很多人之所以相信它的价值，是因为大家觉得靠数学算法背书比靠政府背书更合理，后者可能有太多的人为因素。至于比特币背后的技术，其实大部分人并不了解，有了之前我们学的数学基础，我们就可以谈谈比特币或者更广泛地讲，区块链的数学基础了。**为什么加密的本质是数学的不对称性？**&emsp;&emsp;从数学上讲，所有的加密货币之所以能够流通，而且不被破解，靠的是数学上一种不对称的美。人们通常喜欢对称，厌恶不对称，觉得后者不完美。在获取信息时，大家都希望透明，因为不透明、藏着掖着总让人感觉不踏实。但是，不对称有时却自有其妙处与美感，比如黄金分割就是不对称的。&emsp;&emsp;对于信息安全来讲，完全透明、完全对称会带来很多安全隐患。当我们自己是信息的拥有者时，其实并不希望别人可以获得我们的信息，特别是私密信息，只不过常常为了便利，不得不开放许多信息的访问权限，好让对方验证真伪，知道我们是谁，或者能够让对方进行一些统计，来为我们提供更好的服务。过去，我们不开放信息，很多事情就做不成，比如你向银行申请贷款时，几乎就是把所有个人和财务信息开放给了银行。&emsp;&emsp;在完全开放信息的社会里，彻底保护信息安全几乎是天方夜谭，这些我们在上一次加餐里已经说了。要想保护私有信息，特别是隐私，必须有一套不对称的机制，做到在特定授权的情况下，不需要拥有信息也能使用信息，在不授予访问信息的权限时，也能验证信息。&emsp;&emsp;而比特币的意义就在于，它证实了我们可以通过加密和授权，兼顾保护信息不外泄，而且某些得到授权的人还能使用信息。&emsp;&emsp;比特币做到这一点，是靠加密的密钥和解密所需要的密钥不是同一把这个特性。加密时用的密钥是所谓的私钥，只有比特币的主人有，解密的人用的则是由私钥生成的公钥，它可以给任何人。&emsp;&emsp;这种加密的不对称性就在于，在有限的计算时间里，无法从公钥倒推出私钥。因此你可以认为拿着私钥的人，能看到全部信息，而拿到公钥的人，只能看到部分信息或者只验证信息的真伪。为了进一步理解这种非对称的特性，我们不妨看一个具体的例子。&emsp;&emsp;假如，我们要卖房子，首先就要证明这个房子属于我们，有资格出售，过去我们要让买主看房产证，并且要由有关部门或者公证机构证明房产证是真的。这样来回来去多次，买房的人对你的很多信息就了解了，他们甚至就可以伪造一份和你一模一样的房契。&emsp;&emsp;在未来，数字化的房产证可以用区块链来保存，作为房主，区块链的算法会给我们一个私钥，全部信息在你手上。然后可以产生相应的公钥给购房者，用于验证我们房主的所有权，这就足够了，购房者不需要了解我们的其他信息。&emsp;&emsp;这个利用区块链协议验证房产证的过程，可以用一张图来说明：&emsp;&emsp;当然，需要说明的是，购买者使用公钥后验证了房契的真伪。如果他购买了房子，房契会转到他的名下，并作废原来房主的私钥，然后新房主可以拥有新的私钥，这个过程都会记录在区块链的账本里。![](/images/192.jpg)&emsp;&emsp;接下来，我们就来看看这件事在数学上是怎么做到的。我们还是以比特币协议为例来说明。它采用的是一种被称为椭圆曲线加密的方法。相比目前比较流行的RSA加密算法，采用椭圆曲线加密方法可以用更短的密钥达到相当或更好的加密效果。&emsp;&emsp;那么，什么是椭圆曲线加密呢？我们就要从椭圆曲线及其性质说起。&emsp;&emsp;椭圆曲线其实和椭圆没有什么关系，它是具有如下性质的一组曲线：$y^{2}=x^{3}+ax+b$这一类曲线的形状如下图所示：![椭圆曲线加密的原理](/images/193.jpg)&emsp;&emsp;这种曲线的特点是上下对称，非常平滑，具有很多很好的性质，特别是从曲线上的任意一点（图中的A点）画一条直线，它最多和曲线本身有三个交点（包括该点本身）。&emsp;&emsp;那么这样一种曲线，与加密有什么关系呢？我们用下面的图来说明。![椭圆曲线上的点乘运算过程](/images/194.jpg)&emsp;&emsp;在图中，我们从A点出发，画一条线经过B点，最后又和曲线交于C点。利用这条性质，我们定义一种运算，叫做点乘“·”，我们用A·B=C&emsp;&emsp;来表示这三个点之间的关系，意思就是：从A点向B点连线，与曲线相交于C点。由于椭圆曲线是相对x轴对称的，因此我们做C关于x轴的对称点D，把D作为新的一个点，再与A点连一条线。于是，便与椭圆曲线又有了一个交点E，这么一连，就得到A·D=E&emsp;&emsp;然后我们可以不断重复这个过程。假设我们最后经过K次这样的点乘运算，停到了Z点。注：在这个过程中，有四点需要作一下说明：&emsp;&emsp;首先，点乘这个运算满足交换律和结合律，因此先算哪一步，后算哪一步结果是一样的。这个性质我们就不证明了。&emsp;&emsp;其次，有可能这样的点乘计算了若干次后，某个交点的x值，即横坐标非常大，为了防止不断迭代后计算结果发散，我们在右边某个横坐标很大的地方设一个边界Max（最大值），超过Max后，再让直线反射回来。&emsp;&emsp;再其次，虽然图中的曲线是连续的，每一个点的取值是实数，但是我们在真正使用时，是通过某种变换将它离散化了，因此所有的点都是整数值。&emsp;&emsp;最后，有人可能担心，经过这一次次的运算，会不会又回到原来某个点了。这个不用担心，这个操作有点像两个巨大的素数相乘后，再对某个素数相除取余数（也被称为模运算，Mod），只要算法设计得好，和原来某个点重复的可能性近乎为零。&emsp;&emsp;如果我们把上述曲线操作中的点乘想象为数字的乘法，经过K次点乘，就相当于做了K次方的乘方，那么当给定起点A和终点Z之后，K其实相当于以A为底Z的对数。因此，这种计算的过程便被称为椭圆曲线的离散对数计算。那我为什么要给你讲这个连来连去的计算过程呢？&emsp;&emsp;我上面说的椭圆曲线的计算有一个特点，如果我告诉你一开始是从A经过B到C，再到D，到E等等，一共走了K步，你可以推算出最后停到了Z，这一过程直观而简单。但是，如果我告诉你起点是A，终点是Z，你要想猜出我经过了多少步完成上述过程，这几乎是不可能的，或者说，计算量是极大的。这种不对称性使得验证结果非常容易，但是想破解密码却难上加难。&emsp;&emsp;具体到比特币所使用的加密协议，是一种被称为SECP256K1的标准，采用的就是下面这条非常简单的椭圆曲线：  $y^{2} = x^{3}+7$![](/images/195.jpg)&emsp;&emsp;利用上面这个在形式上非常简单的曲线，我们就完成了在外界看来非常复杂的加密。&emsp;&emsp;椭圆曲线的加密方法有很多种，它们的算法和密钥的长度虽然各不相同，但是它们的原理却大同小异。美国国家标准与研究院已经规定了这一类算法的最小密钥长度为160位，再往上还有192位、224位，等等。它们都比RSA所要求的最短1024位短很多，这是椭圆曲线加密的优势所在。&emsp;&emsp;那么这么短的密钥安全么？事实上，2003年，一个研究团队用一万台PC花了一年半时间破解了一个较短的109位密钥。但是，破译的时间是随着密钥长度呈指数增长的，破解160位的密钥需要大约1亿倍的计算量，破译192位、224位的密钥就更难了。因此，除非计算机的速度有百万倍的提升，否则很难破译椭圆曲线加密的信息。&emsp;&emsp;当然，2019年Google在量子计算上取得了突破，在特定计算中，可以将原来需要上万年才能完成的计算在瞬间完成。因此很多人担心区块链的加密是否还安全，应该讲如果Google的技术真能走出实验室，而且能用于更多的计算，而不仅是特定的计算，目前的区块链加密算法要修改。&emsp;&emsp;但是，椭圆曲线加密的思想依然是安全的，因为加密（以及验证密码的难度）和解密永远不对称，就算计算机的计算能力提高了万亿倍，那么可以使用更复杂一点的加密，那样量子计算也无济于事。总之，只要数学的这种非对称性存在，加密就是安全的。&emsp;&emsp;说到椭圆曲线，还要补充一个信息，就是我们前面讲到的怀尔斯证明费马大定理，用的就是这个工具。最初日本数学家谷山丰发现椭圆曲线可能和费马大定理有关联，然后另一位日本数学家志村五郎进一步完善了他的想法，形成了所谓的“谷山-志村猜想”，怀尔斯是从他们的工作中得到启发，最终完成了对费马大定理的证明。&emsp;&emsp;从这里大家可以看出，那些看似没有用的数学理论，最后可能会有很大的实际用途，而且数学各个分支，很多时候是相关联的。&emsp;&emsp;好，通过这一讲的加餐，希望你已经从数学上理解了加密货币的安全性。欢迎你把文章分享给那些想了解加密货币计算原理的好朋友。下一篇的加餐，我为大家推荐一本新书。下一讲见。</details><h2><span id="xin-shu-tui-jian-gu-ge-qian-ceo-shi-mi-te-de-guan-li-jing-sui">新书推荐 ｜ 谷歌前CEO施密特的管理精髓</span><a href="#xin-shu-tui-jian-gu-ge-qian-ceo-shi-mi-te-de-guan-li-jing-sui" class="header-anchor">#</a></h2><p><img src="/images/196.jpg" alt=""></p><p>&emsp;&emsp;我非常有幸能够为施密特博士和罗森伯格的新书《成就》撰写序言，这是他们二人继《重新定义公司》之后又一本力作。今天就把这篇序言作为加餐，放送给大家。</p><details><summary>...</summary>&emsp;&emsp;作为和两位作者有着8年工作交集的Google老兵，我读这本书倍感亲切。书中所描绘的场景我是再熟悉不过了，但是当施密特和罗森伯格将那些在企业管理之道中最精华的东西总结出来，我再重温一遍时，还是感到收获巨大。&emsp;&emsp;施密特博士从2001年起到2011年担任Google的CEO，而我入职Google则是在他到Google之后的半年。那时Google正经历着从一家百人的小公司向着世界IT产业巨头转变的过程，而我有幸经历了整个这个过程。&emsp;&emsp;在施密特到Google之前，它还只是一家技术领先、文化宽松、产品卓越的创业公司。当时公司员工的平均年龄不到28岁，绝大部分人都是第一次参加正式的工作，公司充满活力，发展迅速，营收也不错，但是那时绝没有能力挑战世界上那些巨无霸的企业，甚至在互联网行业里还要让雅虎三分。至于做事的规范化，就更是没有达到一家伟大公司应有的水准。&emsp;&emsp;施密特接手的是这样一家公司。到2011年施密特交出Google时，它已经是全球最有影响力的公司之一了，并且一度成为过世界上市值最高的公司。可以讲，施密特对于Google的作用，堪比安迪∙格鲁夫之于英特尔。&emsp;&emsp;那么施密特是怎样将Google从一家小企业打造成世界上最成功、最有影响力的IT企业之一的呢？&emsp;&emsp;首先，是培养大家做事的规范性。在2001年之前，Google发展良好，业绩增长很快，但这在很大程度上是靠早期员工的个人能力。我在《浪潮之巅》中介绍了Google早期的很多“超级英雄”。&emsp;&emsp;但是，当一家企业发展到几千人、上万人时，不可能再找到那么高比例的“超级英雄”，即使能做到，这些人的个性也会让那个大组织崩溃。施密特了不起的地方在于，能够在延续Google早期文化的同时，对Google进行规范化的改造，让那些通过个人的偶然性的成功，变成了必然性的结果。&emsp;&emsp;在施密特担任CEO期间，Google开发了AdSense（基于网页内容的广告系统）、Google地图、Google文档（Docs）、Google翻译、无人驾驶汽车，并购了YouTube和安卓。正是靠这些不断的成功，才让Google今天依然能傲视全球各大IT公司。&emsp;&emsp;其次，是打造人才梯队，不断培养创新人才。这件事是由施密特和另外几位在2001—2002年进入Google的高级经理人一同完成的，在这些人中特别要提的是施密特的直接下属，主管整个研发的尤斯塔斯博士和本书的另一位作者罗森伯格先生。&emsp;&emsp;在他们的共同努力下，Google为每一位员工设计了职业发展通道，并且由相关的专业人士和职业经理人帮助员工们，特别是骨干员工们的成长。这使得Google成为了后来IT行业的黄埔军校。今天在中国颇有影响力的小米、拼多多、创新工场和快手等企业，创始人或者共同创始人都来自Google。&emsp;&emsp;在硅谷，风险投资基金有这样的统计，Google出来的创业者创业成功的概率，要远远高于行业的平均水平。相比之下，有些大企业虽然营收水平不错，但是在人才培养上却乏善可陈，难以成为伟大的企业。&emsp;&emsp;Google对人才的培养不仅仅在专业技能和企业管理方面，而是全方位的。事实上，罗森伯格是我们的第一位投资导师，他还请来了比尔∙夏普（诺贝尔经济学奖获得者）和马尔基尔（《漫步华尔街》的作者）等人给大家讲投资课。今天中美两国的不少风险投资人，最初系统性地学习投资，都是在Google期间，虽然他们当时在Google的本职工作并不是投资。&emsp;&emsp;最后，值得一提的是，施密特和罗森伯格都是Google全球化，特别是该公司进入中国的倡导者。2004年，施密特了解了我的工作，大加赞赏并且直接推动Google进入中国开展业务。虽然当时最高管理层对此有所分歧，但他和罗森伯格一直在积极推进此事，并且说服了其他高管，正式开设了在中国的业务。&emsp;&emsp;施密特把Google进入中国比做1972年尼克松改变世界的访华之旅。后来，施密特博士还多次直接和中国的运营商以及国家领导商谈合作的可能性。虽然今天Google在中国的业务并不大，但是施密特和罗森伯格等人的全球化眼光和只争朝夕的做法，确保了Google在全世界的影响力。&emsp;&emsp;我记得在内部会议上，施密特多次强调全球化的重要性。今天Google一大半的收入都来自海外，施密特对此功不可没。此外，施密特也是最先倡导Google向移动互联网转型的人，我记得早在2004年，他就预言将来移动互联网的流量将超过PC机互联网。&emsp;&emsp;讲到这里，大家可能有一个疑问，施密特和罗森伯格等人难道是天生的管理人才么？他们在培养下属之前，自己是如何学到管理经验的？这就要讲到本书的主角，施密特和罗森伯格等人的导师比尔∙坎贝尔了。&emsp;&emsp;事实上这本书的英文副标题“硅谷比尔的领导力手册”更好地反映了本书的内容。比尔∙坎贝尔自己虽然也不是学习管理出身的，但是他从多年的科技行业工作经验中，总结出信息时代和工业时代管理方法的不同之处，并且成功地影响了很多知名的商业巨子。除了Google的诸多高管外，还有苹果公司的创始人乔布斯和亚马逊公司的创始人贝佐斯。&emsp;&emsp;坎贝尔的管理思想和人才培养方式概括起来有这样四个特色：**1.强调在IT企业里规范管理的必要性**&emsp;&emsp;今天很多人觉得IT企业需要灵活性，管理要松散些，甚至觉得公司的组织架构越扁平越好。比如不少企业经常出现一个副总裁或者CEO下面有上百个直接汇报者的情况。这些看似灵活的管理方式，其实是管理不善的表现。除了公司在成长之后难以维持效率之外，对每一个人的成长也不利。&emsp;&emsp;在Google从小公司变成中型公司的时候，很多人希望从单纯的工程师，变成技术管理者，而他们当时最需要的不再是给他们传授更多的专业知识，而是有一个导师一样的管理者帮助他们全方位地成长。施密特、尤斯塔斯和罗森伯格来到Google之后，就为大家做了这件事。&emsp;&emsp;今天中国很多创业公司，难以完成从小公司到中型公司的转变，管理水平跟不上业务的发展是至关重要的原因，那些创业者和管理者可以部分借鉴一下这本书中的一些建议。**2.强调IT企业管理和传统工业企业的差异**&emsp;&emsp;虽然IT企业需要管理，但是管理的方式绝不能和传统的工业企业一样，因为它们要管理的是知识型员工。那种只动口不动手的经理人，在IT企业中是没有存在的必要的，也是难以立足的。&emsp;&emsp;坎贝尔认为，IT企业需要新型经理，他们是通过下属对他们的信任，而非公司赋予的权威来管理团队的。在Google这样的企业，大量的管理者都是技术专家，他们是通过自己对行业更深入的认识，让下属跟着他们走。&emsp;&emsp;就以施密特本人为例，外界很少知道他早年是UNIX操作系统的专家，也是该操作系统词法分析器软件Lex的作者，后来他当选了美国工程院院士。技术人员们在和施密特的交流中，永远不会有“和外行讲东西”的感觉，而是会觉得在和一个行业里有经验的老兵取经。**3.强调服务型管理**&emsp;&emsp;坎贝尔强调管理是对下属提供服务。这一点我深有体会，我在Google的几个上级，包括阿密特·辛格哈尔、诺威格和尤斯塔斯等人，都一直强调他们是我的资源，需要什么尽管找他们。事实上我也是不断在利用他们的支持开展工作的。IT企业管理者的任务，是协调好资源和各方面的关系，保证企业的业务以最快的速度、最好的结果发展，而不是炫耀自己的权力。&emsp;&emsp;为了做到服务型管理，好的管理者必须成为好的倾听者，他们能全神贯注地倾听别人的意见，然后能够找出真正的问题所在，并且给出建议。**4.强调管理者自身的提高和工作效率**&emsp;&emsp;坎贝尔认为每个管理者都需要学习并接受专业的培训，那些根据自己以往有限经验，自作聪明的人是无法胜任更高的领导岗位的。罗森伯格对此深有感触，并且在书里讲了一段他自己的经历。当一个管理者愿意放下架子学习，经过一段时间的锻炼，在管理能力上就会有质的飞跃。&emsp;&emsp;根据坎贝尔的看法，乔布斯在苹果的第一段经历说明他还不是一个合格的管理者。但是乔布斯经过后来近十年的学习和锻炼，终于脱胎换骨了，成为全球最好的管理者之一。&emsp;&emsp;管理者除了要不断提高自身水平外，还要讲究管理的效率，毕竟IT企业的管理者比例不应该很高。坎贝尔反对搞任何方式的形式主义，比如在做PPT时，不要搞一堆花里胡哨的东西，要有实质内容，要关注细节。&emsp;&emsp;《成就》这本书对所有的管理者和知识型员工，都会是有所启发的。该书写得通俗易懂，由于是作者们根据亲身经历写成，很有代入感，我一口气读完全书，把思路整理了一遍，受益匪浅。因此，我郑重将此书推荐给广大的中国读者。&emsp;&emsp;好，序言介绍完了，希望你有所收获。欢迎你在留言区写下你对管理员工这件事的新见解。</details><h2><span id="yuan-dan-cai-dan-2020-tan-sha-shi-bi-ya-bu-xiu-de-xi-ju-jiao-se-fu-si-ta-fu">元旦彩蛋 ｜ 2020谈莎士比亚：不朽的喜剧角色福斯塔夫</span><a href="#yuan-dan-cai-dan-2020-tan-sha-shi-bi-ya-bu-xiu-de-xi-ju-jiao-se-fu-si-ta-fu" class="header-anchor">#</a></h2><p><img src="/images/197.jpg" alt=""></p><p>&emsp;&emsp;你好！</p><p>&emsp;&emsp;又到了新年，首先祝你新年好。在新年到来之际，我们还是和往年一样聊一聊莎士比亚。莎士比亚戏剧中水平最高的是悲剧，但是在新年聊悲剧不太应景，因此今天我们聊一个莎士比亚历史剧中的人物，喜剧角色福斯塔夫。</p><details><summary>...</summary>&emsp;&emsp;福斯塔夫是莎士比亚历史剧《亨利四世》（上、下共两部）中的人物。他并不是其中的主角，但却成为了莎剧中最有趣的人物，以至于当时的女王伊丽莎白一世在看了《亨利四世》后，希望莎士比亚以这个非常有喜感，小丑般的角色为主角再写一部剧，据说莎翁只用了两周时间就写成了，后一部剧是《温莎的风流娘儿们》。&emsp;&emsp;后世的一些批评家认为这是英国文学史上塑造得最成功的戏剧角色。也有不少人认为，这个角色在莎剧中的地位不亚于哈姆雷特和罗密欧。那么这个中国读者并不算很熟悉的福斯塔夫是个什么样的人，又为什么在文学史上如此重要呢？我们先来看看他是一个什么样的人。&emsp;&emsp;福斯塔夫的形象不佳，有肥猪般的身体。他在《温莎的风流娘儿们》中吹牛，一位贵妇人用水汪汪的眼睛看了他几眼，他的随从讲：“正好比太阳照在粪堆上。”你可以想象出他的形象。&emsp;&emsp;福斯塔夫作为一名骑士，却完全没有那个时代军人所应有的骑士精神，没有任何国家荣誉感和勇气。相反，懒惰、贪婪、好色、好撒谎、胆小，还好吹牛，总之你能想出来的坏毛病他都有。&emsp;&emsp;在《亨利四世》一开始，哈尔王子和朋友两个人假扮强盗，把福斯塔夫和他的一大群狐朋狗友打了个落花流水。转过头，福斯塔夫就向（恢复了王子装束的）哈尔吹牛，他们如何以一当十，打跑了几十个强盗。&emsp;&emsp;福斯塔夫就是这样一个人，他带领着一伙流氓成天混迹于野猪头酒店（你听听这个名字），无拘无束，恣意享乐，寻求恶作剧，过着寄生虫一般的生活。&emsp;&emsp;在一部原本应该很严肃的历史剧中，莎士比亚为什么要虚构这样一个非常富有喜感的小丑呢？这就要从《亨利四世》的剧情、历史背景，以及莎士比亚创作的时代背景来看。&emsp;&emsp;先从剧情来看。亨利四世在英国历史上是靠推翻他的堂兄查理二世而登上王位的，因此就被一些贵族们觉得得位不正。亨利四世在担任国王的十几年里，就在不断地忙于平定来自威尔士、苏格兰和诺森伯兰等地的叛乱。很多人觉得英国（更准确地讲是英格兰）正是靠亨利四世不断地平叛，才形成了统一的国家。&emsp;&emsp;如果这样写历史剧，就显得很无趣，于是莎士比亚就需要加入另一条主线，虚构出这位破落骑士福斯塔夫，而他的角色则是亨利四世的儿子威尔士亲王哈尔的酒肉朋友和教唆犯。福斯塔夫的出现，就将这部原本应该很严肃的历史剧，变成了喜剧。&emsp;&emsp;《亨利四世》上下两部剧中的主角是哈尔王子，它讲述了一个放浪形骸的逆子如何转变为勇敢的战士和合格的君王的故事。在莎士比亚的安排下，早年的哈尔在福斯塔夫的帮衬下，以储君之尊混迹逍遥于市井陋巷，与这帮流氓无赖为伍，成天饮酒作乐，甚至违法乱纪，拳打大法官而入狱受罚。&emsp;&emsp;哈尔的这种行为，你应该不陌生，从一个人的成长来讲，这种叛逆想法是青春期少年人人都有的。从时代背景看，莎士比亚创作的时代正是文艺复兴之后人文主义盛行的年代，反叛传统，讴歌底层人民，甚至蔑视君权和神权，是当时的风尚。&emsp;&emsp;对哈尔这位青年王子来说，与其闷在宫廷里，不如出来听福斯塔夫说笑话，看他出洋相。因此，贵为亲王的哈尔时常和他一起鬼混。但是哈尔其实是在演戏，他只是暂时同他们“一起无聊鬼混”，有朝一日要“抛弃这种放荡的行为”。最后，在战场上哈尔杀死了敌方的主将，证明了他会是一个合格的人君。&emsp;&emsp;在该剧下部的最后，老国王亨利四世去世，哈尔当上了国王，就是英国历史上一代雄主亨利五世。福斯塔夫听到这个消息，觉得自己飞黄腾达的机会终于来了。但是，亨利五世却翻脸不认旧故，放逐了福斯塔夫，还要他减轻体重，增进德行，在改邪归正之前，不许靠近他十里以内，等他改好之后，再根据才能和德行升擢录用。&emsp;&emsp;再从亨利四世到亨利五世统治的历史背景来看，福斯塔夫这个角色有着特殊的意义。福斯塔夫是破落骑士，作为骑士，他和上层有联系，但是因为是破落的贵族，又和下层有联系。因此，福斯塔夫的出现，让这部剧不仅体现出了当时英国上层社会贵族与贵族之间的斗争（即亨利四世阵营的贵族和反叛贵族的斗争），也刻画出底层农民和市民的生活，以及五光十色的社会背景。&emsp;&emsp;在剧中，宫殿里运筹帷幄、决胜千里的权谋和贵族们在战场上的厮杀，伴随着野猪头酒店里的插科打诨、鸡飞狗跳式的胡闹，构成了一曲丰富绚烂的多声部大合唱。恩格斯把这种全景式的戏剧场景称之为“福斯塔夫式的背景”。恩格斯盛赞莎士比亚的这种构思是在广阔复杂的社会背景中再现还原出真实的生活。&emsp;&emsp;福斯塔夫这个角色在文学史上非常重要。我不确信金庸先生在写《鹿鼎记》时参考了《亨利四世》，但是在《鹿鼎记》中，康熙和韦小宝的关系倒是非常像身为王子的哈尔和福斯塔夫的关系。福斯塔夫的缺点，在韦小宝身上几乎都能找到，而康熙在离开朝堂之后，也会放纵自己，就如同当王子时的哈尔。&emsp;&emsp;在《亨利四世》接下来的续集《亨利五世》中，福斯塔夫没有再出现，只是提了一句，这个可怜人已经死了。后世的批评家认为，亨利五世（哈尔）和福斯塔夫的分离，代表着在文艺复兴和宗教改革之后，贵族和平民在摆脱神权束缚之后分道扬镳。&emsp;&emsp;当然这种评论大多来自19世纪的评论家们，他们受到后来法国大革命和欧洲各国的资产阶级革命的影响，因为在那些革命之后，工厂主和商人们就和劳工分道扬镳了。莎士比亚是否有这层意思，大家不妨见仁见智。&emsp;&emsp;福斯塔夫后来又出现在《温莎的风流娘儿们》中，那时他已经失去了亨利五世这个靠山，“快要穷得连鞋子都没有后跟啦”，于是就把心思花在勾引市民女眷，假装恋爱骗钱上，其结果就是不断被人捉弄和羞辱。&emsp;&emsp;在这部剧中，福斯塔夫的外表和个性与他在《亨利四世》中没有太大差别，但是，莎士比亚对他的态度更多的是批评。作者赋予了福斯塔夫浓厚的封建寄生色彩，将没落贵族的腐朽与虚荣表现得淋漓尽致。在《温莎的风流娘儿们》中，莎士比亚将女性人物塑造得光采照人，反映出在文艺复兴之后，欧洲社会尊重和歌颂女性，赞美爱情的社会风尚。&emsp;&emsp;需要指出的是，莎士比亚是一位人文主义大师，他所有的作品中都体现出人文主义的光辉。人们甚至觉得他给自己起Shakespeare这个笔名就是“摇（shake）、矛（spear）”两字的意思，也就是为人文主义摇旗呐喊。&emsp;&emsp;莎士比亚通过福斯塔夫这个滑稽的形象，让我们用另一种视角看待生活。比如在《亨利四世》中，贵族霍茨波视荣誉为生命，福斯塔夫却问：“荣誉能够替我重装一条腿吗？”大法官劝他说：“头上的白发提醒你做一个老成持重的人。”他的回答却是：“它提醒我生命无常，应该多吃吃喝喝。”&emsp;&emsp;莎士比亚在福斯塔夫这个丑角身上，不仅注入了旺盛的生命力，而且寄托了自己对自由的向往和对秩序的嘲讽和颠覆。福斯塔夫那种欢乐的天性一直伴随着人类走到今天，也是我们应该有的。&emsp;&emsp;世界上有两种富翁，一种是愁眉苦脸的，另一种是吹着口哨的。他们的差别不在于口袋里钱的多少，而在于天性是否快乐。新年到了，大家不妨打起响指，吹起口哨，过好当下的生活。&emsp;&emsp;欢迎你在留言区，写下自己的新年愿望，再次祝大家新年快乐。</details></a²+b²。></details></100,000，那么算法b更好，否则就是算法a好。比如，n是20万时，a方案就相当于10万*20万，b方案相当于20万*20万，可见b是很大的。></details></1，比如我们不希望谣言扩散，时间会让r逐步下降，这时要做的事情是千万不要挑起新的事端，火上浇油。></1，它就是收敛的，多少项加到一起，它也是一个有限的数字。></1，无论怎么传播，无论一开始花多少钱让a0变得很大，读的人数都有限。比如，第一批读者是5000人（不算少了），接下来r=1></1时，它就收敛，加起来是一个有限的数。></1时，上面这个式子虽然加了无穷多项，但到后面都是零点几这样的小数的次方，只能是越乘越小，所以总和是一个有限的数（a*k*p></details></details>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="吴军" scheme="https://hejtao.netlify.com/tags/%E5%90%B4%E5%86%9B/"/>
    
      <category term="数学" scheme="https://hejtao.netlify.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="电子书" scheme="https://hejtao.netlify.com/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>MySQL是怎样运行的：从根儿上理解 MySQL</title>
    <link href="https://hejtao.netlify.com/2019/09/20/2019-9-20/"/>
    <id>https://hejtao.netlify.com/2019/09/20/2019-9-20/</id>
    <published>2019-09-19T16:00:00.000Z</published>
    <updated>2020-12-16T15:26:18.965Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><meta name="referrer" content="no-referrer"></p><div class="toc"><!-- toc --><ul><li><a href="#chong-xin-ren-shi-mysql">重新认识MySQL</a><ul><li><a href="#ke-hu-duan-fu-wu-qi">客户端 + 服务器</a></li><li><a href="#qi-dong-fu-wu-qi-cheng-xu">启动服务器程序</a><ul><li><a href="#unix">UNIX</a></li><li><a href="#windows">Windows</a></li></ul></li><li><a href="#qi-dong-ke-hu-duan-cheng-xu">启动客户端程序</a></li><li><a href="#ke-hu-duan-yu-fu-wu-qi-de-tong-xin">客户端与服务器的通信</a><ul><li><a href="#tcp-ip">TCP/IP</a></li><li><a href="#ming-ming-guan-dao-he-gong-xiang-nei-cun">命名管道和共享内存</a></li><li><a href="#unix-yu-tao-jie-zi-wen-jian">UNIX域套接字文件</a></li></ul></li><li><a href="#fu-wu-qi-chu-li-ke-hu-duan-qing-qiu">服务器处理客户端请求</a></li><li><a href="#cun-chu-yin-qing">存储引擎</a></li></ul></li><li><a href="#qi-dong-xuan-xiang-he-xi-tong-bian-liang">启动选项和系统变量</a><ul><li><a href="#zai-ming-ling-xing-shang-shi-yong-xuan-xiang">在命令行上使用选项</a></li><li><a href="#pei-zhi-wen-jian-zhong-shi-yong-xuan-xiang">配置文件中使用选项</a><ul><li><a href="#windows-1">Windows</a></li><li><a href="#unix-1">UNIX</a></li></ul></li><li><a href="#xi-tong-bian-liang">系统变量</a><ul><li><a href="#cha-kan-xi-tong-bian-liang">查看系统变量</a></li><li><a href="#she-zhi-xi-tong-bian-liang">设置系统变量</a></li></ul></li><li><a href="#zhuang-tai-bian-liang">状态变量</a></li></ul></li><li><a href="#zi-fu-ji-he-bi-jiao-gui-ze">字符集和比较规则</a><ul><li><a href="#zi-fu-ji-de-zhuan-huan">字符集的转换</a></li></ul></li><li><a href="#innodb-ji-lu-cun">InnoDB记录存</a><ul><li><a href="#innodb-ye">InnoDB页</a></li><li><a href="#innodb-xing-ge-shi">InnoDB行格式</a><ul><li><a href="#compact-xing-ge-shi">Compact行格式</a></li><li><a href="#xing-shu-ju-yi-chu">行数据溢出</a></li><li><a href="#xing-yi-chu-de-lin-jie-dian">行溢出的临界点</a></li></ul></li></ul></li><li><a href="#innodb-shu-ju-ye">InnoDB数据页</a><ul><li><a href="#shu-ju-ye-jie-gou">数据页结构</a></li><li><a href="#ji-lu-zai-ye-zhong-de-cun-chu">记录在页中的存储</a><ul><li><a href="#ji-lu-tou-xin-xi">记录头信息</a></li></ul></li><li><a href="#page-directory">Page Directory</a></li><li><a href="#page-header">Page Header</a></li><li><a href="#file-header">File Header</a></li><li><a href="#file-trailer">File Trailer</a></li></ul></li><li><a href="#b-shu-suo-yin">B+树索引</a><ul><li><a href="#wu-suo-yin-cha-zhao">无索引查找</a><ul><li><a href="#zai-ye-nei-cha-zhao">在页内查找</a></li><li><a href="#zai-duo-ye-zhong-cha-zhao">在多页中查找</a></li></ul></li><li><a href="#suo-yin">索引</a><ul><li><a href="#mu-lu-xiang">目录项</a></li><li><a href="#yong-ye-cun-fang-mu-lu-xiang">用页存放目录项</a></li><li><a href="#ju-cu-suo-yin">聚簇索引</a></li><li><a href="#er-ji-suo-yin">二级索引</a></li></ul></li></ul></li><li><a href="#b-shu-suo-yin-de-shi-yong">B+树索引的使用</a><ul><li><a href="#he-li-shi-yong-suo-yin">合理使用索引</a><ul><li><a href="#quan-zhi-pi-pei">全值匹配</a></li><li><a href="#pi-pei-zuo-bian-de-lie">匹配左边的列</a></li><li><a href="#pi-pei-lie-qian-zhui">匹配列前缀</a></li></ul></li><li><a href="#hui-biao-de-dai-jie">回表的代价</a><ul><li><a href="#er-ji-suo-yin-hui-biao-or-quan-biao-sao-ma">二级索引 + 回表 or 全表扫码</a></li><li><a href="#fu-gai-suo-yin">覆盖索引</a></li></ul></li><li><a href="#he-li-di-jian-li-suo-yin">合理地建立索引</a></li></ul></li><li><a href="#mysql-de-shu-ju-mu-lu">MySQL的数据目录</a><ul><li><a href="#shu-ju-ku-he-wen-jian-xi-tong-de-guan-xi">数据库和文件系统的关系</a></li><li><a href="#shu-ju-mu-lu">数据目录</a><ul><li><a href="#shu-ju-mu-lu-he-an-zhuang-mu-lu-de-qu-bie">数据目录和安装目录的区别</a></li><li><a href="#cha-zhao-shu-ju-mu-lu">查找数据目录</a></li></ul></li><li><a href="#shu-ju-mu-lu-de-jie-gou">数据目录的结构</a><ul><li><a href="#shu-ju-ku-zai-wen-jian-xi-tong-zhong-de-biao-shi">数据库在文件系统中的表示</a></li><li><a href="#biao-zai-wen-jian-xi-tong-zhong-de-biao-shi">表在文件系统中的表示</a></li></ul></li><li><a href="#wen-jian-xi-tong-dui-shu-ju-ku-de-ying-xiang">文件系统对数据库的影响</a></li><li><a href="#mysql-xi-tong-shu-ju-ku-jian-jie">MySQL系统数据库简介</a></li></ul></li><li><a href="#innodb-biao-kong-jian">InnoDB表空间</a><ul><li><a href="#shu-ju-ye">数据页</a><ul><li><a href="#ye-lei-xing">页类型</a></li><li><a href="#ye-tong-yong-jie-gou">页通用结构</a></li></ul></li><li><a href="#du-li-biao-kong-jian-jie-gou">独立表空间结构</a><ul><li><a href="#qu-extent-de-gai-nian">区（extent）的概念</a></li><li><a href="#duan-segment-de-gai-nian">段（segment）的概念</a></li></ul></li></ul></li><li><a href="#dan-biao-fang-wen-fang-fa">单表访问方法</a></li></ul><!-- tocstop --></div><p>本文为敝人的学习记录，感兴趣的请在掘金小册购买同名原著 8-)</p><h2><span id="chong-xin-ren-shi-mysql">重新认识MySQL</span><a href="#chong-xin-ren-shi-mysql" class="header-anchor">#</a></h2><h3><span id="ke-hu-duan-fu-wu-qi">客户端 + 服务器</span><a href="#ke-hu-duan-fu-wu-qi" class="header-anchor">#</a></h3><p>MySQL服务器进程(也叫数据库实例)<br>MySQL客户端进程</p><p>进程：进程号(PID，由操作系统随机分配)、进程名称</p><p>MySQL服务器进程的默认名称为mysqld，<br>MySQL客户端进程的默认名称为mysql</p><h3><span id="qi-dong-fu-wu-qi-cheng-xu">启动服务器程序</span><a href="#qi-dong-fu-wu-qi-cheng-xu" class="header-anchor">#</a></h3><h4><span id="unix">UNIX</span><a href="#unix" class="header-anchor">#</a></h4><p>使用安装目录下(比如 <code>/usr/local/mysql/bin/</code>):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld_safe</span><br></pre></td></tr></table></figure><p><code>mysqld_safe</code>是一个启动脚本的命令，调用了<code>mysqld</code>，并启动一个监控进程(重启，日志)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql.server start</span><br><span class="line">ysql.server stop</span><br></pre></td></tr></table></figure><p><code>mysql.server</code>是一个链接文件， 会调用<code>mysqld_safe</code></p><h4><span id="windows">Windows</span><a href="#windows" class="header-anchor">#</a></h4><p>使用安装目录下(比如 <code>D:\Program Files\mysql-5.7.26-winx64\bin\</code>) <code>mysqld.exe</code> 可执行文件</p><p>使用 Windows服务。把某个程序注册为Windows服务的格式：<br>“可执行文件路径” —install [-manual] [服务名称]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\Program Files\mysql-5.7.26-winx64\bin\mysqld --install [MySQL_Service]</span><br><span class="line">net start MySQL_Service</span><br><span class="line">net stop MySQL_Service</span><br></pre></td></tr></table></figure></p><h3><span id="qi-dong-ke-hu-duan-cheng-xu">启动客户端程序</span><a href="#qi-dong-ke-hu-duan-cheng-xu" class="header-anchor">#</a></h3><p>mysql -h主机名  -u用户名 -p密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -hlocalhost  -uroot -p123abc</span><br><span class="line">mysql -u root -p</span><br><span class="line">mysql --host=localhost  --user=root --password=123abc</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-c583b0a1eabe5ff6.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>退出客户端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br><span class="line">exit</span><br><span class="line">\q</span><br></pre></td></tr></table></figure></p><h3><span id="ke-hu-duan-yu-fu-wu-qi-de-tong-xin">客户端与服务器的通信</span><a href="#ke-hu-duan-yu-fu-wu-qi-de-tong-xin" class="header-anchor">#</a></h3><p>本质是两个进程间的通信</p><h4><span id="tcp-ip">TCP/IP</span><a href="#tcp-ip" class="header-anchor">#</a></h4><p>每台计算机都有一个唯一的IP地址<br>每个进程向操作系统申请一个端口号(0~65535)<br>通过IP地址 + 端口号来与某个进程通信<br>MySQL服务器进程的默认端口号为3306，自定义MySQL服务器进程的端口号如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld -P3307</span><br></pre></td></tr></table></figure></p><h4><span id="ming-ming-guan-dao-he-gong-xiang-nei-cun">命名管道和共享内存</span><a href="#ming-ming-guan-dao-he-gong-xiang-nei-cun" class="header-anchor">#</a></h4><p>Windows系统中的进程间通信方式</p><p>命名管道<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysqld --enable-named-pipe</span><br><span class="line"></span><br><span class="line">mysql --pipe</span><br><span class="line">or</span><br><span class="line">mysql --protocol=pipe</span><br></pre></td></tr></table></figure></p><p>共享内存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqld --shared-memory</span><br><span class="line"></span><br><span class="line">mysql --protocol=memory</span><br></pre></td></tr></table></figure></p><h4><span id="unix-yu-tao-jie-zi-wen-jian">UNIX域套接字文件</span><a href="#unix-yu-tao-jie-zi-wen-jian" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --protocol=socket</span><br></pre></td></tr></table></figure><p>服务器程序默认监听的套接字文件路径为<code>/tmp/mysql.sock</code>，指定套接字文件路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqld --socket=/tmp/a.txt</span><br><span class="line">mysql -hlocalhost -uroot --socket=/tmp/a.txt -p</span><br></pre></td></tr></table></figure></p><h3><span id="fu-wu-qi-chu-li-ke-hu-duan-qing-qiu">服务器处理客户端请求</span><a href="#fu-wu-qi-chu-li-ke-hu-duan-qing-qiu" class="header-anchor">#</a></h3><p><img src="https://upload-images.jianshu.io/upload_images/1863961-a6bef812a91553aa.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3><span id="cun-chu-yin-qing">存储引擎</span><a href="#cun-chu-yin-qing" class="header-anchor">#</a></h3><p><img src="https://upload-images.jianshu.io/upload_images/1863961-b31ff09869340b51.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><code>XA</code>列代表是否支持分布式事务<br><code>Savepoints</code>代表是否支持部分事务回滚</p><h2><span id="qi-dong-xuan-xiang-he-xi-tong-bian-liang">启动选项和系统变量</span><a href="#qi-dong-xuan-xiang-he-xi-tong-bian-liang" class="header-anchor">#</a></h2><h3><span id="zai-ming-ling-xing-shang-shi-yong-xuan-xiang">在命令行上使用选项</span><a href="#zai-ming-ling-xing-shang-shi-yong-xuan-xiang" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqld --skip-networking</span><br><span class="line">mysqld --default-storage-engine=MyISAM \\ 等号两边不能有空格</span><br></pre></td></tr></table></figure><p>使用<code>mysql --help</code>可以看到mysql程序支持的启动选项<br>使用<code>mysqld --verbose --help</code>查看mysqld支持的启动选项</p><h3><span id="pei-zhi-wen-jian-zhong-shi-yong-xuan-xiang">配置文件中使用选项</span><a href="#pei-zhi-wen-jian-zhong-shi-yong-xuan-xiang" class="header-anchor">#</a></h3><h4><span id="windows">Windows</span><a href="#windows" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%WINDIR%\my.ini</span><br><span class="line">%WINDIR%\my.cnf</span><br><span class="line"></span><br><span class="line">C:\my.ini</span><br><span class="line">C:\my.cnf</span><br><span class="line"></span><br><span class="line">BASEDIR\my.ini  \\ MySQL安装路径</span><br><span class="line">BASEDIR\my.cnf</span><br><span class="line"></span><br><span class="line">defaults-extra-file命令行指定的额外配置文件路径，如</span><br><span class="line">mysqld --defaults-extra-file=C:\Users\chiangtao ho\my_extra_file.txt</span><br><span class="line"></span><br><span class="line">%APPDATA%\MySQL\.mylogin.cnf登录路径选项（仅限客户端）</span><br></pre></td></tr></table></figure><h4><span id="unix">UNIX</span><a href="#unix" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/etc/my.cnf</span><br><span class="line">/etc/mysql/my.cnf</span><br><span class="line">SYSCONFDIR/my.cnf</span><br><span class="line">$MYSQL_HOME/my.cnf特定于服务器的选项（仅限服务器）</span><br><span class="line"></span><br><span class="line">defaults-extra-file</span><br><span class="line"></span><br><span class="line">~/.my.cnf用户特定选项</span><br><span class="line"></span><br><span class="line">~/.mylogin.cnf用户特定的登录路径选项（仅限客户端）</span><br></pre></td></tr></table></figure><h3><span id="xi-tong-bian-liang">系统变量</span><a href="#xi-tong-bian-liang" class="header-anchor">#</a></h3><h4><span id="cha-kan-xi-tong-bian-liang">查看系统变量</span><a href="#cha-kan-xi-tong-bian-liang" class="header-anchor">#</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">like</span> <span class="string">'max_connections'</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'default%'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>系统变量的单词之间必须使用下划线_连接</p></blockquote><h4><span id="she-zhi-xi-tong-bian-liang">设置系统变量</span><a href="#she-zhi-xi-tong-bian-liang" class="header-anchor">#</a></h4><p>变量的作用范围<br><strong>GLOBAL</strong>：全局变量，影响服务器的整体操作<br><strong>SESSION (LOCAL)</strong>：会话变量，影响某个客户端连接的操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> default_storage_engine = MyISAM;</span><br><span class="line"><span class="keyword">SET</span> @@GLOBAL.default_storage_engine = MyISAM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> default_storage_engine = MyISAM;</span><br><span class="line"><span class="keyword">SET</span> @@SESSION.default_storage_engine = MyISAM;</span><br><span class="line"><span class="keyword">SET</span> default_storage_engine = MyISAM; \\ 默认作用范围是LOCAL</span><br></pre></td></tr></table></figure><blockquote><p>那我们的SHOW VARIABLES语句默认查看的是SESSION作用范围的系统变量<br>并不是所有系统变量都具有GLOBAL和SESSION的作用范围</p></blockquote><h3><span id="zhuang-tai-bian-liang">状态变量</span><a href="#zhuang-tai-bian-liang" class="header-anchor">#</a></h3><p>与系统变量类似，状态变量也有GLOBAL和SESSION两个作用范围的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'thread%'</span>;</span><br></pre></td></tr></table></figure></p><h2><span id="zi-fu-ji-he-bi-jiao-gui-ze">字符集和比较规则</span><a href="#zi-fu-ji-he-bi-jiao-gui-ze" class="header-anchor">#</a></h2><p>查看字符集<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CHARSET</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span>;</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-7c37618995aa0d2a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>Default collation</strong>表示字符集默认的比较规则<br><strong>Maxlen</strong>代表该字符集表示一个字符最多需要几个字节</p><p>查看比较规则<br><img src="https://upload-images.jianshu.io/upload_images/1863961-434c1321853a6064.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-28b9ac453cbdcce8.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>MySQL中utf8是utf8mb3的别名，所以在MySQL中utf8就意味着使用1~3个字节来表示一个字符，如果大家有使用4字节编码一个字符的情况，比如存储一些emoji表情，使用utf8mb4</p></blockquote><p>MySQL有4个级别的字符集和比较规则，分别是：<br>服务器级别 <code>character_set_server</code>, <code>collation_server</code></p><p>数据库级别 <code>character_set_database</code>, <code>collation_database</code></p><p>表级别</p><p>列级别</p><blockquote><p>编码和解码使用的字符集不一致将导致乱码</p></blockquote><h3><span id="zi-fu-ji-de-zhuan-huan">字符集的转换</span><a href="#zi-fu-ji-de-zhuan-huan" class="header-anchor">#</a></h3><p><code>character_set_client</code> 服务器解码请求语句时使用的字符集</p><p><code>character_set_connection</code>    服务器处理请求时会把请求字符串从<code>character_set_client</code>转为<code>character_set_connection</code></p><p><code>character_set_results</code>    服务器向客户端返回数据时使用的字符集</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-d6053a1496be0af5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>通常把 <code>character_set_client</code> 、<code>character_set_connection</code>、<code>character_set_results</code> 这三个系统变量设置成和客户端使用的相同的字符集</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">NAMES</span> 字符集名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> character_set_client = 字符集名;</span><br><span class="line"><span class="keyword">SET</span> character_set_connection = 字符集名;</span><br><span class="line"><span class="keyword">SET</span> character_set_results = 字符集名;</span><br></pre></td></tr></table></figure><h2><span id="innodb-ji-lu-cun">InnoDB记录存</span><a href="#innodb-ji-lu-cun" class="header-anchor">#</a></h2><h3><span id="innodb-ye">InnoDB页</span><a href="#innodb-ye" class="header-anchor">#</a></h3><p>InnoDB是一个将表中的数据存储到磁盘上的存储引擎。磁盘读写的速度比内存的读写速度差了几个数量级，因此设计InnoDB时将数据划分为若干个页并以页作为磁盘和内存之间交互的基本单位，页的大小一般为 16 KB。</p><h3><span id="innodb-xing-ge-shi">InnoDB行格式</span><a href="#innodb-xing-ge-shi" class="header-anchor">#</a></h3><p>4种行格式:</p><p>Compact</p><p>Redundant</p><p>Dynamic</p><p>Compressed</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 ROW_FORMAT=行格式名称</span><br></pre></td></tr></table></figure><h4><span id="compact-xing-ge-shi">Compact行格式</span><a href="#compact-xing-ge-shi" class="header-anchor">#</a></h4><p><img src="https://upload-images.jianshu.io/upload_images/1863961-769f50ea36079f99.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>所有变长字段的真实数据占用的字节长度都被存放在<strong>变长字段长度列表</strong><br>把值为NULL的列统一存储到<strong>NULL值列表</strong>中<br><strong>记录头信息</strong>是由固定的5个字节组成</p><blockquote><p>MySQL会为每个记录默认的添加一些列（隐藏列），包括：<strong>row_id</strong>（DB_ROW_ID）、<strong>transaction_id</strong>（DB_TRX_ID）、<strong>roll_pointer</strong>（DB_ROLL_PTR）。</p></blockquote><h4><span id="xing-shu-ju-yi-chu">行数据溢出</span><a href="#xing-shu-ju-yi-chu" class="header-anchor">#</a></h4><p><img src="https://upload-images.jianshu.io/upload_images/1863961-a7e5ed104feb0ad1.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于MySQL的每条记录，除了BLOB或者TEXT类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节。这个65535个字节除了列本身的数据之外，还包括一些其他的数据，即</p><ul><li>真实数据本身</li><li>真实数据占用字节的长度标识（&lt;= 2 bytes）</li><li>NULL值标识（&lt;= 1 byte），当列都有NOT NULL属性时为0</li></ul><p>因此，上图中设置变长类型<code>VARCHAR(M)</code>（M表示允许的字符数量）M=65535时导致了溢出。</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-0e1da580a7f2aa45.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>真实数据：65533 = 65529(c1)+ 4(c2)</p><p>长度标识：2</p><p>NULL值标识：1</p><p>共65536 &gt; 65535溢出。</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-f0eb4612f6ec51fd.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>更换字符集后溢出。</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-58720a826df6d70e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>VARCHAR(M)类型的列就最多可以存储65533个字节，而一个页的大小一般是16KB，也就是16384字节，因此在Compact和Reduntant行格式中，在本记录只会存储该列的前768个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中；而在Dynamic和Compressed行格式中，记录中只存储其他页的地址。</p><h4><span id="xing-yi-chu-de-lin-jie-dian">行溢出的临界点</span><a href="#xing-yi-chu-de-lin-jie-dian" class="header-anchor">#</a></h4><p>MySQL中规定一个页中至少要存放两行记录</p><ul><li>每个页除了存放记录外，也需要存储一些额外的信息，这些额外信息加起来需要132个字节</li><li>每个记录的额外信息需要27字节<ul><li>真实数据的长度标识 1B</li><li>NULL值标识 1B</li><li>记录头信息 5B</li><li>row_id 6B</li><li>transaction_id 6B</li><li>roll_pointer 7B</li></ul></li></ul><blockquote><p>不溢出的临界条件：132 + 2×(27 + n) &lt; 16384</p></blockquote><h2><span id="innodb-shu-ju-ye">InnoDB数据页</span><a href="#innodb-shu-ju-ye" class="header-anchor">#</a></h2><h3><span id="shu-ju-ye-jie-gou">数据页结构</span><a href="#shu-ju-ye-jie-gou" class="header-anchor">#</a></h3><p><img src="https://upload-images.jianshu.io/upload_images/1863961-7b48bacba1c08eed.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3><span id="ji-lu-zai-ye-zhong-de-cun-chu">记录在页中的存储</span><a href="#ji-lu-zai-ye-zhong-de-cun-chu" class="header-anchor">#</a></h3><p><img src="https://upload-images.jianshu.io/upload_images/1863961-c4157ce34c34235e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4><span id="ji-lu-tou-xin-xi">记录头信息</span><a href="#ji-lu-tou-xin-xi" class="header-anchor">#</a></h4><p>以 page_demo 表为例<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> page_demo(</span><br><span class="line">    c1 <span class="built_in">INT</span>,</span><br><span class="line">    c2 <span class="built_in">INT</span>,</span><br><span class="line">    c3 <span class="built_in">VARCHAR</span>(<span class="number">10000</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (c1)</span><br><span class="line">) <span class="keyword">CHARSET</span>=<span class="keyword">ascii</span> ROW_FORMAT=<span class="keyword">Compact</span>;</span><br></pre></td></tr></table></figure></p><p><img src="/images/1.PNG" alt=""></p><p>由于指定 c1 为主键，所以在行格式中就没有隐藏列 row_id。</p><p>插入数据4条记录<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="string">'aaaa'</span>),</span><br><span class="line">    (<span class="number">2</span>, <span class="number">200</span>, <span class="string">'bbbb'</span>),</span><br><span class="line">    (<span class="number">3</span>, <span class="number">300</span>, <span class="string">'cccc'</span>),</span><br><span class="line">    (<span class="number">4</span>, <span class="number">400</span>, <span class="string">'dddd'</span>);</span><br></pre></td></tr></table></figure></p><p><img src="/images/2.PNG" alt=""></p><ul><li><p>delete_mask</p><p>  标记当前记录是否被删除，值为0的时候代表记录没有被删除，1则被删除了；<br>  所有被删的记录会组成一个<strong>垃圾链表</strong>，新记录插入到表时可以覆盖这些被删除的记录占用的存储空间。</p></li><li><p>n_owned</p><p>  见<a href="#page-directory">Page Directory</a></p></li><li><p>heap_no</p><p>  表示当前记录在本页中的位置，从上图中可以看出，插入的4条记录在本页中的位置分别是：2、3、4、5。最小记录和最大记录分别为0、1。</p><p>  <img src="/images/3.PNG" alt=""></p></li><li><p>record_type</p><p>  记录类型，共4种：</p><p>  0：普通记录</p><p>  1：B+树非叶节点记录 （或目录项记录，见<a href="#mu-lu-xiang">目录项</a>）</p><p>  2：最小记录</p><p>  3：最大记录</p><ul><li><p>min_rec_mask</p><p>代表B+树的每层非叶节点中的最小记录 （或者主键值最小的目录项记录的min_rec_mask值为1）</p></li></ul></li><li><p>next_record</p><p>  表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。例如第一条记录的next_record值为32，意味着从第一条记录的真实数据的地址处向后找32个字节便是下一条记录的真实数据。记录按照主键从小到大的顺序形成了一个单链表</p><p>  <img src="/images/4.PNG" alt=""></p></li></ul><p>如果删除第二条记录<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> page_demo <span class="keyword">WHERE</span> c1 = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p><img src="/images/5.PNG" alt=""></p><p>删除第2条记录前后的主要变化：</p><ul><li>第2条记录的delete_mask值设置为1；</li><li>第2条记录的next_record值变为了0，意味着该记录没有下一条记录了；</li><li>第1条记录的next_record指向了第3条记录；</li><li>最大记录的n_owned值从5变成了4。</li></ul><h3><span id="page-directory">Page Directory</span><a href="#page-directory" class="header-anchor">#</a></h3><p>设计页目录是为了方便快速查找记录，就像书的目录那样，创建 page directory 的步骤：</p><ul><li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组；</li><li>每个组内最大的那条记录的头信息的 n_owned 表示组内记录的数量；</li><li>将每个组的最大的那条记录的地址偏移量（也称槽，slot）集中起来存放，构成 Page Directory；</li></ul><p><img src="/images/6.PNG" alt=""></p><p>InnoDB规定最小记录所在的分组只能有 1 条记录，最大记录所在的分组的记录条数在 1~8 条之间，其它分组中记录的条数则在是 4~8 条之间。</p><p>利用页目录查找指定主键的记录的过程分为两步：</p><ul><li>通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录；</li><li>通过记录的 next_record 属性遍历组中的各个记录。</li></ul><h3><span id="page-header">Page Header</span><a href="#page-header" class="header-anchor">#</a></h3><p>存储数据的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等。</p><h3><span id="file-header">File Header</span><a href="#file-header" class="header-anchor">#</a></h3><p>不同类型的页都会以File Header作为第一个组成部分，它记录了针对各种页都通用的一些信息。<br>索引页（数据页）通过 file header 构成双向链表</p><p><img src="/images/7.PNG" alt=""></p><h3><span id="file-trailer">File Trailer</span><a href="#file-trailer" class="header-anchor">#</a></h3><p>与file header一样对不同类型的页通用，主要用于校验页数据的完整性。</p><h2><span id="b-shu-suo-yin">B+树索引</span><a href="#b-shu-suo-yin" class="header-anchor">#</a></h2><h3><span id="wu-suo-yin-cha-zhao">无索引查找</span><a href="#wu-suo-yin-cha-zhao" class="header-anchor">#</a></h3><h4><span id="zai-ye-nei-cha-zhao">在页内查找</span><a href="#zai-ye-nei-cha-zhao" class="header-anchor">#</a></h4><ul><li><p>以主键查找<br>  依据页目录（槽）采用二分查找定位分组，再遍历分组</p></li><li><p>以主键以外的列查找<br>  遍历页内的记录链表</p></li></ul><h4><span id="zai-duo-ye-zhong-cha-zhao">在多页中查找</span><a href="#zai-duo-ye-zhong-cha-zhao" class="header-anchor">#</a></h4><ul><li>定位记录所在的页</li><li>页内查找</li></ul><h3><span id="suo-yin">索引</span><a href="#suo-yin" class="header-anchor">#</a></h3><p>建立索引是为了快速定位记录所在的数据页。</p><ul><li>对数据页进行排序。即让下一个数据页的记录的主键值大于上一个页的记录的主键值，因此在插入新的记录时涉及数据页间的记录的调整<br>  <img src="/images/8.PNG" alt=""></li></ul><blockquote><p>对页进行排序后，全部记录的主键值就构成了一个递增的序列，从而可以利用二分法实现快速查找。</p></blockquote><ul><li>对每个页设置目录项</li></ul><h4><span id="mu-lu-xiang">目录项</span><a href="#mu-lu-xiang" class="header-anchor">#</a></h4><p>目录项包括</p><ul><li>数据页中的记录的最小主键值，用key来表示；</li><li>页号，用page_no表示。</li></ul><p><img src="/images/9.PNG" alt=""></p><h4><span id="yong-ye-cun-fang-mu-lu-xiang">用页存放目录项</span><a href="#yong-ye-cun-fang-mu-lu-xiang" class="header-anchor">#</a></h4><p><img src="/images/10.PNG" alt=""><br><img src="/images/11.PNG" alt=""><br><img src="/images/12.PNG" alt=""></p><p>用户记录都存放在B+树的叶节点上，而目录项都存放在非页节点上。</p><h4><span id="ju-cu-suo-yin">聚簇索引</span><a href="#ju-cu-suo-yin" class="header-anchor">#</a></h4><p>特性包括：</p><ol><li>依据记录的主键值排序<ul><li>页内的记录是按照主键的大小顺序排成一个单向链表</li><li>数据页根据主键大小顺序排成一个双向链表</li><li>存放目录项记录的页根据主键大小分为不同的层次</li></ul></li><li>B+树的叶节点存储的是完整的记录，即记录的所有列的值（包括隐藏列）</li></ol><h4><span id="er-ji-suo-yin">二级索引</span><a href="#er-ji-suo-yin" class="header-anchor">#</a></h4><p>依据记录的其它列（比如c1）的值排序形成的B+树。将聚簇索引的主键值换为c1的值，此外，叶节点存储的不是完整的记录而只有主键和c1。</p><blockquote><p>通过二级索引来查找完整记录：通过二级索引找到主键值之后再通过聚簇索引查找完整记录。</p></blockquote><h2><span id="b-shu-suo-yin-de-shi-yong">B+树索引的使用</span><a href="#b-shu-suo-yin-de-shi-yong" class="header-anchor">#</a></h2><h3><span id="he-li-shi-yong-suo-yin">合理使用索引</span><a href="#he-li-shi-yong-suo-yin" class="header-anchor">#</a></h3><p>考虑表 person_info<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_info(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    birthday <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    phone <span class="built_in">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    country <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">    <span class="keyword">KEY</span> idx_name_birthday_phone (<span class="keyword">name</span>, birthday, phone)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>idx_name_birthday_phone 为二级索引<br><img src="/images/13.PNG" alt=""></p><h4><span id="quan-zhi-pi-pei">全值匹配</span><a href="#quan-zhi-pi-pei" class="header-anchor">#</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span> <span class="keyword">AND</span> birthday = <span class="string">'1990-09-27'</span> <span class="keyword">AND</span> phone = <span class="string">'15123983239'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>由于查询优化器的存在，调换name、birthday、phone这几个搜索列的顺序<strong>不影响</strong>查询的执行过程。</p></blockquote><h4><span id="pi-pei-zuo-bian-de-lie">匹配左边的列</span><a href="#pi-pei-zuo-bian-de-lie" class="header-anchor">#</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span>;</span><br></pre></td></tr></table></figure><p>可以使用索引idx_name_birthday_phone，而</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> birthday = <span class="string">'1990-09-27'</span>;</span><br></pre></td></tr></table></figure><p>不能使用索引idx_name_birthday_phone。</p><h4><span id="pi-pei-lie-qian-zhui">匹配列前缀</span><a href="#pi-pei-lie-qian-zhui" class="header-anchor">#</a></h4><p>比如查询名字以 As 开头的记录<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'As%'</span>;</span><br></pre></td></tr></table></figure></p><h3><span id="hui-biao-de-dai-jie">回表的代价</span><a href="#hui-biao-de-dai-jie" class="header-anchor">#</a></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> &gt; <span class="string">'Asa'</span> <span class="keyword">AND</span> <span class="keyword">name</span> &lt; <span class="string">'Barlow'</span>;</span><br></pre></td></tr></table></figure><p>二级索引搜索到的结果（即值在Asa～Barlow之间的记录）在磁盘中的存储是相连的，集中分布在一个或几个数据页中，因此可以很快从磁盘中读出，这种读取方式可以称为顺序I/O。而回表是根据不连续的id值到聚簇索引中读出完整的用户记录（可能分布在不同的数据页中），这种读取方式可以称为随机I/O。一般情况下，顺序I/O比随机I/O的性能高很多。</p><h4><span id="er-ji-suo-yin-hui-biao-or-quan-biao-sao-ma">二级索引 + 回表 or 全表扫码</span><a href="#er-ji-suo-yin-hui-biao-or-quan-biao-sao-ma" class="header-anchor">#</a></h4><p>需要回表的记录越多，使用二级索引的性能就越低，甚至不如使用聚簇索引全表扫码；</p><p>使用<code>LIMIT</code>限制回表次数，使优化器倾向于使用二级索引 + 回表的方式执行查询。</p><h4><span id="fu-gai-suo-yin">覆盖索引</span><a href="#fu-gai-suo-yin" class="header-anchor">#</a></h4><p>如果需要查询的列包含在二级索引中，就可以避免回表查询，这种只需要用到索引的查询方式称为索引覆盖。例如对于索引idx_name_birthday_phone<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, birthday, phone <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> &gt; <span class="string">'Asa'</span> <span class="keyword">AND</span> <span class="keyword">name</span> &lt; <span class="string">'Barlow'</span></span><br></pre></td></tr></table></figure></p><h3><span id="he-li-di-jian-li-suo-yin">合理地建立索引</span><a href="#he-li-di-jian-li-suo-yin" class="header-anchor">#</a></h3><ul><li><p>只给搜索、排序、分组的列创建索引</p><p>  即只给出现在 WHERE、ORDER BY、GROUP BY 子句中的列创建索引；</p></li><li><p>列的方差越大越适合建立索引</p><p>  列的数据越分散，越适合索引查询。举个极端的例子，数据都相同的列，对这样的列建立索引毫无意义；</p></li><li><p>列的数据类型越小越适合建立索引</p><p>  比较数据大小更快，占用的存储空间更小；</p></li><li><p>索引字符串的前缀</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_info(</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    birthday <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    phone <span class="built_in">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    country <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">KEY</span> idx_name_birthday_phone (<span class="keyword">name</span>(<span class="number">10</span>), birthday, phone)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>  其中 name(10) 表示在建立的B+树索引中只保留记录的前10个字符的编码，但是该索引不支持 name 排序</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">name</span> <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>让索引列在比较表达式中单独出现</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WHERE my_col * 2 &lt; 4</span><br><span class="line">WHERE my_col &lt; 4/2</span><br></pre></td></tr></table></figure><p>  如果列是以某个表达式或者函数调用形式出现是用不到索引的，比如上面的<code>my_col * 2</code>；</p></li><li><p>开启主键AUTO_INCREMENT属性</p><p>  可减少页分裂和记录移位的次数。</p></li></ul><h2><span id="mysql-de-shu-ju-mu-lu">MySQL的数据目录</span><a href="#mysql-de-shu-ju-mu-lu" class="header-anchor">#</a></h2><h3><span id="shu-ju-ku-he-wen-jian-xi-tong-de-guan-xi">数据库和文件系统的关系</span><a href="#shu-ju-ku-he-wen-jian-xi-tong-de-guan-xi" class="header-anchor">#</a></h3><p>InnoDB、MyISAM等存储引擎都是把表存储在磁盘上。操作系统通过文件系统管理磁盘。</p><p>InnoDB、MyISAM等存储引擎 $ \Leftrightarrow $ 文件系统 $ \Leftrightarrow $ 磁盘</p><h3><span id="shu-ju-mu-lu">数据目录</span><a href="#shu-ju-mu-lu" class="header-anchor">#</a></h3><h4><span id="shu-ju-mu-lu-he-an-zhuang-mu-lu-de-qu-bie">数据目录和安装目录的区别</span><a href="#shu-ju-mu-lu-he-an-zhuang-mu-lu-de-qu-bie" class="header-anchor">#</a></h4><p>数据目录是用来存储MySQL在运行过程中产生的数据，要与MySQL的安装目录区别开来。</p><h4><span id="cha-zhao-shu-ju-mu-lu">查找数据目录</span><a href="#cha-zhao-shu-ju-mu-lu" class="header-anchor">#</a></h4><p><img src="/images/14.PNG" alt=""></p><h3><span id="shu-ju-mu-lu-de-jie-gou">数据目录的结构</span><a href="#shu-ju-mu-lu-de-jie-gou" class="header-anchor">#</a></h3><h4><span id="shu-ju-ku-zai-wen-jian-xi-tong-zhong-de-biao-shi">数据库在文件系统中的表示</span><a href="#shu-ju-ku-zai-wen-jian-xi-tong-zhong-de-biao-shi" class="header-anchor">#</a></h4><p>每新建一个数据库，MySQL执行了：</p><ul><li>在数据目录下创建一个和数据库名同名的子目录；</li><li>并在该子目录下创建一个db.opt文件，这个文件中包含了该数据库的各种属性，比方说该数据库的字符集和比较规则等。</li></ul><p>查看数据库<br><img src="/images/15.PNG" alt=""><br>查看数据目录<br><img src="/images/16.PNG" alt=""></p><p>除了information_schema这个系统数据库外，其他的数据库在数据目录下都有对应的子目录。</p><h4><span id="biao-zai-wen-jian-xi-tong-zhong-de-biao-shi">表在文件系统中的表示</span><a href="#biao-zai-wen-jian-xi-tong-zhong-de-biao-shi" class="header-anchor">#</a></h4><p>每个表包含两部分信息：</p><ul><li><p>表结构的定义</p><p>  用<code>表名.frm</code>文件来描述表结构</p></li><li><p>表中的数据</p><p>  InnoDB: 数据存在独立表空间(file-per-table tablespace)中，即 <code>test.ibd</code> 文件</p><p>  MyISAM: <code>表名.MYD</code>表示表的数据文件、<code>表名.MYI</code>表示表的索引文件</p></li></ul><h3><span id="wen-jian-xi-tong-dui-shu-ju-ku-de-ying-xiang">文件系统对数据库的影响</span><a href="#wen-jian-xi-tong-dui-shu-ju-ku-de-ying-xiang" class="header-anchor">#</a></h3><ul><li><p>数据库名和表名不得超过文件系统所允许的最大长度</p></li><li><p>特殊字符</p><p>  MySQL会把数据库名和表名中除<strong>数字</strong>和<strong>拉丁字母</strong>外的所有字符在文件名里都映射成 @+编码值的形式，如<code>test?.frm</code> $ \rightarrow $ <code>test@003f.frm</code></p></li><li><p>文件大小受文件系统限制 </p></li></ul><h3><span id="mysql-xi-tong-shu-ju-ku-jian-jie">MySQL系统数据库简介</span><a href="#mysql-xi-tong-shu-ju-ku-jian-jie" class="header-anchor">#</a></h3><ul><li><p>mysql</p><p>  存储了MySQL的账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息、以及时区信息等</p></li><li><p>information_schema</p><p>  这个数据库保存着MySQL服务器维护的所有其他数据库的信息，比如表、视图、触发器、列、索引等</p></li><li><p>performance_schema</p><p>  这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，包括统计最近执行的语句，执行时间，内存使用情况等</p></li><li><p>sys</p><p>  这个数据库主要是通过视图的形式把information_schema和performance_schema结合起来</p></li></ul><h2><span id="innodb-biao-kong-jian">InnoDB表空间</span><a href="#innodb-biao-kong-jian" class="header-anchor">#</a></h2><p>表空间对应着文件系统中一个或多个实际文件（独立表空间对应一个<code>表名.ibd</code>文件）。可以把表空间想象成一本书，当想为某个表插入一条记录的时候，就在书中对应的页来把数据写进去。</p><h3><span id="shu-ju-ye">数据页</span><a href="#shu-ju-ye" class="header-anchor">#</a></h3><h4><span id="ye-lei-xing">页类型</span><a href="#ye-lei-xing" class="header-anchor">#</a></h4><p><img src="/images/198.png" alt=""></p><h4><span id="ye-tong-yong-jie-gou">页通用结构</span><a href="#ye-tong-yong-jie-gou" class="header-anchor">#</a></h4><p><img src="/images/199.jpg" alt=""></p><p>File Header : 记录数据页的一些通用信息<br><img src="/images/200.png" alt=""></p><p>File Trailer：校验数据页，保证从内存到磁盘的数据的一致性</p><h3><span id="du-li-biao-kong-jian-jie-gou">独立表空间结构</span><a href="#du-li-biao-kong-jian-jie-gou" class="header-anchor">#</a></h3><h4><span id="qu-extent-de-gai-nian">区（extent）的概念</span><a href="#qu-extent-de-gai-nian" class="header-anchor">#</a></h4><p>数据页16KB</p><p>物理上连续的64个页就是一个区1MB</p><p>每256个区被划分成一组，每个组的最开始的几个页面类型是固定的</p><p>系统表空间或独立表空间由若干个区组成</p><p><img src="/images/201.jpg" alt=""></p><p><img src="/images/202.jpg" alt=""></p><p>为什么引入区的设计？</p><blockquote><p>区是连续的存储空间，这样可以减少随机I/O， 增加顺序I/O</p></blockquote><h4><span id="duan-segment-de-gai-nian">段（segment）的概念</span><a href="#duan-segment-de-gai-nian" class="header-anchor">#</a></h4><p>所以设计InnoDB的大叔们对B+树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段（segment），存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。</p><h2><span id="dan-biao-fang-wen-fang-fa">单表访问方法</span><a href="#dan-biao-fang-wen-fang-fa" class="header-anchor">#</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="长文" scheme="https://hejtao.netlify.com/tags/%E9%95%BF%E6%96%87/"/>
    
      <category term="MySQL" scheme="https://hejtao.netlify.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL Notes</title>
    <link href="https://hejtao.netlify.com/2019/09/05/2019-9-5/"/>
    <id>https://hejtao.netlify.com/2019/09/05/2019-9-5/</id>
    <published>2019-09-04T16:00:00.000Z</published>
    <updated>2020-12-23T13:16:07.232Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><meta name="referrer" content="no-referrer"></p><div class="toc"><!-- toc --><ul><li><a href="#lian-biao-cha-xun">联表查询</a></li><li><a href="#zi-fu-ti-huan">字符替换</a></li><li><a href="#zheng-ze-cha-xun">正则查询</a></li><li><a href="#dao-ru-sql-wen-jian">导入SQL文件</a></li><li><a href="#pai-xu">排序</a></li><li><a href="#shi-jian-zhuan-huan">时间转换</a></li><li><a href="#chang-yong-ming-ling">常用命令</a></li></ul><!-- tocstop --></div><h4><span id="lian-biao-cha-xun">联表查询</span><a href="#lian-biao-cha-xun" class="header-anchor">#</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> library.id, library.name, r.reader_sum, b.book_sum <span class="keyword">FROM</span> </span><br><span class="line"><span class="keyword">library</span> </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">( <span class="keyword">SELECT</span> library_id, <span class="keyword">count</span>(*) <span class="keyword">AS</span> reader_sum <span class="keyword">FROM</span> reader <span class="keyword">WHERE</span> library_group_id = <span class="number">10</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> library_id ) <span class="keyword">AS</span> r</span><br><span class="line"><span class="keyword">ON</span> r.library_id = library.id </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">( <span class="keyword">SELECT</span> library_id, <span class="keyword">count</span>( * ) <span class="keyword">AS</span> book_sum <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> library_group_id = <span class="number">10</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> library_id ) <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> b.library_id = library.id;</span><br></pre></td></tr></table></figure><h4><span id="zi-fu-ti-huan">字符替换</span><a href="#zi-fu-ti-huan" class="header-anchor">#</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> grade = <span class="keyword">replace</span>(grade,<span class="string">'級'</span>,<span class="string">'级'</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> reader <span class="keyword">SET</span> <span class="keyword">class</span> = <span class="keyword">REPLACE</span>(<span class="keyword">class</span>,<span class="built_in">CHAR</span>(<span class="number">13</span>),<span class="string">''</span>) <span class="keyword">WHERE</span> library_id = <span class="number">666</span>;</span><br><span class="line">char(9)    水平制表符</span><br><span class="line"></span><br><span class="line">char(10)   换行</span><br><span class="line"></span><br><span class="line">char(13)   回车</span><br></pre></td></tr></table></figure><h4><span id="zheng-ze-cha-xun">正则查询</span><a href="#zheng-ze-cha-xun" class="header-anchor">#</a></h4><p><img src="https://upload-images.jianshu.io/upload_images/1863961-2bcf89b08ee87c02.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> grade REGEXP <span class="string">'級'</span>; <span class="comment">-- 查询包含</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> <span class="keyword">name</span> REGEXP <span class="string">'^[aeiou]|ok$'</span>; <span class="comment">-- aeiou开头，或ok结尾</span></span><br></pre></td></tr></table></figure></p><h4><span id="dao-ru-sql-wen-jian">导入SQL文件</span><a href="#dao-ru-sql-wen-jian" class="header-anchor">#</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @@global.max_allowed_packet = <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @@global.sql_mode =<span class="string">'ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'</span>;</span><br><span class="line"><span class="keyword">SET</span> @@sql_mode =<span class="string">'ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'</span>;</span><br></pre></td></tr></table></figure><h4><span id="pai-xu">排序</span><a href="#pai-xu" class="header-anchor">#</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> library_id = <span class="number">257</span> <span class="keyword">AND</span> (title REGEXP <span class="string">"我"</span> <span class="keyword">OR</span> author REGEXP <span class="string">"我"</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">LOCATE</span>(<span class="string">"我"</span>, <span class="keyword">CONCAT</span>(title, author)), <span class="keyword">LENGTH</span>(title), <span class="keyword">LENGTH</span>(author);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">IN</span> (<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">field</span>(<span class="keyword">id</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span></span><br><span class="line">( <span class="keyword">SELECT</span> isbn13, cn_title, <span class="keyword">count</span>(*) total <span class="keyword">FROM</span> book_info <span class="keyword">WHERE</span> isbn13 != <span class="string">''</span> <span class="keyword">AND</span> <span class="keyword">source</span> <span class="keyword">IN</span> (<span class="string">'yidi'</span>, <span class="string">'guotu'</span>, <span class="string">'douban'</span>, <span class="string">'dangdang'</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> isbn13, cn_title ) t1</span><br><span class="line"><span class="keyword">WHERE</span> total &gt; <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> total <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h4><span id="shi-jian-zhuan-huan">时间转换</span><a href="#shi-jian-zhuan-huan" class="header-anchor">#</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">project</span> <span class="keyword">SET</span> start_time = <span class="keyword">date_format</span>(<span class="keyword">date_add</span>(from_unixtime(<span class="number">0</span>), <span class="built_in">INTERVAL</span> start_time_unix <span class="keyword">SECOND</span>),<span class="string">'%Y-%m-%d'</span>), end_time = <span class="keyword">date_format</span>(<span class="keyword">date_add</span>(from_unixtime(<span class="number">0</span>), <span class="built_in">INTERVAL</span> end_time_unix <span class="keyword">SECOND</span>),<span class="string">'%Y-%m-%d'</span>) <span class="keyword">WHERE</span> start_time = <span class="string">''</span> <span class="keyword">AND</span> end_time = <span class="string">''</span> <span class="keyword">AND</span> start_time_unix &gt; <span class="number">-62135625943</span> <span class="keyword">AND</span> end_time_unix &gt; <span class="number">-62135625943</span>;</span><br></pre></td></tr></table></figure><h4><span id="chang-yong-ming-ling">常用命令</span><a href="#chang-yong-ming-ling" class="header-anchor">#</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> hejtao <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> <span class="string">'utf8mb4'</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> hejtao <span class="keyword">COLLATE</span> <span class="string">'utf8mb4_general_ci'</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="SQL" scheme="https://hejtao.netlify.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>麻省理工 MapReduce 实验</title>
    <link href="https://hejtao.netlify.com/2019/04/30/2019-4-30/"/>
    <id>https://hejtao.netlify.com/2019/04/30/2019-4-30/</id>
    <published>2019-04-29T16:00:00.000Z</published>
    <updated>2019-11-11T19:59:33.204Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><meta name="referrer" content="no-referrer"></p><div class="toc"><!-- toc --><ul><li><a href="#mapreduce-zhi-xing-gai-shu">MapReduce执行概述</a></li><li><a href="#xu-yan-shou-xi-yuan-dai-ma">序言：熟悉源代码</a></li><li><a href="#part-i-map-reduce-shu-ru-he-shu-chu">Part I: Map/Reduce 输入和输出</a></li><li><a href="#part-ii-single-worker-dan-ci-tong-ji">Part II: Single-worker单词统计</a></li><li><a href="#part-iii-fen-bu-shi-mapreduce-ren-wu">Part III: 分布式 MapReduce 任务</a></li><li><a href="#part-iv-worker-cuo-wu-chu-li">Part IV: worker错误处理</a></li></ul><!-- tocstop --></div><p><a href="http://nil.csail.mit.edu/6.824/2018/labs/lab-1.html" target="_blank" rel="noopener">原文链接</a></p><h3><span id="mapreduce-zhi-xing-gai-shu">MapReduce执行概述</span><a href="#mapreduce-zhi-xing-gai-shu" class="header-anchor">#</a></h3><p><a href="http://nil.csail.mit.edu/6.824/2018/papers/mapreduce.pdf" target="_blank" rel="noopener">论文地址</a><br><img src="https://upload-images.jianshu.io/upload_images/1863961-e3049b9f4645a329.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/840" alt=""></p><p>通过自动将输入数据划分为$M$个片段，Map调用分布在多台机器上。 不同片段的输入数据可以由不同的机器并行处理。 Reduce调用的分布式则通过使用分区函数(即 $hash(key)$  $mod$  $R$)将键空间划分为$R$个部分来实现，$R$的大小和分区函数由用户指定。上图显示了MapReduce操作的总体流程。 当用户程序调用MapReduce函数时，会发生以下操作序列(图中的编号标签对应于下面的数字)：</p><ol><li>用户程序中的MapReduce库首先将输入文件拆分为16MB到64MB(用户可通过参数设置)的$M$个片段。 然后，它会在一组计算机上启动该程序的许多副本；</li><li>master为副本之一，其余的是由master分配工作的workers。 有$M$个Map任务和$R$个Reduce任务需要分配。master为每个空闲的worker分配一个Map任务或Reduce任务；</li><li>被分配Map任务的worker读取相应输入片段。 它从输入片段中解析键/值对，并将键/值对传递给用户定义的Map函数。 Map函数生成的中间键/值对缓存在内存中；</li><li>内存中的键\值对被周期性地写入到本地磁盘，并通过分区函数划分为$R$个分区。 键\值对在本地磁盘的位置将被传回到master，master再将位置信息转发给Reduce worker；</li><li>当Reduce worker收到来自master的位置信息后，它使用远程过程调用(RPC)从Map worker的本地磁盘读取缓冲数据。 当Reduce worker读取了所有中间数据时，它会根据中间键进行排序，以便将所有相同的中间键组合在一起。 之所以需要排序是因为通常有许多不同的键映射到同一个reduce任务。 如果中间数据量太大而无法容纳在内存中，则使用外部排序；</li><li>Reduce worker对排好序的中间数据进行遍历。对遇到的每个唯一中间键，它将键和相应的一组中间值传递给用户的Reduce函数。 Reduce函数的输出附加到此Reduce分区的最终输出文件。</li><li>完成所有Map任务和Reduce任务后，master会唤醒用户程序。 此时，用户程序中的MapReduce()将返回用户代码。</li></ol><h3><span id="xu-yan-shou-xi-yuan-dai-ma">序言：熟悉源代码</span><a href="#xu-yan-shou-xi-yuan-dai-ma" class="header-anchor">#</a></h3><p>提供的Map/Reduce代码支持两种操作模式，即串行和分布式。 在前者中，map和reduce任务每次执行一个：首先是第一个map任务执行完成，然后是第二个，然后是第三个，等等。当所有map任务完成后，执行第一个reduce任务，然后是第二个，等等。这种模式虽然不快，但方便调试。 分布式模式运行着许多worker线程，这些线程先并行执行map任务，然后reduce任务。 这要快得多，但也难以调试。mapreduce包提供了一个简单的Map/Reduce库。 应用程序通常调用<code>master.go</code>中的<code>Distributed()</code>来启动分布式模式，而调用<code>master.go</code>中的<code>Sequential()</code>来获取调试的串行执行。</p><p>代码如下执行：</p><ol><li>该应用程序提供了许多输入文件、一个<strong>map函数</strong>、一个<strong>reduce函数</strong>和<strong>reduce任务的数量</strong>（$nReduce$）；</li><li>创建master。 master启动一个RPC服务器(参见<code>master_rpc.go</code>)，并等待worker注册(使用RPC调用<code>Register()</code>，在<code>master.go</code>中定义)。 当任务变得可用时(在步骤4和5中)，<code>schedule()</code>(位于schedule.go)决定如何将这些任务分配给workers以及如何处理worker故障；</li><li>master将每个输入文件视为一个  Map任务，并为每个Map任务至少调用一次(at-least-once)<code>doMap()</code>(<code>common_map.go</code>)，可以通过直接使用<code>Sequential()</code>或通过向worker (<code>worker.go</code>)发出DoTask RPC来实现。每次调用<code>doMap()</code>都会读取适当的文件，调用该文件中的map函数，并将生成的键/值对写入$nReduce$个中间文件。doMap() 对每个键哈希化以便挑选中间文件和 将会处理键的reduce任务。 完成所有map任务后，将会有$nMap \times nReduce$个文件。 每个文件名都包含一个前缀，map任务编号和reduce任务编号。 如果有两个map任务和三个reduce任务，map任务将创建如下六个中间文件：<br><code>mrtmp.xxx-0-0</code><br><code>mrtmp.xxx-0-1</code><br><code>mrtmp.xxx-0-2</code><br><code>mrtmp.xxx-1-0</code><br><code>mrtmp.xxx-1-1</code><br><code>mrtmp.xxx-1-2</code><br>每个worker必须能够读取由任何其他worker写入的文件以及输入文件。 现实部署利用分布式存储系统(如GFS)来允许此读取，即使workers在不同的计算机上运行。 在本实验中，您将在同一台计算机上运行所有workers，并使用本地文件系统；</li><li>接下来master为每个reduce任务至少调用一次(at-least-once) <code>doReduce()</code>(<code>common_reduce.go</code>)。 与<code>doMap()</code>一样，可以直接或通过worker来完成。 用于reduce任务r的`doReduce()从每个map任务中收集第$r$个中间文件，并为这些文件中出现的每个键调用reduce函数。 reduce任务生成$nReduce$个结果文件；</li><li>master调用<code>mr.merge()</code>(<code>master_splitmerge.go</code>)，将上一步生成的所有$nReduce$个文件合并为单个输出；</li><li>master向每个woker发送Shutdown RPC，然后关闭自己的RPC服务器。<blockquote><p>说明：在后续的练习中，您必须编写/修改<code>doMap()</code>，<code>doReduce()</code>和<code>schedule()</code>，它们分别位于<code>common_map.go</code>、<code>common_reduce.go</code>和<code>schedule.go</code>中。 您还必须在<code>../main/wc.go</code>中编写map函数和reduce函数。</p></blockquote></li></ol><h3><span id="part-i-map-reduce-shu-ru-he-shu-chu">Part I: Map/Reduce 输入和输出</span><a href="#part-i-map-reduce-shu-ru-he-shu-chu" class="header-anchor">#</a></h3><p>提供的Map/Reduce实现缺少部分代码。 在编写第一个Map/Reduce函数对之前，您需要修改sequential的实现代码。 特别是，提供的代码缺少两个关键部分：分配一个map任务输出的函数，以及收集一个reduce任务所有输入的函数。 这些任务分别由<code>common_map.go</code>中的<code>doMap()</code>函数和<code>common_reduce.go</code>中的<code>doReduce()</code>函数执行。 </p><p>为了帮助您确定是否正确实现了<code>doMap()</code>和<code>doReduce()</code>，我们为您提供了一个Go测试套件(<code>test_test.go</code>)用于检查文件中实现。 例如测试修改后的sequence实现代码，请运行：<br><code>go test -run Sequential</code><br>or<br><code>go test -v -run Sequential</code></p><p><strong>解答：</strong><br>该部分任务只需要补全<code>common_map.go</code>中的<code>doMap()</code>和<code>common_reduce.go</code>中的<code>doReduce()</code>的代码，补全的结果如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mapreduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"hash/fnv"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doMap</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">jobName <span class="keyword">string</span>, // the name of the MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">mapTask <span class="keyword">int</span>, // which <span class="keyword">map</span> task this is</span></span></span><br><span class="line"><span class="function"><span class="params">inFile <span class="keyword">string</span>,</span></span></span><br><span class="line">nReduce int, // the number of reduce task that will be run ("R" in the paper)</span><br><span class="line">mapF <span class="function"><span class="keyword">func</span>(<span class="params">filename <span class="keyword">string</span>, content <span class="keyword">string</span></span>) []<span class="title">KeyValue</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// doMap manages one map task: it should read one of the input files</span></span><br><span class="line"><span class="comment">// (inFile), call the user-defined map function (mapF) for that file's</span></span><br><span class="line"><span class="comment">// content, and partition mapF's output into nReduce intermediate files.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// There is one intermediate file per reduce task. The file name</span></span><br><span class="line"><span class="comment">// includes both the map task number and the reduce task number. Use</span></span><br><span class="line"><span class="comment">// the filename generated by reduceName(jobName, mapTask, r)</span></span><br><span class="line"><span class="comment">// as the intermediate file for reduce task r. Call ihash() (see</span></span><br><span class="line"><span class="comment">// below) on each key, mod nReduce, to pick r for a key/value pair.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// mapF() is the map function provided by the application. The first</span></span><br><span class="line"><span class="comment">// argument should be the input file name, though the map function</span></span><br><span class="line"><span class="comment">// typically ignores it. The second argument should be the entire</span></span><br><span class="line"><span class="comment">// input file content. mapF() returns a slice containing the</span></span><br><span class="line"><span class="comment">// key/value pairs for reduce; see common.go for the definition of</span></span><br><span class="line"><span class="comment">// KeyValue.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Look at Go's ioutil and os packages for functions to read</span></span><br><span class="line"><span class="comment">// and write files.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Coming up with a scheme for how to format the key/value pairs on</span></span><br><span class="line"><span class="comment">// disk can be tricky, especially when taking into account that both</span></span><br><span class="line"><span class="comment">// keys and values could contain newlines, quotes, and any other</span></span><br><span class="line"><span class="comment">// character you can think of.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// One format often used for serializing data to a byte stream that the</span></span><br><span class="line"><span class="comment">// other end can correctly reconstruct is JSON. You are not required to</span></span><br><span class="line"><span class="comment">// use JSON, but as the output of the reduce tasks *must* be JSON,</span></span><br><span class="line"><span class="comment">// familiarizing yourself with it here may prove useful. You can write</span></span><br><span class="line"><span class="comment">// out a data structure as a JSON string to a file using the commented</span></span><br><span class="line"><span class="comment">// code below. The corresponding decoding functions can be found in</span></span><br><span class="line"><span class="comment">// common_reduce.go.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   enc := json.NewEncoder(file)</span></span><br><span class="line"><span class="comment">//   for _, kv := ... &#123;</span></span><br><span class="line"><span class="comment">//     err := enc.Encode(&amp;kv)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Remember to close the file after you have written all the values!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code here (Part I).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取输入文件</span></span><br><span class="line">content, err := ioutil.ReadFile(inFile)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doMap读取输入文件错误"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//map操作</span></span><br><span class="line">kvPairs := mapF(inFile, <span class="keyword">string</span>(content))  <span class="comment">//调用mapF，返回键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将键值对写入到中间文件</span></span><br><span class="line">tmpFiles := <span class="built_in">make</span>([] *os.File, nReduce)  <span class="comment">//R个中间文件</span></span><br><span class="line">encoders := <span class="built_in">make</span>([] *json.Encoder, nReduce)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nReduce; i++ &#123;</span><br><span class="line">tmpFileName := reduceName(jobName, mapTask, i)  <span class="comment">//中间文件名,mrtmp.test-mapTask-i</span></span><br><span class="line"></span><br><span class="line">tmpFiles[i], err = os.Create(tmpFileName)  <span class="comment">//创建中间文件mrtmp.test-mapTask-i</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doMap生成中间文件错误"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> tmpFiles[i].Close()</span><br><span class="line"></span><br><span class="line">encoders[i] = json.NewEncoder(tmpFiles[i])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doMap编码错误"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ , kv := <span class="keyword">range</span> kvPairs &#123;</span><br><span class="line">hashKey := ihash(kv.Key) % nReduce  <span class="comment">//根据键将键值对分成R组</span></span><br><span class="line"></span><br><span class="line">err := encoders[hashKey].Encode(&amp;kv)  <span class="comment">//将R个键值对写入R个中间文件</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doMap编码错误"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ihash</span>(<span class="params">s <span class="keyword">string</span></span>) <span class="title">int</span></span> &#123;</span><br><span class="line">h := fnv.New32a()</span><br><span class="line">h.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(h.Sum32() &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mapreduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doReduce</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">jobName <span class="keyword">string</span>, // the name of the whole MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">reduceTask <span class="keyword">int</span>, // which reduce task this is</span></span></span><br><span class="line"><span class="function"><span class="params">outFile <span class="keyword">string</span>, // write the output here</span></span></span><br><span class="line">nMap int, // the number of map tasks that were run ("M" in the paper)</span><br><span class="line">reduceF <span class="function"><span class="keyword">func</span>(<span class="params">key <span class="keyword">string</span>, values []<span class="keyword">string</span></span>) <span class="title">string</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// doReduce manages one reduce task: it should read the intermediate</span></span><br><span class="line"><span class="comment">// files for the task, sort the intermediate key/value pairs by key,</span></span><br><span class="line"><span class="comment">// call the user-defined reduce function (reduceF) for each key, and</span></span><br><span class="line"><span class="comment">// write reduceF's output to disk.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You'll need to read one intermediate file from each map task;</span></span><br><span class="line"><span class="comment">// reduceName(jobName, m, reduceTask) yields the file</span></span><br><span class="line"><span class="comment">// name from map task m.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your doMap() encoded the key/value pairs in the intermediate</span></span><br><span class="line"><span class="comment">// files, so you will need to decode them. If you used JSON, you can</span></span><br><span class="line"><span class="comment">// read and decode by creating a decoder and repeatedly calling</span></span><br><span class="line"><span class="comment">// .Decode(&amp;kv) on it until it returns an error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You may find the first example in the golang sort package</span></span><br><span class="line"><span class="comment">// documentation useful.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// reduceF() is the application's reduce function. You should</span></span><br><span class="line"><span class="comment">// call it once per distinct key, with a slice of all the values</span></span><br><span class="line"><span class="comment">// for that key. reduceF() returns the reduced value for that key.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You should write the reduce output as JSON encoded KeyValue</span></span><br><span class="line"><span class="comment">// objects to the file named outFile. We require you to use JSON</span></span><br><span class="line"><span class="comment">// because that is what the merger than combines the output</span></span><br><span class="line"><span class="comment">// from all the reduce tasks expects. There is nothing special about</span></span><br><span class="line"><span class="comment">// JSON -- it is just the marshalling format we chose to use. Your</span></span><br><span class="line"><span class="comment">// output code will look something like this:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// enc := json.NewEncoder(file)</span></span><br><span class="line"><span class="comment">// for key := ... &#123;</span></span><br><span class="line"><span class="comment">// enc.Encode(KeyValue&#123;key, reduceF(...)&#125;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// file.Close()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code here (Part I).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历属于自己的中间文件，将键值对合并到kvs中</span></span><br><span class="line">kvs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nMap; i++ &#123;</span><br><span class="line">fileName := reduceName(jobName, i, reduceTask)</span><br><span class="line"></span><br><span class="line">file, err := os.Open(fileName)  <span class="comment">//打开中间文件mrtmp.test-i-reduceTask</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doReduce打开文件错误"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dec := json.NewDecoder(file)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;  <span class="comment">//每个中间文件可能包含多个键值对</span></span><br><span class="line"><span class="keyword">var</span> kv KeyValue</span><br><span class="line">err = dec.Decode(&amp;kv)  <span class="comment">//解码一个键值对</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, ok := kvs[kv.Key]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;  <span class="comment">//出现新的键则初始化kvs</span></span><br><span class="line">kvs[kv.Key] = []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">kvs[kv.Key] = <span class="built_in">append</span>(kvs[kv.Key], kv.Value)  <span class="comment">//加入与键对应的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将键集合到一起并排序</span></span><br><span class="line"><span class="keyword">var</span> keys []<span class="keyword">string</span>  </span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(keys)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建输出文件</span></span><br><span class="line">out := mergeName(jobName, reduceTask)  </span><br><span class="line">file, err := os.Create(out)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doReduce创建输出文件错误"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">enc := json.NewEncoder(file)</span><br><span class="line"></span><br><span class="line"><span class="comment">//reduce操作</span></span><br><span class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">res := reduceF(k, kvs[k])  <span class="comment">//调用客户端的reduceF，进行reduce</span></span><br><span class="line">enc.Encode(KeyValue&#123;k, res&#125;)  <span class="comment">//reduce后的键值对写入到输出文件</span></span><br><span class="line">&#125;</span><br><span class="line">file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>go test -run Sequential</code>，结果如下：<br>&nbsp;<br><img src="https://upload-images.jianshu.io/upload_images/1863961-b5960850942d11a2.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><h3><span id="part-ii-single-worker-dan-ci-tong-ji">Part II: Single-worker单词统计</span><a href="#part-ii-single-worker-dan-ci-tong-ji" class="header-anchor">#</a></h3><p>在该部分，您将要实现一个简单的Map/Reduce示例——单词统计。 具体是需要实现<code>main/wc.go</code>中的<code>mapF()</code>和<code>reduceF()</code>函数。 您的工作是插入代码，以便<code>wc.go</code>返回输入文件中每个单词出现的次数。 一个单词是任意连续的字母序列，其中字母可用Golang的<a href="https://golang.org/pkg/unicode/#IsLetter" target="_blank" rel="noopener">unicode.IsLetter</a>函数来判断。</p><p>在<code>~/6.824/src/main</code>目录中提供了一些路径名为<code>pg-*.txt</code>形式的输入文件， 可用如下命令给<code>wc.go</code>使用输入文件运行：<br><code>go run wc.go master sequential pg-*.txt</code></p><p>查看MapReduce论文的第2部分。<code>mapF()</code>和<code>reduceF()</code>函数与论文第2.1节中的函数略有不同。<code>mapF()</code>将接收一个文件名和该文件的内容，并将内容分成单词最终输出一个<code>mapreduce.KeyValue</code>型切片。 对于单词统计可将单词作为键。对输出中的每个键都将调用一次<code>reduceF()</code>，其中包含<code>mapF()</code>为该键生成的所有值的切片。 <code>reduceF()</code>返回一个包含键出现总数的字符串。</p><blockquote><p>提示1：关于Go的字符串处理，可以参读 <a href="http://blog.golang.org/strings" target="_blank" rel="noopener">Go Blog on strings</a><br>提示2：可以使用<a href="https://golang.org/pkg/strings/#FieldsFunc" target="_blank" rel="noopener">strings.FieldsFunc</a>函数将字符串拆分成单词<br>提示3： 利用Go的<a href="https://golang.org/pkg/strconv/" target="_blank" rel="noopener">strconv</a>包可以很方便地将字符串转换成整型</p></blockquote><p>使用如下命令来验证答案：<br><code>go run wc.go master sequential pg-*.txt</code></p><p><strong>答案：</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"mapreduce"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"unicode"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The map function is called once for each file of input. The first</span></span><br><span class="line"><span class="comment">// argument is the name of the input file, and the second is the</span></span><br><span class="line"><span class="comment">// file's complete contents. You should ignore the input file name,</span></span><br><span class="line"><span class="comment">// and look only at the contents argument. The return value is a slice</span></span><br><span class="line"><span class="comment">// of key/value pairs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span>(<span class="params">filename <span class="keyword">string</span>, contents <span class="keyword">string</span></span>) []<span class="title">mapreduce</span>.<span class="title">KeyValue</span></span> &#123;</span><br><span class="line"><span class="comment">// Your code here (Part II).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res []mapreduce.KeyValue</span><br><span class="line"></span><br><span class="line">f := <span class="function"><span class="keyword">func</span>(<span class="params">c <span class="keyword">rune</span></span>) <span class="title">bool</span></span> &#123; <span class="comment">//不是字母</span></span><br><span class="line"><span class="keyword">return</span> !unicode.IsLetter(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">words := strings.FieldsFunc(contents, f) <span class="comment">//在不是字母地方拆分字符串contents</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> words &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, mapreduce.KeyValue&#123;key, <span class="string">"1"</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The reduce function is called once for each key generated by the</span></span><br><span class="line"><span class="comment">// map tasks, with a list of all the values created for that key by</span></span><br><span class="line"><span class="comment">// any map task.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span>(<span class="params">key <span class="keyword">string</span>, values []<span class="keyword">string</span></span>) <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="comment">// Your code here (Part II).</span></span><br><span class="line"></span><br><span class="line">count := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line">num, _ := strconv.ParseInt(value, <span class="number">10</span>, <span class="number">64</span>) <span class="comment">// 将字符串value（例如："157"）按照十进制转换成整型</span></span><br><span class="line">count = count + <span class="keyword">int</span>(num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> strconv.Itoa(count) <span class="comment">//整型转换成字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Can be run in 3 ways:</span></span><br><span class="line"><span class="comment">// 1) Sequential (e.g., go run wc.go master sequential x1.txt .. xN.txt)</span></span><br><span class="line"><span class="comment">// 2) Master (e.g., go run wc.go master localhost:7777 x1.txt .. xN.txt)</span></span><br><span class="line"><span class="comment">// 3) Worker (e.g., go run wc.go worker localhost:7777 localhost:7778 &amp;)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &lt; <span class="number">4</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s: see usage comments in file\n"</span>, os.Args[<span class="number">0</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> os.Args[<span class="number">1</span>] == <span class="string">"master"</span> &#123;</span><br><span class="line"><span class="keyword">var</span> mr *mapreduce.Master</span><br><span class="line"><span class="keyword">if</span> os.Args[<span class="number">2</span>] == <span class="string">"sequential"</span> &#123;</span><br><span class="line">mr = mapreduce.Sequential(<span class="string">"wcseq"</span>, os.Args[<span class="number">3</span>:], <span class="number">3</span>, mapF, reduceF)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mr = mapreduce.Distributed(<span class="string">"wcseq"</span>, os.Args[<span class="number">3</span>:], <span class="number">3</span>, os.Args[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line">mr.Wait()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mapreduce.RunWorker(os.Args[<span class="number">2</span>], os.Args[<span class="number">3</span>], mapF, reduceF, <span class="number">100</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行<code>go run wc.go master sequential pg-sherlock_holmes.txt</code>和<code>sort -n -k2 mrtmp.wcseq | tail -10</code>的结果：<br>&nbsp;<br><img src="https://upload-images.jianshu.io/upload_images/1863961-2d925a0b957652b7.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><h3><span id="part-iii-fen-bu-shi-mapreduce-ren-wu">Part III: 分布式 MapReduce 任务</span><a href="#part-iii-fen-bu-shi-mapreduce-ren-wu" class="header-anchor">#</a></h3><p>在当前的实现中，是通过串行的方式来执行Map任务和Reduce任务。 Map/Reduce最大的卖点之一是它可以自动地并行执行原始的串行代码而无需开发人员的任何额外工作。 在这一部分中，您将完成一个分布式MapReduce版本，即将工作拆分为在多核上运行的一组worker线程。 尽管不像真实的Map/Reduce部署被分布在多台机器上那样，但你本部分的实现中将使用RPC来模拟分布式计算。</p><p><code>mapreduce/master.go</code>中的代码完成了管理MapReduce的大部分工作。 我们还为您提供了<code>mapreduce/worker.go</code>中worker线程的完整代码以及在<code>mapreduce/common_rpc.go</code>中处理RPC的一些代码。</p><p><strong>你的任务是实现<code>mapreduce/schedule.go</code>中的<code>schedule()</code>函数</strong>。 master在MapReduce期间将两次调用<code>schedule()</code>，一次用于Map阶段，一次用于Reduce阶段。 <code>schedule()</code>的功能是将任务分发给可用的worker。 任务的数量通常比worker线程多，因此<code>schedule()</code>必须为每个worker分配一系列任务，一次一个。 <code>schedule()</code>应该等到所有任务都完成后再返回。</p><p><code>schedule()</code>通过读取<code>registerChan</code>参数来了解一组worker。 该channel为每个worker生成一个包含worker的RPC地址的字符串。所有的worker都会出现在registerChan，其中一些worker可能在调用<code>schedule()</code>之前就存在，而另一些worker可能在<code>schedule()</code>运行时才启动。<code>schedule()</code>应该充分利用所有的worker，包括启动后出现的worker。</p><p><code>schedule()</code>通过向worker发送<code>Worker.DoTask</code>RPC来通知worker执行任务。 此RPC的参数由<code>mapreduce/common_rpc.go</code>中的<code>DoTaskArgs</code>定义。<code>File</code>元素仅由Map任务使用，代表要读取的文件的名称；<code>schedule()</code>可以在<code>mapFiles</code>中找到这些文件名。</p><p>使用<code>mapreduce/common_rpc.go</code>中的<code>call()</code>函数将RPC发送给worker。 第一个参数是worker的地址，从<code>registerChan</code>读取，第二个参数是<code>Worker.DoTask</code>， 第三个参数是<code>DoTaskArgs</code>结构，最后一个参数是<code>nil</code>。</p><p>您对在第III部分的解答仅涉及对<code>schedule.go</code>的修改；如果您在调试过程中修改了其他文件，请恢复其原始内容。请先测试再提交。</p><p>使用<code>go test -run TestParallel</code>来测试您的答案。 该命令将执行两个测试，<code>TestParallelBasic</code>和<code>TestParallelCheck</code>，后者验证您的<code>schedule()</code>是否使worker并行执行任务。</p><blockquote><p>提示1：<code>schedule()</code>应该并行地向worker发送RPC，以便worker可以并发执行任务。 你会发现go语句对此很有用，参见<a href="http://golang.org/doc/effective_go.html#concurrency" target="_blank" rel="noopener">Concurrency in Go</a>。<br>提示2：<code>schedule()</code>必须等待worker完成一个任务后才能给它另下一个任务，Go的channel对此很有用。<br>提示3： <a href="https://golang.org/pkg/sync/#WaitGroup" target="_blank" rel="noopener">sync.WaitGroup</a><br>提示4：追踪错误的最简单的方法是插入print语句（在common.go中可能是调用<code>debug()</code>），使用<code>go test -run TestParallel &gt; out</code>将输出收集到一个文件中，然后分析输出是否与你对代码的预期相符。 最后一步是最重要的。<br>提示5：检查您的代码是否有竞争的情况可在测试中运行<a href="https://golang.org/doc/articles/race_detector.html" target="_blank" rel="noopener">race detector</a>。</p><p>注意：我们提供的代码是在单个UNIX进程中将worker作为线程运行，并且可以在单台机器上使用多核。 要想在使用网络进行通信的多台机器上运行worker必须进行一些修改：RPC必须使用TCP而不是UNIX-domain套接字；需要有一种方法来启动所有机器上的worker进程；所有的机器都必须通过某种网络文件系统共享存储。</p></blockquote><p><strong>答案</strong>见Part IV。</p><h3><span id="part-iv-worker-cuo-wu-chu-li">Part IV: worker错误处理</span><a href="#part-iv-worker-cuo-wu-chu-li" class="header-anchor">#</a></h3><p>在这部分中，您将实现master处理失败的worker的功能。由于worker的状态不是持久的，该功能在MapReduce中相对容易实现。 如果worker在处理来自master的RPC时发生错误，master的<code>call()</code>最终会因超时而返回<code>false</code>。在这种情况下，master会将该任务重新分配给另一个worker。</p><p>RPC故障并不一定意味着worker没有执行任务；worker可能已执行任务但是返回结果丢失，或者worker可能仍在执行但master的RPC超时。因此，可能会发生两个worker接收相同任务、计算并产生输出的情况。 需要对map或reduce函数进行两次调用才能为给定输入生成相同的输出，因此如果后续处理读取一个输出或者读取另一个输出，则不会出现不一致。 此外，MapReduce框架确保map和reduce函数输出以原子方式出现：输出文件要么不存在，要么包含单个map或单个reduce函数执行的整个输出（提供的代码不涉及这部分）。</p><p>您的实现必须通过<code>test_test.go</code>中剩下的两个测试用例。 第一个用例测试一个worker的失败，而第二个测试用例测试对多个worker的失败的处理。 测试用例会定期启动新的worker，master可以使用这些worker来推进程序过程，但这些worker在处理完一些任务后会失败。 使用下面的命令来运行测试：<br><code>go test -run Failure</code></p><p>在第IV部分，只涉及对<code>schedule.go</code>的修改。 如果您在调试过程中修改了其他文件，请恢复其原始内容，然后再进行测试、提交。</p><p>Part III、Part IV<strong>答案：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mapreduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// schedule() starts and waits for all tasks in the given phase (mapPhase</span></span><br><span class="line"><span class="comment">// or reducePhase). the mapFiles argument holds the names of the files that</span></span><br><span class="line"><span class="comment">// are the inputs to the map phase, one per map task. nReduce is the</span></span><br><span class="line"><span class="comment">// number of reduce tasks. the registerChan argument yields a stream</span></span><br><span class="line"><span class="comment">// of registered workers; each item is the worker's RPC address,</span></span><br><span class="line"><span class="comment">// suitable for passing to call(). registerChan will yield all</span></span><br><span class="line"><span class="comment">// existing registered workers (if any) and new ones as they register.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span>(<span class="params">jobName <span class="keyword">string</span>, mapFiles []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>, phase jobPhase, registerChan <span class="keyword">chan</span> <span class="keyword">string</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">var</span> ntasks <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> n_other <span class="keyword">int</span> <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line"><span class="keyword">switch</span> phase &#123;</span><br><span class="line"><span class="keyword">case</span> mapPhase:</span><br><span class="line">ntasks = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">n_other = nReduce</span><br><span class="line"><span class="keyword">case</span> reducePhase:</span><br><span class="line">ntasks = nReduce</span><br><span class="line">n_other = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Schedule: %v %v tasks (%d I/Os)\n"</span>, ntasks, phase, n_other)</span><br><span class="line"></span><br><span class="line"><span class="comment">// All ntasks tasks have to be scheduled on workers. Once all tasks</span></span><br><span class="line"><span class="comment">// have completed successfully, schedule() should return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code here (Part III, Part IV).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ntasks; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params">num <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">args := DoTaskArgs&#123;jobName, mapFiles[num], phase, num, n_other&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> worker <span class="keyword">string</span></span><br><span class="line">reply := <span class="built_in">new</span>(<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">ok := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> ok != <span class="literal">true</span> &#123;</span><br><span class="line">worker = &lt;-registerChan</span><br><span class="line">ok = call(worker, <span class="string">"Worker.DoTask"</span>, args, reply)</span><br><span class="line">&#125;</span><br><span class="line">done &lt;- <span class="literal">true</span>           <span class="comment">//任务完成</span></span><br><span class="line">registerChan &lt;- worker <span class="comment">//该worker工作完毕，处于空闲，加入channel中以分配给其它任务</span></span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ntasks; i++ &#123; <span class="comment">//等待所有任务完成</span></span><br><span class="line">&lt;-done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Schedule: %v done\n"</span>, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>go test -run TestParallel</code>的结果：<br>&nbsp;<br><img src="https://upload-images.jianshu.io/upload_images/1863961-da345dba91fc382f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://hejtao.netlify.com/tags/Golang/"/>
    
      <category term="MapReduce" scheme="https://hejtao.netlify.com/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>远程过程调用和线程(RPC and Thread)</title>
    <link href="https://hejtao.netlify.com/2019/03/25/2019-3-25/"/>
    <id>https://hejtao.netlify.com/2019/03/25/2019-3-25/</id>
    <published>2019-03-24T16:00:00.000Z</published>
    <updated>2019-11-11T19:59:33.204Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><p><a href="http://nil.csail.mit.edu/6.824/2018/schedule.html" target="_blank" rel="noopener">MIT Distributed System Course: Lecture 2</a><br>Remote Procedure Call (RPC)</p><p><strong>目标</strong>：<br>建立编程友好的客户端/服务器通信</p><p><strong>RPC消息图</strong>：<br>   客户端 &nbsp;&nbsp;&nbsp;&nbsp; 服务器<br>    请求—-&gt;<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;—-响应</p><p><strong>软件结构</strong>：<br> client app   &nbsp;&nbsp;&nbsp;&nbsp;      handlers<br>   &nbsp;&nbsp; stubs      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     dispatcher<br>  &nbsp;&nbsp; RPC lib      &nbsp;&nbsp;&nbsp;&nbsp;     RPC lib<br>  &nbsp;&nbsp;&nbsp;&nbsp;   net  —————— net</p><p><strong>Go rpc包</strong>：<br><a href="https://golang.org/pkg/net/rpc/" target="_blank" rel="noopener">官方文档</a><br><code>import &quot;net/rpc</code><br>rpc包提供对通过网络或其他I / O连接的对象的导出方法的访问。 服务器注册一个对象，并作为一种服务可见。 注册的对象其导出方法可以被远程访问。 服务器可以注册不同类型的多个对象（服务），但是注册相同类型的多个对象是错误的。</p><p>只有满足下列标准的方法（method）才能被远程访问：</p><ul><li>the method’s type is exported.</li><li>the method is exported.</li><li>the method has two arguments, both exported (or builtin) types.</li><li>the method’s second argument is a pointer.</li><li>the method has return type error.</li></ul><p>实际上，该方法必须看起来像<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">t *T</span>) <span class="title">MethodName</span>(<span class="params">argType T1, replyType *T2</span>) <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p><p>其中<code>T1</code>和<code>T2</code>可以通过 encoding/gob包来编码。即便使用不同的编解码器，上述标准仍然适用。</p><p>第一个参数<code>T1</code>表示调用者提供的参数;第二个参数<code>T2</code>表示要返回给调用者的结果参数。服务器可以通过调用ServeConn来处理单个连接上的请求。更典型的例子有创建网络侦听器并调用Accept，创建HTTP侦听器并调用HandleHTTP和http.Serve。</p><p>希望使用该服务的客户端首先和服务器建立连接，然后在连接的基础上调用NewClient。可以使用Dial函数（DialHTTP）方便地执行原始网络连接（HTTP连接）的两个步骤。新建的客户端对象具备Call方法和Go方法。</p><p>Call方法等待远程调用完成，而Go方法使用Call结构的Done通道启动异步调用和发出完成信号。</p><p>除非设置了显式编解码器，否则一般使用encoding/gob包来传输数据。</p><p>一个服务器导出Arith类型的对象的例子：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> server</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"errors"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">A, B <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Quotient <span class="keyword">struct</span> &#123;</span><br><span class="line">Quo, Rem <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Arith <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">t *Arith</span>) <span class="title">Multiply</span>(<span class="params">args *Args, reply *<span class="keyword">int</span></span>) <span class="title">error</span></span> &#123;</span><br><span class="line">*reply = args.A * args.B</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">t *Arith</span>) <span class="title">Divide</span>(<span class="params">args *Args, quo *Quotient</span>) <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> args.B == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"divide by zero"</span>)</span><br><span class="line">&#125;</span><br><span class="line">quo.Quo = args.A / args.B</span><br><span class="line">quo.Rem = args.A % args.B</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务器端调用 HTTP service：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arith := <span class="built_in">new</span>(Arith)</span><br><span class="line">rpc.Register(arith)</span><br><span class="line">rpc.HandleHTTP()</span><br><span class="line">l, e := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1234"</span>)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"listen error:"</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> http.Serve(l, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>现在，客户端拥有了一项服务Arith，该服务提供了Arith.Multiply和Arith.Divide方法。要调用这些方法，客户端得先拨通服务器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client, err := rpc.DialHTTP(<span class="string">"tcp"</span>, serverAddress + <span class="string">":1234"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"dialing:"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进行远程调用：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Synchronous call</span></span><br><span class="line">args := &amp;server.Args&#123;<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">var</span> reply <span class="keyword">int</span></span><br><span class="line">err = client.Call(<span class="string">"Arith.Multiply"</span>, args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"arith error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Arith: %d*%d=%d"</span>, args.A, args.B, reply)</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Asynchronous call</span></span><br><span class="line">quotient := <span class="built_in">new</span>(Quotient)</span><br><span class="line">divCall := client.Go(<span class="string">"Arith.Divide"</span>, args, quotient, <span class="literal">nil</span>)</span><br><span class="line">replyCall := &lt;-divCall.Done<span class="comment">// will be equal to divCall</span></span><br><span class="line"><span class="comment">// check errors, print, etc.</span></span><br></pre></td></tr></table></figure></p><p>服务器通常会为客户端提供一个简单的、类型安全的封装。<br>net/rpc包已冻结，不会增加新的功能属性。</p><p><strong>Go举例</strong>：<br> 一个简单的key/value存储服务器——Put(key,value), Get(key)-&gt;value<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"net/rpc"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// RPC request/reply definitions</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">OK       = <span class="string">"OK"</span></span><br><span class="line">ErrNoKey = <span class="string">"ErrNoKey"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Err <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PutArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Key   <span class="keyword">string</span></span><br><span class="line">Value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PutReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Err Err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Key <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Err   Err</span><br><span class="line">Value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Client</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span>(<span class="params"></span>) *<span class="title">rpc</span>.<span class="title">Client</span></span> &#123;</span><br><span class="line">client, err := rpc.Dial(<span class="string">"tcp"</span>, <span class="string">":1234"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"dialing:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span>(<span class="params">key <span class="keyword">string</span></span>) <span class="title">string</span></span> &#123;</span><br><span class="line">client := connect()</span><br><span class="line">args := GetArgs&#123;Key: key&#125;</span><br><span class="line">reply := GetReply&#123;&#125;</span><br><span class="line">err := client.Call(<span class="string">"KV.Get"</span>, &amp;args, &amp;reply) <span class="comment">//远程调用KV.Get，等待它完成，并返回其错误状态。</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">client.Close()</span><br><span class="line"></span><br><span class="line">log.Println(reply.Err)</span><br><span class="line"><span class="keyword">return</span> reply.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">put</span>(<span class="params">key <span class="keyword">string</span>, val <span class="keyword">string</span></span>)</span> &#123;</span><br><span class="line">client := connect()</span><br><span class="line">args := PutArgs&#123;Key: key, Value: val&#125;</span><br><span class="line">reply := PutReply&#123;&#125;</span><br><span class="line">err := client.Call(<span class="string">"KV.Put"</span>, &amp;args, &amp;reply) <span class="comment">//远程调用KV.Put</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">client.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Server</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> KV <span class="keyword">struct</span> &#123;</span><br><span class="line">mu   sync.Mutex</span><br><span class="line">data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">kv := <span class="built_in">new</span>(KV)</span><br><span class="line">kv.data = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">rpcs := rpc.NewServer()</span><br><span class="line">rpcs.Register(kv)</span><br><span class="line"></span><br><span class="line">l, e := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1234"</span>)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"listen error:"</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := l.Accept()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">go</span> rpcs.ServeConn(conn)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">l.Close()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">kv *KV</span>) <span class="title">Get</span>(<span class="params">args *GetArgs, reply *GetReply</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">kv.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">val, ok := kv.data[args.Key]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">reply.Err = OK</span><br><span class="line">reply.Value = val</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reply.Err = ErrNoKey</span><br><span class="line">reply.Value = <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">kv *KV</span>) <span class="title">Put</span>(<span class="params">args *PutArgs, reply *PutReply</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">kv.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">kv.data[args.Key] = args.Value</span><br><span class="line">reply.Err = OK</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">server()</span><br><span class="line"></span><br><span class="line">put(<span class="string">"passwd"</span>, <span class="string">"2w6C*kcXWWmzK$Jg"</span>) <span class="comment">//客户端存储密码</span></span><br><span class="line">fmt.Println(get(<span class="string">"passwd"</span>))        <span class="comment">//客户端获取密码</span></span><br><span class="line">&#125;</span><br><span class="line">command-line-arguments</span><br><span class="line"><span class="number">2019</span>/<span class="number">04</span>/<span class="number">02</span> <span class="number">18</span>:<span class="number">34</span>:<span class="number">11</span> OK</span><br><span class="line"><span class="number">2</span>w6C*kcXWWmzK$Jg</span><br></pre></td></tr></table></figure></p><ul><li>共同：必须为每种RPC类型声明Args和Reply结构</li><li><p>Client:<br>connect()的Dial()创建与服务器的TCP连接<br>Call()要求RPC库执行远程调用<br>指定server function name, args,reply<br>library marshalls args, sends request, waits, unmarshally reply<br>Call()的返回值表示是否收到回复<br>usually you’ll also have a reply.Err indicating service-level failure</p></li><li><p>server：<br>   Go要求您声明一个带有方法的对象作为RPC处理程序(RPC handler)<br>   然后，您使用RPC库注册该对象<br>   您接受TCP连接，并给它们提供RPC库</p><ul><li>RPC库<br>读取每个请求<br>为此请求创建一个新的goroutine<br>unmarshalls request<br>调用命名方法（调度）<br>marshalls reply<br>在TCP连接上写回复</li><li>服务器的Get()和Put()处理程序<br>必须锁定，因为RPC库给每个请求创建goroutines<br>解读args; 修改reply</li></ul></li></ul><hr><p><strong>线程</strong>:<br>  线程是一种有用的结构化工具<br>  Go称他们为goroutines;其他人称他们为线程<br>  他们可能很棘手</p><p><strong>Why threads?</strong><br>  用它们实现并发，在分布式系统中自然地出现</p><ul><li>I / O并发：<br> 在等待来自其他服务器的响应时，处理下一个请求</li><li>多核：<br> 线程在多个核心上并行运行</li></ul><p><strong>Thread =“执行线程”</strong><br>  线程允许一个程序（逻辑上）一次执行许多事情<br>  线程共享内存<br>  each thread includes some per-thread state，包括：程序计数器，寄存器，堆栈</p><p><strong>程序中有多少个线程？</strong></p><ul><li>由结构驱动<br> 例如每个客户端一个线程，一个用于后台任务</li><li>多核并行<br> one active thread per core。Go的 runtime 自动地在可用内核上调度可运行的goroutine</li><li>I / O并发<br> 数量由延迟和容量决定<br> 继续增加直到吞吐量停止增长</li><li>Go threads are pretty cheap<br> 100或1000是好的，但可能达不到数百万的量级<br> 创建线程比方法调用更昂贵</li></ul><p><strong>Threading challenges：</strong></p><ul><li>共享数据<br> 一个线程读取另一个线程正在改变的数据？例如当两个线程执行count = count + 1时，this is a “race” — and is usually a bug<br>  ——使用互斥锁（或其他同步）<br>  ——或避免共享</li><li>线程之间的协调<br> 如何等待所有Map线程完成？<br>  ——使用Go channel或WaitGroup</li><li>并发的粒度<br> 粗粒度(coarse-grained)  —— 简单，但并发/并行很少<br> 细粒度  —— 更多的并发、竞争(race)和死锁</li></ul><p><strong>什么是爬虫？</strong><br>  目标是获取所有网页，例如提供给索引器(indexer)<br>  网页形成一个图(graph)<br>  每个页面的多个链接<br>  graph has cycles</p><p><strong>Crawler challenges</strong></p><ul><li>安排I / O并发<br> 同时获取多个URL<br> 增加每秒获取的URL<br> 由于网络延迟远远超过网络容量<ul><li>Fetch each URL only once<br>避免浪费网络带宽<br>对远程服务器很好<br>需要记住访问过的URL</li></ul></li><li>知道什么时候完成</li></ul><p><strong>Crawler solutions：</strong></p><ul><li>串行爬虫：<br>fetched map 避免重复、进入死循环<br>它是一个单一的映射，通过递归调用传递<br>一次只能爬取一页</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span> &#123;</span><br><span class="line">Fetch(url <span class="keyword">string</span>) (urls []<span class="keyword">string</span>, err error) <span class="comment">//由一个URL返回多个URL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeResult <span class="keyword">struct</span> &#123;</span><br><span class="line">body <span class="keyword">string</span></span><br><span class="line">urls []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeFetcher <span class="keyword">map</span>[<span class="keyword">string</span>]*fakeResult</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">f fakeFetcher</span>) <span class="title">Fetch</span>(<span class="params">url <span class="keyword">string</span></span>) (<span class="params">[]<span class="keyword">string</span>, error</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> res, ok := f[url]; ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"found:   %s\n"</span>, url)</span><br><span class="line"><span class="keyword">return</span> res.urls, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"missing: %s\n"</span>, url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"not found: %s"</span>, url) <span class="comment">//打印字符串错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fetcher = fakeFetcher&#123; </span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"The Go Programming Language"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/cmd/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Packages"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/cmd/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/fmt/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/os/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/pkg/fmt/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Package fmt"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/pkg/os/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Package os"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 串行爬虫</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serial</span>(<span class="params">url <span class="keyword">string</span>, fetcher Fetcher, fetched <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> fetched[url] &#123; <span class="comment">// 已经爬取</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetched[url] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">urls, err := fetcher.Fetch(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">Serial(u, fetcher, fetched)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">Serial(<span class="string">"http://golang.org/"</span>, fetcher, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ConcurrentMutex爬虫：<ul><li>为每个页面的爬取创建一个线程，因此可以并发爬取，爬取率更高</li><li>线程共享 fetched map</li><li>Why the Mutex (== lock)?<ol><li>没有锁：<br>两个网页包含指向同一URL的链接，导致两个线程同时获取这这个页面<br>T1、T2检查获取[url]，当两者都看到url尚未获取，两者都取，导致错误</li><li>同时读写（或写入+写入）是竞争</li><li>如果我注释掉Lock()/Unlock()调用会发生什么？<br>go run crawler.go<br>go run -race crawler.go<br>The lock causes the check and update to be atomic</li></ol></li><li>How does it decide it is done?<br>sync.WaitGroup<br> implicitly waits for children to finish recursive fetches</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span> &#123;</span><br><span class="line">Fetch(url <span class="keyword">string</span>) (urls []<span class="keyword">string</span>, err error) <span class="comment">//由一个URL返回多个URL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeResult <span class="keyword">struct</span> &#123;</span><br><span class="line">body <span class="keyword">string</span></span><br><span class="line">urls []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeFetcher <span class="keyword">map</span>[<span class="keyword">string</span>]*fakeResult</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">f fakeFetcher</span>) <span class="title">Fetch</span>(<span class="params">url <span class="keyword">string</span></span>) (<span class="params">[]<span class="keyword">string</span>, error</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> res, ok := f[url]; ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"found:   %s\n"</span>, url)</span><br><span class="line"><span class="keyword">return</span> res.urls, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"missing: %s\n"</span>, url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"not found: %s"</span>, url) <span class="comment">//打印字符串错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fetcher = fakeFetcher&#123;</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"The Go Programming Language"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/cmd/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Packages"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/cmd/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/fmt/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/os/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/pkg/fmt/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Package fmt"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/pkg/os/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Package os"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concurrent crawler with shared state and Mutex</span></span><br><span class="line"><span class="keyword">type</span> fetchState <span class="keyword">struct</span> &#123;</span><br><span class="line">mu      sync.Mutex</span><br><span class="line">fetched <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeState</span>(<span class="params"></span>) *<span class="title">fetchState</span></span> &#123;</span><br><span class="line">f := &amp;fetchState&#123;&#125;</span><br><span class="line">f.fetched = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentMutex</span>(<span class="params">url <span class="keyword">string</span>, fetcher Fetcher, f *fetchState</span>)</span> &#123;</span><br><span class="line">f.mu.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> f.fetched[url] &#123; <span class="comment">// 已经爬取</span></span><br><span class="line">f.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.fetched[url] = <span class="literal">true</span></span><br><span class="line">f.mu.Unlock()</span><br><span class="line"></span><br><span class="line">urls, err := fetcher.Fetch(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> done sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">done.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params">u <span class="keyword">string</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> done.Done() <span class="comment">//等价于defer done.Add(-1)</span></span><br><span class="line">ConcurrentMutex(u, fetcher, f)</span><br><span class="line">&#125;(u)</span><br><span class="line">&#125;</span><br><span class="line">done.Wait() <span class="comment">//等待所有的goroutine完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">ConcurrentMutex(<span class="string">"http://golang.org/"</span>, fetcher, makeState())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ConcurrentChannel爬虫<ul><li>Go channel：<br>channel是一个对象,可能有很多个, ch：= make（chan int）<br>channel允许一个线程将对象发送到另一个线程：<br><code>ch &lt; -  x</code>，sender等待goroutine接收<br><code>y：= &lt; -  ch;  for y := range ch</code>，receiver等待goroutine发送<br>可以用channel来进行通信和同步<br>多个线程可以在一个channel上发送和接收<br>在发送时握住锁可能很危险…</li><li>ConcurrentChannel master（）<br>master()创建一个worker goroutine来获取每个页面<br>worker()在channel上发送URL<br>多个worker在一个channel上发送<br>master()从channel中读取URL<br>[图：主人，通道，工人]</li><li>无需锁定 fetched map，因为它不是共享的！</li><li>有共享数据吗？<br>channel<br>通道上发送的切片和字符串<br>master()传递给worker()的参数</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span> &#123;</span><br><span class="line">Fetch(url <span class="keyword">string</span>) (urls []<span class="keyword">string</span>, err error) <span class="comment">//由一个URL返回多个URL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeResult <span class="keyword">struct</span> &#123;</span><br><span class="line">body <span class="keyword">string</span></span><br><span class="line">urls []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeFetcher <span class="keyword">map</span>[<span class="keyword">string</span>]*fakeResult</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">f fakeFetcher</span>) <span class="title">Fetch</span>(<span class="params">url <span class="keyword">string</span></span>) (<span class="params">[]<span class="keyword">string</span>, error</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> res, ok := f[url]; ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"found:   %s\n"</span>, url)</span><br><span class="line"><span class="keyword">return</span> res.urls, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"missing: %s\n"</span>, url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"not found: %s"</span>, url) <span class="comment">//打印字符串错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fetcher = fakeFetcher&#123;</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"The Go Programming Language"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/cmd/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Packages"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/cmd/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/fmt/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/os/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/pkg/fmt/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Package fmt"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/pkg/os/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Package os"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concurrent crawler with channels</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span>(<span class="params">url <span class="keyword">string</span>, ch <span class="keyword">chan</span> []<span class="keyword">string</span>, fetcher Fetcher</span>)</span> &#123;</span><br><span class="line">urls, err := fetcher.Fetch(url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ch &lt;- []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ch &lt;- urls</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">master</span>(<span class="params">ch <span class="keyword">chan</span> []<span class="keyword">string</span>, fetcher Fetcher</span>)</span> &#123;</span><br><span class="line">n := <span class="number">1</span></span><br><span class="line">fetched := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> urls := <span class="keyword">range</span> ch &#123;</span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line"><span class="keyword">if</span> fetched[u] == <span class="literal">false</span> &#123;</span><br><span class="line">fetched[u] = <span class="literal">true</span></span><br><span class="line">n += <span class="number">1</span></span><br><span class="line"><span class="keyword">go</span> worker(u, ch, fetcher)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentChannel</span>(<span class="params">url <span class="keyword">string</span>, fetcher Fetcher</span>)</span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">ch &lt;- []<span class="keyword">string</span>&#123;url&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">master(ch, fetcher)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">ConcurrentChannel(<span class="string">"http://golang.org/"</span>, fetcher)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><strong>什么时候使用sharing和locks，而不是channels？</strong></p><ul><li>大多数问题都可以用任何一种方式解决</li><li>最有意义的取决于程序员的想法<br> state(状态) — sharing and locks<br> communication — channels<br> waiting for events — channels</li><li>使用Go的竞争检测器：<br> <a href="https://golang.org/doc/articles/race_detector.html" target="_blank" rel="noopener">Data Race Detector</a><br> go test -race</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://hejtao.netlify.com/tags/Golang/"/>
    
      <category term="RPC" scheme="https://hejtao.netlify.com/tags/RPC/"/>
    
      <category term="并发" scheme="https://hejtao.netlify.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Go并发模式 (Cocurrency Pattern)</title>
    <link href="https://hejtao.netlify.com/2019/02/10/2019-2-10/"/>
    <id>https://hejtao.netlify.com/2019/02/10/2019-2-10/</id>
    <published>2019-02-09T16:00:00.000Z</published>
    <updated>2019-11-11T19:59:33.203Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><p>这篇博客的原创来自Go的<a href="https://blog.golang.org/advanced-go-concurrency-patterns" target="_blank" rel="noopener">官方博客</a>，其中提供了丰富的关于Go的并发的相关资料。本文仅仅是对 Rob Pike 的演讲 Go Concurrency Patterns 和 Sameer Ajmani 的续集  Advanced Go Concurrency Patterns 的学习，相关内容的视频和ppt在网上都可以找到。</p><h4><span id="1-han-shu-fan-hui-channel">1. 函数返回 channel</span><a href="#1-han-shu-fan-hui-channel" class="header-anchor">#</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boring</span>(<span class="params">msg <span class="keyword">string</span></span>) &lt;-<span class="title">chan</span> <span class="title">string</span></span> &#123; <span class="comment">// 返回字符串通道，仅接收</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">c &lt;- fmt.Sprintf(<span class="string">"%s %d"</span>, msg, i)</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">3e3</span>)) * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">c := boring(<span class="string">"boring!"</span>) <span class="comment">// 通道作为返回的函数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"You say: %q\n"</span>, &lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"You're boring; I'm leaving."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">You say: <span class="string">"boring! 0"</span></span><br><span class="line">You say: <span class="string">"boring! 1"</span></span><br><span class="line">You say: <span class="string">"boring! 2"</span></span><br><span class="line">You say: <span class="string">"boring! 3"</span></span><br><span class="line">You say: <span class="string">"boring! 4"</span></span><br><span class="line">You<span class="string">'re boring; I'</span>m leaving.</span><br></pre></td></tr></table></figure><h4><span id="2-tong-dao-zuo-wei-fu-wu">2. 通道作为服务</span><a href="#2-tong-dao-zuo-wei-fu-wu" class="header-anchor">#</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">joe := boring(<span class="string">"Joe"</span>)</span><br><span class="line">ann := boring(<span class="string">"Ann"</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">fmt.Println(&lt;-joe)</span><br><span class="line">fmt.Println(&lt;-ann)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"You're both boring; I'm leaving."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Joe <span class="number">0</span></span><br><span class="line">Ann <span class="number">0</span></span><br><span class="line">Joe <span class="number">1</span></span><br><span class="line">Ann <span class="number">1</span></span><br><span class="line">Joe <span class="number">2</span></span><br><span class="line">Ann <span class="number">2</span></span><br><span class="line">Joe <span class="number">3</span></span><br><span class="line">Ann <span class="number">3</span></span><br><span class="line">Joe <span class="number">4</span></span><br><span class="line">Ann <span class="number">4</span></span><br><span class="line">You<span class="string">'re both boring; I'</span>m leaving.</span><br></pre></td></tr></table></figure><h4><span id="3-duo-chong-tong-dao-shan-ru-han-shu-fan-in-function">3.多重通道(扇入函数，fan-in function)</span><a href="#3-duo-chong-tong-dao-shan-ru-han-shu-fan-in-function" class="header-anchor">#</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boring</span>(<span class="params">msg <span class="keyword">string</span></span>) &lt;-<span class="title">chan</span> <span class="title">string</span></span> &#123; <span class="comment">// 返回字符串通道，仅接收</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">c &lt;- fmt.Sprintf(<span class="string">"%s %d"</span>, msg, i)</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">1e3</span>)) * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span>(<span class="params">input1, input2 &lt;-<span class="keyword">chan</span> <span class="keyword">string</span></span>) &lt;-<span class="title">chan</span> <span class="title">string</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">c &lt;- &lt;-input1</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">c &lt;- &lt;-input2</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">c := fanIn(boring(<span class="string">"Joe"</span>), boring(<span class="string">"Ann"</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"You're both boring; I'm leaving."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1863961-e259e9b8d2d6bbe2.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><h4><span id="4-tong-dao-fa-song-tong-dao-shi-goroutine-you-xu">4. 通道发送通道，使 goroutine 有序</span><a href="#4-tong-dao-fa-song-tong-dao-shi-goroutine-you-xu" class="header-anchor">#</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">str  <span class="keyword">string</span></span><br><span class="line">wait <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boring</span>(<span class="params">msg <span class="keyword">string</span></span>) <span class="title">chan</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> Message)</span><br><span class="line">waitForIt := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>) <span class="comment">// 被所有 Message 共享</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">c &lt;- Message&#123;fmt.Sprintf(<span class="string">"%s: %d"</span>, msg, i), waitForIt&#125;</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">1e3</span>)) * time.Millisecond)</span><br><span class="line">&lt;-waitForIt  <span class="comment">// 进入等待</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span>(<span class="params">input1, input2 <span class="keyword">chan</span> Message</span>) <span class="title">chan</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> Message)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">c &lt;- &lt;-input1</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">c &lt;- &lt;-input2</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">c := fanIn(boring(<span class="string">"Joe"</span>), boring(<span class="string">"Ann"</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">msg1 := &lt;-c</span><br><span class="line">fmt.Println(msg1.str)</span><br><span class="line">msg2 := &lt;-c</span><br><span class="line">fmt.Println(msg2.str)  <span class="comment">// 当 Joe 和 Ann 的信息都收到后，才开放下一次消息接收</span></span><br><span class="line">msg1.wait &lt;- <span class="literal">true</span></span><br><span class="line">msg2.wait &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="5-select-yu-ju">5. select 语句</span><a href="#5-select-yu-ju" class="header-anchor">#</a></h4><p>使用 select 来写扇入函数，减少 goroutine 数量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span>(<span class="params">input1, input2 &lt;-<span class="keyword">chan</span> <span class="keyword">string</span></span>) &lt;-<span class="title">chan</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> s := &lt;-input1:  c &lt;- s</span><br><span class="line">            <span class="keyword">case</span> s := &lt;-input2:  c &lt;- s</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select设置超时</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boring</span>(<span class="params">msg <span class="keyword">string</span></span>) &lt;-<span class="title">chan</span> <span class="title">string</span></span> &#123; <span class="comment">// 返回字符串通道，仅接收</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">c &lt;- fmt.Sprintf(<span class="string">"%s %d"</span>, msg, i)</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">1500</span>)) * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">c := boring(<span class="string">"Joe"</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s := &lt;-c:</span><br><span class="line">fmt.Println(s)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">fmt.Println(<span class="string">"You're too slow."</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Joe <span class="number">0</span></span><br><span class="line">Joe <span class="number">1</span></span><br><span class="line">Joe <span class="number">2</span></span><br><span class="line">Joe <span class="number">3</span></span><br><span class="line">Joe <span class="number">4</span></span><br><span class="line">You<span class="string">'re too slow.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://hejtao.netlify.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>MySQL驱动</title>
    <link href="https://hejtao.netlify.com/2018/12/31/2018-12-31/"/>
    <id>https://hejtao.netlify.com/2018/12/31/2018-12-31/</id>
    <published>2018-12-30T16:00:00.000Z</published>
    <updated>2019-12-13T03:54:47.577Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><meta name="referrer" content="no-referrer"></p><div class="toc"><!-- toc --><ul><li><a href="#qi-dong-yi-mi-ma-deng-ru-he-chuang-jian-shu-ju-ku">启动、以密码登入和创建数据库</a><ul><li><a href="#windows">windows:</a></li><li><a href="#ubuntu">ubuntu:</a></li></ul></li><li><a href="#bian-xie-go-wen-jian">编写Go文件</a></li></ul><!-- tocstop --></div><p>MySQL基础见<a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>;<br>本文参考了<a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/05.2.md" target="_blank" rel="noopener">astaxie/build-web-application-with-golang</a>.</p><h3><span id="qi-dong-yi-mi-ma-deng-ru-he-chuang-jian-shu-ju-ku">启动、以密码登入和创建数据库</span><a href="#qi-dong-yi-mi-ma-deng-ru-he-chuang-jian-shu-ju-ku" class="header-anchor">#</a></h3><h4><span id="windows">windows:</span><a href="#windows" class="header-anchor">#</a></h4><p>在bin目录下，运行(git-bash以管理员运行，加winpty)</p><p><code>mysqld --remove</code> 删除之前的mysql服务</p><p><code>mysqld -install mysql</code> 安装windows服务，服务名称为mysql(任意取)</p><p><code>mysqld --initialize-insecure</code> 可无密码登陆root</p><p><code>net start mysql</code> 启动服务(关闭的命令是 <code>net stop mysql</code>)</p><h4><span id="ubuntu">ubuntu:</span><a href="#ubuntu" class="header-anchor">#</a></h4><p><code>service mysql start</code>　启动服务</p><p><code>service mysql stop</code>　关闭服务</p><p><code>service restart stop</code>　重启服务</p><p><code>ps -ef | grep mysqld</code>   查看mysql进程列表</p><p>执行如下SQL语句以密码登入</p><p><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;</code></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-b53852355153eddc.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/740" alt=""></p><p>或者编写 test.sql 创建</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-279c6b518995b5ab.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/740" alt=""></p><p>source test.sql 文件</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-89f3de8a8ea85d68.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/740" alt=""></p><h3><span id="bian-xie-go-wen-jian">编写Go文件</span><a href="#bian-xie-go-wen-jian" class="header-anchor">#</a></h3><p>test.go 内容如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@/test"</span>) <span class="comment">//Linux用户名:MySQL密码@/数据库名test</span></span><br><span class="line">checkErr(err)</span><br><span class="line">stm, err := db.Prepare(<span class="string">"DROP TABLE IF EXISTS userinfo;"</span>) <span class="comment">//准备SQL语句，删除数据表</span></span><br><span class="line">checkErr(err)</span><br><span class="line">_, err = stm.Exec() <span class="comment">//Excute, 执行语句</span></span><br><span class="line">checkErr(err)</span><br><span class="line">stm, err = db.Prepare(<span class="string">`CREATE TABLE userinfo (</span></span><br><span class="line"><span class="string">                                uid INT(10) NOT NULL AUTO_INCREMENT,</span></span><br><span class="line"><span class="string">                                name VARCHAR(64) NOT NULL DEFAULT '匿名',</span></span><br><span class="line"><span class="string">                                city VARCHAR(64) NULL DEFAULT '不详',</span></span><br><span class="line"><span class="string">                                moment DATE NOT NULL DEFAULT '1949-10-10',</span></span><br><span class="line"><span class="string">                                PRIMARY KEY (uid)</span></span><br><span class="line"><span class="string">                            ) DEFAULT CHARSET=utf8;`</span>) <span class="comment">//创建数据表，设置utf8以支持中文字符</span></span><br><span class="line">checkErr(err)</span><br><span class="line">_, err = stm.Exec()</span><br><span class="line">checkErr(err)</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加数据</span></span><br><span class="line">stm, err = db.Prepare(<span class="string">"INSERT userinfo SET name=?, city=?, moment=?"</span>) <span class="comment">//准备SQL语句</span></span><br><span class="line">checkErr(err)</span><br><span class="line">_, err = stm.Exec(<span class="string">"诸葛亮"</span>, <span class="string">"山东临沂"</span>, <span class="string">"234-10-8"</span>) <span class="comment">//Excute, 传入参数并执行</span></span><br><span class="line">checkErr(err)</span><br><span class="line">_, err = stm.Exec(<span class="string">"关羽"</span>, <span class="string">"山西运城"</span>, <span class="string">"220-1-1"</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">_, err = stm.Exec(<span class="string">"荀彧"</span>, <span class="string">"河南许昌"</span>, <span class="string">"212-1-1"</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line"></span><br><span class="line">stm, err = db.Prepare(<span class="string">"INSERT userinfo SET city=?"</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">res, err := stm.Exec(<span class="string">"河南禹州"</span>)</span><br><span class="line">id, err := res.LastInsertId()</span><br><span class="line">checkErr(err)</span><br><span class="line">fmt.Println(<span class="string">"最后插入的用户序号为:"</span>, id)</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询数据</span></span><br><span class="line">rows, err := db.Query(<span class="string">"SELECT * FROM userinfo"</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">fmt.Println(<span class="string">"打印数据表的每行信息:"</span>)</span><br><span class="line">fmt.Println(<span class="string">"---------------------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="keyword">var</span> uid <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> city <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> moment <span class="keyword">string</span></span><br><span class="line">err = rows.Scan(&amp;uid, &amp;name, &amp;city, &amp;moment)</span><br><span class="line">checkErr(err)</span><br><span class="line"></span><br><span class="line">fmt.Print(uid, <span class="string">" "</span>)</span><br><span class="line">fmt.Print(name, <span class="string">" "</span>)</span><br><span class="line">fmt.Print(city, <span class="string">" "</span>)</span><br><span class="line">fmt.Println(moment)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除数据</span></span><br><span class="line">stm, err = db.Prepare(<span class="string">"DELETE FROM userinfo WHERE uid=?"</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">res, err = stm.Exec(<span class="number">2</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">fmt.Println(<span class="string">"删除了第2行"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//更改数据</span></span><br><span class="line">stm, err = db.Prepare(<span class="string">"UPDATE userinfo SET name=? WHERE uid=? OR uid=?"</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">res, err = stm.Exec(<span class="string">"郭嘉"</span>, id<span class="number">-1</span>, id)</span><br><span class="line">checkErr(err)</span><br><span class="line">affect, err := res.RowsAffected()</span><br><span class="line">checkErr(err)</span><br><span class="line">fmt.Println(<span class="string">"总共有"</span>, affect, <span class="string">"行的信息发生了更改"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询数据</span></span><br><span class="line">rows, err = db.Query(<span class="string">"SELECT * FROM userinfo"</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">fmt.Println(<span class="string">"打印数据表的每行信息:"</span>)</span><br><span class="line">fmt.Println(<span class="string">"---------------------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="keyword">var</span> uid <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> city <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> moment <span class="keyword">string</span></span><br><span class="line">err = rows.Scan(&amp;uid, &amp;name, &amp;city, &amp;moment)</span><br><span class="line">checkErr(err)</span><br><span class="line"></span><br><span class="line">fmt.Print(uid, <span class="string">" "</span>)</span><br><span class="line">fmt.Print(name, <span class="string">" "</span>)</span><br><span class="line">fmt.Print(city, <span class="string">" "</span>)</span><br><span class="line">fmt.Println(moment)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkErr</span>(<span class="params">err error</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-ab78626ef24500f9.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/740" alt=""></p><p>进入MySQL查看数据表：</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-135e838917e196c5.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/740" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://hejtao.netlify.com/tags/Golang/"/>
    
      <category term="MySQL" scheme="https://hejtao.netlify.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构</title>
    <link href="https://hejtao.netlify.com/2018/12/20/2018-12-20/"/>
    <id>https://hejtao.netlify.com/2018/12/20/2018-12-20/</id>
    <published>2018-12-20T15:04:00.000Z</published>
    <updated>2019-11-11T19:59:33.200Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><meta name="referrer" content="no-referrer"></p><div class="toc"><!-- toc --><ul><li><a href="#3-4-shun-xu-cun-chu-jie-gou">3.4 顺序存储结构</a></li><li><a href="#3-6-lian-shi-cun-chu-jie-gou">3.6 链式存储结构</a></li><li><a href="#3-11-dan-lian-biao-jie-gou-yu-shun-xu-cun-chu-jie-gou">3.11 单链表结构与顺序存储结构</a></li><li><a href="#3-12-jing-tai-lian-biao">3.12 静态链表</a></li><li><a href="#3-13-xun-huan-lian-biao">3.13 循环链表</a></li><li><a href="#3-14-shuang-xiang-lian-biao">3.14 双向链表</a></li><li><a href="#4-2-zhan">4.2 栈</a></li><li><a href="#4-10-dui-lie">4.10 队列</a></li><li><a href="#4-12-xun-huan-dui-lie">4.12 循环队列</a></li><li><a href="#6-4-shu-de-cun-chu-jie-gou">6.4 树的存储结构</a><ul><li><a href="#6-5-2-te-shu-er-cha-shu">6.5.2 特殊二叉树</a></li></ul></li><li><a href="#6-6-er-cha-shu-xing-zhi">6.6 二叉树性质</a></li><li><a href="#6-8-bian-li-er-cha-shu">6.8 遍历二叉树</a></li><li><a href="#6-8-6-tui-dao-bian-li-jie-guo">6.8.6 推导遍历结果</a></li><li><a href="#6-10-xian-suo-er-cha-shu">6.10 线索二叉树</a><ul><li><a href="#6-11-1-shu-zhuan-huan-wei-er-cha-shu">6.11.1 树转换为二叉树</a></li></ul></li><li><a href="#6-12-he-fu-man-shu">6.12 <strong>赫夫曼树</strong></a><ul><li><a href="#7-4-1-lin-jie-ju-zhen-adjacency-matrix">7.4.1 <strong>邻接矩阵</strong>(adjacency matrix)</a></li><li><a href="#7-4-2-lin-jie-biao">7.4.2 <strong>邻接表</strong></a></li><li><a href="#7-5-1-shen-du-you-xian-bian-li-depth-first-search">7.5.1 <strong>深度优先遍历</strong>(Depth First Search)</a></li><li><a href="#7-5-2-guang-du-you-xian-bian-li-breadth-first-search">7.5.2 <strong>广度优先遍历</strong>(Breadth First Search)</a></li><li><a href="#8-4-1-er-fen-cha-zhao">8.4.1 二分查找</a></li></ul></li><li><a href="#8-6-er-cha-cha-zhao-shu-binary-sort-tree">8.6 二叉查找树(Binary Sort Tree)</a><ul><li><a href="#8-6-2-er-cha-cha-zhao-shu-cha-ru">8.6.2 二叉查找树插入</a></li><li><a href="#8-6-3-er-cha-cha-zhao-shu-shan-chu">8.6.3 二叉查找树删除</a></li></ul></li><li><a href="#8-7-ping-heng-er-cha-shu-avl-shu">8.7 平衡二叉树(AVL树)</a><ul><li><a href="#9-2-1-pai-xu-de-wen-ding-xing">9.2.1 排序的稳定性</a></li><li><a href="#9-2-2-nei-pai-xu-he-wai-pai-xu">9.2.2 内排序和外排序</a></li><li><a href="#9-3-2-mou-pao-pai-xu-suan-fa-bubble-sort">9.3.2 冒泡排序算法(Bubble Sort)</a></li><li><a href="#9-3-3-mou-pao-pai-xu-you-hua">9.3.3 冒泡排序优化</a></li></ul><ul><li><a href="#9-4-1-jian-dan-xuan-ze-pai-xu-simple-selection-sort">9.4.1 简单选择排序(Simple Selection Sort)</a></li></ul><ul><li><a href="#9-5-1-zhi-jie-cha-ru-pai-xu-straight-insertion-sort">9.5.1 直接插入排序(Straight Insertion Sort)</a></li></ul></li><li><a href="#9-6-xi-er-pai-xu-shell-sort">9.6 希尔排序(Shell Sort)</a></li><li><a href="#9-7-dui-pai-xu">9.7 堆排序</a></li><li><a href="#9-8-gui-bing-pai-xu">9.8 归并排序</a></li><li><a href="#9-9-kuai-su-pai-xu">9.9 快速排序</a></li></ul><!-- tocstop --></div><h4><span id="3-4-shun-xu-cun-chu-jie-gou">3.4 顺序存储结构</span><a href="#3-4-shun-xu-cun-chu-jie-gou" class="header-anchor">#</a></h4><p>数值data(起始位置)；数组长度MaxSize；线性表长度length<br>LOC($a<em>{i}$)=LOC($a</em>{1}$)+(i-1)c</p><h4><span id="3-6-lian-shi-cun-chu-jie-gou">3.6 链式存储结构</span><a href="#3-6-lian-shi-cun-chu-jie-gou" class="header-anchor">#</a></h4><p><strong>单链表</strong>，每个节点只包含一个指针域<br>头指针，头节点，第一个节点<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">data <span class="keyword">string</span></span><br><span class="line">next *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LinkList <span class="keyword">struct</span> &#123;</span><br><span class="line">length <span class="keyword">int</span></span><br><span class="line">head   *Node</span><br><span class="line">rear   *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLinkList</span>(<span class="params">head *Node</span>) *<span class="title">LinkList</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;LinkList&#123;<span class="number">0</span>, head, head&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *LinkList</span>) <span class="title">Append</span>(<span class="params">data <span class="keyword">string</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> this.rear == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">node := &amp;Node&#123;data: data&#125;</span><br><span class="line"></span><br><span class="line">this.rear.next = node</span><br><span class="line">this.rear = node</span><br><span class="line">this.length++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *LinkList</span>) <span class="title">Reverse</span>(<span class="params"></span>) *<span class="title">LinkList</span></span> &#123;</span><br><span class="line">head := this.head</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> || head.next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pre *Node = <span class="literal">nil</span></span><br><span class="line">cur := head.next <span class="comment">//head不为空时，当前为第1节点</span></span><br><span class="line">this.rear = head.next  <span class="comment">//第1节点不为空时，作为最后节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">cur.next, pre, cur = pre, cur, cur.next</span><br><span class="line"></span><br><span class="line"><span class="comment">//buf := cur.next</span></span><br><span class="line"><span class="comment">//cur.next = pre</span></span><br><span class="line"><span class="comment">//pre = cur</span></span><br><span class="line"><span class="comment">//cur = buf</span></span><br><span class="line">&#125;</span><br><span class="line">head.next = pre <span class="comment">//指向第最后一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">head := &amp;Node&#123;&#125;</span><br><span class="line">bl := NewLinkList(head)</span><br><span class="line"></span><br><span class="line">bl.Append(<span class="string">"1"</span>)</span><br><span class="line">bl.Append(<span class="string">"2"</span>)</span><br><span class="line">bl.Append(<span class="string">"3"</span>)</span><br><span class="line">bl.Append(<span class="string">"4"</span>)</span><br><span class="line">bl.Reverse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> node := bl.head; node != <span class="literal">nil</span>; node = node.next &#123;</span><br><span class="line">fmt.Print(node.data, <span class="string">"  "</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">  <span class="number">4</span>  <span class="number">3</span>  <span class="number">2</span>  <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h4><span id="3-11-dan-lian-biao-jie-gou-yu-shun-xu-cun-chu-jie-gou">3.11 单链表结构与顺序存储结构</span><a href="#3-11-dan-lian-biao-jie-gou-yu-shun-xu-cun-chu-jie-gou" class="header-anchor">#</a></h4><p>内存分配；时间复杂度(查找，插入和删除)；空间复杂度</p><h4><span id="3-12-jing-tai-lian-biao">3.12 静态链表</span><a href="#3-12-jing-tai-lian-biao" class="header-anchor">#</a></h4><h4><span id="3-13-xun-huan-lian-biao">3.13 循环链表</span><a href="#3-13-xun-huan-lian-biao" class="header-anchor">#</a></h4><p>尾指针rear<br>头节点rear-&gt;next<br>第一个节点rear-&gt;next-&gt;next<br>合并：<br>p=rearA-&gt;next<br>q=rearB-&gt;next<br>rearA-&gt;next=rearB-&gt;next-&gt;next<br>rearB-&gt;next=p<br>free(q)</p><h4><span id="3-14-shuang-xiang-lian-biao">3.14 双向链表</span><a href="#3-14-shuang-xiang-lian-biao" class="header-anchor">#</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">data <span class="keyword">string</span></span><br><span class="line">pre  *Node</span><br><span class="line">next *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BiLinkList <span class="keyword">struct</span> &#123;</span><br><span class="line">length <span class="keyword">int</span></span><br><span class="line">head   *Node</span><br><span class="line">rear   *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBiLinkList</span>(<span class="params">head *Node</span>) *<span class="title">BiLinkList</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;BiLinkList&#123;<span class="number">0</span>, head, head&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *BiLinkList</span>) <span class="title">Append</span>(<span class="params">data <span class="keyword">string</span></span>)</span> &#123;</span><br><span class="line">node := &amp;Node&#123;data: data&#125;</span><br><span class="line"></span><br><span class="line">this.rear.next = node</span><br><span class="line">node.pre = this.rear</span><br><span class="line">this.rear = node</span><br><span class="line">this.length++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *BiLinkList</span>) <span class="title">InsertNext</span>(<span class="params">p *Node, e <span class="keyword">string</span></span>)</span> &#123;</span><br><span class="line"><span class="comment">//省略判断 nd 不为空且属于链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.next == <span class="literal">nil</span> &#123;</span><br><span class="line">this.Append(e)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s := &amp;Node&#123;data: e&#125;</span><br><span class="line">s.pre = p</span><br><span class="line">s.next = p.next</span><br><span class="line">p.next.pre = s</span><br><span class="line">p.next = s</span><br><span class="line">&#125;</span><br><span class="line">this.length++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">head := &amp;Node&#123;&#125;</span><br><span class="line">bl := NewBiLinkList(head)</span><br><span class="line"></span><br><span class="line">bl.Append(<span class="string">"1"</span>)</span><br><span class="line">bl.Append(<span class="string">"2"</span>)</span><br><span class="line">bl.Append(<span class="string">"3"</span>)</span><br><span class="line"></span><br><span class="line">bl.InsertNext(head.next.next, <span class="string">"2.5"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//for i := 0; i &lt; bl.length; i++ &#123;</span></span><br><span class="line"><span class="comment">//fmt.Print(head.next.data, "  ")</span></span><br><span class="line"><span class="comment">//head = head.next</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> node := bl.head; node.next != <span class="literal">nil</span>; node = node.next &#123;</span><br><span class="line">fmt.Print(node.data, <span class="string">"  "</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(bl.rear.data)  <span class="comment">//打印末节点</span></span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2.5</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure><p>使用标准库<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"container/list"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">bl := list.New()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">bl.PushBack(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">head := bl.Front()</span><br><span class="line">rear := bl.Back()</span><br><span class="line"><span class="keyword">for</span> p := head; p != rear; p = p.Next() &#123;</span><br><span class="line">fmt.Print(p.Value, <span class="string">"  "</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(rear.Value)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure></p><h4><span id="4-2-zhan">4.2 栈</span><a href="#4-2-zhan" class="header-anchor">#</a></h4><p>123依次进栈，出栈次序不可能有312(12同时在栈中,2一定先出)<br>s-&gt;top 栈顶指针<br>栈顶指针为-1表示控栈<br>s-&gt;data[s-&gt;top]栈顶元素<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123; <span class="comment">//用于存放 int 的栈</span></span><br><span class="line">nums []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Stack</span>) <span class="title">Push</span>(<span class="params">n <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">this.nums = <span class="built_in">append</span>(this.nums, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Stack</span>) <span class="title">Pop</span>(<span class="params"></span>) <span class="title">int</span></span> &#123;</span><br><span class="line">res := this.nums[<span class="built_in">len</span>(this.nums)<span class="number">-1</span>]</span><br><span class="line">this.nums = this.nums[:<span class="built_in">len</span>(this.nums)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4><span id="4-10-dui-lie">4.10 队列</span><a href="#4-10-dui-lie" class="header-anchor">#</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123; <span class="comment">//Queue 是用于存放 int 的队列</span></span><br><span class="line">nums []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Queue</span>) <span class="title">Push</span>(<span class="params">n <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">this.nums = <span class="built_in">append</span>(this.nums, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Queue</span>) <span class="title">Pop</span>(<span class="params"></span>) <span class="title">int</span></span> &#123;</span><br><span class="line">res := this.nums[<span class="number">0</span>]</span><br><span class="line">this.nums = this.nums[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="4-12-xun-huan-dui-lie">4.12 循环队列</span><a href="#4-12-xun-huan-dui-lie" class="header-anchor">#</a></h4><p>队列满的条件: <strong>(rear+1)%QueueSize == front</strong><br>队列长度:<strong>(rear-front+QueueSize)%QueueSize</strong></p><h4><span id="6-4-shu-de-cun-chu-jie-gou">6.4 树的存储结构</span><a href="#6-4-shu-de-cun-chu-jie-gou" class="header-anchor">#</a></h4><p>双亲表示(数组)，孩子兄弟表示(数组)，孩子表示(数组+链表)</p><h5><span id="6-5-2-te-shu-er-cha-shu">6.5.2 特殊二叉树</span><a href="#6-5-2-te-shu-er-cha-shu" class="header-anchor">#</a></h5><p>斜树，满二叉树，完全二叉树</p><h4><span id="6-6-er-cha-shu-xing-zhi">6.6 二叉树性质</span><a href="#6-6-er-cha-shu-xing-zhi" class="header-anchor">#</a></h4><p>总结点数：$n=n<em>{0}+n</em>{1}+n<em>{2}$<br>分支线总数： $n-1=n</em>{1}+2n<em>{2}$<br>完全二叉树深度：$[log</em>{2}n]+1$<br>完全二叉树按层序排号：节点$i$的左节点为$2i$</p><h4><span id="6-8-bian-li-er-cha-shu">6.8 遍历二叉树</span><a href="#6-8-bian-li-er-cha-shu" class="header-anchor">#</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BinaryTree <span class="keyword">struct</span> &#123;</span><br><span class="line">data  <span class="keyword">string</span></span><br><span class="line">left  *BinaryTree</span><br><span class="line">right *BinaryTree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreOrderRec</span>(<span class="params">bt *BinaryTree</span>)</span> &#123; <span class="comment">//前序</span></span><br><span class="line"><span class="keyword">if</span> bt == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Print(bt.data, <span class="string">" "</span>)</span><br><span class="line">PreOrderRec(bt.left)</span><br><span class="line">PreOrderRec(bt.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MidOrderRec</span>(<span class="params">bt *BinaryTree</span>)</span> &#123; <span class="comment">//中序</span></span><br><span class="line"><span class="keyword">if</span> bt == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MidOrderRec(bt.left)</span><br><span class="line">fmt.Print(bt.data, <span class="string">" "</span>)</span><br><span class="line">MidOrderRec(bt.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PostOrderRec</span>(<span class="params">bt *BinaryTree</span>)</span> &#123; <span class="comment">//后序</span></span><br><span class="line"><span class="keyword">if</span> bt == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PostOrderRec(bt.left)</span><br><span class="line">PostOrderRec(bt.right)</span><br><span class="line">fmt.Print(bt.data, <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">node9 := &amp;BinaryTree&#123;data: <span class="string">"I"</span>&#125;</span><br><span class="line">node8 := &amp;BinaryTree&#123;data: <span class="string">"H"</span>&#125;</span><br><span class="line">node7 := &amp;BinaryTree&#123;data: <span class="string">"G"</span>&#125;</span><br><span class="line">node6 := &amp;BinaryTree&#123;data: <span class="string">"F"</span>&#125;</span><br><span class="line">node5 := &amp;BinaryTree&#123;data: <span class="string">"E"</span>, right: node9&#125;</span><br><span class="line">node4 := &amp;BinaryTree&#123;<span class="string">"D"</span>, node7, node8&#125;</span><br><span class="line">node3 := &amp;BinaryTree&#123;<span class="string">"C"</span>, node5, node6&#125;</span><br><span class="line">node2 := &amp;BinaryTree&#123;data: <span class="string">"B"</span>, left: node4&#125;</span><br><span class="line">root := &amp;BinaryTree&#123;<span class="string">"A"</span>, node2, node3&#125;</span><br><span class="line"></span><br><span class="line">PreOrderRec(root)</span><br><span class="line">fmt.Println()</span><br><span class="line">MidOrderRec(root)</span><br><span class="line">fmt.Println()</span><br><span class="line">PostOrderRec(root)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">A B D G H C E I F </span><br><span class="line">G D H B A E I C F </span><br><span class="line">G H D B I E F C A</span><br></pre></td></tr></table></figure><h4><span id="6-8-6-tui-dao-bian-li-jie-guo">6.8.6 推导遍历结果</span><a href="#6-8-6-tui-dao-bian-li-jie-guo" class="header-anchor">#</a></h4><p>前序遍历序列+中序遍历序列-&gt;二叉树<br>后序遍历序列+中序遍历序列-&gt;二叉树<br>前中后：BAC ABC ACB<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BinaryTree <span class="keyword">struct</span> &#123;</span><br><span class="line">data  <span class="keyword">string</span></span><br><span class="line">left  *BinaryTree</span><br><span class="line">right *BinaryTree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreOrderRec</span>(<span class="params">bt *BinaryTree</span>)</span> &#123; <span class="comment">//前序</span></span><br><span class="line"><span class="keyword">if</span> bt == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Print(bt.data, <span class="string">" "</span>)</span><br><span class="line">PreOrderRec(bt.left)</span><br><span class="line">PreOrderRec(bt.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MidOrderRec</span>(<span class="params">bt *BinaryTree</span>)</span> &#123; <span class="comment">//中序</span></span><br><span class="line"><span class="keyword">if</span> bt == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MidOrderRec(bt.left)</span><br><span class="line">fmt.Print(bt.data, <span class="string">" "</span>)</span><br><span class="line">MidOrderRec(bt.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PostOrderRec</span>(<span class="params">bt *BinaryTree</span>)</span> &#123; <span class="comment">//后序</span></span><br><span class="line"><span class="keyword">if</span> bt == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PostOrderRec(bt.left)</span><br><span class="line">PostOrderRec(bt.right)</span><br><span class="line">fmt.Print(bt.data, <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreMid2Tree</span>(<span class="params">pre, mid []<span class="keyword">string</span></span>) *<span class="title">BinaryTree</span></span> &#123; <span class="comment">//前序+中序推导二叉树</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(pre) != <span class="built_in">len</span>(mid) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"两个切片的长度不相等"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(mid) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root := &amp;BinaryTree&#123; <span class="comment">//前序第一个元素为root</span></span><br><span class="line">data: pre[<span class="number">0</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(mid) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">position := IndexOf(root.data, mid) <span class="comment">//找出root在中序的位置</span></span><br><span class="line"></span><br><span class="line">root.left = PreMid2Tree(pre[<span class="number">1</span>:position+<span class="number">1</span>], mid[:position]) <span class="comment">//递归</span></span><br><span class="line">root.right = PreMid2Tree(pre[position+<span class="number">1</span>:], mid[position+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexOf</span>(<span class="params">ele <span class="keyword">string</span>, seq []<span class="keyword">string</span></span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> seq &#123;</span><br><span class="line"><span class="keyword">if</span> v == ele &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"IndexOf错误，元素不存在"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">bt := PreMid2Tree([]<span class="keyword">string</span>&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"D"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"C"</span>, <span class="string">"E"</span>, <span class="string">"I"</span>, <span class="string">"F"</span>&#125;,</span><br><span class="line">[]<span class="keyword">string</span>&#123;<span class="string">"G"</span>, <span class="string">"D"</span>, <span class="string">"H"</span>, <span class="string">"B"</span>, <span class="string">"A"</span>, <span class="string">"E"</span>, <span class="string">"I"</span>, <span class="string">"C"</span>, <span class="string">"F"</span>&#125;)</span><br><span class="line"></span><br><span class="line">PostOrderRec(bt)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">G H D B I E F C A</span><br></pre></td></tr></table></figure></p><h4><span id="6-10-xian-suo-er-cha-shu">6.10 线索二叉树</span><a href="#6-10-xian-suo-er-cha-shu" class="header-anchor">#</a></h4><p>将节点的空指针改为指向在遍历序列中的前驱或后继的指针。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ThreadBiTree <span class="keyword">struct</span> &#123;</span><br><span class="line">    data  <span class="keyword">string</span></span><br><span class="line">    left  *ThreadBiTree</span><br><span class="line">    right *ThreadBiTree</span><br><span class="line">    lTag  *ThreadBiTree <span class="comment">//一个bit位，区分是指向孩子还是线索</span></span><br><span class="line">    rTag  *ThreadBiTree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pre *ThreadBiTree <span class="comment">//保存前驱</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MidThreading</span>(<span class="params">bt *ThreadBiTree</span>)</span> &#123; <span class="comment">//中序遍历线索化</span></span><br><span class="line">    <span class="keyword">if</span> bt == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MidThreading(bt.left)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> bt.left == <span class="literal">nil</span> &#123; <span class="comment">//若bt有左空指针，则把pre设为bt的前驱，并设置标志位</span></span><br><span class="line">        bt.left = pre</span><br><span class="line">        bt.lTag = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> bt.right == <span class="literal">nil</span> &#123; <span class="comment">//若bt有右空指针，则把bt设为pre的后继，并设置标志位</span></span><br><span class="line">        pre.right = bt</span><br><span class="line">        pre.rTag = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pre = bt</span><br><span class="line"></span><br><span class="line">    MidThreading(bt.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5><span id="6-11-1-shu-zhuan-huan-wei-er-cha-shu">6.11.1 树转换为二叉树</span><a href="#6-11-1-shu-zhuan-huan-wei-er-cha-shu" class="header-anchor">#</a></h5><p>兄弟连线；只保留第一个孩子的连线</p><h4><span id="6-12-he-fu-man-shu">6.12 <strong>赫夫曼树</strong></span><a href="#6-12-he-fu-man-shu" class="header-anchor">#</a></h4><p>带权路径长度(WPL)最小的二叉树<br><img src="https://upload-images.jianshu.io/upload_images/1863961-81d44580cf5163ee.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="Huffman Tree"></p><p>WPL(a)= 5<em>1+15</em>2+40<em>3+30</em>4+10<em>4<br>WPL(b)= 5</em>3+15<em>3+40</em>2+30<em>2+10</em>2</p><p>构造<br><img src="https://upload-images.jianshu.io/upload_images/1863961-1acee79132eab45b.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><p>排序：A5, E10, B15, D30, C40</p><h5><span id="7-4-1-lin-jie-ju-zhen-adjacency-matrix">7.4.1 <strong>邻接矩阵</strong>(adjacency matrix)</span><a href="#7-4-1-lin-jie-ju-zhen-adjacency-matrix" class="header-anchor">#</a></h5><p>无向图：<br><img src="https://upload-images.jianshu.io/upload_images/1863961-d9ce3ee2d67e574e.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><p>有向图：<br><img src="https://upload-images.jianshu.io/upload_images/1863961-d915f439c8959688.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><p>有向网：<br><img src="https://upload-images.jianshu.io/upload_images/1863961-f214b0dd61c11ca3.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><p>无向网的实现：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">INFINITY <span class="keyword">int32</span> = <span class="number">65536</span> <span class="comment">// 无穷</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Edge <span class="keyword">struct</span> &#123; <span class="comment">//边的顶点和权值</span></span><br><span class="line">v0     <span class="keyword">string</span></span><br><span class="line">v1     <span class="keyword">string</span></span><br><span class="line">weight <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Graph <span class="keyword">struct</span> &#123; <span class="comment">//无向网</span></span><br><span class="line">v []<span class="keyword">string</span> <span class="comment">//顶点数组</span></span><br><span class="line">e []Edge   <span class="comment">//边的权值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexOfVertex</span>(<span class="params">vs []<span class="keyword">string</span>, v <span class="keyword">string</span></span>) <span class="title">int</span></span> &#123; <span class="comment">//顶点在顶点数组的位置</span></span><br><span class="line"><span class="keyword">for</span> i, value := <span class="keyword">range</span> vs &#123;</span><br><span class="line"><span class="keyword">if</span> value == v &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"边的顶点不在顶点数组中！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Graph</span>) <span class="title">AdjMatrix</span>(<span class="params"></span>) [][]<span class="title">int32</span></span> &#123;</span><br><span class="line">vertexNum := <span class="built_in">len</span>(this.v)</span><br><span class="line"></span><br><span class="line">adjM := <span class="built_in">make</span>([][]<span class="keyword">int32</span>, vertexNum) <span class="comment">//生成矩阵用两次make()</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; vertexNum; i++ &#123;   <span class="comment">//初始化</span></span><br><span class="line">adjM[i] = <span class="built_in">make</span>([]<span class="keyword">int32</span>, vertexNum)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; vertexNum; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == i &#123;</span><br><span class="line">adjM[i][j] = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">adjM[i][j] = INFINITY</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e := this.e</span><br><span class="line">v := this.v</span><br><span class="line"><span class="keyword">for</span> _, edge := <span class="keyword">range</span> e &#123;</span><br><span class="line">adjM[IndexOfVertex(v, edge.v0)][IndexOfVertex(v, edge.v1)] = edge.weight</span><br><span class="line">adjM[IndexOfVertex(v, edge.v1)][IndexOfVertex(v, edge.v0)] = edge.weight <span class="comment">//因为是无向图所以是对称矩阵</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> adjM</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">v := []<span class="keyword">string</span>&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>&#125;</span><br><span class="line">e := []Edge&#123;</span><br><span class="line">Edge&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="number">5</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"A"</span>, <span class="string">"C"</span>, <span class="number">3</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"A"</span>, <span class="string">"D"</span>, <span class="number">6</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"B"</span>, <span class="string">"C"</span>, <span class="number">7</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"C"</span>, <span class="string">"D"</span>, <span class="number">9</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">graph := &amp;Graph&#123;v, e&#125; <span class="comment">//生成无向网</span></span><br><span class="line"></span><br><span class="line">fmt.Println(graph.AdjMatrix())</span><br><span class="line"><span class="comment">//     A    B     C    D</span></span><br><span class="line"><span class="comment">//A [  0    5      3    6   ]</span></span><br><span class="line"><span class="comment">//B [  5    0      7  65536 ]</span></span><br><span class="line"><span class="comment">//C [  3    7      0    9   ]</span></span><br><span class="line"><span class="comment">//D [  6  65536    9    0   ]</span></span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">[[<span class="number">0</span> <span class="number">5</span> <span class="number">3</span> <span class="number">6</span>] [<span class="number">5</span> <span class="number">0</span> <span class="number">7</span> <span class="number">65536</span>] [<span class="number">3</span> <span class="number">7</span> <span class="number">0</span> <span class="number">9</span>] [<span class="number">6</span> <span class="number">65536</span> <span class="number">9</span> <span class="number">0</span>]]</span><br></pre></td></tr></table></figure></p><h5><span id="7-4-2-lin-jie-biao">7.4.2 <strong>邻接表</strong></span><a href="#7-4-2-lin-jie-biao" class="header-anchor">#</a></h5><p>无向图：<br><img src="https://upload-images.jianshu.io/upload_images/1863961-a0854989cc6149ef.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Edge <span class="keyword">struct</span> &#123; <span class="comment">//给定顶点定义边</span></span><br><span class="line">v0 <span class="keyword">string</span></span><br><span class="line">v1 <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Graph <span class="keyword">struct</span> &#123; <span class="comment">//无向图</span></span><br><span class="line">v []<span class="keyword">string</span> <span class="comment">//顶点数组</span></span><br><span class="line">e []Edge   <span class="comment">//边数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123; <span class="comment">//邻接表的边表节点</span></span><br><span class="line">adjvex <span class="keyword">int</span></span><br><span class="line">next   *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123; <span class="comment">//邻接表的顶点</span></span><br><span class="line">data      <span class="keyword">string</span></span><br><span class="line">firstedge *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LinkList <span class="keyword">struct</span> &#123; <span class="comment">//邻接表的链表</span></span><br><span class="line">head *Vertex</span><br><span class="line">rear *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *LinkList</span>) <span class="title">Append</span>(<span class="params">adjvex <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">newNode := &amp;Node&#123;adjvex: adjvex&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> this.rear == <span class="literal">nil</span> &#123;</span><br><span class="line">this.head.firstedge = newNode</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">this.rear.next = newNode</span><br><span class="line">this.rear = newNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.rear = newNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexOfVertex</span>(<span class="params">vs []<span class="keyword">string</span>, v <span class="keyword">string</span></span>) <span class="title">int</span></span> &#123; <span class="comment">//顶点在顶点数组的位置</span></span><br><span class="line"><span class="keyword">for</span> i, value := <span class="keyword">range</span> vs &#123;</span><br><span class="line"><span class="keyword">if</span> value == v &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"边的顶点不在顶点数组中！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Graph</span>) <span class="title">AdjList</span>(<span class="params"></span>) []<span class="title">LinkList</span></span> &#123;</span><br><span class="line">vertexNum := <span class="built_in">len</span>(this.v)</span><br><span class="line">v := this.v</span><br><span class="line">e := this.e</span><br><span class="line"></span><br><span class="line">adjL := <span class="built_in">make</span>([]LinkList, vertexNum) <span class="comment">//用一个单向链表的数组来表示邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for i := 0; i &lt; vertexNum; i++ &#123; //初始</span></span><br><span class="line"><span class="comment">//  adjL[i].head.data = v[i]                因为此时head为nil，没有data字段</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; vertexNum; i++ &#123; <span class="comment">//初始</span></span><br><span class="line">adjL[i].head = &amp;Vertex&#123;data: v[i]&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, edge := <span class="keyword">range</span> e &#123;</span><br><span class="line">i := IndexOfVertex(v, edge.v0)</span><br><span class="line">j := IndexOfVertex(v, edge.v1)</span><br><span class="line">adjL[i].Append(j)</span><br><span class="line">adjL[j].Append(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> adjL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">v := []<span class="keyword">string</span>&#123;<span class="string">"v0"</span>, <span class="string">"v1"</span>, <span class="string">"v2"</span>, <span class="string">"v3"</span>&#125;</span><br><span class="line">e := []Edge&#123;</span><br><span class="line">Edge&#123;<span class="string">"v0"</span>, <span class="string">"v1"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"v0"</span>, <span class="string">"v2"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"v0"</span>, <span class="string">"v3"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"v1"</span>, <span class="string">"v2"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"v2"</span>, <span class="string">"v3"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">graph := &amp;Graph&#123;v, e&#125; <span class="comment">//生成无向图</span></span><br><span class="line"></span><br><span class="line">adjL := graph.AdjList()</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> adjL &#123;</span><br><span class="line">fmt.Print(v.head.data, <span class="string">" "</span>)</span><br><span class="line"><span class="keyword">for</span> node := v.head.firstedge; node != <span class="literal">nil</span>; node = node.next &#123;</span><br><span class="line">fmt.Print(node.adjvex, <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">v0 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line">v1 <span class="number">0</span> <span class="number">2</span> </span><br><span class="line">v2 <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> </span><br><span class="line">v3 <span class="number">0</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>有向网：<br><img src="https://upload-images.jianshu.io/upload_images/1863961-95004e37703686d9.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><h5><span id="7-5-1-shen-du-you-xian-bian-li-depth-first-search">7.5.1 <strong>深度优先遍历</strong>(Depth First Search)</span><a href="#7-5-1-shen-du-you-xian-bian-li-depth-first-search" class="header-anchor">#</a></h5><p><img src="https://upload-images.jianshu.io/upload_images/1863961-4139cb15eb112b82.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flag []<span class="keyword">bool</span> <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Edge <span class="keyword">struct</span> &#123; <span class="comment">//给定顶点定义边</span></span><br><span class="line">v0 <span class="keyword">string</span></span><br><span class="line">v1 <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Graph <span class="keyword">struct</span> &#123; <span class="comment">//无向图</span></span><br><span class="line">v []<span class="keyword">string</span> <span class="comment">//顶点数组</span></span><br><span class="line">e []Edge   <span class="comment">//边数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Graph</span>) <span class="title">AdjMatrix</span>(<span class="params"></span>) [][]<span class="title">int</span></span> &#123;</span><br><span class="line">vertexNum := <span class="built_in">len</span>(this.v)</span><br><span class="line"></span><br><span class="line">adjM := <span class="built_in">make</span>([][]<span class="keyword">int</span>, vertexNum) <span class="comment">//生成矩阵用两次make()</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; vertexNum; i++ &#123; <span class="comment">//初始化</span></span><br><span class="line">adjM[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, vertexNum)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; vertexNum; j++ &#123;</span><br><span class="line">adjM[i][j] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e := this.e</span><br><span class="line">v := this.v</span><br><span class="line"><span class="keyword">for</span> _, edge := <span class="keyword">range</span> e &#123;</span><br><span class="line">adjM[IndexOfVertex(v, edge.v0)][IndexOfVertex(v, edge.v1)] = <span class="number">1</span></span><br><span class="line">adjM[IndexOfVertex(v, edge.v1)][IndexOfVertex(v, edge.v0)] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> adjM</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexOfVertex</span>(<span class="params">vs []<span class="keyword">string</span>, v <span class="keyword">string</span></span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, value := <span class="keyword">range</span> vs &#123;</span><br><span class="line"><span class="keyword">if</span> value == v &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"边的顶点不在顶点数组中！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DFSTraverse</span>(<span class="params">adjM [][]<span class="keyword">int</span></span>)</span> &#123; <span class="comment">//输入无向图的邻接矩阵</span></span><br><span class="line">vertexNum := <span class="built_in">len</span>(adjM)</span><br><span class="line"></span><br><span class="line">flag = <span class="built_in">make</span>([]<span class="keyword">bool</span>, vertexNum) <span class="comment">//初始化flag，注意这里不能用 :=</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; vertexNum; i++ &#123;</span><br><span class="line">flag[i] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; vertexNum; i++ &#123; <span class="comment">//对未访问的节点执行深度搜索</span></span><br><span class="line"><span class="keyword">if</span> !flag[i] &#123;</span><br><span class="line">DFS(vertexNum, i, adjM)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DFS</span>(<span class="params">vertexNum <span class="keyword">int</span>, i <span class="keyword">int</span>, adjM [][]<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">flag[i] = <span class="literal">true</span></span><br><span class="line">fmt.Print(i, <span class="string">"  "</span>)               <span class="comment">//打印被访问的节点序号</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; vertexNum; j++ &#123; <span class="comment">//对未被访问的邻节点递归</span></span><br><span class="line"><span class="keyword">if</span> adjM[i][j] == <span class="number">1</span> &amp;&amp; !flag[j] &#123;</span><br><span class="line">DFS(vertexNum, j, adjM)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">v := []<span class="keyword">string</span>&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>&#125;</span><br><span class="line">e := []Edge&#123;</span><br><span class="line">Edge&#123;<span class="string">"A"</span>, <span class="string">"B"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"A"</span>, <span class="string">"F"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"B"</span>, <span class="string">"C"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"B"</span>, <span class="string">"G"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"B"</span>, <span class="string">"I"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"F"</span>, <span class="string">"G"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"F"</span>, <span class="string">"E"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"C"</span>, <span class="string">"D"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"C"</span>, <span class="string">"I"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"G"</span>, <span class="string">"D"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"G"</span>, <span class="string">"H"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"E"</span>, <span class="string">"D"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"E"</span>, <span class="string">"H"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">graph := &amp;Graph&#123;v, e&#125; <span class="comment">//生成无向图</span></span><br><span class="line">adjM := graph.AdjMatrix()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(adjM); i++ &#123;</span><br><span class="line">fmt.Println(adjM[i])</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"-------------------"</span>)</span><br><span class="line">DFSTraverse(adjM)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">-------------------</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br></pre></td></tr></table></figure><h5><span id="7-5-2-guang-du-you-xian-bian-li-breadth-first-search">7.5.2 <strong>广度优先遍历</strong>(Breadth First Search)</span><a href="#7-5-2-guang-du-you-xian-bian-li-breadth-first-search" class="header-anchor">#</a></h5><p><img src="https://upload-images.jianshu.io/upload_images/1863961-1aab42f56392a97a.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Edge <span class="keyword">struct</span> &#123; <span class="comment">//给定顶点定义边</span></span><br><span class="line">v0 <span class="keyword">string</span></span><br><span class="line">v1 <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Graph <span class="keyword">struct</span> &#123; <span class="comment">//无向图</span></span><br><span class="line">v []<span class="keyword">string</span> <span class="comment">//顶点数组</span></span><br><span class="line">e []Edge   <span class="comment">//边数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123; <span class="comment">//邻接表的边表节点</span></span><br><span class="line">adjvex <span class="keyword">int</span></span><br><span class="line">next   *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123; <span class="comment">//邻接表的顶点</span></span><br><span class="line">data      <span class="keyword">string</span></span><br><span class="line">firstedge *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LinkList <span class="keyword">struct</span> &#123; <span class="comment">//邻接表的链表</span></span><br><span class="line">head *Vertex</span><br><span class="line">rear *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">nums []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Queue</span>) <span class="title">Push</span>(<span class="params">n <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">this.nums = <span class="built_in">append</span>(this.nums, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Queue</span>) <span class="title">Pop</span>(<span class="params"></span>) <span class="title">int</span></span> &#123;</span><br><span class="line">res := this.nums[<span class="number">0</span>]</span><br><span class="line">this.nums = this.nums[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *LinkList</span>) <span class="title">Append</span>(<span class="params">adjvex <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">newNode := &amp;Node&#123;adjvex: adjvex&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> this.rear == <span class="literal">nil</span> &#123;</span><br><span class="line">this.head.firstedge = newNode</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">this.rear.next = newNode</span><br><span class="line">this.rear = newNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.rear = newNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexOfVertex</span>(<span class="params">vs []<span class="keyword">string</span>, v <span class="keyword">string</span></span>) <span class="title">int</span></span> &#123; <span class="comment">//顶点在顶点数组的位置</span></span><br><span class="line"><span class="keyword">for</span> i, value := <span class="keyword">range</span> vs &#123;</span><br><span class="line"><span class="keyword">if</span> value == v &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"边的顶点不在顶点数组中！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Graph</span>) <span class="title">AdjList</span>(<span class="params"></span>) []<span class="title">LinkList</span></span> &#123;</span><br><span class="line">vertexNum := <span class="built_in">len</span>(this.v)</span><br><span class="line">v := this.v</span><br><span class="line">e := this.e</span><br><span class="line"></span><br><span class="line">adjL := <span class="built_in">make</span>([]LinkList, vertexNum) <span class="comment">//用一个单向链表的数组来表示邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for i := 0; i &lt; vertexNum; i++ &#123; //初始</span></span><br><span class="line"><span class="comment">//adjL[i].head.data = v[i]                因为此时head为nil，没有data字段</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; vertexNum; i++ &#123; <span class="comment">//初始</span></span><br><span class="line">adjL[i].head = &amp;Vertex&#123;data: v[i]&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, edge := <span class="keyword">range</span> e &#123;</span><br><span class="line">i := IndexOfVertex(v, edge.v0)</span><br><span class="line">j := IndexOfVertex(v, edge.v1)</span><br><span class="line">adjL[i].Append(j)</span><br><span class="line">adjL[j].Append(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> adjL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFSTraverse</span>(<span class="params">adjL []LinkList</span>)</span> &#123; <span class="comment">//输入邻接表</span></span><br><span class="line">vertexNum := <span class="built_in">len</span>(adjL)</span><br><span class="line"></span><br><span class="line">flag := <span class="built_in">make</span>([]<span class="keyword">bool</span>, vertexNum) <span class="comment">//标记被访问的节点</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; vertexNum; i++ &#123;</span><br><span class="line">flag[i] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Q := <span class="built_in">new</span>(Queue) <span class="comment">//队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; vertexNum; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> !flag[i] &#123; <span class="comment">//如果顶点未被访问</span></span><br><span class="line">flag[i] = <span class="literal">true</span></span><br><span class="line">Q.Push(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(Q.nums) &gt; <span class="number">0</span> &#123; <span class="comment">//队列不为空</span></span><br><span class="line">j := Q.Pop()</span><br><span class="line">fmt.Print(adjL[j].head.data, <span class="string">" "</span>) <span class="comment">//打印节点</span></span><br><span class="line"><span class="keyword">for</span> node := adjL[j].head.firstedge; node != <span class="literal">nil</span>; node = node.next &#123;</span><br><span class="line"><span class="keyword">if</span> flag[node.adjvex] == <span class="literal">false</span> &#123;</span><br><span class="line">flag[node.adjvex] = <span class="literal">true</span></span><br><span class="line">Q.Push(node.adjvex)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">v := []<span class="keyword">string</span>&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>&#125;</span><br><span class="line">e := []Edge&#123;</span><br><span class="line">Edge&#123;<span class="string">"A"</span>, <span class="string">"B"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"A"</span>, <span class="string">"F"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"B"</span>, <span class="string">"C"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"B"</span>, <span class="string">"G"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"B"</span>, <span class="string">"I"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"F"</span>, <span class="string">"G"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"F"</span>, <span class="string">"E"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"C"</span>, <span class="string">"D"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"C"</span>, <span class="string">"I"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"G"</span>, <span class="string">"D"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"G"</span>, <span class="string">"H"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"E"</span>, <span class="string">"D"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"E"</span>, <span class="string">"H"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">graph := &amp;Graph&#123;v, e&#125; <span class="comment">//生成无向图</span></span><br><span class="line"></span><br><span class="line">adjL := graph.AdjList()</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> adjL &#123;</span><br><span class="line">fmt.Print(v.head.data, <span class="string">" "</span>)</span><br><span class="line"><span class="keyword">for</span> node := v.head.firstedge; node != <span class="literal">nil</span>; node = node.next &#123;</span><br><span class="line">fmt.Print(adjL[node.adjvex].head.data, <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"-----------------"</span>)</span><br><span class="line">BFSTraverse(adjL)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">A B F </span><br><span class="line">B A C G I </span><br><span class="line">C B D I </span><br><span class="line">D C G E </span><br><span class="line">E F D H </span><br><span class="line">F A G E </span><br><span class="line">G B F D H </span><br><span class="line">H G E </span><br><span class="line">I B C </span><br><span class="line">-----------------</span><br><span class="line">A B F C G I E D H</span><br></pre></td></tr></table></figure><h5><span id="8-4-1-er-fen-cha-zhao">8.4.1 二分查找</span><a href="#8-4-1-er-fen-cha-zhao" class="header-anchor">#</a></h5><p><img src="https://upload-images.jianshu.io/upload_images/1863961-e7c869cf58b3751b.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BiSearch</span>(<span class="params">a []<span class="keyword">int</span>, n, key <span class="keyword">int</span></span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> low, high, mid <span class="keyword">int</span></span><br><span class="line">low = <span class="number">1</span></span><br><span class="line">high = n</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">mid = (low + high) / <span class="number">2</span></span><br><span class="line"><span class="comment">//mid = low + (high-low)(key-1)/(99-1)  插值</span></span><br><span class="line"><span class="keyword">if</span> key == a[mid] &#123;</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> key &lt; a[mid] &#123;</span><br><span class="line">high = mid - <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">35</span>, <span class="number">47</span>, <span class="number">59</span>, <span class="number">62</span>, <span class="number">73</span>, <span class="number">88</span>, <span class="number">99</span>&#125;</span><br><span class="line">fmt.Println(BiSearch(a, <span class="number">10</span>, <span class="number">62</span>))</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><h4><span id="8-6-er-cha-cha-zhao-shu-binary-sort-tree">8.6 二叉查找树(Binary Sort Tree)</span><a href="#8-6-er-cha-cha-zhao-shu-binary-sort-tree" class="header-anchor">#</a></h4><p>左小右大<br><img src="https://upload-images.jianshu.io/upload_images/1863961-ac2cd3676f5e970c.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BinaryTree <span class="keyword">struct</span> &#123;</span><br><span class="line">data  <span class="keyword">int</span></span><br><span class="line">left  *BinaryTree</span><br><span class="line">right *BinaryTree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchBST</span>(<span class="params">root *BinaryTree, key <span class="keyword">int</span></span>) <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> key &lt; root.data:</span><br><span class="line"><span class="keyword">return</span> SearchBST(root.left, key)</span><br><span class="line"><span class="keyword">case</span> key &gt; root.data:</span><br><span class="line"><span class="keyword">return</span> SearchBST(root.right, key)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">node10 := &amp;BinaryTree&#123;data: <span class="number">37</span>&#125;</span><br><span class="line">node9 := &amp;BinaryTree&#123;data: <span class="number">93</span>&#125;</span><br><span class="line">node8 := &amp;BinaryTree&#123;data: <span class="number">51</span>&#125;</span><br><span class="line">node7 := &amp;BinaryTree&#123;data: <span class="number">35</span>, right: node10&#125;</span><br><span class="line">node6 := &amp;BinaryTree&#123;data: <span class="number">99</span>, left: node9&#125;</span><br><span class="line">node5 := &amp;BinaryTree&#123;data: <span class="number">73</span>&#125;</span><br><span class="line">node4 := &amp;BinaryTree&#123;data: <span class="number">47</span>, left: node7, right: node8&#125;</span><br><span class="line">node3 := &amp;BinaryTree&#123;<span class="number">88</span>, node5, node6&#125;</span><br><span class="line">node2 := &amp;BinaryTree&#123;data: <span class="number">58</span>, left: node4&#125;</span><br><span class="line">root := &amp;BinaryTree&#123;<span class="number">62</span>, node2, node3&#125;</span><br><span class="line"></span><br><span class="line">fmt.Print(SearchBST(root, <span class="number">73</span>), <span class="string">" "</span>)</span><br><span class="line">fmt.Print(SearchBST(root, <span class="number">99</span>), <span class="string">" "</span>)</span><br><span class="line">fmt.Print(SearchBST(root, <span class="number">37</span>), <span class="string">" "</span>)</span><br><span class="line">fmt.Print(SearchBST(root, <span class="number">48</span>), <span class="string">" "</span>)</span><br><span class="line">fmt.Print(SearchBST(root, <span class="number">100</span>))</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line"><span class="literal">true</span> <span class="literal">true</span> <span class="literal">true</span> <span class="literal">false</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><h5><span id="8-6-2-er-cha-cha-zhao-shu-cha-ru">8.6.2 二叉查找树插入</span><a href="#8-6-2-er-cha-cha-zhao-shu-cha-ru" class="header-anchor">#</a></h5><p><img src="https://upload-images.jianshu.io/upload_images/1863961-a95e74e49282a74c.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BinaryTree <span class="keyword">struct</span> &#123;</span><br><span class="line">data  <span class="keyword">int</span></span><br><span class="line">left  *BinaryTree</span><br><span class="line">right *BinaryTree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertBST</span>(<span class="params">root *BinaryTree, key <span class="keyword">int</span></span>) (<span class="params"><span class="keyword">bool</span>, *BinaryTree</span>)</span> &#123;</span><br><span class="line"><span class="comment">//if SearchBST(root, key) &#123;  //假设不存在</span></span><br><span class="line"><span class="comment">//return false, root</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, Insert(root, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insert</span>(<span class="params">root *BinaryTree, key <span class="keyword">int</span></span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;BinaryTree&#123;data: key&#125; <span class="comment">//插入的本质要生成新的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> key &lt; root.data &#123;</span><br><span class="line">root.left = Insert(root.left, key)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有key = root.data 的情况</span></span><br><span class="line">root.right = Insert(root.right, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">node10 := &amp;BinaryTree&#123;data: <span class="number">37</span>&#125;</span><br><span class="line">node9 := &amp;BinaryTree&#123;data: <span class="number">93</span>&#125;</span><br><span class="line">node8 := &amp;BinaryTree&#123;data: <span class="number">51</span>&#125;</span><br><span class="line">node7 := &amp;BinaryTree&#123;data: <span class="number">35</span>, right: node10&#125;</span><br><span class="line">node6 := &amp;BinaryTree&#123;data: <span class="number">99</span>, left: node9&#125;</span><br><span class="line">node5 := &amp;BinaryTree&#123;data: <span class="number">73</span>&#125;</span><br><span class="line">node4 := &amp;BinaryTree&#123;data: <span class="number">47</span>, left: node7, right: node8&#125;</span><br><span class="line">node3 := &amp;BinaryTree&#123;<span class="number">88</span>, node5, node6&#125;</span><br><span class="line">node2 := &amp;BinaryTree&#123;data: <span class="number">58</span>, left: node4&#125;</span><br><span class="line">root := &amp;BinaryTree&#123;<span class="number">62</span>, node2, node3&#125;</span><br><span class="line"></span><br><span class="line">fmt.Print(root.right.right.left.data, root.right.right.left.right, <span class="string">" "</span>)</span><br><span class="line">_, root = InsertBST(root, <span class="number">95</span>)</span><br><span class="line">fmt.Print(root.right.right.left.right.data)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line"><span class="number">93</span> &lt;<span class="literal">nil</span>&gt; <span class="number">95</span></span><br></pre></td></tr></table></figure><h5><span id="8-6-3-er-cha-cha-zhao-shu-shan-chu">8.6.3 二叉查找树删除</span><a href="#8-6-3-er-cha-cha-zhao-shu-shan-chu" class="header-anchor">#</a></h5><p><img src="https://upload-images.jianshu.io/upload_images/1863961-73f49cf999259ca8.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-f901a4ee0de2558c.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BinaryTree <span class="keyword">struct</span> &#123;</span><br><span class="line">data  <span class="keyword">int</span></span><br><span class="line">left  *BinaryTree</span><br><span class="line">right *BinaryTree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除data为key的节点，并返回该二叉树的根节点。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteBST</span>(<span class="params">root *BinaryTree, key <span class="keyword">int</span></span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> key &gt; root.data: <span class="comment">//在右子树中</span></span><br><span class="line">root.right = DeleteBST(root.right, key)</span><br><span class="line"><span class="keyword">case</span> key &lt; root.data: <span class="comment">//在左子树中</span></span><br><span class="line">root.left = DeleteBST(root.left, key)</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//key == root.data</span></span><br><span class="line"><span class="keyword">if</span> root.left == <span class="literal">nil</span> &amp;&amp; root.right == <span class="literal">nil</span> &#123; <span class="comment">//该节点为叶节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> root.left == <span class="literal">nil</span> &amp;&amp; root.right != <span class="literal">nil</span> &#123; <span class="comment">//该节点仅有右子树</span></span><br><span class="line"><span class="keyword">return</span> root.right</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> root.left != <span class="literal">nil</span> &amp;&amp; root.right == <span class="literal">nil</span> &#123; <span class="comment">//该节点仅有左子树</span></span><br><span class="line"><span class="keyword">return</span> root.left</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//该节点有左、右子树</span></span><br><span class="line">success := FindMin(root.right) <span class="comment">//找到key的后继节点,即48</span></span><br><span class="line">root.right = DeleteBST(root.right, success)</span><br><span class="line">root.data = success</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到BST中data最小的节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindMin</span>(<span class="params">root *BinaryTree</span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root.left == <span class="literal">nil</span> &#123; <span class="comment">//最小值在根节点</span></span><br><span class="line"><span class="keyword">return</span> root.data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> FindMin(root.left) <span class="comment">//最小值在左子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">node16 := &amp;BinaryTree&#123;data: <span class="number">50</span>&#125;</span><br><span class="line">node15 := &amp;BinaryTree&#123;data: <span class="number">48</span>&#125;</span><br><span class="line">node14 := &amp;BinaryTree&#123;data: <span class="number">36</span>&#125;</span><br><span class="line">node13 := &amp;BinaryTree&#123;data: <span class="number">56</span>&#125;</span><br><span class="line">node12 := &amp;BinaryTree&#123;<span class="number">49</span>, node15, node16&#125;</span><br><span class="line">node11 := &amp;BinaryTree&#123;data: <span class="number">37</span>, left: node14&#125;</span><br><span class="line">node10 := &amp;BinaryTree&#123;data: <span class="number">29</span>&#125;</span><br><span class="line">node9 := &amp;BinaryTree&#123;data: <span class="number">93</span>&#125;</span><br><span class="line">node8 := &amp;BinaryTree&#123;<span class="number">51</span>, node12, node13&#125;</span><br><span class="line">node7 := &amp;BinaryTree&#123;<span class="number">35</span>, node10, node11&#125;</span><br><span class="line">node6 := &amp;BinaryTree&#123;data: <span class="number">99</span>, left: node9&#125;</span><br><span class="line">node5 := &amp;BinaryTree&#123;data: <span class="number">73</span>&#125;</span><br><span class="line">node4 := &amp;BinaryTree&#123;data: <span class="number">47</span>, left: node7, right: node8&#125;</span><br><span class="line">node3 := &amp;BinaryTree&#123;<span class="number">88</span>, node5, node6&#125;</span><br><span class="line">node2 := &amp;BinaryTree&#123;data: <span class="number">58</span>, left: node4&#125;</span><br><span class="line">root := &amp;BinaryTree&#123;<span class="number">62</span>, node2, node3&#125;</span><br><span class="line"></span><br><span class="line">root = DeleteBST(root, <span class="number">47</span>)</span><br><span class="line">NewNode := root.left.left</span><br><span class="line">fmt.Print(NewNode.data, <span class="string">" "</span>) <span class="comment">//打印代替删除位置的新节点</span></span><br><span class="line">fmt.Print(NewNode.left.data, NewNode.right.data)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line"><span class="number">48</span> <span class="number">35</span> <span class="number">51</span></span><br></pre></td></tr></table></figure><h4><span id="8-7-ping-heng-er-cha-shu-avl-shu">8.7 平衡二叉树(AVL树)</span><a href="#8-7-ping-heng-er-cha-shu-avl-shu" class="header-anchor">#</a></h4><p><strong>平衡因子</strong>(BF)=左子树的深度-右子树的深度<br><strong>旋转：</strong><br><img src="https://upload-images.jianshu.io/upload_images/1863961-b493bc28e8068b46.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-b6715f1391c81757.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RRotate</span>(<span class="params">k2 *BinaryTree</span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line">k1 := k2.left</span><br><span class="line">y := k1.right</span><br><span class="line">k1.right = k2</span><br><span class="line">k2.left = y</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> k1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>双旋转：</strong><br><img src="https://upload-images.jianshu.io/upload_images/1863961-132deac059f8995f.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LRRotate</span>(<span class="params">k3 *BinaryTree</span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line">k3.left = LRotate(k3.left)</span><br><span class="line"><span class="keyword">return</span> RRotate(k3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-fe05b14c2bdb3e2c.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""></p><p>将任意二叉树一次性调整AVL<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BinaryTree <span class="keyword">struct</span> &#123;</span><br><span class="line">data  <span class="keyword">int</span></span><br><span class="line">bf    <span class="keyword">int</span> <span class="comment">//Balance Factor</span></span><br><span class="line">left  *BinaryTree</span><br><span class="line">right *BinaryTree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">R_Rotate</span>(<span class="params">root *BinaryTree</span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line">a := root.left</span><br><span class="line">b := a.right</span><br><span class="line">a.right = root</span><br><span class="line">root.left = b</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左旋</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">L_Rotate</span>(<span class="params">root *BinaryTree</span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line">a := root.right</span><br><span class="line">b := a.left</span><br><span class="line">a.left = root</span><br><span class="line">root.right = b</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LR_Rotate</span>(<span class="params">root *BinaryTree</span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line">root.left = L_Rotate(root.left)</span><br><span class="line"><span class="keyword">return</span> R_Rotate(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右左旋转</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RL_Rotate</span>(<span class="params">root *BinaryTree</span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line">root.right = R_Rotate(root.right)</span><br><span class="line"><span class="keyword">return</span> L_Rotate(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将任意二叉树转化成AVL</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span>(<span class="params">root *BinaryTree</span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line">a := &amp;BinaryTree&#123;left: root&#125; <span class="comment">//给二叉树生成一个父母节点</span></span><br><span class="line">_, isAVL := Bal(root)        <span class="comment">//调整二叉树的子树并判断二叉树是否平衡</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> !isAVL &#123;</span><br><span class="line">Bal(a)                 <span class="comment">//处理a的左子树，即二叉树</span></span><br><span class="line">_, isAVL = Bal(a.left) <span class="comment">//判断二叉树是否平衡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a.left <span class="comment">//返回二叉树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整子树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bal</span>(<span class="params">root *BinaryTree</span>) (<span class="params"><span class="keyword">int</span>, <span class="keyword">bool</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">leftHeight, leftIsBalanced := Bal(root.left)</span><br><span class="line">rightHeight, rightIsBalanced := Bal(root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !leftIsBalanced &#123;</span><br><span class="line">root.left = Rotate(root.left)    <span class="comment">//调整左子树</span></span><br><span class="line">leftHeight = UpdateBF(root.left) <span class="comment">//刷新左子树的BF和高度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !rightIsBalanced &#123;</span><br><span class="line">root.right = Rotate(root.right)</span><br><span class="line">rightHeight = UpdateBF(root.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root.bf = leftHeight - rightHeight <span class="comment">//计算本身的BF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Abs(root.bf) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Max(leftHeight, rightHeight) + <span class="number">1</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Max(leftHeight, rightHeight) + <span class="number">1</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对不平衡树进行旋转调整</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Rotate</span>(<span class="params">root *BinaryTree</span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root.bf &gt; <span class="number">0</span> &#123; <span class="comment">//左边太重，需要右旋</span></span><br><span class="line"><span class="keyword">if</span> root.left.bf &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> LR_Rotate(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> R_Rotate(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> root.right.bf &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> RL_Rotate(root)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> L_Rotate(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateBF</span>(<span class="params">root *BinaryTree</span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">leftHeight := UpdateBF(root.left)</span><br><span class="line">rightHeight := UpdateBF(root.right)</span><br><span class="line">root.bf = leftHeight - rightHeight</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Max(leftHeight, rightHeight) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span>(<span class="params">a, b <span class="keyword">int</span></span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span>(<span class="params">a <span class="keyword">int</span></span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertBST</span>(<span class="params">root *BinaryTree, key <span class="keyword">int</span></span>) (<span class="params"><span class="keyword">bool</span>, *BinaryTree</span>)</span> &#123;</span><br><span class="line"><span class="comment">//if SearchBST(root, key) &#123;  //假设不存在</span></span><br><span class="line"><span class="comment">//  return false, root</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, Insert(root, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insert</span>(<span class="params">root *BinaryTree, key <span class="keyword">int</span></span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;BinaryTree&#123;data: key&#125; <span class="comment">//插入的本质要生成新的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> key &lt; root.data &#123;</span><br><span class="line">root.left = Insert(root.left, key)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有key = root.data 的情况</span></span><br><span class="line">root.right = Insert(root.right, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintBF</span>(<span class="params">root *BinaryTree</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrintBF(root.left)</span><br><span class="line">fmt.Print(root.bf, <span class="string">" "</span>)</span><br><span class="line">PrintBF(root.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">root := &amp;BinaryTree&#123;data: <span class="number">1</span>&#125;</span><br><span class="line">InsertBST(root, <span class="number">7</span>)</span><br><span class="line">InsertBST(root, <span class="number">2</span>)</span><br><span class="line">InsertBST(root, <span class="number">4</span>)</span><br><span class="line">InsertBST(root, <span class="number">8</span>)</span><br><span class="line">InsertBST(root, <span class="number">3</span>)</span><br><span class="line">InsertBST(root, <span class="number">10</span>)</span><br><span class="line">InsertBST(root, <span class="number">5</span>)</span><br><span class="line">InsertBST(root, <span class="number">9</span>)</span><br><span class="line">InsertBST(root, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">UpdateBF(root)</span><br><span class="line">PrintBF(root) <span class="comment">//二叉树的BF</span></span><br><span class="line">fmt.Println()</span><br><span class="line">PrintBF(Balance(root)) <span class="comment">//平衡调整后的二叉树的BF</span></span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line"><span class="number">-5</span> <span class="number">-3</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><h5><span id="9-2-1-pai-xu-de-wen-ding-xing">9.2.1 排序的稳定性</span><a href="#9-2-1-pai-xu-de-wen-ding-xing" class="header-anchor">#</a></h5><p><img src="https://upload-images.jianshu.io/upload_images/1863961-da3eb9745c415426.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><h5><span id="9-2-2-nei-pai-xu-he-wai-pai-xu">9.2.2 内排序和外排序</span><a href="#9-2-2-nei-pai-xu-he-wai-pai-xu" class="header-anchor">#</a></h5><p><strong>内排序</strong>是在排序的整个过程中，待排序的所有记录全部在内存中。<strong>外排序</strong>的整个过程则需要在内外存之间交换数据。</p><h5><span id="9-3-2-mou-pao-pai-xu-suan-fa-bubble-sort">9.3.2 冒泡排序算法(Bubble Sort)</span><a href="#9-3-2-mou-pao-pai-xu-suan-fa-bubble-sort" class="header-anchor">#</a></h5><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改 变，所以冒泡排序是一种稳定排序算法。<br><img src="https://upload-images.jianshu.io/upload_images/1863961-35aca3bf05e9be84.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span>(<span class="params">a []<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length<span class="number">-1</span>; i++ &#123; <span class="comment">//需要交换(length-2)次，从后往前排</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; length-i; j++ &#123; <span class="comment">//当i=1时，j可以取到(length-2)</span></span><br><span class="line"><span class="keyword">if</span> a[j] &gt; a[j+<span class="number">1</span>] &#123;</span><br><span class="line">a[j], a[j+<span class="number">1</span>] = a[j+<span class="number">1</span>], a[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>&#125;</span><br><span class="line">BubbleSort(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归实现. for 循环找出最大值排到末尾，去掉末尾把对新的序列递归<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func RecurBubble(a []int) &#123;</span><br><span class="line">length := len(a)</span><br><span class="line">if length &lt; 3 &#123;  //递归跳出条件</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for j := 1; j &lt;= length-2; j++ &#123;</span><br><span class="line">if a[j] &gt; a[j+1] &#123;</span><br><span class="line">a[j], a[j+1] = a[j+1], a[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = a[0 : length-1] //不包括第 length-1 个元素</span><br><span class="line"></span><br><span class="line">RecurBubble(a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a := []int&#123;0, 9, 1, 5, 8, 3, 7, 4, 6, 2&#125;</span><br><span class="line">RecurBubble(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5><span id="9-3-3-mou-pao-pai-xu-you-hua">9.3.3 冒泡排序优化</span><a href="#9-3-3-mou-pao-pai-xu-you-hua" class="header-anchor">#</a></h5><p><img src="https://upload-images.jianshu.io/upload_images/1863961-2c7713c7b8115947.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort2</span>(<span class="params">a []<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">flag := <span class="literal">true</span> <span class="comment">// 有数据交换</span></span><br><span class="line">length := <span class="built_in">len</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length<span class="number">-1</span> &amp;&amp; flag; i++ &#123; </span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; length-i; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> a[j] &gt; a[j+<span class="number">1</span>] &#123;</span><br><span class="line">a[j], a[j+<span class="number">1</span>] = a[j+<span class="number">1</span>], a[j]</span><br><span class="line">flag = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>&#125;</span><br><span class="line">BubbleSort2(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3><span id="9-4-1-jian-dan-xuan-ze-pai-xu-simple-selection-sort">9.4.1 简单选择排序(Simple Selection Sort)</span><a href="#9-4-1-jian-dan-xuan-ze-pai-xu-simple-selection-sort" class="header-anchor">#</a></h3><p>复杂度与冒泡排序同为$O(n^{2})$,但性能更优(数据交换次数更少)。选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SelectionSort</span>(<span class="params">a []<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">var</span> min <span class="keyword">int</span></span><br><span class="line">length := <span class="built_in">len</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length<span class="number">-1</span>; i++ &#123; <span class="comment">//插入次数(length-2)，从前往后排；把后面序列中较小的数插</span></span><br><span class="line">min = i</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环找出序列中的最小数的下标</span></span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; length; j++ &#123; <span class="comment">//j取到i后的所有数</span></span><br><span class="line"><span class="keyword">if</span> a[j] &lt; a[min] &#123; <span class="comment">//之后有更小的数</span></span><br><span class="line">min = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i != min &#123; <span class="comment">//下标改变，交换，防止数据丢失</span></span><br><span class="line">a[i], a[min] = a[min], a[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>&#125;</span><br><span class="line">SelectionSort(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>反过来排<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func SelectionSort(a []int) &#123;</span><br><span class="line">var max int</span><br><span class="line">length := len(a)</span><br><span class="line"></span><br><span class="line">for i := length - 1; i &gt; 0; i-- &#123; 从大到小排</span><br><span class="line">max = i</span><br><span class="line">for j := 1; j &lt; i; j++ &#123;</span><br><span class="line">if a[j] &gt; a[max] &#123;</span><br><span class="line">max = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if max != i &#123;</span><br><span class="line">a[i], a[max] = a[max], a[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a := []int&#123;0, 9, 1, 5, 8, 3, 7, 4, 6, 2&#125;</span><br><span class="line">SelectionSort(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>递归</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SelectionSort</span>(<span class="params">a []<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> length &lt; <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max := length - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; length<span class="number">-1</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> a[j] &gt; a[max] &#123;</span><br><span class="line">max = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> max != length<span class="number">-1</span> &#123;</span><br><span class="line">a[length<span class="number">-1</span>], a[max] = a[max], a[length<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SelectionSort(a[:length<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>&#125;</span><br><span class="line">SelectionSort(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="9-5-1-zhi-jie-cha-ru-pai-xu-straight-insertion-sort">9.5.1 直接插入排序(Straight Insertion Sort)</span><a href="#9-5-1-zhi-jie-cha-ru-pai-xu-straight-insertion-sort" class="header-anchor">#</a></h5><p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳 定的。<br>复杂度同为为$O(n^{2})$，性能：<strong>插入排序&gt;选择排序&gt;冒泡排序</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertionSort</span>(<span class="params">a []<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">var</span> j <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">2</span>; i &lt; length; i++ &#123; <span class="comment">//第二个数到最后一个数</span></span><br><span class="line"><span class="keyword">if</span> a[i] &lt; a[i<span class="number">-1</span>] &#123; <span class="comment">//第i个数比前面的数小，需要插入</span></span><br><span class="line">a[<span class="number">0</span>] = a[i] <span class="comment">//哨兵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j = i - <span class="number">1</span>; a[j] &gt; a[<span class="number">0</span>]; j-- &#123; <span class="comment">//j取 i-1 到 1</span></span><br><span class="line">a[j+<span class="number">1</span>] = a[j] <span class="comment">//将大于第i个数的数后移一位，留出空位</span></span><br><span class="line">&#125;</span><br><span class="line">a[j+<span class="number">1</span>] = a[<span class="number">0</span>] <span class="comment">//将第i个数放入空位</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>&#125;</span><br><span class="line">InsertionSort(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4><span id="9-6-xi-er-pai-xu-shell-sort">9.6 希尔排序(Shell Sort)</span><a href="#9-6-xi-er-pai-xu-shell-sort" class="header-anchor">#</a></h4><p>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。<br><img src="https://upload-images.jianshu.io/upload_images/1863961-8713bb4788430478.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShellSort</span>(<span class="params">a []<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">var</span> i, j <span class="keyword">int</span></span><br><span class="line">length := <span class="built_in">len</span>(a) - <span class="number">1</span> <span class="comment">//去掉第0位</span></span><br><span class="line">inc := length <span class="comment">//增量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> inc &gt; <span class="number">1</span> &#123;</span><br><span class="line">inc = inc/<span class="number">3</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> + inc; i &lt;= length; i++ &#123; <span class="comment">//第(1+inc)个数到最后一个数</span></span><br><span class="line"><span class="keyword">if</span> a[i] &lt; a[i-inc] &#123;</span><br><span class="line">a[<span class="number">0</span>] = a[i]</span><br><span class="line"><span class="keyword">for</span> j = i - inc; j &gt; <span class="number">0</span> &amp;&amp; a[j] &gt; a[<span class="number">0</span>]; j -= inc &#123;</span><br><span class="line">a[j+inc] = a[j]</span><br><span class="line">&#125;</span><br><span class="line">a[j+inc] = a[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>&#125;</span><br><span class="line">ShellSort(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4><span id="9-7-dui-pai-xu">9.7 堆排序</span><a href="#9-7-dui-pai-xu" class="header-anchor">#</a></h4><p>时间复杂度$O(nlogn)$<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span>(<span class="params">a []<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//循环后a[1]为最大值</span></span><br><span class="line"><span class="keyword">for</span> i := length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i-- &#123; <span class="comment">//(length/2)是最后一个节点的父节点到根节点</span></span><br><span class="line">HeapAdjust(a, i, length)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := length; i &gt; <span class="number">1</span>; i-- &#123; <span class="comment">//从最后节点到第二个节点</span></span><br><span class="line">a[<span class="number">1</span>], a[i] = a[i], a[<span class="number">1</span>] <span class="comment">//排序第i位</span></span><br><span class="line">HeapAdjust(a, <span class="number">1</span>, i<span class="number">-1</span>)   <span class="comment">//将1到i-1中的最大数放到a[1]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapAdjust</span>(<span class="params">a []<span class="keyword">int</span>, s, m <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">var</span> temp, j <span class="keyword">int</span></span><br><span class="line">temp = a[s]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j = <span class="number">2</span> * s; j &lt;= m; j *= <span class="number">2</span> &#123; <span class="comment">//以s为父节点开始</span></span><br><span class="line"><span class="keyword">if</span> j &lt; m &amp;&amp; a[j] &lt; a[j+<span class="number">1</span>] &#123; <span class="comment">//取出较大的孩子节点</span></span><br><span class="line">j = j + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> temp &gt;= a[j] &#123; <span class="comment">//父节点已经最大</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">a[s] = a[j] <span class="comment">//将最大的值替换给父节点</span></span><br><span class="line">s = j       <span class="comment">//将当前节点作为父节点，进行下一轮操作</span></span><br><span class="line">&#125;</span><br><span class="line">a[s] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>&#125;</span><br><span class="line">HeapAdjust(a, <span class="number">1</span>, <span class="number">9</span>)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4><span id="9-8-gui-bing-pai-xu">9.8 归并排序</span><a href="#9-8-gui-bing-pai-xu" class="header-anchor">#</a></h4><p>归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的段序列合并成一个有 序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定 性。那么，在短的有序序列合并的过程中，稳定是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。</p><p>递归方法<br><img src="https://upload-images.jianshu.io/upload_images/1863961-494a82286018f65f.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><p>Merge()归并排序示意图：<br><img src="https://upload-images.jianshu.io/upload_images/1863961-cfe727471bdad794.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将a排序到b</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergeSort</span>(<span class="params">a []<span class="keyword">int</span></span>) []<span class="title">int</span></span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(a)</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line"></span><br><span class="line">MSort(a, b, <span class="number">1</span>, length<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MSort</span>(<span class="params">a, b []<span class="keyword">int</span>, s, t <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> s == t &#123;</span><br><span class="line">b[s] = a[s] <span class="comment">//将a复制到到b</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m := (s + t) / <span class="number">2</span></span><br><span class="line">MSort(a, b, s, m)</span><br><span class="line">MSort(a, b, m+<span class="number">1</span>, t)</span><br><span class="line">Merge(b, s, m, t) <span class="comment">//将b归并排序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Merge</span>(<span class="params">SR []<span class="keyword">int</span>, i, m, n <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">TR := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(SR)) <span class="comment">//归并的序列暂存到TR</span></span><br><span class="line"></span><br><span class="line">s := i <span class="comment">//保存起始位置</span></span><br><span class="line">j := m + <span class="number">1</span></span><br><span class="line">k := i <span class="comment">//TR序号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &lt;= m &amp;&amp; j &lt;= n &#123;</span><br><span class="line"><span class="keyword">if</span> SR[i] &lt; SR[j] &#123;</span><br><span class="line">TR[k] = SR[i]</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">TR[k] = SR[j]</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &lt;= m &#123;</span><br><span class="line"><span class="keyword">for</span> l := <span class="number">0</span>; l &lt;= m-i; l++ &#123;</span><br><span class="line">TR[k+l] = SR[i+l]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> j &lt;= n &#123;</span><br><span class="line"><span class="keyword">for</span> l := <span class="number">0</span>; l &lt;= n-j; l++ &#123;</span><br><span class="line">TR[k+l] = SR[j+l]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p := s; p &lt;= n; p++ &#123; <span class="comment">//将排好序的TR写回到SR</span></span><br><span class="line"><span class="keyword">if</span> SR[p] != TR[p] &#123;</span><br><span class="line">SR[p] = TR[p]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">16</span>&#125;</span><br><span class="line">fmt.Println(MergeSort(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归方法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergeSort2</span>(<span class="params">a []<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k := <span class="number">1</span>; k &lt; length; &#123;</span><br><span class="line">MergePass(a, k, length)</span><br><span class="line">k = k * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergePass</span>(<span class="params">a []<span class="keyword">int</span>, s, n <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= n<span class="number">-2</span>*s+<span class="number">1</span> &#123;</span><br><span class="line">Merge2(a, i, i+s<span class="number">-1</span>, i+<span class="number">2</span>*s<span class="number">-1</span>) <span class="comment">//i+2*s-1&lt;=n</span></span><br><span class="line">i = i + <span class="number">2</span>*s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &lt; n-s+<span class="number">1</span> &#123; <span class="comment">//n&gt;i+s-1,归并最后两个子块</span></span><br><span class="line">Merge2(a, i, i+s<span class="number">-1</span>, n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Merge2</span>(<span class="params">SR []<span class="keyword">int</span>, i, m, n <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">TR := <span class="built_in">make</span>([]<span class="keyword">int</span>, n-i+<span class="number">1</span>) <span class="comment">//与Merge相比栈空间更小</span></span><br><span class="line"></span><br><span class="line">s := i <span class="comment">//保存起始位置</span></span><br><span class="line">j := m + <span class="number">1</span></span><br><span class="line">k := <span class="number">0</span> <span class="comment">//TR序号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &lt;= m &amp;&amp; j &lt;= n &#123;</span><br><span class="line"><span class="keyword">if</span> SR[i] &lt; SR[j] &#123;</span><br><span class="line">TR[k] = SR[i]</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">TR[k] = SR[j]</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &lt;= m &#123;</span><br><span class="line"><span class="keyword">for</span> l := <span class="number">0</span>; l &lt;= m-i; l++ &#123;</span><br><span class="line">TR[k+l] = SR[i+l]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> j &lt;= n &#123;</span><br><span class="line"><span class="keyword">for</span> l := <span class="number">0</span>; l &lt;= n-j; l++ &#123;</span><br><span class="line">TR[k+l] = SR[j+l]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p := s; p &lt;= n; p++ &#123; <span class="comment">//将排好序的TR写回到SR</span></span><br><span class="line"><span class="keyword">if</span> SR[p] != TR[p-s] &#123;</span><br><span class="line">SR[p] = TR[p-s]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">3</span>, <span class="number">41</span>, <span class="number">7</span>, <span class="number">55</span>, <span class="number">21</span>&#125;</span><br><span class="line">MergeSort2(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4><span id="9-9-kuai-su-pai-xu">9.9 快速排序</span><a href="#9-9-kuai-su-pai-xu" class="header-anchor">#</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span>(<span class="params">a []<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">Qsort(a, <span class="number">1</span>, <span class="built_in">len</span>(a)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Qsort</span>(<span class="params">a []<span class="keyword">int</span>, low, high <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> low &lt; high &#123;</span><br><span class="line">pivot := Partition(a, low, high)</span><br><span class="line"></span><br><span class="line">Qsort(a, low, pivot<span class="number">-1</span>)</span><br><span class="line">Qsort(a, pivot+<span class="number">1</span>, high)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Partition</span>(<span class="params">a []<span class="keyword">int</span>, low, high <span class="keyword">int</span></span>) <span class="title">int</span></span> &#123;</span><br><span class="line">pivotValue := a[low]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line"><span class="keyword">for</span> pivotValue &lt;= a[high] &#123; <span class="comment">//找出a[high]&lt;pivotValue</span></span><br><span class="line">high--</span><br><span class="line">&#125;</span><br><span class="line">a[low], a[high] = a[high], a[low] <span class="comment">//将a[hign]放到pivoValue左边</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> low &lt; high &amp;&amp; pivotValue &gt;= a[low] &#123; <span class="comment">//找出a[low]&gt;pivotValue</span></span><br><span class="line">low++</span><br><span class="line">&#125;</span><br><span class="line">a[low], a[high] = a[high], a[low] <span class="comment">//将a[low]放到pivoValue右边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> low</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Partition2</span>(<span class="params">a []<span class="keyword">int</span>, low, high <span class="keyword">int</span></span>) <span class="title">int</span></span> &#123;</span><br><span class="line">pivotValue := a[low]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line"><span class="keyword">for</span> pivotValue &lt;= a[high] &#123; <span class="comment">//找出a[high]&lt;pivotValue</span></span><br><span class="line">high--</span><br><span class="line">&#125;</span><br><span class="line">a[low] = a[high] <span class="comment">//将a[hign]放到较低的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> low &lt; high &amp;&amp; pivotValue &gt;= a[low] &#123; <span class="comment">//找出a[low]&gt;pivotValue</span></span><br><span class="line">low++</span><br><span class="line">&#125;</span><br><span class="line">a[high] = a[low] <span class="comment">//将a[low]放到较高的位置</span></span><br><span class="line">&#125;</span><br><span class="line">a[low] = pivotValue</span><br><span class="line"><span class="keyword">return</span> low</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span>&#125;</span><br><span class="line">QuickSort(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1863961-25127e3a301cf527.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://hejtao.netlify.com/tags/Golang/"/>
    
      <category term="长文" scheme="https://hejtao.netlify.com/tags/%E9%95%BF%E6%96%87/"/>
    
      <category term="数据结构" scheme="https://hejtao.netlify.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Go内存模型</title>
    <link href="https://hejtao.netlify.com/2018/11/14/2018-11-14/"/>
    <id>https://hejtao.netlify.com/2018/11/14/2018-11-14/</id>
    <published>2018-11-13T16:00:00.000Z</published>
    <updated>2019-11-11T19:59:33.199Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><meta name="referrer" content="no-referrer"></p><div class="toc"><!-- toc --><ul><li><a href="#1-shi-me-shi-go-nei-cun-mo-xing">1. 什么是 Go内存模型？</a></li><li><a href="#2-happens-before">2. Happens Before</a></li><li><a href="#3-synchronization">3. Synchronization</a><ul><li><a href="#3-1-initialization">3.1 Initialization</a></li><li><a href="#3-2-goroutine-creation">3.2 Goroutine creation</a></li><li><a href="#3-3-goroutine-destruction">3.3 Goroutine destruction</a></li><li><a href="#3-4-channel-communication">3.4 Channel communication</a></li><li><a href="#3-5-locks">3.5 Locks</a></li><li><a href="#3-6-once">3.6 Once</a></li></ul></li><li><a href="#4-incorrect-synchronization">4. Incorrect synchronization</a></li></ul><!-- tocstop --></div><p>本文主要翻译自官方文档 <a href="https://golang.org/ref/mem" target="_blank" rel="noopener">The Go Memory Model</a></p><h3><span id="1-shi-me-shi-go-nei-cun-mo-xing">1. 什么是 Go内存模型？</span><a href="#1-shi-me-shi-go-nei-cun-mo-xing" class="header-anchor">#</a></h3><p>我们知道不同的 goroutine 可以对同一个变量进行读写操作。Go内存模型指定了在什么样的条件下可以保证一个 goroutine 写入到变量的值可以被另外一个 goroutine 正确的读取。</p><h3><span id="2-happens-before">2. Happens Before</span><a href="#2-happens-before" class="header-anchor">#</a></h3><p>在单个 goroutine 中，读、写操作按照程序设计的顺序进行。需要注意的是，在不改变 goroutine 程序行为的前提下，这些读、写顺序在编译的过程中可能会被<strong>重排</strong>。因此导致对相同变量的读、写操作在不同的 goroutine 看来执行顺序可能不同。例如，如果在某个 goroutine 中执行 a = 1; b = 2;，另一个 goroutine 可能观察到变量 b 比 a 先被赋值。</p><p>Happens Before 是针对Go语言编程中内存操作的一种局部排序。 如果 $e<em>{1}$ happens before  $e</em>{2}$，那么也可以说 $e<em>{2}$ happens after  $e</em>{1}$。进一步，如果 $e<em>{1}$  既不 happens before  $e</em>{2}$，也不 happens after  $e<em>{2}$，那么我们称 $e</em>{1}$ 和 $e_{2}$  happen concurrently (<strong>并发</strong>)。</p><blockquote><p>在单个 goroutine 中，Happens Before顺序就是程序设计的顺序</p></blockquote><p>$v$：某个变量<br>$w$: 对$v$的写<br> $w’$: 对$v$的写，不同于$w$<br>$r$: 对$v$的读</p><p><strong>$w$可以被$r$获取的条件</strong>：</p><ul><li>$r$ 不 happen before $w$. (包括 happen after 和 happen concurrently)</li><li>不存在另一个 $w’$  happens after $w$ but before $r$.</li></ul><p><strong>$w$保证能被$r$获取的条件</strong>(该条件不允许$w’$与$w$或者$r$并发，因此比上面的条件更强):</p><ul><li>$w$ happens before $r$.</li><li>任何其它的 $w’$ 要么 happens before $w$，要么 happens after $r$.</li></ul><p>当有多个 goroutine 可以访问$v$时，必须利用同步事件(synchronization events)来建立 happens before 以保证 $r$能够获取想要的$w$。<br>在初始化过程中，赋给$v$以其类型的零值的操作可以看作是内存模型中的一种$w$</p><h3><span id="3-synchronization">3. Synchronization</span><a href="#3-synchronization" class="header-anchor">#</a></h3><h4><span id="3-1-initialization">3.1 Initialization</span><a href="#3-1-initialization" class="header-anchor">#</a></h4><p>程序的初始化在一个 goroutine 中进行，并且在该 goroutine 中还可以创建其它的 goroutine</p><blockquote><p>如果包 $p$导入了包$q$，那么包$q$在被导入之前就完成了初始化，函数main.main在所有的init函数完成后开始执行，见astaxie的<a href="https://github.com/jiangtaohe/build-web-application-with-golang/blob/master/zh/02.3.md" target="_blank" rel="noopener">main函数和init函数一文</a></p></blockquote><h4><span id="3-2-goroutine-creation">3.2 Goroutine creation</span><a href="#3-2-goroutine-creation" class="header-anchor">#</a></h4><blockquote><p>启动一个新的 goroutine 的 <strong>Go</strong>声明发生在该 goroutine开始执行之前</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用hello()将会在未来某个时间点( 可能在hello()返回之后 )打印hello, world</p><h4><span id="3-3-goroutine-destruction">3.3 Goroutine destruction</span><a href="#3-3-goroutine-destruction" class="header-anchor">#</a></h4><p>无法保证 goroutine 在其创建程序中的某个位置退出<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123; a = <span class="string">"hello"</span> &#125;()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对 a 的写(赋值)没有进行任何同步操作，无法被其它 goroutine 获取，在激进的编译器中甚至可能会删除整个 go 声明。</p><h4><span id="3-4-channel-communication">3.4 Channel communication</span><a href="#3-4-channel-communication" class="header-anchor">#</a></h4><p>通道通信(channel communication)是同步两个 goroutine 的主要方法。</p><blockquote><p>send 发生在完成相应的 receive 之前</p></blockquote><p>程序：<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line">c &lt;- <span class="number">0</span> <span class="comment">// send</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">&lt;-c <span class="comment">// receive</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure></p><p>会保证打印 hello, world，因为：<br>对 a 的写 <strong>happens before</strong> 通道 c 的 send<br>通道 c 的 send <strong>happens before</strong> 通道 c 的 receive<br>通道 c 的 receive <strong>happens before</strong> print(a)，因此 ,<br>对 a 的写 <strong>happens before</strong> print(a), 即保证 main() 获取了 goroutine 对 a的写</p><blockquote><p>channel 的关闭发生在完成 receive(此时得到的是通道类型的零值)之前</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line"><span class="built_in">close</span>(c) <span class="comment">// 关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line"><span class="built_in">print</span>(a, <span class="string">"\n"</span>, &lt;-c) <span class="comment">// receive</span></span><br><span class="line">&#125;</span><br><span class="line">&gt;Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">hello, world</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>无缓存通道的 receive 发生在完成 send 之前</p></blockquote><p>调换 <code>c &lt;- 0 // send</code> 和 <code>&lt;-c // receive</code>的位置，得到程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line">&lt;-c <span class="comment">//receive</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">c &lt;- <span class="number">0</span> <span class="comment">// send</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure><p>仍然保证打印 hello, world<br>但如果channel具有缓存，例如当<code>c = make(chan int, 1)</code>，那么程序无法保证打印 hello, world</p><blockquote><p>当通道的容量为$c$时，第 $k$ 次 receive 发生在完成第 $k+c$ 次 send 之前</p></blockquote><p>下面的程序给 work 的每个条目(函数类型)启动一个 goroutine，由于通道limit的容量为3，因此最多允许3个 goroutine 调用调用了函数w()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> limit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params">w <span class="keyword">func</span>(</span>))</span> &#123;</span><br><span class="line">limit &lt;- <span class="number">1</span></span><br><span class="line">w()</span><br><span class="line">&lt;-limit</span><br><span class="line">&#125;(w)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="3-5-locks">3.5 Locks</span><a href="#3-5-locks" class="header-anchor">#</a></h4><p> <code>sync</code> 包实现了两种 <code>lock</code> 数据类型, <code>sync.Mutex</code>和 <code>sync.RWMutex</code>.</p><blockquote><p>对任意的 <code>sync.Mutex</code> 或者 <code>sync.RWMutex</code>变量 <code>l</code>且$n&lt;m$，第$n$次调用  <code>l.Unlock()</code> 发生在 第 $m$次调用 <code>l.Lock()</code>返回之前</p></blockquote><p>程序<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> l sync.Mutex</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line">l.Unlock() <span class="comment">//第一次 l.Unlock()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">l.Lock()</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">l.Lock() <span class="comment">//第二次 l.Lock()</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure></p><p>保证打印hello, world，因为，<br>第一次 <code>l.Unlock()</code>  <strong>happens before</strong>  第二次 <code>l.Lock()</code> 返回<br>第二次 <code>l.Lock()</code> 返回 <strong>happens before</strong>  print(a)</p><blockquote><p>对于任意的<code>l.RLock</code>，存在$k$满足：<br>第 $k$ 次调用 <code>l.Unlock</code> <strong>happens  before</strong> <code>l.RLock</code>；<br>与<code>l.RLock</code>对应的<code>l.RUnlock</code> <strong>happens before</strong> 第 $k+1$次调用 <code>l.Lock</code></p></blockquote><h4><span id="3-6-once">3.6 Once</span><a href="#3-6-once" class="header-anchor">#</a></h4><p>对某个函数<code>f()</code>，可以有多个线程通过<code>once.Do(f)</code>来对其调用，但仅有线程能够调用执行函数<code>f()</code>，其它的调用会被阻塞知道<code>f()</code>返回。</p><p>程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SETUP</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="string">"HELLO, WORLD"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doprint</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">once.Do(setup) <span class="comment">//注意不要括号</span></span><br><span class="line">once.Do(SETUP)</span><br><span class="line"><span class="built_in">print</span>(a, <span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> doprint()</span><br><span class="line"><span class="keyword">go</span> doprint()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">hello, world</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure><p>会打印两次 hello, world，但是仅在第一次调用 doprint 时执行了 setup</p><h3><span id="4-incorrect-synchronization">4. Incorrect synchronization</span><a href="#4-incorrect-synchronization" class="header-anchor">#</a></h3><p>程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(b, <span class="string">"\n"</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">g()</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output: <span class="comment">//大多数输出结果</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt; Output: <span class="comment">//少数输出结果</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>也可能先打印2，然后打印0</p><p>程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="string">"hello, world \n"</span></span><br><span class="line">done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doprint</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !done &#123;</span><br><span class="line">setup()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoprint</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> doprint()</span><br><span class="line"><span class="keyword">go</span> doprint()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">twoprint()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有3种输出的可能</span></span><br><span class="line">&gt; Output:</span><br><span class="line">hello, world </span><br><span class="line">hello, world </span><br><span class="line">&gt; Output:</span><br><span class="line">hello, world </span><br><span class="line">&gt; Output:</span><br></pre></td></tr></table></figure><p>下面的程序，由于不能保证main()先获取对done的写，因此print()可能打印空字符串。甚至main()完全没有获取对done的写，此时main()进入死循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line">done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> setup()</span><br><span class="line"><span class="keyword">for</span> !done &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; Output:</span><br><span class="line">hello, world</span><br><span class="line">&gt; Elapsed: <span class="number">3.703</span>s  <span class="comment">//等待了较长的时间</span></span><br><span class="line">&gt; Result: Success</span><br><span class="line">&gt; Output:</span><br><span class="line">hello, world</span><br><span class="line">&gt; Elapsed: <span class="number">0.704</span>s </span><br><span class="line">&gt; Result: Success</span><br></pre></td></tr></table></figure><p>类似的程序如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">msg <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g *T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">t := <span class="built_in">new</span>(T)</span><br><span class="line">t.msg = <span class="string">"hello, world"</span></span><br><span class="line">g = t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> setup()</span><br><span class="line"><span class="keyword">for</span> g == <span class="literal">nil</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(g.msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://hejtao.netlify.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>搭建IPFS 私有网络</title>
    <link href="https://hejtao.netlify.com/2018/11/05/2018-11-5/"/>
    <id>https://hejtao.netlify.com/2018/11/05/2018-11-5/</id>
    <published>2018-11-04T16:00:00.000Z</published>
    <updated>2019-11-11T19:59:33.200Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><meta name="referrer" content="no-referrer"></p><div class="toc"><!-- toc --><ul><li><a href="#zai-servers-shang-an-zhuang-go-huan-jing">在servers上安装 Go 环境</a></li><li><a href="#sheng-cheng-ifps-jie-dian">生成 ifps 节点</a></li><li><a href="#chuang-jian-gong-xiang-mi-yao">创建共享密钥</a></li><li><a href="#tian-jia-qi-dong-jie-dian">添加启动节点</a></li><li><a href="#qi-dong-si-you-wang-luo">启动私有网络</a></li></ul><!-- tocstop --></div><p>本例为建立包含三个节点的IPFS私有网络，节点分别为：<br> server a: root@45.32.28.71<br> server b: root@207.148.109.110<br>本地 mac</p><h3><span id="zai-servers-shang-an-zhuang-go-huan-jing">在servers上安装 Go 环境</span><a href="#zai-servers-shang-an-zhuang-go-huan-jing" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd ~ </span><br><span class="line">$wget https://dl.google.com/go/go1.11.2.linux-amd64.tar.gz</span><br><span class="line">$tar -C /usr/local -xzf go1.11.2.linux-amd64.tar.gz    //解压到得到的 go 目录，放到 /usr/local 目录下</span><br><span class="line">$vim .bashrc</span><br><span class="line">export GOPATH=~/hejtao/go_projects</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOBIN=$GOROOT/bin</span><br><span class="line">export PATH=$PATH:$GOBIN</span><br><span class="line">$source .bashrc</span><br><span class="line">$go version </span><br><span class="line">go version go1.11.2 linux/amd64  //安装成功</span><br></pre></td></tr></table></figure><p> mac 上的安装类似。</p><h3><span id="sheng-cheng-ifps-jie-dian">生成 ifps 节点</span><a href="#sheng-cheng-ifps-jie-dian" class="header-anchor">#</a></h3><p>在三台机器上执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$go get -u -d github.com/ipfs/go-ipfs         </span><br><span class="line">$cd $GOPATH/src/github.com/ipfs/go-ipfs</span><br><span class="line">$make install</span><br><span class="line">Command &apos;make&apos; not found, but can be installed with:</span><br><span class="line"></span><br><span class="line">sudo apt install make</span><br><span class="line">sudo apt install make-guile</span><br><span class="line">$apt update        \\ 需要安装 make ， 先检查安装包</span><br><span class="line">...</span><br><span class="line">$apt upgrade        \\ 更新安装包</span><br><span class="line">...</span><br><span class="line">$apt install make      \\ 安装 make</span><br><span class="line">...</span><br><span class="line">$make install</span><br><span class="line">/usr/local/go/pkg/tool/linux_amd64/link: running gcc failed: exec: &quot;gcc&quot;: executable file not found in $PATH</span><br><span class="line"></span><br><span class="line">cmd/ipfs/Rules.mk:37: recipe for target &apos;cmd/ipfs-install&apos; failed</span><br><span class="line">make: *** [cmd/ipfs-install] Error 2</span><br><span class="line"></span><br><span class="line">$apt install gcc</span><br><span class="line">...</span><br><span class="line">$gcc -v</span><br><span class="line">...</span><br><span class="line">gcc version 7.3.0 (Ubuntu 7.3.0-27ubuntu1~18.04)</span><br><span class="line">$make install</span><br><span class="line">...</span><br><span class="line">$ipfs init</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>记下每个节点的ID，比如本例<br>server a 的ID: <strong>QmQ9RjTGVDjhZ2kRVx9tjL4CciiKdNrQzknSyUnCMmB3m2</strong><br>server b 的ID: <strong>QmRyxoe9JpkDZuMK4G7PkXUy7nGv8VdM98d6Vr2wxFSa3V</strong><br>mac 的ID: <strong>QmWKKVUy9XqWEGhrikJW8ugHuFzKJJGP5DCGFyvzUJFjzL</strong></p><h3><span id="chuang-jian-gong-xiang-mi-yao">创建共享密钥</span><a href="#chuang-jian-gong-xiang-mi-yao" class="header-anchor">#</a></h3><p>先在任意一台机器上创建密钥，然后拷贝到剩余节点。本例在mac上创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$go get -u github.com/Kubuxu/go-ipfs-swarm-key-gen/ipfs-swarm-key-gen</span><br><span class="line">$ipfs-swarm-key-gen &gt; ~/.ipfs/swarm.key</span><br></pre></td></tr></table></figure></p><ul><li>手动拷贝</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$vim ~/.ipfs/swarm.key        \\ 打开swarm.key, 拷贝内容</span><br></pre></td></tr></table></figure><p>在servers上新建swarm.key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$vim ~/.ipfs/swarm.key        \\ 将拷贝的内容粘贴</span><br></pre></td></tr></table></figure></p><ul><li>使用 <code>scp</code> 命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$scp ~/.ipfs/swarm.key root@45.32.28.71:~/.ipfs/</span><br><span class="line">$scp ~/.ipfs/swarm.key root@207.148.109.110:~/.ipfs/</span><br></pre></td></tr></table></figure><h3><span id="tian-jia-qi-dong-jie-dian">添加启动节点</span><a href="#tian-jia-qi-dong-jie-dian" class="header-anchor">#</a></h3><p><code>pfs init</code>后的默认启动节点是连接ipfs公网的节点。建立私有网络需要在<strong>每一个节点上</strong>删掉默认启动节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ipfs bootstrap rm --all</span><br></pre></td></tr></table></figure><p>将网络中任意其他节点作为启动节点。例如将 server a 作为mac的启动节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ipfs bootstrap add/ip4/45.32.28.71/tcp/4001/ipfs/QmQ9RjTGVDjhZ2kRVx9tjL4CciiKdNrQzknSyUnCMmB3m2</span><br></pre></td></tr></table></figure><h3><span id="qi-dong-si-you-wang-luo">启动私有网络</span><a href="#qi-dong-si-you-wang-luo" class="header-anchor">#</a></h3><p>给三个节点添加了启动节点后，启动所有节点，便建立起了含有三个节点的IPFS私有网络。分别执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ipfs daemon</span><br></pre></td></tr></table></figure></p><p>可以使用 <figure class="highlight plain"><figcaption><span>bootstrap list```查看节点所包含的启动节点，使用```ipfs swarm peers```查看节点连接了哪些其他节点。使用```ipfs add file```上传文件到节点，比如给mac节点上传pdf文件，并得到该文件的ID</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">$ipfs add ~/files/GO语言编程.pdf</span><br></pre></td></tr></table></figure></p><p>该文件的ID：<strong>QmRDqZoSMCLMP2GH66MKKnduqgTqKBfqNeysPugp9xadUi</strong>。现在与mac建立了连接的server就可以下载该文件了，在server上执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ipfs get QmRDqZoSMCLMP2GH66MKKnduqgTqKBfqNeysPugp9xadUi        \\在当前目录会多出一个新的文件便是get到的文件</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="IPFS" scheme="https://hejtao.netlify.com/tags/IPFS/"/>
    
  </entry>
  
  <entry>
    <title>A Study for the Reed-Solomon Code</title>
    <link href="https://hejtao.netlify.com/2018/10/18/2018-10-18/"/>
    <id>https://hejtao.netlify.com/2018/10/18/2018-10-18/</id>
    <published>2018-10-18T04:11:11.000Z</published>
    <updated>2019-11-11T19:59:33.199Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><meta name="referrer" content="no-referrer"></p><div class="toc"><!-- toc --><ul><li><a href="#introduction">Introduction</a></li><li><a href="#galois-field">Galois Field</a></li><li><a href="#galois-field-arithmetic">Galois Field Arithmetic</a><ul><li><a href="#addition-and-subtraction">Addition and Subtraction</a></li><li><a href="#multiplication-and-division">Multiplication and Division</a></li></ul></li><li><a href="#rs-code">RS Code</a><ul><li><a href="#coding-matrix-method">Coding Matrix Method</a></li><li><a href="#generator-polynomial-method">Generator Polynomial Method</a></li></ul></li><li><a href="#rs-code-in-distributed-storage-systems">RS Code in Distributed Storage Systems</a><ul><li><a href="#5-1-rotated-reed-solomon-code">5.1 Rotated Reed-Solomon code</a><ul><li><a href="#local-reconstruction-code-lrc">Local Reconstruction Code (LRC)</a></li></ul></li></ul></li><li><a href="#references">References</a></li></ul><!-- tocstop --></div><h3><span id="introduction">Introduction</span><a href="#introduction" class="header-anchor">#</a></h3><p>Reed-Solomon (RS) code is an error-correcting code first proposed by Reed and Solomon in 1960, which is the most frequently applied digital error correction code around the word. The applications include data storage(hard drives, CD/DVD/Blue Ray), data transmission and common commercial activities(bar codes, QR codes) .<br>RS code has the advantage of high capability of correcting  random or burst errors since it encodes  groups of bits instead of one bit at a time. Redundant datas are generated  so that the original data can be reconstructed with part of the stored or received data loss.  People often back up important files which can be regarded as kind of  data loss protection with redundant data. However, backup is just a copy of the original datas while the redundant data generated in the RS code is a  fusion of the all the original data parts, which is more efficient for storage and error correction.<br>In this article, I have run through the procedure of the RS code and hope it is usefull for you to understand what is going on with this erasure code. Its application in the distributed strorage system are briefly introduced at the end. Part of implementations in pure Go are also provided whose source files can be found on the <a href="https://github.com/klauspost/reedsolomon" target="_blank" rel="noopener">Githup website</a> . </p><h3><span id="galois-field">Galois Field</span><a href="#galois-field" class="header-anchor">#</a></h3><p>The finite field is also called Galois field which has finite elements  and the property that arithmetic operations on field elements always have a result in the field. In the sequel, we illustrate two kind of representations of the finite elements and its arithmetic operations.</p><blockquote><p><strong>Proposition 1.</strong> For any prime $ p $ and any natual number$ r $ there exists a finite field with $ p^{r} $ elements and vice versa.</p></blockquote><p>With the proposition 1, the Galois Field is denoted as $ GF(p^{r}) $. In fact, the nature of RS encoding is mapping $ k $ elments of $ GF(2^{r}) $ into another $ n $ elements of $ GF(2^{r}) $ and $k+2\leq n\leq 2^{r} $. This Galois fields can be represented with the help of $ \mathbf{Z}<em>{2}[x] $, the set of polynomials with coefficients in the field of two elements $ \mathbf{Z}</em>{2} $, namely the polynomial representation as</p><script type="math/tex; mode=display">0,1,x,x+1,x^{2},..,x^{r-1}+x^{r-2}+...+1 \tag{1}</script><p>This representation  can also be seen as a $r$-bit digit or binary vector.</p><blockquote><p><strong>Proposition 2.</strong> $ GF(q) $ has cyclic the multiplicative group $ {\alpha, \alpha^{2},…,\alpha^{q-1}=1}$, where $ \alpha $ is the primitive element.</p></blockquote><p>Thus, $ GF(2^{r}) $ has the exponential representation as </p><script type="math/tex; mode=display">0, 1(=\alpha^{255}), \alpha, \alpha^{2},..., \alpha^{2^{r}-2} \tag{2}</script><p>which is a better choice for the ‘$ \times $’ and ‘$ / $’  operation. Even a binary matrix can be used to  represente the elements. For example, we can establish a bijection between the vector representation and matrix representation over $ GF(2^{4}) $ as follows</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-ea01dad7bef4b4f4.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Matrix representation"></p><p>where the first column is the vector representation and the columns satisfy $column(i)=2\times column(i-1)$. This matrix representation transforms arithmetic over $ GF(2^{4}) $ into arithmetic over $ GF(2) $ which only has XOR, AND operations.</p><h3><span id="galois-field-arithmetic">Galois Field Arithmetic</span><a href="#galois-field-arithmetic" class="header-anchor">#</a></h3><p>In this section, we discuss  arithmetic in $ GF(2^{8}) $, whose element corresponds a byte data.</p><h4><span id="addition-and-subtraction">Addition and Subtraction</span><a href="#addition-and-subtraction" class="header-anchor">#</a></h4><p>Addition and subtraction are operated under the polynomial representation (also a byte in $ GF(2^{8}) $) and both are equivalent to XOR operation<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">galAdd</span>(<span class="params">a, b <span class="keyword">byte</span></span>) <span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a ^ b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">galSub</span>(<span class="params">a, b <span class="keyword">byte</span></span>) <span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a ^ b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4><span id="multiplication-and-division">Multiplication and Division</span><a href="#multiplication-and-division" class="header-anchor">#</a></h4><p>The multiplication is operated with the exponential representation $(2)$, before that we should establish a bijection (injection and surjection) between the two representations. Suppose </p><script type="math/tex; mode=display">\alpha^{i}   ->  2^{i}</script><p>where $0\leq i \leq 2^{8}-2=254$. According to proposition 2, $\forall j\geq 255,\alpha^{j}=\alpha^{j-255}$.</p><blockquote><p><strong>Proposition 3.</strong>$ GF(2^{8}) $ has the irreducible polynomial $ f(x)=x^{8}+x^{4}+x^{3}+x^{2}+1 $ which has no factors of smaller polynomials.</p></blockquote><p>The irreducible polynomial is necessary to establish the bijection since some $2^{i}$ term are no longer in  $GF(2^{8})$. Let $ f(\alpha) =0$, we have <script type="math/tex">\alpha^{8}=\alpha^{4}+\alpha^{3}+\alpha^{2}+1=2^{4}+2^{3}+2^{2}+1=00011101</script><br>or <strong>0x1d</strong> . For convenience, we record the bijection with a table, namely called exponent table, whose indexs is the exponents of elements in exponential representation and value is elements in byte representation.<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expTable = [<span class="number">255</span>]<span class="keyword">byte</span>&#123;<span class="number">0x1</span>, <span class="number">0x2</span>, <span class="number">0x4</span>, <span class="number">0x8</span>, <span class="number">0x10</span>, <span class="number">0x20</span>, <span class="number">0x40</span>, <span class="number">0x80</span>, <span class="number">0x1d</span>, <span class="number">0x3a</span>, ..., <span class="number">0x8e</span>&#125;</span><br></pre></td></tr></table></figure></p><p>Use logTable[expTable[$i$]]=$i$, the logarithmic table is generated,<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logTable = []<span class="keyword">byte</span>&#123;</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">25</span>, <span class="number">2</span>, <span class="number">50</span>, <span class="number">26</span>, <span class="number">198</span>,</span><br><span class="line">...</span><br><span class="line"><span class="number">116</span>, <span class="number">214</span>, <span class="number">244</span>, <span class="number">234</span>, <span class="number">168</span>, <span class="number">80</span>, <span class="number">88</span>, <span class="number">175</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>With these tables, the $\times$ and $/$ functions in $GF(2^8)$ are easily defined,<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">galMultiply</span>(<span class="params">a, b <span class="keyword">byte</span></span>) <span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a == <span class="number">0</span> || b == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logA := <span class="keyword">int</span>(logTable[a])</span><br><span class="line">logB := <span class="keyword">int</span>(logTable[b])</span><br><span class="line"></span><br><span class="line">sum := logA+logB</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sum&gt;<span class="number">254</span> &#123;</span><br><span class="line">        sum -= <span class="number">255</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> expTable[sum]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">galDivide</span>(<span class="params">a, b <span class="keyword">byte</span></span>) <span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"Argument 'divisor' is 0"</span>)</span><br><span class="line">&#125;</span><br><span class="line">logA := <span class="keyword">int</span>(logTable[a])</span><br><span class="line">logB := <span class="keyword">int</span>(logTable[b])</span><br><span class="line">logResult := logA - logB</span><br><span class="line"><span class="keyword">if</span> logResult &lt; <span class="number">0</span> &#123;</span><br><span class="line">logResult += <span class="number">255</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> expTable[logResult]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Based on the result above, the power and inverse functions can be further obtained. In fact, the method to establish the bijection is not unique. The original paper of Reed and Solomon in 1960 provides another method  with finite difference equation which has better computability.</p><h3><span id="rs-code">RS Code</span><a href="#rs-code" class="header-anchor">#</a></h3><h4><span id="coding-matrix-method">Coding Matrix Method</span><a href="#coding-matrix-method" class="header-anchor">#</a></h4><p><strong>1.</strong> Orignal approach:<br>For arbitrary $ k $  8-bit symbols,$ m<em>{0}$,  $m</em>{1}$,  $…$,  $m_{k-1} $, we have the message polynomial</p><script type="math/tex; mode=display">m(x)=m_{0}+m_{1}x+...+m_{k-1}x^{k-1},</script><p>with this $ m(x) $, $ 2^{8} $ codewords, i.e. $ m(0)$,$m(1)$,$…$,  $m(\alpha^{r-2}) $ are obtained and the  the encoded messages, which will be transmitted or stored, are $ n $ of the codewords (professionally called stripe).  Using linear algebra, the stripe are denoted collectively as follows</p><script type="math/tex; mode=display">\begin{bmatrix}m(\alpha_{1})\\m(\alpha_{2})\\...\\m(\alpha_{n})\end{bmatrix} =  \begin{bmatrix}   1 & \alpha_{1} & ... & \alpha_{1}^{k-1} \\   1 & \alpha_{2} & ...&\alpha_{2}^{k-1} \\   ... & ... & ...&... \\   1 & \alpha_{n} & ...&\alpha_{n}^{k-1}  \end{bmatrix} \begin{bmatrix}m_{0}\\m_{1}\\...\\m_{k-1}\end{bmatrix}\tag{3}</script><p>Note that  we only discuss one byte a shard (the messages are splited into multiple shards for encoding) here, in practice  one input shard contains thousands of bytes, in this case the output shard contains same size of byte as input shard and the vectors in $(3)$ becomes matrice. </p><blockquote><p><strong>Coding procedure :</strong> <br>1.Split the whole message into same size data shards;  <br>2. Build the  Vandermonde matrix (coding matrix); <br>3. Multiplies the coding matrix by data shards to produce code shards.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">r reedSolomon</span>) <span class="title">Split</span>(<span class="params">data []<span class="keyword">byte</span></span>) (<span class="params">[][]<span class="keyword">byte</span>, error</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrShortData</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Calculate number of bytes per data shard.</span></span><br><span class="line">perShard := (<span class="built_in">len</span>(data) + r.DataShards - <span class="number">1</span>) / r.DataShards</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span>(data) &gt; <span class="built_in">len</span>(data) &#123;</span><br><span class="line">data = data[:<span class="built_in">cap</span>(data)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only allocate memory if necessary</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(data) &lt; (r.Shards * perShard) &#123;</span><br><span class="line"><span class="comment">// Pad data to r.Shards*perShard.</span></span><br><span class="line">padding := <span class="built_in">make</span>([]<span class="keyword">byte</span>, (r.Shards*perShard)-<span class="built_in">len</span>(data))</span><br><span class="line">data = <span class="built_in">append</span>(data, padding...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Split into equal-length shards.</span></span><br><span class="line">dst := <span class="built_in">make</span>([][]<span class="keyword">byte</span>, r.Shards)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> dst &#123;</span><br><span class="line">dst[i] = data[:perShard]</span><br><span class="line">data = data[perShard:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dst, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">vandermonde</span>(<span class="params">rows, cols <span class="keyword">int</span></span>) (<span class="params">matrix, error</span>)</span> &#123;</span><br><span class="line">result, err := newMatrix(rows, cols)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> r, row := <span class="keyword">range</span> result &#123;</span><br><span class="line"><span class="keyword">for</span> c := <span class="keyword">range</span> row &#123;</span><br><span class="line">result[r][c] = galExp(<span class="keyword">byte</span>(r), c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiplies a subset of rows from a coding matrix by a full set of</span></span><br><span class="line"><span class="comment">// input shards to produce some output shards.</span></span><br><span class="line"><span class="comment">// 'matrixRows' is The rows from the matrix to use.</span></span><br><span class="line"><span class="comment">// 'inputs' An array of byte arrays, each of which is one input shard.</span></span><br><span class="line"><span class="comment">// The number of inputs used is determined by the length of each matrix row.</span></span><br><span class="line"><span class="comment">// outputs Byte arrays where the computed shards are stored.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">r reedSolomon</span>) <span class="title">codeSomeShards</span>(<span class="params">matrixRows, inputs, outputs [][]<span class="keyword">byte</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> c := <span class="number">0</span>; c &lt; r.DataShards; c++ &#123;</span><br><span class="line">in := inputs[c]</span><br><span class="line"><span class="keyword">for</span> iRow := <span class="number">0</span>; iRow &lt; outputCount; iRow++ &#123;</span><br><span class="line"><span class="keyword">if</span> c == <span class="number">0</span> &#123;</span><br><span class="line">galMulSlice(matrixRows[iRow][c], in, outputs[iRow], r.o.useSSSE3, r.o.useAVX2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">galMulSliceXor(matrixRows[iRow][c], in, outputs[iRow], r.o.useSSSE3, r.o.useAVX2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Since any $ k $ rows of Vandermonde matrix are linearly independent, with arbitrary $ k $ correct code shards, the original $ k $  data shards can be reconstructed by multiplying the corresponding inverse matrix. However, in practice, we usually do not know which one is correct or corrupted for the $ n $ received codewords. In this case, the plurality of votes method is necessary and </p><script type="math/tex; mode=display">\left(\begin{array}{c}n-s\\k\end{array} \right)>\left(\begin{array}{c}s+k-1\\k\end{array} \right)</script><p>or</p><script type="math/tex; mode=display">s<\frac{n-k+1}{2}</script><p>where $s$ is number of unkown errors, therefore $ n=k+2s $ always satisfies the in-equation. Another approach is to use the Berlekamp-Welsh Algorithm  which avoids the heavy computation of votes: </p><blockquote><p><strong>Berlekamp-Welsh decoder:</strong><br> 1. Send $m(0),m(1),…,m(n)$,  receive $m’(0),m’(1),…,m’(n)$, and most $s$ of  them such that $m(i)\neq m’(i)$；<br> 2.  $E(x)=x^{s}+b<em>{s-1}x^{s-1}+…+b</em>{0}$, $Q(x)=a<em>{k+s-1}x^{k+s-1}+a</em>{k+s-2}x^{k+s-2}+…+a_{0}$ <br> 3. Solve the coefficients of co$E(x)$,$Q(x)$ with $  Q(i)=m’(i)E(i)$ <br>4. Derive $m(x)=Q(x)/E(x)$.</p></blockquote><p>And $\forall m(i)\neq m’(i)$,$E(i)=0$.<br> <strong>The implicite principle:</strong> $Q’(x)/E’(x)$ and $Q(x)/E(x)$  agree on at least $k+s$ points. $E’(x)$  and  $E(x)$ both have at most $s$ zero points. Elimilate $E’(x)$  and  $E(x)$,$Q’(x)/E’(x)$ and $Q(x)/E(x)$ are degree at least $k-1$ and agree on at least $k$ points, thus $Q’(x)/E’(x)=Q(x)/E(x)=m(x)$.<br><br><strong>2.</strong> Systematic coding matrix:</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-aceb4a25d416d295.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""><br></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-8b2f627ce05e386f.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""><br></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-7404acc2dbc829e4.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""><br></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-df23756e41d208b3.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""><br></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-8c7bbe0310c9efea.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""><br></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-d69a32352af4c86a.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""><br></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-c0a5889de5a6bd1d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""><br></p><p>In the original approach, all the code shards have been encoded. While in the systematic encoding, the original data shards become part of the code shards and only the parity shards should be encoded. In other words, the stripe contains the original datas and parity codewords together no longer codewords only. The coding matrix is composed of  the top square identity matrix and the parity matrix. There are three methods of building the coding matrix in this systematic way are provided:</p><ul><li>Elementary transform on the Vandermonde matrix as the procedure 1.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildMatrix</span>(<span class="params">dataShards, totalShards <span class="keyword">int</span></span>) (<span class="params">matrix, error</span>)</span> &#123;</span><br><span class="line">vm, err := vandermonde(totalShards, dataShards)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">top, err := vm.SubMatrix(<span class="number">0</span>, <span class="number">0</span>, dataShards, dataShards)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">topInv, err := top.Invert()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> vm.Multiply(topInv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Parity matrix is Vandermonde matrix.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildMatrixPAR1</span>(<span class="params">dataShards, totalShards <span class="keyword">int</span></span>) (<span class="params">matrix, error</span>)</span> &#123;</span><br><span class="line">result, err := newMatrix(totalShards, dataShards)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> r, row := <span class="keyword">range</span> result &#123;</span><br><span class="line"><span class="comment">// The top portion of the matrix is the identity</span></span><br><span class="line"><span class="comment">// matrix, and the bottom is a transposed Vandermonde</span></span><br><span class="line"><span class="comment">// matrix starting at 1 instead of 0.</span></span><br><span class="line"><span class="keyword">if</span> r &lt; dataShards &#123;</span><br><span class="line">result[r][r] = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> c := <span class="keyword">range</span> row &#123;</span><br><span class="line">result[r][c] = galExp(<span class="keyword">byte</span>(c+<span class="number">1</span>), r-dataShards)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Parity matrix is Cauchy matrix. Cauchy matrices are easier to invert than general matrices [8].</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildMatrixCauchy</span>(<span class="params">dataShards, totalShards <span class="keyword">int</span></span>) (<span class="params">matrix, error</span>)</span> &#123;</span><br><span class="line">result, err := newMatrix(totalShards, dataShards)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> r, row := <span class="keyword">range</span> result &#123;</span><br><span class="line"><span class="comment">// The top portion of the matrix is the identity</span></span><br><span class="line"><span class="comment">// matrix, and the bottom is a transposed Cauchy matrix.</span></span><br><span class="line"><span class="keyword">if</span> r &lt; dataShards &#123;</span><br><span class="line">result[r][r] = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> c := <span class="keyword">range</span> row &#123;</span><br><span class="line">result[r][c] = invTable[(<span class="keyword">byte</span>(r ^ c))]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="generator-polynomial-method">Generator Polynomial Method</span><a href="#generator-polynomial-method" class="header-anchor">#</a></h4><p>Define the generator polynomial:</p><script type="math/tex; mode=display">g(x)=(x-\alpha)(x-\alpha^{2})\dots(x-\alpha^{2s})</script><p>and the codeword polynomial can be directly computed as </p><script type="math/tex; mode=display">c(x)=m(x)g(x)</script><p>For the systematic form, which is more often used in practice, we define</p><script type="math/tex; mode=display">b(x)=x^{2s}m(x) \quad mod\quad g(x)</script><p>then the codeword polynomial becomes</p><script type="math/tex; mode=display">c(x)=x^{2s}m(x)-b(x)</script><p>where $-b(x)$ is the parity  codeword polynomial. All the polynomial operation above is processed over $GF(2^8)$. It is also observed that the correction of received message can be checked  by testing its divisibility by g(x), and there is no need to decode for the systematic encoding if the answer is affirmative. Otherwise, we denote $r(x)=c(x)+e(x)$ and suppose there are $ v(\leq s) $ errors</p><blockquote><p><strong>Syndrome based decoder:</strong><br> 1.Calculate the $2s$ Syndromes: $S_{j}=r(\alpha^{j})=e(\alpha^{j})$ <br> 2. Solve </p><p><script type="math/tex">\begin{bmatrix}   S_{1} & S_{2}& ... & S_{v} \\   S_{2} & S_{3} & ...&S_{v+1} \\   ... & ... & ...&... \\   S_{v} & S_{v+1} & ...&S_{2v-1}  \end{bmatrix} \begin{bmatrix}\Lambda_{v}\\\Lambda_{v-1}\\...\\\Lambda_{1}\end{bmatrix}=\begin{bmatrix} -S_{v} \\-S_{v+1}\\...\\-S_{2v}\tag{4}\end{bmatrix}</script> and use <a href="https://en.wikipedia.org/wiki/Chien_search" target="_blank" rel="noopener">Chien search</a> solve $\Lambda(x)=\Lambda<em>{v}x^{v} +\Lambda</em>{v-1}x^{v-1}+…+1=0$ to derive the $v$ roots, denoted as,$x<em>{1},..,x</em>{v}$. <br> 3. Use <a href="https://en.wikipedia.org/wiki/Forney_algorithm" target="_blank" rel="noopener">Forney algorithm</a> to solve </p><p><script type="math/tex">\begin{bmatrix}   x_{1}^{-1} & x_{2}^{-1}& ... & x_{v}^{-1} \\   x_{1}^{-2} & x_{2}^{-2} & ...&x_{v}^{-2} \\   ... & ... & ...&... \\  x_{1}^{-2s} & x_{2}^{-2s} & ...&x_{v}^{-2s}  \end{bmatrix} \begin{bmatrix}e_{i_{1}}\\e_{i_{2}}\\...\\e_{i_{v}}\end{bmatrix}=\begin{bmatrix} S_{1} \\S_{2}\\...\\S_{2s}\tag{5}\end{bmatrix}</script>  <br>4. The index $i<em>{j}$ of $e</em>{i<em>{j}}$ are determined by looking up the  logarithmic table as earlier mentioned <br> 5. Compute $e(x)=\sum</em>{j=1}^{v}e<em>{i</em>{j}}x^{i_{j}}$ and $c(x) = r(x)-e(x)$.</p></blockquote><p>It is worth mentioning that all the syndromes are zeros if $r(x)=c(x)$,  this can be used to check if the received message is corrupted or if the message was completely constructed.  RS encoding is relatively straightforward for the generator approach, but decoding needs complicated algebraic computation, especially for the step 2. Because the real value of $v$ is unknown and the normal way has to use the trial value  untill the matrix in $(4)$ is nonsingular.  Other algebraic methods for the evaluation of this error location polynomial $\Lambda(x)$ include  <a href="https://en.wikipedia.org/wiki/Berlekamp%E2%80%93Massey_algorithm" target="_blank" rel="noopener">Berlekamp–Massey algorithm</a> and <a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm" target="_blank" rel="noopener">Extended Euclidean algorithm</a>.<br>This syndrome based decoder  can be implemented with different hardware unit such as matrix vector multiplication unit, remainder unit,  and performs <strong>hard-decision decoding</strong> up to $s$ errors. Hard-decision decoding decides the  bit according to the a threshold, where each bit is  definitely one or zero. While <strong>soft-decision decoding</strong>  requires additional reliability information to improve the decision, which has better coding gain for the white Guassian channel [2].</p><h3><span id="rs-code-in-distributed-storage-systems">RS Code in Distributed Storage Systems</span><a href="#rs-code-in-distributed-storage-systems" class="header-anchor">#</a></h3><p>The RS code are stored in different disks in the distributed storage systems, and the performance arasure code in distributed storage systems involves  disk I/O and repair bandwidth overhead. </p><h5><span id="5-1-rotated-reed-solomon-code">5.1 Rotated Reed-Solomon code</span><a href="#5-1-rotated-reed-solomon-code" class="header-anchor">#</a></h5><p>In the conventional RS code, all the parity blocds are encoded with data blocks in the same strip, while in the rotated reed-solomon code, parity blocks may be generated with different stripes as in the following figure,</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-1a81fb7850f88085.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="RRS code"></p><p>when the disk 5 in the figure fails, this method reduceS 3 operations of reading the data blocks than the conventional RS code [5].</p><h4><span id="local-reconstruction-code-lrc">Local Reconstruction Code (LRC)</span><a href="#local-reconstruction-code-lrc" class="header-anchor">#</a></h4><p>LRC introduces local parity codes which requires slightly more storage space than conventional RS code, but significantly reduce the number of participating data discs for encoding, thus it is beneficial to the reduction of bandwidth and disc I/O overhead.  The figure of pyramid code is shown as follows [6]</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-eb3e80741654047b.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Pyramid"></p><p> However, repair of the global redundancy still needs to access all data discs, another LRC approach in  [7] further introduces parity code ($ S<em>{3} $ in the figure) for the global parity codes ($P</em>{1}$,$P<em>{2}$,$P</em>{3}$,$P<em>{4}$)  to avoid this undesirable situation. By choosing the coefficients of $c</em>{1}^{‘}$, $c<em>{2}^{‘}$, $c</em>{3}^{‘}$, $c<em>{4}^{‘}$ and $c</em>{5}^{‘}$, $c<em>{6}^{‘}$ properly, the parity code of  $ S</em>{3} $ can be calculated by the existing parity codes $ S<em>{1} $ and $ S</em>{2} $. Thus parity code $ S_{3} $ does not have to occupy additional storage.</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-26576a62ea3ad8ca.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="HDFS-Xorbas"></p><blockquote><p><strong>Observation:</strong>  Copy is kind of LRC.</p></blockquote><h3><span id="references">References</span><a href="#references" class="header-anchor">#</a></h3><p>[1] I. Reed and G. Solomon, BPolynomial codes over certain finite fields,[ J. Soc. Ind. Appl. Math., vol. 8,<br>no. 2, pp. 300–304, Jun. 1960.<br>[2] Wicker and Bhargava, Reed-Solomon Codes and Their Applications, 1994.<br>[3] James S. Plank and Lihao Xu, Optimizing Cauchy Reed-Solomon Codes for Fault-Tolerant Network Storage Applications.<br>[4] Reed–Solomon codes for coders.<br>[5] Khan O, Burns R C, Plank J S, et al. Rethinking erasure codes for cloud file systems: minimizing I/O for recovery and degraded reads.<br>[6] Huang Cheng, Chen Minghua, Li Jin. Pyramid codes: flexible schemes to trade space for access efficiency in reliable data storage systems.<br>[7] Sathiamoorthy M, Asteris M, Papailiopoulos D, et al. Xoring elephants: novel erasure codes for big data.<br>[8]  J. Blomer, M. Kalfane, R. Karp, M. Karpinski, M. Luby, and D. Zuckerman, An XOR-Based Erasure-Resilient Coding Scheme.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://hejtao.netlify.com/tags/Golang/"/>
    
      <category term="RS Code" scheme="https://hejtao.netlify.com/tags/RS-Code/"/>
    
      <category term="长文" scheme="https://hejtao.netlify.com/tags/%E9%95%BF%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Golang编程基础</title>
    <link href="https://hejtao.netlify.com/2018/08/20/2018-8-20/"/>
    <id>https://hejtao.netlify.com/2018/08/20/2018-8-20/</id>
    <published>2018-08-20T05:59:10.000Z</published>
    <updated>2019-11-11T19:59:33.203Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><meta name="referrer" content="no-referrer"></p><div class="toc"><!-- toc --><ul><li><a href="#zai-ubuntu-an-zhuang">在Ubuntu安装:</a></li><li><a href="#shu-ju-lei-xing">数据类型:</a><ul><li><a href="#ji-ben-lei-xing">基本类型：</a></li><li><a href="#ju-ji-lei-xing-aggregate-types">聚集类型 (aggregate types)：</a><ul><li><a href="#shu-zu">数组</a></li><li><a href="#jie-gou">结构</a></li></ul></li><li><a href="#yin-yong-lei-xing">引用类型</a><ul><li><a href="#zhi-zhen">指针</a></li><li><a href="#qie-pian-slice">切片（slice）</a></li><li><a href="#zi-dian-map">字典（map）</a></li><li><a href="#han-shu">函数</a></li><li><a href="#tong-dao-channel">通道（channel）</a></li></ul></li><li><a href="#jie-kou-lei-xing-interface">接口类型（interface）：</a></li></ul></li><li><a href="#kong-zhi-liu-for-if-switch-defer-goto">控制流 （for if switch defer goto）：</a></li><li><a href="#chuang-jian-gong-cheng-mu-lu">创建工程目录：</a></li><li><a href="#tips">Tips:</a></li><li><a href="#qi-ta">其他：</a></li><li><a href="#can-kao-zi-liao">参考资料：</a></li></ul><!-- tocstop --></div><h3><span id="zai-ubuntu-an-zhuang">在Ubuntu安装:</span><a href="#zai-ubuntu-an-zhuang" class="header-anchor">#</a></h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">cd</span> ~ </span><br><span class="line">&gt;wget https://dl.google.com/go/go1.11.2.linux-amd64.tar.gz</span><br><span class="line">&gt;tar -C /usr/<span class="built_in">local</span> -xzf go1.11.2.linux-amd64.tar.gz    // 解压到得到的 go 目录，放到 /usr/<span class="built_in">local</span> 目录下</span><br><span class="line">&gt;vim .bashrc    // 写入以下内容</span><br><span class="line"><span class="built_in">export</span> GOPATH=~/hejtao/go_projects</span><br><span class="line"><span class="built_in">export</span> GOROOT=/usr/<span class="built_in">local</span>/go</span><br><span class="line"><span class="built_in">export</span> GOBIN=<span class="variable">$GOROOT</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOBIN</span></span><br><span class="line">&gt;<span class="built_in">source</span> .bashrc</span><br></pre></td></tr></table></figure><h3><span id="shu-ju-lei-xing">数据类型:</span><a href="#shu-ju-lei-xing" class="header-anchor">#</a></h3><p><img src="https://upload-images.jianshu.io/upload_images/1863961-07626fa602c42064.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p><h4><span id="ji-ben-lei-xing">基本类型：</span><a href="#ji-ben-lei-xing" class="header-anchor">#</a></h4><ul><li>数值<ul><li>整型：<code>int</code>； <code>int8</code>； <code>int16</code>；  <code>int32</code>(<code>rune</code>，<code>Unicode</code>)；  <code>int64</code>； <code>uint</code>； <code>uint8</code>(<code>byte</code>)； <code>uint16</code>； <code>uint32</code>； <code>uint64</code>； <code>uintptr</code><br><code>int</code>, <code>uint</code>, <code>uintptr</code> 在 32 位系统上是 32 位，在 64位 系统上是 64位</li><li>浮点型：<code>float32</code>； <code>float64</code></li><li>复数型：<code>complex64</code>； <code>complex128</code></li></ul></li><li>字符串：使用双引号 <code>&quot;a&quot;</code></li><li>布尔: <code>true</code>； <code>false</code></li><li>常量：三种基本类型<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  kb = <span class="number">1024</span></span><br><span class="line">  e = <span class="number">2.71828182845904523536028747135266249775724709369995957496696763</span></span><br><span class="line">  F = <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>在 <code>if</code>语句中，若检验条件为<code>i &gt;= 0</code>，则<code>i</code> 的类型不宜为 <code>uint</code> 型（<code>uint</code> 数据始终 &gt;= 0）。尽管内置函数 <code>len()</code> 返回值是非负整数，但它际返回 <code>int</code> 型，<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">medals := []<span class="keyword">string</span>&#123;<span class="string">"gold"</span>, <span class="string">"silver"</span>, <span class="string">"bronze"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(medals)<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--&#123;</span><br><span class="line">  fmt.Println(medals[i]) <span class="comment">// "bronze", "silver", "gold"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>基本类型与操作符构成表达式</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-f1c19a4e5f60b7af.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p><ul><li>取余 <code>%</code> 只用于整型；余数与被除数符号相同，<code>5%3=2</code>； <code>-5%3=-2</code></li><li><code>5.0/4=1.25</code>；<code>5/4.0=1.25</code>；<code>5/4=1</code></li><li><code>&amp;&amp;</code> 若左边的表达式结果为 <code>false</code>，不检验右边的表达式；<code>&amp;</code> 始终检验两边的表达式 </li><li>与或<code>^</code> ; 一元前缀<code>^</code></li></ul><h4><span id="ju-ji-lei-xing-aggregate-types">聚集类型 (aggregate types)：</span><a href="#ju-ji-lei-xing-aggregate-types" class="header-anchor">#</a></h4><h5><span id="shu-zu">数组</span><a href="#shu-zu" class="header-anchor">#</a></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">r := [...]<span class="keyword">int</span>&#123;<span class="number">99</span>: <span class="number">1</span>&#125;    <span class="comment">// 索引为99的元素，r[99]， 等于 1，其他默认 0</span></span><br><span class="line"></span><br><span class="line">p := <span class="built_in">new</span>([<span class="number">10</span>]<span class="keyword">int</span>)    <span class="comment">// 将生成的数组的指针赋给 p, 为 *[10]int 类型</span></span><br><span class="line">p[<span class="number">0</span>]=<span class="number">1</span>    <span class="comment">// 给 p 指向的数组的索引为0的元素赋值 1</span></span><br></pre></td></tr></table></figure><p>数组的长度也是数组类型的一部分，因此 <code>[3]int</code> 和 <code>[4]int</code> 是不同类型的数组，不能进行比较或赋值。</p><h5><span id="jie-gou">结构</span><a href="#jie-gou" class="header-anchor">#</a></h5><p>（1）结构的字段（field）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;      <span class="comment">// 定义 person 类型</span></span><br><span class="line">    gender <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    student := person&#123;&#125;</span><br><span class="line">    student.age = <span class="number">16</span></span><br><span class="line">    student.gender = <span class="string">"male"</span></span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    student := person&#123;</span><br><span class="line">       gender : <span class="string">"male"</span>, </span><br><span class="line">        age : <span class="number">16</span>,    <span class="comment">//逗号不能省</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    student := person&#123;<span class="string">"male"</span>, <span class="number">16</span>&#125;</span><br><span class="line"></span><br><span class="line">    teacher := &amp;person&#123;    <span class="comment">//取指针</span></span><br><span class="line">      gender : <span class="string">"female"</span>, </span><br><span class="line">       age : <span class="number">30</span>,    </span><br><span class="line">    &#125;</span><br><span class="line">    teacher.age = <span class="number">36</span>    <span class="comment">//指针 teacher 仍然可以进行点操作</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>指针也可以进行点操作。</p></blockquote><p>匿名结构，字段匿名<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">student := <span class="keyword">struct</span>&#123;      <span class="comment">// 匿名结构</span></span><br><span class="line">    gender : <span class="keyword">string</span></span><br><span class="line">    age : <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    gender : <span class="string">"male"</span>,</span><br><span class="line">    age : <span class="string">"17"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;      </span><br><span class="line">    <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照顺序初始化</span></span><br><span class="line">student := person&#123;<span class="string">"male"</span>, <span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure></p><p>结构嵌套，<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;      </span><br><span class="line">    gender <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    parents <span class="keyword">struct</span>&#123;      <span class="comment">//  嵌套一个匿名结构</span></span><br><span class="line">        dad, mom : <span class="keyword">string</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span>&#123;</span><br><span class="line">    state, city <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person2 <span class="keyword">struct</span>&#123;      </span><br><span class="line">    gender <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    address    <span class="comment">// 嵌套你一个结构address</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    student := person&#123;gender : <span class="string">"female"</span>, age : <span class="number">10</span>&#125;</span><br><span class="line">    student.parents.dad = <span class="string">"Tom"</span></span><br><span class="line">    student.parents.mom = <span class="string">"Lily"</span>     </span><br><span class="line">    </span><br><span class="line">    student2 := person2&#123;gender:<span class="string">"female"</span>, age:<span class="number">10</span>, address : address&#123;county:<span class="string">"LA"</span> state:<span class="string">"California"</span>&#125;  &#125; </span><br><span class="line">    student2.address.state = <span class="string">"Massachusetts"</span>    <span class="comment">// or</span></span><br><span class="line">    student2.state = <span class="string">"Massachusetts"</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2）结构的方法（method）<br> 函数与方法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Distance</span>(<span class="params">p, q Point</span>) <span class="title">float64</span></span> &#123;<span class="comment">//函数</span></span><br><span class="line"><span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">p Point</span>) <span class="title">Distance</span>(<span class="params">q Point</span>) <span class="title">float64</span></span> &#123;<span class="comment">// 方法，在函数名前增加一个形参（receiver） 类似于Java的this 和python的 self，</span></span><br><span class="line"><span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)             <span class="comment">// 接收者的名称通常取它的类型名称的第一个字母</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line">fmt.Println(Distance(p, q))<span class="comment">// 打印 5， 调用函数</span></span><br><span class="line">fmt.Println(p.Distance(q))<span class="comment">// 调用方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当需要使用方法对值（value of type T，相对于方法来讲就是实参，argument） 的字段进行修改时，使用接收者为指针的方法或者叫指针方法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">p *Point</span>) <span class="title">ScaleBy</span>(<span class="params">factor <span class="keyword">float64</span></span>)</span> &#123;      <span class="comment">// 接收者参数p的类型是指针类型</span></span><br><span class="line">    p.X *= factor      <span class="comment">// p在这里是指针，等价于 (*p).X</span></span><br><span class="line">    p.Y *= factor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>同一个 struct 的方法和字段占据相同的命名空间（name space），因此两者的名称不能重复；<br>指针方法看作高权限方法。</p></blockquote><p>对方法的调用, 值（实参） 和 接收者（形参）类型要相同<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;.Distance(q)     <span class="comment">// Point  Point</span></span><br><span class="line">pptr.ScaleBy(<span class="number">2</span>)       <span class="comment">// *Point  *Point</span></span><br><span class="line"></span><br><span class="line">pptr.Distance(q)     <span class="comment">// 隐含 (*pptr)</span></span><br><span class="line">p.ScaleBy(<span class="number">2</span>)     <span class="comment">// 隐含 (&amp;p)</span></span><br><span class="line"></span><br><span class="line">             Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;.ScaleBy(<span class="number">2</span>)    <span class="comment">//错误！！！</span></span><br><span class="line">(&amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;).ScaleBy(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>不仅仅是 <code>struct</code><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> INT <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">var</span> a INT</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">a.Print()    <span class="comment">// 打印 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">a *INT</span>) <span class="title">Print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">*a = <span class="number">2</span></span><br><span class="line">fmt.Println(*a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>方法是与命名类型(named type)相关联的函数。</p></blockquote><h4><span id="yin-yong-lei-xing">引用类型</span><a href="#yin-yong-lei-xing" class="header-anchor">#</a></h4><h5><span id="zhi-zhen">指针</span><a href="#zhi-zhen" class="header-anchor">#</a></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">i := <span class="number">20</span></span><br><span class="line">p = &amp;i</span><br><span class="line">*p = <span class="number">10</span>    <span class="comment">// i 的值为 10</span></span><br></pre></td></tr></table></figure><h5><span id="qie-pian-slice">切片（slice）</span><a href="#qie-pian-slice" class="header-anchor">#</a></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span>    <span class="comment">// 声明切片 s</span></span><br><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s = a[:<span class="number">2</span>]    <span class="comment">// [1, 2]， len(s)等于2，cap(s)等于5</span></span><br><span class="line">s = a[<span class="number">0</span>:<span class="number">1</span>]    <span class="comment">// [1]，len(s)等于1，cap(s)等于5</span></span><br><span class="line">s = a[<span class="number">3</span>:]    <span class="comment">// [4, 5]，len(s)等于2，cap(s)等于2</span></span><br><span class="line"></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">4</span>)    <span class="comment">//make([]type, len, cap) ，切片长度为2，底层数组的长度为4</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)    <span class="comment">// s 的地址不变</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>)    <span class="comment">// 生成新的数组，地址改变，容量翻倍，也就是cap(s)等于4*2=8</span></span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(s1, s2)    <span class="comment">//把 s2 复制到 s1，s1 为 [4, 5, 3]</span></span><br><span class="line"></span><br><span class="line">s1 = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(s2, s1)    <span class="comment">// s2 为 [1, 2]</span></span><br></pre></td></tr></table></figure><blockquote><p>切片的本质是对底层数组的引用；切片的容量（cap）是切片的始索引到底层数组的末索引的长度。</p></blockquote><h5><span id="zi-dian-map">字典（map）</span><a href="#zi-dian-map" class="header-anchor">#</a></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>    <span class="comment">// key int 型；value string 型</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">m[<span class="number">0</span>] = <span class="string">"OK"</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="number">0</span>)    <span class="comment">// 删除 m 中键为0的键值对</span></span><br></pre></td></tr></table></figure><p>嵌套，<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)    <span class="comment">// value  map型</span></span><br><span class="line">m[<span class="number">1</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">m[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">"YES"</span></span><br></pre></td></tr></table></figure></p><h5><span id="han-shu">函数</span><a href="#han-shu" class="header-anchor">#</a></h5><p><code>func main(int, []string) int</code><br>means， function main takes an int and a slice of strings and returns an int<br>函数作为类型，<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span>(<span class="params"><span class="keyword">func</span>(<span class="keyword">int</span>,<span class="keyword">int</span></span>) <span class="title">int</span>, <span class="title">int</span>) <span class="title">func</span>(<span class="params"><span class="keyword">int</span>, <span class="keyword">int</span></span>) <span class="title">int</span></span></span><br></pre></td></tr></table></figure></p><p>不定长变参，闭包<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  var_args(<span class="number">1</span>)    </span><br><span class="line">  var_args(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)    </span><br><span class="line"></span><br><span class="line">  f := closure(<span class="number">10</span>)</span><br><span class="line">  fmt.Println(f(<span class="number">1</span>))   </span><br><span class="line">  fmt.Println(f(<span class="number">2</span>))    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">var_args</span>(<span class="params">args ...<span class="keyword">int</span></span>)</span>&#123;</span><br><span class="line">  fmt.Println(args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closure</span>(<span class="params">x <span class="keyword">int</span></span>) <span class="title">func</span>(<span class="params"><span class="keyword">int</span></span>) <span class="title">int</span></span>&#123;    <span class="comment">// 返回匿名函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span>(<span class="params">y <span class="keyword">int</span></span>) <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure></p><h5><span id="tong-dao-channel">通道（channel）</span><a href="#tong-dao-channel" class="header-anchor">#</a></h5><p>channel 是 goroutine 沟通的桥梁，通过 make 创建，close 关闭<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"I from goroutine !"</span>)</span><br><span class="line">c &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>channel 作为函数形参<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> Hello(c)</span><br><span class="line"></span><br><span class="line">&lt;-c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span>(<span class="params">c <span class="keyword">chan</span> <span class="keyword">bool</span></span>)</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello, I from goroutine!"</span>)</span><br><span class="line">c &lt;- <span class="literal">true</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>多个 goroutine，多个channel<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(runtime.NumCPU())    <span class="comment">// 开启多核</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;    <span class="comment">// 启动多个 goroutin</span></span><br><span class="line"><span class="keyword">go</span> Decomposition(c, i, <span class="number">100000007</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;    <span class="comment">// 多个 channel 阻塞</span></span><br><span class="line">&lt;-c</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decomposition</span>(<span class="params">c <span class="keyword">chan</span> <span class="keyword">bool</span>, index <span class="keyword">int</span>, n <span class="keyword">int</span></span>)</span> &#123;    <span class="comment">// 质数分解</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> n != i &#123;</span><br><span class="line"><span class="keyword">if</span> n%i == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d*"</span>, i)</span><br><span class="line">n = n / i</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%d: %d\n"</span>, index, n)</span><br><span class="line"></span><br><span class="line">c &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：   </span><br><span class="line"><span class="number">0</span>: <span class="number">100000007</span></span><br><span class="line"><span class="number">2</span>: <span class="number">100000007</span></span><br><span class="line"><span class="number">1</span>: <span class="number">100000007</span></span><br><span class="line"><span class="number">4</span>: <span class="number">100000007</span></span><br><span class="line"><span class="number">3</span>: <span class="number">100000007</span></span><br><span class="line">从输出结果的顺序可以看出 goroutine 并非先启动先执行</span><br></pre></td></tr></table></figure></p><p>使用同步包来代替 channel<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">5</span>)    <span class="comment">//  添加 5 个 任务（goroutine）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> Decomposition(&amp;wg, i, <span class="number">100000007</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()    <span class="comment">// 等到任务数减到 0 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decomposition</span>(<span class="params">wg *sync.WaitGroup, m <span class="keyword">int</span>, n <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> n != i &#123;</span><br><span class="line"><span class="keyword">if</span> n%i == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d*"</span>, i)</span><br><span class="line">n = n / i</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%d: %d\n"</span>, m, n)</span><br><span class="line"></span><br><span class="line">wg.Done()    <span class="comment">// 任务数减 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">0</span>: <span class="number">100000007</span></span><br><span class="line"><span class="number">2</span>: <span class="number">100000007</span></span><br><span class="line"><span class="number">4</span>: <span class="number">100000007</span></span><br><span class="line"><span class="number">1</span>: <span class="number">100000007</span></span><br><span class="line"><span class="number">3</span>: <span class="number">100000007</span></span><br></pre></td></tr></table></figure></p><p><code>selec{}</code>语句，<br>如果有多个case 读取数据，select会随机选择一个case执行，其他不执行；<br>如果没有case读取数据，就执行default；<br>如果没有case读取数据，且没有default，select将阻塞，直到某个case可以执行。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">c1, c2, block := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;    <span class="comment">// 按随机顺序处理多个 case</span></span><br><span class="line"><span class="keyword">case</span> message, open := &lt;-c1:</span><br><span class="line"><span class="keyword">if</span> !open &#123;    <span class="comment">// 如果通道 c1 关闭，则跳出无限循环</span></span><br><span class="line">block &lt;- <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"A message from main by c1:"</span>, message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> message, open := &lt;-c2:</span><br><span class="line"><span class="keyword">if</span> !open &#123;    <span class="comment">// 如果通道 c2 关闭，则跳出无限循环</span></span><br><span class="line">block &lt;- <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"A message from main by c2:"</span>, message)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">c1 &lt;- <span class="number">10</span></span><br><span class="line">c2 &lt;- <span class="string">"hello"</span></span><br><span class="line">c1 &lt;- <span class="number">20</span></span><br><span class="line">c2 &lt;- <span class="string">"world"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(c1)    <span class="comment">// 关闭通道 c1</span></span><br><span class="line"></span><br><span class="line">&lt;-block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">A message from main by c1: <span class="number">10</span></span><br><span class="line">A message from main by c2: hello</span><br><span class="line">A message from main by c1: <span class="number">20</span></span><br><span class="line">A message from main by c2: world</span><br></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">2000000</span> * time.Microsecond):</span><br><span class="line">fmt.Println(<span class="string">"2 seconds"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1999999</span> * time.Microsecond):</span><br><span class="line">fmt.Println(<span class="string">"1.999999 seconds"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1.999999</span> seconds</span><br></pre></td></tr></table></figure><h4><span id="jie-kou-lei-xing-interface">接口类型（interface）：</span><a href="#jie-kou-lei-xing-interface" class="header-anchor">#</a></h4><p>（1）接口代表某些方法的集合<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> game <span class="keyword">interface</span> &#123;</span><br><span class="line">Strike_of_Kings() <span class="keyword">int</span></span><br><span class="line">Battle_Grounds() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> contact <span class="keyword">interface</span> &#123;</span><br><span class="line">Wechat()</span><br><span class="line">QQ()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> smartphone <span class="keyword">interface</span>&#123;    <span class="comment">// 接口嵌套，</span></span><br><span class="line">    game</span><br><span class="line">    contact</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iphone <span class="keyword">struct</span> &#123;    </span><br><span class="line">version <span class="keyword">string</span></span><br><span class="line">price   <span class="keyword">float32</span></span><br><span class="line">user    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">iph iphone</span>) <span class="title">Wechat</span>(<span class="params"></span>)</span> &#123;    </span><br><span class="line">fmt.Println(<span class="string">"I installed wechat on my iphone"</span>, iph.version)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">iph *iphone</span>) <span class="title">QQ</span>(<span class="params"></span>)</span> &#123;    </span><br><span class="line">fmt.Println(<span class="string">"I installed wechat on my iphone"</span>, iph.version)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// iphone 不满足 contact 接口</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">iph iphone</span>) <span class="title">Battle_Grounds</span>(<span class="params"></span>) <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"There are 4 teammates at most in the Battle Grounds."</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">iph iphone</span>) <span class="title">Strike_of_Kings</span>(<span class="params"></span>) <span class="title">int</span></span> &#123;    </span><br><span class="line">fmt.Println(<span class="string">"There are 5 teammates at most in the Strike of Kings."</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// iphone 满足 game 接口</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">iph *iphone</span>) <span class="title">New_Version</span>(<span class="params">version <span class="keyword">string</span></span>)</span> &#123;</span><br><span class="line">iph.version = version</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">all_round_game</span>(<span class="params">game</span>)</span> &#123;      <span class="comment">// 接口作为形参</span></span><br><span class="line">fmt.Println(<span class="string">"Both Strike of_Kings and Battle Grounds have installed."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">my_phone := iphone&#123;<span class="string">"X"</span>, <span class="number">8316</span>, <span class="string">"Xiaohe"</span>&#125;</span><br><span class="line">my_phone.Wechat()</span><br><span class="line">    fmt.Println(my_phone.Battle_Grounds())</span><br><span class="line"></span><br><span class="line">all_round_game(my_phone)    <span class="comment">// my_phone 符合 game 接口，可作为该函数的实参</span></span><br><span class="line"><span class="keyword">var</span> _ game = iphone   <span class="comment">// 确保 iphone 实现了接口game </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2）任何类型都满足空接口；空接口<code>interface{}</code>作为形参可以接受任何类型的实参<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">m[<span class="number">1</span>] = <span class="string">"a"</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">m[<span class="number">3</span>] = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">print_map(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print_map</span>(<span class="params">m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">interface</span>&#123;&#125;</span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(k, <span class="string">":"</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span> : a</span><br><span class="line"><span class="number">2</span> : <span class="number">2</span></span><br><span class="line"><span class="number">3</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><blockquote><p><code>[]string</code> 和 <code>[]interface{}</code> 是不同的类型；<br>接口是一种抽象类型，可理解为是将所有具体类型按照方法集进行再分类；<br>指针方法集包含非指针方法集。</p></blockquote><p>（3）接口值（interface value）包含 类型 （接口的动态类型）和 类型值 （接口的动态值） 两个部分，仅当两者均为<code>nil</code> 时，接口才为<code>nil</code><br><img src="https://upload-images.jianshu.io/upload_images/1863961-48d541dd9a4ab443.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="The zero value for an interface has both its type and value components set to nil"><br>（4）反射 （reflection）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iphone <span class="keyword">struct</span> &#123;</span><br><span class="line">version <span class="keyword">string</span></span><br><span class="line">price   <span class="keyword">int</span></span><br><span class="line">user    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">iph iphone</span>) <span class="title">Wechat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"I installed wechat on my iphone"</span>, iph.version)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">my_phone := iphone&#123;<span class="string">"X"</span>, <span class="number">8316</span>, <span class="string">"Xiaohe"</span>&#125;</span><br><span class="line">Info(my_phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Info</span>(<span class="params">itf <span class="keyword">interface</span>&#123;&#125;</span>)</span> &#123;</span><br><span class="line">t := reflect.TypeOf(itf)</span><br><span class="line">fmt.Println(t)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">fmt.Println(t.Field(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"___________________"</span>)</span><br><span class="line"></span><br><span class="line">v := reflect.ValueOf(itf)</span><br><span class="line">fmt.Println(v)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">fmt.Println(v.Field(i))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">main.iphone</span><br><span class="line">&#123;version main <span class="keyword">string</span>  <span class="number">0</span> [<span class="number">0</span>] <span class="literal">false</span>&#125;</span><br><span class="line">&#123;price main <span class="keyword">int</span>  <span class="number">16</span> [<span class="number">1</span>] <span class="literal">false</span>&#125;</span><br><span class="line">&#123;user main <span class="keyword">string</span>  <span class="number">24</span> [<span class="number">2</span>] <span class="literal">false</span>&#125;</span><br><span class="line">___________________</span><br><span class="line">&#123;X <span class="number">8316</span> Xiaohe&#125;</span><br><span class="line">X</span><br><span class="line"><span class="number">8316</span></span><br><span class="line">Xiaohe</span><br></pre></td></tr></table></figure></p><h3><span id="kong-zhi-liu-for-if-switch-defer-goto">控制流 （for if switch defer goto）：</span><a href="#kong-zhi-liu-for-if-switch-defer-goto" class="header-anchor">#</a></h3><p>（1）<code>for</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (inti statement)；condition；(post statement) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> ; i &lt; <span class="number">10</span>; &#123;    <span class="comment">// 去掉分号</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span>&#123;    <span class="comment">// while 语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>&#123;    <span class="comment">// 无限循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2）<code>if</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (init statement)；condition &#123;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (init statement)；condition &#123;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（3）<code>switch</code>：<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (init statement)；some value &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>：</span><br><span class="line">    <span class="keyword">case</span> f()：</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>：</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> 布尔表达式<span class="number">1</span>：</span><br><span class="line">    <span class="keyword">case</span> 布尔表达式<span class="number">2</span>：</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>：</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一旦符合条件自动终止，若希望继续检验下面的case，使用 <code>fallthrough</code> 语句。<br>（4）<code>defer</code>：</p><ul><li>defer 后必须跟函数引用</li><li>defer 语句被检验后，延迟函数获得变量的拷贝</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;    <span class="comment">// defer 语句打印0</span></span><br></pre></td></tr></table></figure><ul><li>defer 语句被检验后，延迟匿名函数获得变量的地址</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span>(<span class="params"></span>) (<span class="params">i <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123; i++ &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>    <span class="comment">// 将1 赋给 i</span></span><br><span class="line">&#125;    <span class="comment">// 返回 2。利用 defer 语句修改外围函数的命名返回值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        fmt.Print(i)</span><br><span class="line">  &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;  <span class="comment">// 打印 333</span></span><br></pre></td></tr></table></figure><ul><li>defer 语句被检验后，延迟函数的引用被推入堆栈，当外围函数返回后，按照后进先出的顺序被调用（即使外围函数发生错误，如 panic，延迟函数仍然会被调用）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">d</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Print(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    <span class="comment">// 打印 3210</span></span><br></pre></td></tr></table></figure><p>更多细节如，<code>panic</code>， <code>recover</code>（只能用在延迟函数中） 参考 <a href="https://blog.golang.org/defer-panic-and-recover" target="_blank" rel="noopener">defer blog</a>。</p><p>（5）<code>goto</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">LABEL:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">break</span> LABEL    <span class="comment">// 跳出与LABEL同级的循环，即跳出无限循环</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LABEL:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> LABEL</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LABEL:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> LABEL    <span class="comment">// 将再次进入无限循环</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>通常<code>标签</code>放到 <code>goto</code> 的后面。</p></blockquote><h3><span id="chuang-jian-gong-cheng-mu-lu">创建工程目录：</span><a href="#chuang-jian-gong-cheng-mu-lu" class="header-anchor">#</a></h3><p>Go工程中共有三个部分：</p><ul><li>src：存放go源码文件</li><li>pkg：存放编译后的包文件</li><li>bin：存放编译后的可执行文件</li></ul><blockquote><p><strong>注意：</strong>src目录需要自己创建，pkg和bin编译时会自动创建。</p></blockquote><p>步骤：</p><ol><li>新建工程目录，my_project，并在该目录下创建 src目录；</li><li>把my_project 添加到 GOPATH，GOPATH=/home/user/…;my_project（可以同时添加多个路径目录，Linux下用冒号:隔开，window下分号;隔开）;</li><li>在 src 下创建my_pkg 和 my_cmd;</li><li>包文件放入到 my_pkg 中，比如 test.go <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> my_pkg</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">"Hello,world!"</span>)</span><br><span class="line">  fmt.Println(<span class="string">"You used a function defined in my_package!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在命令行src目录，执行 <code>go install my_pkg</code> 将创建 pkg 目录并声成 my_pkg.a 文件。</p><ol><li>my_cmd 中放入 package main，比如 hello_world.go<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="string">"my_pkg"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  my_pkg.Test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在命令行src目录，执行 <code>go install my_cmd</code> 将创建 bin 目录并生成可执行文件成 hello_world.exe 文件。</p><blockquote><p>目录结构：<br>src/<br>$\quad$ my_pkg/<br>      $\qquad$ test.go<br>$\quad$ my_cmd/<br>     $\qquad$ hello_world.go</p></blockquote><h3><span id="tips">Tips:</span><a href="#tips" class="header-anchor">#</a></h3><p>import 包A的时候，会自动调用包A的init()函数（i字母小写）。如果该包A又import了别的包B，会优先调用包B的init()函数，最后才调用main包的init()函数。<br>一个包的init()函数可以定义多个，每个都会被调用，调用的顺序按文件名排序。同一个文件也可以定义多个init函数。</p><h3><span id="qi-ta">其他：</span><a href="#qi-ta" class="header-anchor">#</a></h3><ul><li><code>fmt.printf</code> verbs：<br><code>%x  %b</code>：16进制，2进制显示；<code>%t</code>：显示 bool 结果；<code>%T</code>：显示值的类型；<code>%v</code>：显示值；<code>%p</code>：显示地址；<code>\n</code>：换行</li><li>Sublime text 3<br>上一个编辑处: alt+-<br>下一个编辑处: alt+shift+- </li><li>GoSublime：<br>GoSublime快捷键列表：ctrl+.+. (连击 .)<br>查看声明：ctrl+.+h<br>代码跳转：ctrl+shift+左键<br>package control：ctrl+shift+p</li><li>Goland：退回上一次光标位置：ctrl+win+alt+左键</li></ul><h3><span id="can-kao-zi-liao">参考资料：</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h3><p>[1] 无闻;<a href="https://study.163.com/course/introduction.htm?courseId=306002" target="_blank" rel="noopener">Go编程基础系列视频</a>.<br>[2] Alan A.A. Donovan; Brain W. Kernighan; The Go Programming Language; 2015.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://hejtao.netlify.com/tags/Golang/"/>
    
      <category term="长文" scheme="https://hejtao.netlify.com/tags/%E9%95%BF%E6%96%87/"/>
    
  </entry>
  
</feed>
