<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>米琴香光</title>
  <icon>https://www.gravatar.com/avatar/0ada4b51ad3a273705846d0117a03f4f</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hejtao.netlify.com/"/>
  <updated>2020-03-22T23:29:31.064Z</updated>
  <id>https://hejtao.netlify.com/</id>
  
  <author>
    <name>Jiang-Tao He</name>
    <email>hejtao@outlook.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx Notes</title>
    <link href="https://hejtao.netlify.com/2020/03/22/2020-3-22/"/>
    <id>https://hejtao.netlify.com/2020/03/22/2020-3-22/</id>
    <published>2020-03-21T16:00:00.000Z</published>
    <updated>2020-03-22T23:29:31.064Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><div class="toc"><!-- toc --><ul><li><a href="#qi-dong-ting-zhi-he-chong-qi">启动、停止和重启</a></li></ul><!-- tocstop --></div><h4><span id="qi-dong-ting-zhi-he-chong-qi">启动、停止和重启</span><a href="#qi-dong-ting-zhi-he-chong-qi" class="header-anchor">#</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br><span class="line">systemctl start nginx.service</span><br><span class="line">systemctl start nginx</span><br><span class="line">ps aux | grep nginx</span><br><span class="line"></span><br><span class="line">ngxin -s quit</span><br><span class="line">nginx -s stop</span><br><span class="line">killall nginx</span><br><span class="line">systemctl stop nginx.service</span><br><span class="line">systemctl stop nginx</span><br><span class="line"></span><br><span class="line">nginx -s reload</span><br><span class="line">systemctl restart nginx.service</span><br><span class="line">systemctl restart nginx</span><br><span class="line"></span><br><span class="line">netstat -tlnp</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="nginx" scheme="https://hejtao.netlify.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Flutter Notes</title>
    <link href="https://hejtao.netlify.com/2019/12/28/2019-12-28/"/>
    <id>https://hejtao.netlify.com/2019/12/28/2019-12-28/</id>
    <published>2019-12-27T16:00:00.000Z</published>
    <updated>2020-03-22T23:27:37.381Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><div class="toc"><!-- toc --><ul><li><a href="#fascinating-flutter-pages">Fascinating Flutter Pages</a><ul><li><a href="#dynamical-disco">Dynamical Disco</a></li></ul></li><li><a href="#notes">Notes</a></li></ul><!-- tocstop --></div><h3><span id="fascinating-flutter-pages">Fascinating Flutter Pages</span><a href="#fascinating-flutter-pages" class="header-anchor">#</a></h3><h4><span id="dynamical-disco">Dynamical Disco</span><a href="#dynamical-disco" class="header-anchor">#</a></h4><p><img src="/images/44.gif" alt=""></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiscData</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> _rng = Random();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">double</span> size;</span><br><span class="line">  Color color;</span><br><span class="line">  Alignment alignment;</span><br><span class="line"></span><br><span class="line">  DiscData() &#123;</span><br><span class="line">    color = Color.fromARGB(</span><br><span class="line">      _rng.nextInt(<span class="number">200</span>),</span><br><span class="line">      _rng.nextInt(<span class="number">255</span>),</span><br><span class="line">      _rng.nextInt(<span class="number">255</span>),</span><br><span class="line">      _rng.nextInt(<span class="number">255</span>),</span><br><span class="line">    );</span><br><span class="line">    size = _rng.nextDouble() * <span class="number">40</span> + <span class="number">10</span>;</span><br><span class="line">    alignment = Alignment(</span><br><span class="line">      _rng.nextDouble() * <span class="number">2</span> - <span class="number">1</span>,</span><br><span class="line">      _rng.nextDouble() * <span class="number">2</span> - <span class="number">1</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main()&#123;</span><br><span class="line">  runApp(</span><br><span class="line">    MaterialApp(</span><br><span class="line">      debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        body: Container(</span><br><span class="line">          color: Color(<span class="number">0xFF15202D</span>),</span><br><span class="line">          child: SizedBox.expand(</span><br><span class="line">            child: VariousDiscs(<span class="number">50</span>),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariousDiscs</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> numberOfDiscs;</span><br><span class="line"></span><br><span class="line">  VariousDiscs(<span class="keyword">this</span>.numberOfDiscs);</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _VariousDiscsState createState() =&gt; _VariousDiscsState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_VariousDiscsState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">VariousDiscs</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> _discs = &lt;DiscData&gt;[];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    _makeDiscs();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _makeDiscs() &#123;</span><br><span class="line">    _discs.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; widget.numberOfDiscs; i++) &#123;</span><br><span class="line">      _discs.add(DiscData());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> GestureDetector(</span><br><span class="line">      onTap: () =&gt; setState(() &#123;</span><br><span class="line">        _makeDiscs();</span><br><span class="line">    &#125;),</span><br><span class="line">      child: Stack(</span><br><span class="line">        children: [</span><br><span class="line">          Center(</span><br><span class="line">            child: Text(</span><br><span class="line">              <span class="string">'DISCO FACE'</span>,</span><br><span class="line">              style: TextStyle(color: Colors.white, fontSize: <span class="number">50</span>),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">final</span> disc <span class="keyword">in</span> _discs)</span><br><span class="line">            Positioned.fill(</span><br><span class="line">              child: AnimatedAlign(</span><br><span class="line">                duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>),</span><br><span class="line">                curve: Curves.easeInOut,</span><br><span class="line">                alignment: disc.alignment,</span><br><span class="line">                child: AnimatedContainer(</span><br><span class="line">                  duration: <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>),</span><br><span class="line">                  decoration: BoxDecoration(</span><br><span class="line">                    color: disc.color,</span><br><span class="line">                    shape: BoxShape.circle,</span><br><span class="line">                  ),</span><br><span class="line">                  height: disc.size,</span><br><span class="line">                  width: disc.size,</span><br><span class="line">                ),</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">    ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="notes">Notes</span><a href="#notes" class="header-anchor">#</a></h3><ol><li>组建调试</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">  Widget build(BuildContext context) &#123;    </span><br><span class="line">    debugPaintSizeEnabled = true;   </span><br><span class="line">    return Container();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>ListView 支持 app body 的滚动, Column + SingleChildScrollView</p></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Flutter" scheme="https://hejtao.netlify.com/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Linux Notes</title>
    <link href="https://hejtao.netlify.com/2019/12/01/2019-12-1/"/>
    <id>https://hejtao.netlify.com/2019/12/01/2019-12-1/</id>
    <published>2019-11-30T16:00:00.000Z</published>
    <updated>2019-12-21T08:27:38.240Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><div class="toc"><!-- toc --><ul><li><a href="#linux">linux</a><ul><li><a href="#wen-jian-yi-dong-fu-zhi">文件移动、复制</a></li><li><a href="#wen-jian-quan-xian">文件权限</a></li><li><a href="#linux-cha-zhao-ming-ling">Linux查找命令</a></li><li><a href="#qi-ta">其它</a></li></ul></li><li><a href="#vim">vim</a></li></ul><!-- tocstop --></div><h3><span id="linux">linux</span><a href="#linux" class="header-anchor">#</a></h3><h4><span id="wen-jian-yi-dong-fu-zhi">文件移动、复制</span><a href="#wen-jian-yi-dong-fu-zhi" class="header-anchor">#</a></h4><p><code>mv a b</code>：重命名<br><code>mv /home/music/往后余生.mp3 /home/loved_music/</code> ： 把往后余生剪切（移动）到 loved_music下<br><code>cp -a /home/jiangtao/* /home/huaxi</code> ： 复制jiangtao下的所有文件到huaxi下<br><code>cp -a /home/jiangtao /home/huaxi</code> ：文件夹拷贝，得到 <code>/home/huaxi/jiangtao</code><br><code>rm -rf /home/jiangtao/*</code> ： 删除jiangtao下的所有内容。<code>-r</code>不管有多少级目录，一并删除；<code>-f</code> 强行删除，不作任何提示<br><code>rm -rf /home/jiangtao</code> ：删除jiangtao目录<br><code>cat textfile</code>：显示内容<br><code>cat -n textfile1 &gt; textfile2</code>：把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里<br><code>cat -b textfile1 textfile2 &gt;&gt; textfile3</code>：把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到textfile3 文档里</p><h4><span id="wen-jian-quan-xian">文件权限</span><a href="#wen-jian-quan-xian" class="header-anchor">#</a></h4><p><code>chown</code> (change ownership)将指定文件的拥有者改为指定的用户或组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;sudo chown -R $(whoami) /usr/local/Cellar</span><br><span class="line">&gt;sudo chown root:hejtao file.txt</span><br><span class="line">&gt;sudo chown hejtao:hejao file.txt</span><br></pre></td></tr></table></figure><p><code>-R</code>: 处理指定目录以及其子目录下的所有文件<br><code>chmod abc file</code><br>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限<br>r=4(可读)，w=2(可写)，x=1(可读写)<br>若要rwx属性则4+2+1=7；<br>若要rw-属性则4+2=6；<br>若要r-x属性则4+1=5。<br><code>chmod 765 file.txt</code> 等价于 <code>chmod u=rwx,g=rw,o=rx file.txt</code></p><h4><span id="linux-cha-zhao-ming-ling">Linux查找命令</span><a href="#linux-cha-zhao-ming-ling" class="header-anchor">#</a></h4><p><code>find . -type f -mmin -10</code> 搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录<br><code>find . -name 'my*' -ls</code> 搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息<br><code>find . -type f -iname &quot;*.php&quot;</code><br><code>find . -size -1M</code> 小于1M的文件<br><code>find . -type d -not -iname &quot;*php&quot;</code> 找不以php结尾的目录<br><code>find . -maxdepth 1 -type f -iname &quot;*.conf&quot;</code> 当前和下一级目录<br><code>find . -type f -iname &quot;*.php&quot; -exec grep &quot;function&quot; {} +</code><br><code>locate -i hello.txt</code> 查找文件位置，<code>-i</code> 选项忽略大小写<br><code>locate ~/m</code> 搜索用户主目录下，所有以m开头的文件</p><h4><span id="qi-ta">其它</span><a href="#qi-ta" class="header-anchor">#</a></h4><p><code>echo</code> 显示字符串，转义字符，变量；内容定向至文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;echo hello, world! &gt; hello   先清空在写入</span><br><span class="line">&gt;cat hello</span><br><span class="line">hello, world!</span><br><span class="line"></span><br><span class="line">&gt;echo hello, world! &gt;&gt; hello    换行后写入</span><br></pre></td></tr></table></figure><p><code>grep ipfs . -r -n</code> 在当前目录的多级文件进行（-r）递归搜索，并（-n）显示行号<br><code>grep -i -n &quot;function&quot; ./*</code><br><code>ps -ax | grep ipfs</code> : 显示系统中当前运行的包含 ipfs 的进程</p><p> 一行输入多个命令,使用<code>;</code> 、<code>&amp;</code> 、<code>|</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;echo i am hejtao\n ; echo hello hejtao</span><br><span class="line">i am hejtao</span><br><span class="line"></span><br><span class="line">hello hejtao</span><br></pre></td></tr></table></figure><p> <code>ifconfig</code>: 查看和配置网络设备<br><code>mkdir</code><br><code>rmdir</code><br><code>touch new.txt</code>新建文件<br><code>man</code>查询命令的信息</p><p> 停止命令 <code>Ctrl + c</code><br>强制停止命令 <code>Ctrl + z</code><br>清空窗口 <code>clear</code><br>自动联想<code>TAB</code><br>关闭<code>sudo halt</code><br>重启 <code>sudo reboot</code>.</p><p> <code>ssh root@207.148.109.110</code><br><code>mosh root@207.148.109.110</code><br><code>scp ./Go语言编程_许式伟.pdf root@207.148.109.110:~/my_files</code> 本地上传到vps</p><p> 清屏 <code>clear</code><br>屏幕翻页 <code>ctrl l</code><br><code>ls</code> <code>-l</code> (long)  <code>-r</code>(reverse)  <code>-s</code>(size)<br><code>ls &gt; outfile.txt</code> 结果写入outfile.txt<br><code>ls | tee outfile2.txt</code> 显示结果，并将结果写入outfile2.txt<br><code>apt-cache</code></p><p> 断开ssh：<code>ctrl d</code></p><h3><span id="vim">vim</span><a href="#vim" class="header-anchor">#</a></h3><p>保存退出：<code>shift zz</code><br>不保存退出：<code>shift zq</code>删除本行： <code>dd</code><br>复制本行：<code>yy</code><br>行标下粘贴：<code>p</code> 行标上粘贴：<code>P</code><br><code>u</code>   撤销上一步的操作,输入<code>u</code>两次，你的文本恢复原样<br><code>Ctrl+r</code> 恢复上一步被撤销的操作<br><code>ggVG</code> 全选 , 选中内容以后就可以<code>d</code>  删除选中内容 , <code>y</code>  复制选中内容到0号寄存器<br><code>gg</code> 让光标移到首行，在vim才有效，vi中无效<br><code>V</code>  是进入Visual(可视）模式<br><code>G</code>  光标移到最后一行<br><img src="/images/42.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://hejtao.netlify.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数学通识50讲</title>
    <link href="https://hejtao.netlify.com/2019/11/25/2019-11-25/"/>
    <id>https://hejtao.netlify.com/2019/11/25/2019-11-25/</id>
    <published>2019-11-24T16:00:00.000Z</published>
    <updated>2020-04-24T09:44:13.867Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><p><img src="/images/26.jpg" alt=""></p><div class="toc"><!-- toc --><ul><li><a href="#fa-kan-ci-shu-xue-gai-zen-me-xue">发刊词：数学该怎么学？</a></li></ul><ul><li><a href="#mo-kuai-yi-shu-xue-de-xian-suo">模块一 ｜ 数学的线索</a><ul><li><a href="#01-dao-lun-shu-xue-tong-shi-ke-de-ti-xi-he-xue-xi-gong-lue">01 ｜ 导论：数学通识课的体系和学习攻略</a></li><li><a href="#02-gou-gu-ding-li-wei-shi-me-zai-xi-fang-jiao-bi-da-ge-la-si-ding-li">02 ｜ 勾股定理：为什么在西方叫毕达哥拉斯定理</a></li><li><a href="#03-shu-xue-de-yu-jian-xing-ru-he-yong-tui-li-zou-chu-ren-zhi-mang-qu">03 ｜ 数学的预见性：如何用推理走出认知盲区</a></li><li><a href="#04-shu-xue-si-wei-shu-xue-jia-ru-he-cong-luo-ji-chu-fa-xiang-wen-ti">04 ｜ 数学思维：数学家如何从逻辑出发想问题</a></li><li><a href="#05-shu-xue-bian-jie-cong-bi-da-ge-la-si-ding-li-dao-fei-ma-da-ding-li">05 ｜ 数学边界：从毕达哥拉斯定理到费马大定理</a></li><li><a href="#06-huang-jin-fen-ge-bi-da-ge-la-si-ru-he-lian-jie-shu-xue-he-mei-xue">06 ｜ 黄金分割：毕达哥拉斯如何连接数学和美学</a></li><li><a href="#07-shu-xue-ying-yong-hua-luo-geng-hua-fan-wei-jian-de-shen-lai-zhi-bi">07 ｜ 数学应用：华罗庚化繁为简的神来之笔</a></li><li><a href="#08-shu-lie-he-ji-shu-yi-dang-xia-hen-chong-yao-dan-qu-shi-geng-chong-yao">08 ｜ 数列和级数（一）：当下很重要，但趋势更重要</a></li><li><a href="#09-shu-lie-he-ji-shu-er-chuan-xiao-pian-ju-de-shu-xue-yuan-li">09 ｜ 数列和级数（二）：传销骗局的数学原理</a></li><li><a href="#10-shu-lie-he-ji-shu-san-cang-zai-li-xi-he-yue-gong-li-de-mi-mi">10 ｜ 数列和级数（三）：藏在利息和月供里的秘密</a></li></ul></li><li><a href="#mo-kuai-er-shu-xue-de-gai-nian">模块二 ｜ 数学的概念</a><ul><li><a href="#11-ji-tu-tong-long-fang-cheng-zhe-ge-shu-xue-gong-ju-wei-shi-me-hen-qiang-da">11 ｜ 鸡兔同笼：方程这个数学工具为什么很强大</a></li><li><a href="#12-san-ci-fang-cheng-shu-xue-shi-shang-de-fa-ming-quan-zhi-zheng">12 ｜ 三次方程：数学史上的发明权之争</a></li><li><a href="#13-xu-shu-xu-gou-zhe-ge-gong-ju-you-shi-me-yong">13 ｜ 虚数：虚构这个工具有什么用</a></li><li><a href="#14-wu-qiong-wo-men-wei-shi-me-nan-yi-li-jie-wu-xian-de-shi-jie">14 ｜ 无穷：我们为什么难以理解无限的世界？</a></li><li><a href="#15-wu-qiong-xiao-yi-ru-he-shuo-fu-gang-jing-zhi-nuo">15 ｜ 无穷小（一）：如何说服杠精“芝诺”？</a></li><li><a href="#16-wu-qiong-xiao-er-niu-dun-he-bei-ke-lai-zai-zheng-shi-me">16 ｜ 无穷小（二）：牛顿和贝克莱在争什么？</a></li><li><a href="#17-wu-qiong-xiao-san-yong-dong-tai-he-ji-xian-de-yan-guang-kan-shi-jie">17 ｜ 无穷小（三）：用动态和极限的眼光看世界</a></li><li><a href="#18-you-shi-me-bi-wu-qiong-da-geng-da-bi-wu-qiong-xiao-geng-xiao">18 ｜ 有什么比无穷大更大，比无穷小更小</a></li><li><a href="#19-fu-pan-shu-xue-gei-liao-wo-shi-me-qi-shi">19 ｜ 复盘：数学给了我什么启示？</a></li></ul></li><li><a href="#mo-kuai-san-ji-he-xue-yi-qie-yuan-zi-gong-li-he-luo-ji">模块三 ｜ 几何学 一切源自公理和逻辑</a><ul><li><a href="#20-ji-he-xue-wei-shi-me-shi-shu-xue-zhong-zui-gu-lao-de-fen-zhi">20 ｜ 几何学：为什么是数学中最古老的分支</a></li><li><a href="#21-gong-li-ti-xi-ji-he-de-xi-tong-li-lun-cong-he-er-lai">21 ｜ 公理体系：几何的系统理论从何而来</a></li><li><a href="#22-fei-ou-ji-he-xiang-dui-lun-de-shu-xue-ji-chu-shi-shi-me">22 ｜ 非欧几何：相对论的数学基础是什么</a></li><li><a href="#23-jie-xi-ji-he-yong-dai-shu-fang-fa-jie-jue-geng-nan-de-ji-he-ti">23 ｜ 解析几何：用代数方法解决更难的几何题</a></li><li><a href="#24-wei-shi-me-ji-he-neng-wei-fa-lu-ti-gong-li-lun-ji-chu">24 ｜ 为什么几何能为法律提供理论基础？</a></li><li><a href="#wen-da-shu-xue-de-ji-xian-he-sheng-huo-de-ji-xian-shi-yi-hui-shi-ma">问答 ｜ 数学的“极限”和生活的“极限”是一回事吗？</a></li></ul></li><li><a href="#mo-kuai-si-dai-shu-xue-yong-shu-liang-miao-hui-shi-jie">模块四 ｜ 代数学 用数量描绘世界</a><ul><li><a href="#25-han-shu-shang-cong-jing-tai-dao-dong-tai-cong-ge-ti-dao-qu-shi">25 ｜ 函数（上）：从静态到动态，从个体到趋势</a></li><li><a href="#26-han-shu-xia-ru-he-tong-guo-gong-shi-li-jie-yin-guo-guan-xi">26 ｜ 函数（下）：如何通过公式理解因果关系</a></li><li><a href="#27-xiang-liang-dai-shu-shang-fang-xiang-bi-nu-li-geng-chong-yao-shi-ji-tang-ma">27 ｜ 向量代数（上）：“方向比努力更重要”是鸡汤吗？</a></li><li><a href="#28-xiang-liang-dai-shu-xia-ru-he-tong-guo-xiang-liang-jia-jiao-li-jie-wei-du">28 ｜ 向量代数（下）：如何通过向量夹角理解“维度”？</a></li><li><a href="#29-xian-xing-dai-shu-ju-zhen-dao-di-zen-me-yong">29 ｜ 线性代数：“矩阵”到底怎么用？</a></li></ul></li><li><a href="#mo-kuai-wu-wei-ji-fen">模块五 ｜ 微积分</a><ul><li><a href="#30-wei-ji-fen-shang-ru-he-cong-hong-guan-bian-hua-liao-jie-wei-guan-qu-shi">30 ｜ 微积分（上）：如何从宏观变化了解微观趋势</a></li></ul></li></ul><!-- tocstop --></div><h3><span id="fa-kan-ci-shu-xue-gai-zen-me-xue">发刊词：数学该怎么学？</span><a href="#fa-kan-ci-shu-xue-gai-zen-me-xue" class="header-anchor">#</a></h3><p><img src="/images/18.jpg" alt=""></p><p>  在上个世纪80年代，国内流行过一句口号：“学好数理化，走遍天下都不怕。”因为当时的教学体系还不完善，数理化这些基础学科比重大，而且容易培养出建设型人才，所以受到重视。当然，随着综合教育体系的完善，这个口号也就不再流行了。</p><details><summary>...</summary>&emsp;&emsp;但是，在今天来看，无论你的专业和工作是什么，你都会发现，数理化这些底层学科是不是牢固，真的决定了一个人的知识结构能搭多高，在专业上能走多远，尤其是数学。数学作为一切科学的基础，它化繁为简，直击本质的思考方式，让很多人获益。那些数学成绩好的人，做起事来总是一通百通，很容易脱颖而出。<p>  但是事实上，很多学习数学的人会感觉自卑，并产生厌恶。这是为什么呢？当然不是数学本身的问题，也不是我们人的问题，而是因为我们和数学之间缺失了一个桥梁。数学是一种抽象的知识体系，而我们人要靠经验感知才能认识世界，这中间需要一个桥梁，这个桥梁一旦构建起来，每一个人都能受益于数学。</p><p>  那么是否每一个人都有可能学好数学呢？公平地讲，数学往深了学确实很费脑力，对大多数人来讲有点难度，但是把平时用到的、能够提升我们思维的数学学好，是每个人都能做到的。接下来我就用一个例子谈谈怎么学数学。</p><p>  2017年，一位原央视的主持人请我和中国科技馆前馆长王渝生先生，做一个有关数学的节目。在节目开始前，主持人对我说，她高考时数学不及格，是个学渣。我说，你能有今天这样的成就，显然不是学渣。数学没学好，不是你的问题，是教学的方法和考量学生的方法不对。</p><p>  然后我就告诉她美国顶级的高中和大学是怎样教数学的。在美国最好的高中，把数学课由中国的一门课变为8～10门内容不同的课程，每门课还要开A、B、C三个难度不同的班。比如我们中国（从初中到高中）的几何，被分为平面几何A、B、C，解析几何A、B、C，等等各种难度的课程和班级。</p><p>  入门的那几门数学课足够浅显，难度较低的班会讲得更浅，内容更精简。比如平面几何的A，讲清楚几何学的原理和用途，以及推理的思维方式就好，就不让学生再做那些比较难的证明题了。像点、线、面、三角形、四边形和多边形等概念，以及平行、垂直等关系，其实对任何人都不难，都能取得好成绩。</p><p>  当然，由于你选择了简单的数学，也就没有浪费时间去攻克对自己来说很难的数学内容，就可以学更多自己喜欢的文学或历史，然后申请那些更适合自己的大学。更重要的是，虽然你所学的数学课不多，也不深，但好歹掌握了基本概念，掌握了相应的思维方式，<strong>如果将来真想再继续学，还是有可能的</strong>。否则你学了一大堆理解不了，考试通不过的内容，不仅浪费时间，而且本来能学会的简单内容也全丢掉了。</p><p>  不信我问你，还记得住计算圆球体积的公式，或者方程组的解法吗？那些都不是什么很难的内容，但是因为大家做不出数学题，考不出满意的分数，就从心里彻底放弃了这门课，以至于那些本应该记住的简单内容也干脆全忘光了。可以说，结果就是早早地就把通往数学的桥梁毁掉了，从此以后，再也没有体会过数学思维的乐趣，放弃了智识生活的可能。</p><p>  <strong>那么在我的数学课中，我会教什么？大家又应该怎么学？学完以后应该怎么用呢？</strong></p><p>  在教学方面，我会模仿美国的数学教学方式，为你做好三件事，也是我这门数学课的三个教学特色：</p><p>  <strong>首先，我会为你重建这座通往数学的桥梁，帮你把那些熟悉的知识点各安其位，放进知识体系里。</strong> 我的讲法是把一门数学课从完整的体系变成一个个的知识点，讲透之后，再还原回体系。让你能够熟练地把握知识点和课程体系的关系，这门课的体系也就搭建好了。</p><p>  以最难的几何学为例，再难的几何题，其实最终都可以拆成那五个最基本的公理。这五个公理，又可以推导出几何学的任何结论。就如同几种乐高积木可以搭出任何形状一样，我会在几何那个模块介绍给大家。</p><p>  至于这个体系能构建得多大，则要看学生能够接受的程度，学生接受的程度高，就搭一些复杂的，接受程度低，就搭一些简单的。但是能够拆解和搭建哪怕是比较小的体系，通识教育的目的就达到了。</p><p>  **其次，在介绍这些关键数学知识点的同时，我会讲清楚它们在数学上的位置，以及和各种知识体系的相关性。**这样不仅能够把各种知识打通，而且能够让你在自己的行业中超越绝大部分从业者。</p><p>  我的《数学之美》出版后，很多人读后感慨，原来数学对信息处理帮助这么大。但其实那本书中介绍的全部内容，不过是一些知识点。而仅仅是理解了那些知识点的计算机从业者，就已经获得更强的竞争力了。</p><p>  再比如，为什么大家熟知的勾股定理，在国际上通行的叫法是毕达哥拉斯定理？因为勾股定理只是经验，而毕达哥拉斯定理却完成了数学证明，但教科书出于发明权的考量并没有说明，结果就是把数学这门课的逻辑基础搞丢了。以至于很多人大学毕业工作多年依然搞不清物理上用实验证实的定律和数学上用逻辑证明的定理有什么差别。如果基础就打歪了，以后进入工作，很可能出大错。</p><p>  **最后一点，也是最重要的，是通过学习数学，实现思维方式的跃进。**为了做到这一点，并不需要讲述太难的数学知识，而是需要讲透。事实上，我们无论是讲透毕达哥拉斯定理，还是更难懂一些的欧拉公式，都可以在讲述的过程中将数学家超出凡人的思维方式讲清楚。毕竟对于大部分人来讲，一辈子用不到欧拉公式，如果他们不容易理解，用简单的例子把道理讲清楚就变得格外重要了。</p><p>  至此，我为你搭建的桥梁就算建造好了，当然，还是需要你亲自从这头走到那头去，我们接下来谈谈你怎么做，才能跟着我学好数学：</p><p>  一个学好数学最重要的办法是，不断训练自己的思维方式。</p><p>  很多人喜欢读侦探小说和悬念小说，喜欢解决各种谜题，这其实是人类的一种天性，也是对头脑的一种训练。学数学能够提高我们这方面的能力，让自己成为一个“深入的思考者”（Deep Thinker）。</p><p>  世界上有两种所谓的聪明人，一种是反应很快的人，被称为Quick Thinker，另一类则是Deep Thinker，也被称为Hard Thinker，无论是哪一种，其实都是可以后天训练的。训练快速反应最好的办法就是多听多看。但是训练Deep Thinker，就需要练习一环扣一环解套的本事了。</p><p>  用数学做这种训练的好处是，它经过上千年的发展，已经有一整套训练材料了。所以学数学，就像打游戏晋级一样，一点点往前探索，一个个击破难题。最后，请你查看课表（即目录），当然我还是想再从不同的维度上帮你提炼一下。</p><p>  首先，我们会学到虚数、极限、微分、积分等等这样的具体知识点，掌握它们之间的关联，以及它们在人类认知方面的地位。这样我们就能理解人类是如何扩展自己的认知的。如果我们把自己成长的过程和人类成长的过程做一个对标，就能通过它们扩展我们自己的认知。</p><p>  再往上一个维度，你还能了解数学在人类知识体系中的地位，比如数学和艺术的关系，和法律，和经济学的关系，等等。很多时候，数学不能直接解决我们的实际问题，但是它能够给我们提供一个思路。在更高的维度上，我会通过介绍数学的发展史，帮你理解数学思维，也就是人类的认识是如何从直观到抽象，从静态到动态，从宏观到微观和宇观，从随意到确定，再到随机，等等。</p><p>  好，如果你想重新认识一下数学，和我一起感受一次数学之美，那么欢迎你加入我的《数学通识50讲》。当然，除了数学通识，我还将开设一系列的通识课程，把每个人都需要掌握的人类知识精华，整理成课程，帮每个现代人装备自己的头脑，找到最适合这个世界的思维方式。</p><p>  好，我们马上开始数学之旅！</p></details><h2><span id="mo-kuai-yi-shu-xue-de-xian-suo">模块一 ｜ 数学的线索</span><a href="#mo-kuai-yi-shu-xue-de-xian-suo" class="header-anchor">#</a></h2><h3><span id="01-dao-lun-shu-xue-tong-shi-ke-de-ti-xi-he-xue-xi-gong-lue">01 ｜ 导论：数学通识课的体系和学习攻略</span><a href="#01-dao-lun-shu-xue-tong-shi-ke-de-ti-xi-he-xue-xi-gong-lue" class="header-anchor">#</a></h3><p><img src="/images/17.jpg" alt=""></p><p>  这一讲算是数学通识课的学习地图，我会带你俯瞰一下这门课的全貌，便于你系统地把握课程内容。</p><details><summary>...</summary>&emsp;&emsp;如果把人类的知识体系用学科来划分的话，数学可能是其最大的一个，因此要想在50讲左右的时间里介绍它的全貌是不可能的。<p>  所幸的是，作为通识教育，你不需要学那么多，而且数学的各个分支，无论难易，从体系到研究方法，再到应用方法是共通的。</p><p>  成年人接受数学通识教育，其实只要做到一点就够了，就是从理解初等数学到理解高等数学——（也就是）把自己对所有和数学相关的概念和方法的理解程度，从静态的、具体的，上升到动态的、规律性的。要达到这个目的，不需要讲很多内容，但需要一些线索。</p><p>  下面我就简单介绍一下课程的内容和我选择它们来串联课程的理由。</p><p>  <strong>第一模块讲的是数学究竟是怎么从一个猜想，得出推论，然后又产生实际应用的。</strong></p><p>  根据《时间简史》和《大设计》的共同作者蒙洛迪诺的讲法，人类早期的所有知识体系都是：“前科学”。这是好听的说法，难听的说法叫做“巫术式”的。</p><p>  在所有早期文明中，唯一的例外是古希腊。但即使是在古希腊，我们所知的那些大学问家们比如泰勒斯、赫拉克利特、亚里士多德，他们的思维依然是前科学的，不是科学的，因为他们对客观世界的解释，加入了太多主观的想象。而在古希腊，真正具有划时代意义的人则是毕达哥拉斯。</p><p>  毕达哥拉斯是将数学从经验上升到系统性学科的第一人。他确立了数学的起点，也就是必须遵循严格的逻辑证明才能得到结论的研究方法，这就让数学从早期那些需要靠测量和观测的学科，比如天文学、地理学和物理学中，脱身出来，成为所有基础学科之上，带有方法论性质的特殊学科。</p><p>  因此，我们会先从毕达哥拉斯学起，他也是整个第一模块的主线。那么我会怎么讲这个模块呢？</p><p>  首先，我会讲毕达哥拉斯最出名的毕达哥拉斯定理，也就是我们所说的勾股定理。</p><p>  我们还知道，毕达哥拉斯最被后人所诟病的地方是否认无理数的存在，并假装视而不见，还把提出这个问题的学生害死了。</p><p>  对此，今天很多人说他无知，顽固，拒绝接受真理等等。但是要知道，在当时人们所知的有限的数学领域中，毕达哥拉斯是这个体系的教主，他需要这个建立在逻辑之上的体系的一致性和完备性，而逻辑上的一致性也是数学最基础的原则。</p><p>  因此，他发现无理数的出现会破坏他所理解的数学体系的完备性，动摇数学大厦时，他就采取了教主们才会采用的激进行为。</p><p>  毕达哥拉斯真正的错误在于，他不懂得要维系数学这个体系，需要定义“无理数”这样的新概念。无理数造成的数学危机解决之后，数学反而发展了，并没有像毕达哥拉斯想的那样崩溃。</p><p>  毕达哥拉斯另一个了不起的成就，就是算出了黄金分割的比例。从黄金分割出发，毕达哥拉斯发现了数学和美学的关系，并且开始用数学指导音乐。</p><p>  概括来讲，我们在第一模块“数学的线索”里面，以毕达哥拉斯为线索，一方面将很多数学知识点串联起来，向大家展示数学是什么样的体系，另一方面，我们把毕达哥拉斯作为例子，说明数学发展和体系构建常常经历的步骤。也就是，<strong>从特例到引理再到定理、推论，最后到应用的全过程。</strong></p><p>  但是数学的发展又非单一线索，从一个点出发可能产生了很多并列的推论，因此我们不得不在课程中把并行的内容按顺序来讲。比如在第一模块中，我们在讲完黄金分割的应用后，又会回来讲和它有关的等比数列。</p><p>  当你知道数学定理是如何从猜想到推论再到应用的过程，我们就进入课程的<strong>第二个模块“数的概念”，通过讲述人类对数字这个概念的认识历程，我会给你一个思维工具——“从具体到抽象”</strong>，从而解释为什么你从小学数字，但其实对数字的认识并没有提高，以及学数学多年都不能为己所用的原因。</p><p>  照理讲，我们的认知水平应该随着所学内容难度的提升而提升，但是通常不是如此。很多人学到大学关于数字的概念时，对数字的理解方式，还停留在小学阶段。</p><p>  比如，对于无穷大和无穷小这样的概念，很多人依然以为它们只是巨大的数字和极小的数字。事实上它们和我们日常遇到的具体数字不同，代表着变化的趋势和变化的快慢。因此从小学到了大学，大家对数字的理解就应该从静态到动态，但遗憾的是，很多人并没有这样的认识。</p><p>  当一个人用小学的思维方式，学习大学的数学内容，一定会觉得难以理解，于是对数学敬而远之。这并不能怪学习的人，而是怪很多数学课在设计时，没有把听众当作未来的主人，而只是把他们当作未来的工匠，教给他们一些具体知识让他们干活，而非更高级的思维认知。</p><p>  因此，在第二模块中，我们会突出数学作为“抽象思维”工具的作用，比如人们从具体算术到抽象代数，用到解方程、虚数等等，为什么要学习它们？因为它们的角色是人类造出来的抽象工具，在现实生活中并不存在，但是有了它们，现实的问题就好解决了。数学通识教育，一个重要目的就是让大家习惯于使用这样的抽象工具。</p><p>  **第三、第四模块的内容集中在我们熟知的几何和代数。**在几何的模块中，我们会以它为例子介绍什么是公理化的知识体系，它是如何建立的。</p><p>  在代数的模块中，我们会重点介绍函数和向量。函数这个概念的发明，把我们人类的认知从个体上升为整体，从单点联系，上升为规律性的网状联系。</p><p>  比如同一道题目，从小学到大学，理解是不同的，这是一个从单纯理解数字大小，到理解它方向性的过程。在小学，如果我们看到一道题，说张三以50公斤的力拉箱子，李四以30公斤的力拉，拉箱子的力是多少？答案很简单，就是80公斤。但是到了初中，我们有了负数的概念，你就要问他们拉箱子的力是相同的还是相反的，如果是相反的，只有20公斤。</p><p>  再往上学，我们就要问他们拉箱子的力夹角是多少度，在90度时和120度时，受力可是不同的，这就进入到了大学思维。</p><p>  向量和线性代数，就是把数字从单纯的数值，变成了有方向的数值。所以，我认为这两大知识点，最能代表代数模块的内涵，可以帮助大家提升认知。</p><p>  **第五模块是微积分，这已经是高等数学的内容了。**但是，我们其实在第二模块里已经不知不觉地把微积分中最难的内容提前讲了，因此在这个模块，大家反而会觉得简单。</p><p>  对于微积分，它和初等数学的工具有什么不同呢？人们开始对把数学从关注静态的关系，变成了对动态规律，特别是瞬间规律的把握上。理解这一点，并且主动应用到工作中，是我们学习微积分的目的。那些很难的概念，解题技巧，其实毫不重要。</p><p>  好，前面你学习了数学公理、数字、几何、代数和微积分，提纲挈领地回顾了数学发展的历史，这些分支有个特点，就是能给出问题唯一的答案。</p><p>  但是到了近代，很多现实问题很难有完全确定的答案。于是，**为了研究不确定世界的规律性，概率和统计发展起来了。**数学的这个分支在今天我们充满不确定性的世界里非常重要，也是所谓的大数据思维的科学基础。</p><p>  纵观数学发展的历程，以及我们应该具有的数学思维历程，我们可以看到这样的趋势，从个案到整体规律，从个别定理到完整的知识体系，从具体到抽象，从完全的确定性，到把握不确定性。</p><p>  无论是在整个的课程中，还是每一个模块之内，我们都能看到这样人类认知升级的过程。当然，我觉得这也应该是我们自己的认知升级过程。</p><p>  在课程的最后，我们会介绍数学和其它学科的关系。这样能够在完整的知识体系中，更好地理解数学。接下来，我们就先从毕达哥拉斯讲起，从数学的起点开始我们的数学之旅。</p></details><h3><span id="02-gou-gu-ding-li-wei-shi-me-zai-xi-fang-jiao-bi-da-ge-la-si-ding-li">02 ｜ 勾股定理：为什么在西方叫毕达哥拉斯定理</span><a href="#02-gou-gu-ding-li-wei-shi-me-zai-xi-fang-jiao-bi-da-ge-la-si-ding-li" class="header-anchor">#</a></h3><p><img src="/images/20.jpg" alt=""></p><p>  我们的第一个模块，会为大家介绍数学的线索，也就是它从猜想到定理再到应用的整个过程。我会以毕达哥拉斯定理为例来展开。</p><details><summary>...</summary>&emsp;&emsp;勾股定理大家都不陌生，它讲的是直角三角形两条直角边的平方之和等于斜边的平方。<p>  但是，这个定理在国外都被称为毕达哥拉斯定理。毕达哥拉斯（Pythagoras，约公元前580年—约公元前500年）是古希腊著名的数学家和知识的集大成者。</p><p>  相关阅读：《科技史纲60讲》15｜为什么其他文明没有诞生古希腊的科学？</p><p>  接下来有两个疑点，你的中学老师可能在刻意回避或者说没有讲清楚，而它们又实在太重要了。</p><p>  <strong>第一个疑点：这个定理是否在毕达哥拉斯之前就被发现了？</strong></p><p>  我们过去的教科书里讲，据汉朝的数学书《周髀算经》的记载，早在公元前1000年的时候，周公和商高这两个人就谈到了“勾三股四弦五”。他们的年代比毕达哥拉斯早，因此教科书中讲是中国人商高最早提出这个定理的，于是称之为勾股定理或者商高定理。</p><p>  我们先不说《周髀算经》里所记载是否靠谱，就算靠谱，它也只是记载了一组勾股数（即直角三角形直角边和斜边都是整数的情况），并不能说明发现了其中的规律。因为比周公和商高早1500年，古埃及人在建造大金字塔时就已经按照勾股数在设计墓室的尺寸了。</p><p>  如果再往前推，美索不达米亚人早在公元前18世纪左右就知道很多组的勾股数（包括勾三股四弦五），而且留下了实物证据。比如耶鲁大学的博物馆里就保存了一块记满勾股数的泥板。</p><p><img src="/images/21.jpg" alt=""></p><p>  <strong>接下来就产生了第二个疑点，古埃及和美索不达米亚为什么不去争夺这个定理的发现权呢？</strong></p><p>  简单地讲，所有这些古代文明不过是举出了一些特例而已，甚至没有提出假说。我们在后面的课程中会看到，很多时候特例中反映出的规律和后来真正的定理可能是不同的。所以，这种特例就没有意义。</p><p>  如果像美索不达米亚人那样举了很多特例，而且没有发现例外，是否可以认为他们最先发现这个定理呢？答案是否定的，因为光举例子还是不够的，还需要做出一个明确的规律性的描述，这种描述我们可以把它称为命题。一个命题在没有证明之前，只能算是猜想，比如著名的哥德巴赫猜想。而总结出一个猜想和证明定理依然是两回事，当然这是比举几个例子进了一大步了。</p><p>  再接下来，猜想如何证实呢？在这一点上数学和自然科学完全不同。那么我们就要说到数学和自然科学的三个本质差别，也是这一讲最重要的三个知识点，它们能够帮助我们理解数学特殊的方法和思维方式，或者说了解数学的推理世界与我们真实的测量世界的区别。</p><p>  <strong>1.测量和逻辑推理的区别</strong></p><p>  我们知道几何学源于古埃及，当地人出于农业生产的考虑，对天文和土地进行度量，发明了几何学。但是，度量出来的几何其实和真正的数学还有很大的差距。</p><p>  比如说，古代文明的人们确实观察到勾股数的现象，他们画一个直角三角形，勾三尺长、股四尺长时，弦长恰好就是五尺长，于是就有了勾三股四弦五的说法。</p><p>  但是这里面存在一个大问题，我们说长度是三尺，其实并非数学上准确的长度，用尺子量出来的3，可能是3.01，也可能是2.99。这样一来勾三股四弦五就是一个比较模糊的说法了。为了让你更好地理解这一点，我们不妨看这样一个例子。</p><p><img src="/images/22.jpg" alt=""></p><p>  图中左上方有一个8x8的方格，它的面积是64，这没有疑问吧？我按照图中所示的粗线将它剪成四部分，两黄两灰，再重新组合，就得到了一个13x5的长方形，它的面积是65。请问面积是64的正方形怎么重新组合一下面积就多出1，变成65了呢？</p><p>  当然我们知道64不等于65，这里面一定有问题。那么问题在哪儿呢？其实，问题就出在再拼接时，它们并不是严丝合缝的，只不过缝隙较小，大部分人看不出来罢了。</p><p>  在数学上，观察的经验可以给我们启发，但是它不能成为我们得到数学结论的依据，数学上的结论只能从定义和公理出发，使用逻辑严格证明得到，不能通过经验总结出来。讲回到勾股定理，一个工匠注意到勾三股四弦五这个现象，和提出一个具有普遍意义的定理是两回事。</p><p>  我们通过观察还可以发现，如果勾3.5，股4.5，那么弦大约是5.7，这个“大约”的误差只有万分之一点六左右（弦长大约是5.700887），古代任何测量都发现不了。这时如果你说勾3.5股4.5弦5.7，从物理上来说基本正确，但是在数学上就错了。这是第一个差别，就是测量会出错，但推理不会。</p><p>  那么，如果我们抛开误差的影响，是否可以认为早期文明的人们发现了勾股定理呢？也不能，只能说他们观察到一些现象，而非发现了定理。这涉及到数学和自然科学的第二个主要区别，证实和证明的区别了。</p><p>  <strong>2.用事实证实和用逻辑证明的区别</strong></p><p>  在自然科学中，一个假说通过实验证实，就变成了定律。比如说与牛顿同时代英国的大科学家波义耳同法国科学家马略特一同发现：一个封闭容器中气体的压强和体积成反比。这很好理解，因为体积压得越小，内部的压强肯定越大。这两个人通过很多实验，都证实了这件事，于是这个定律就由他们两个人的名字命名了。</p><p>  但是，如果有一个非常爱较真的人一定要抬杠，说你们证实了所有的情况（各种体积和压强的组合）吗，你们敢保证没有例外么？波义耳和马略特肯定会说，我们不敢保证没有例外，但是这个规律你平时使用肯定没有问题。果然，后来人们真的发现当压强特别大时，这个定律就不管用了。但是没有关系，在大多数条件下，这个定理依然成立，今天人们在做产品时，依然可以用。</p><p>  事实上，今天几乎所有的自然科学的定律和理论，不仅存在一个被推翻的可能性，而且有很多的例外。比如，证实引力波的实验，也只能保证99.9999%的可能性结论是对的。</p><p>  但是，在数学上，用实验来验证一个假说（在数学上常常被称为猜想）是不被允许的，我们在后面介绍无穷大时，大家还会看到这甚至是做不到的。数学的结论只能从逻辑出发，通过归纳或者演绎得出来。它必须完全正确，没有例外，因为但凡有一个例外（也被称为反例），就要被完全否定掉。这里面最著名的例子就是哥德巴赫猜想。</p><p>  今天人们利用计算机，在可以验证的范围内，都验证了这个猜想是对的，但是因为没有穷尽所有的可能，就不能说猜想被证明了。因此，我们依然不能在这个基础上，构建其它的数学定理。所以，数学世界和测量世界第二个区别就是，数学理论必须要证明，保证没有例外。</p><p>  <strong>3.科学结论相对性和数学结论绝对性的区别</strong></p><p>  为什么数学要那么严格，它的定理为什么不能有任何例外，更不能特殊情况特殊处理呢？因为数学上的每一个定理都是一块基石，后人需要在此基础上往前走，试图建立一块新的基石，然后数学的大厦就一点点建成了。在这个过程中不能有丝毫的缺陷，一旦有，整个数学大厦就轰然倒塌了。</p><p>  还是以勾股定理为例，它的确立，其实教会了人们在平面计算距离的方法，在此基础之上，三角学才得以建立，笛卡尔的解析几何才得以确立，再往上才能建立起微积分等数学工具。此外我们这个模块后面会讲到的无理数的出现、黄金分割，都和它有关。</p><p>  人类今天发明的各种科技，像无线通信、航天等等，依赖于这些定理。如果出现了一个违反毕达哥拉斯定理的反例，不仅是这个定理失效了，而且整个数学就完蛋了，我们的科技也就时灵时不灵了。因此，数学上的每一个定理，必须也只能通过逻辑推演来证明，用多少实例来验证都没有用。</p><p>  理解了数学定理确立的过程，以及它随后产生的巨大影响，我们就清楚定理和定理证明在数学中的重要性了。正是因为这个原因，西方才将这个定理命名为毕达哥拉斯定理，以彰显他的贡献。是他明确提出这个定理，并且严格地证明了它，从此毕达哥拉斯定理才成为了数学上普遍的规律。</p><p>  有了一个个的定理，数学就得以建立起来，而且这个建立在逻辑推理基础上的大厦很坚固。在数学上，当一个新的定理被证明后，就会产生很多自然的推论，每一个推论可能都是一个重大的发现，甚至能带来人类认识的升级。毕达哥拉斯定理的一个直接推论，就是无理数的存在。这个内容我们下一讲再讲。</p><p><strong>要点总结：</strong></p><p>  数学和自然科学不同，它不相信测量，不是建立在实证基础之上，而是建立在逻辑基础之上的。数学也不接受大部分情况正确，但是包含例外的定理。这样整个数学大厦的基础才得以稳固。</p><p>  数学定理确立的过程大致是这样的，一开始可能只是大家注意到几个特例，然后发现很多例证提出猜想，猜想经过证明就成为了定理，定理会有推论，在此基础上，会有新的定理和应用。</p><p><strong>思考题：</strong></p><p>  在物理学中，从不同的角度理解光，会得到粒子说和波动说两种解释，数学从两个角度证明一个定理，会不会得到不同的结论？</p></details><h3><span id="03-shu-xue-de-yu-jian-xing-ru-he-yong-tui-li-zou-chu-ren-zhi-mang-qu">03 ｜ 数学的预见性：如何用推理走出认知盲区</span><a href="#03-shu-xue-de-yu-jian-xing-ru-he-yong-tui-li-zou-chu-ren-zhi-mang-qu" class="header-anchor">#</a></h3><p><img src="/images/19.jpg" alt=""></p><p>  上一讲，我们通过毕达哥拉斯定理解释了数学的起点，它必须是从逻辑推理和证明得来的，而非测量和实验出来的。我们这一讲就看看以毕达哥拉斯定理为起点出发，人们又发现了什么。</p><details><summary>...</summary>&emsp;&emsp;在古希腊毕达哥拉斯（Pythagoras，约公元前580年—约公元前500年）所处的时代，人们认识到的数学上的数字都是有理数，它们都有我们平时所说的分数，具有A/B这样的形式，比如2/3，其中A和B都是整数，当然，整数本身可以被看成分母等于1的分数，比如5=5/1。<p>  毕达哥拉斯有一个很怪的想法，他坚信世界的本源是数字，而数字必须是完美的。整数很完美，而且分数的分子分母也都是整数，不会是零碎的，因此也很完美，整数和分数所构成的有理数让毕达哥拉斯一直坚信自己的想法。</p><p>  但是，一旦毕达哥拉斯定理被他证明以后，麻烦就来了。</p><p>  我们上一讲讲过，数学的定理具有永真的特点，它一旦被证明，你就找不到反例。当人们在用毕达哥拉斯定理时，就发现了问题。假设某一个直角三角形的两条直角边长都是1，那么斜边该是多少呢？</p><p>  你可以根据毕达哥拉斯定理算一下，既然两条直角边都是1，它们各自的平方也是1，加起来是2，因此斜边的平方是2，这个斜边就是一个自己乘以自己等于2的数字，从大小来看，它应该在1和2之间。接下来请问，这个自己乘以自己等于2的数字是否是“完美”的有理数？</p><p>  根据毕达哥拉斯对所有的数字都是有理数的认识，它必须是啊！好，我们就假定存在一个数字是R，它能够写成R=A/B的形式，其中A、B都是互素的整数（互素指的是两个数写成分数的形式，不可再约分），那么现在假设这个数字R的平方恰好等于2。注意一下，这里面有三个条件，请一定牢记：</p><p>  A、B都是整数。</p><p>  A、B互素，也就是不能再约分了。</p><p>  A/B的平方等于2。</p><p>这三个条件能否同时满足呢？答案是不能。为了说明这一点，大家不妨跟着我做一个简单的逻辑训练。</p><p>  好，这次我们用的方法，在数学上被称为反证法，就是先假定你说的条件都满足，然后我来找出矛盾之处，这样就能推翻原来的假设。</p><p>  具体到上面这个问题，我们从上面第三个条件出发，就得知分子A的平方除以分母B的平方等于2：</p><p>    $ A^{2} / B^{2} = 2 $</p><p>  我们把B的平方移到等式的右边2那边，就是：</p><p>    $ A^{2} = 2 \times B^{2} $</p><p>  接下来我来问你，A是奇数还是偶数？你会说它当然是偶数，因为等式的右边是2乘以B的平方，都乘以2了，那A的平方结果肯定是偶数，奇数的平方不可能是偶数，所以A必须是偶数啊。既然A是偶数，我可以把A写成2乘以一个数，比如C，也就是A=2C这种形式，其中C是一个整数。</p><p>  那么A的平方等于什么呢，等于4倍的C的平方，我就用这个4倍的C的平方代替A的平方，放在原来等式的左边，右边还是2乘以B的平方：</p><p>    $ 4 \times C^{2} = 2 \times B^{2} $</p><p>  这个等式的两边都可以用2去同时除一下，于是就成了两倍的C的平方等于B的平方：</p><p>    $ 2 \times C^{2} = B^{2} $</p><p>  这时我问你，B是偶数还是奇数？你会说当然是偶数，因为两倍的C的平方是偶数啊。</p><p>  这下子问题来了，怎么A和B都是偶数呢，这不就和上面的第二个条件，也就是“A、B互素，不能再约分”矛盾了吗？</p><p>  那么到底哪里发生了错误呢？我们先要检查一下我们的推导过程，我们发现没有错误。因此，要么是数学错了，要么是认知错了。勾股定理的证明是通过严格的逻辑推导出来的，也不会有错，于是只能是我们的认知错了。</p><p>  也就是说，存在一种数字，我们过去没有认识到，它们无法写成有理数的形式，即A/B，它们是无限的不循环小数，在这样的数中有一个自己乘以自己时等于2。我们今天把这个数字称为√2。这一类的数字其实很多，它们被统称为无理数。</p><p>  据说毕达哥拉斯的学生希帕索斯最初发现了上述矛盾，于是就去和他的老师讲了。而毕达哥拉斯是个把数学看成宗教的人，出现无限的不循环小数在毕达哥拉斯看来是数学的漏洞，但他又无法把这件事解释圆满，这就是数学史上的第一次危机。</p><p>  毕达哥拉斯决定把这位学生扔到海里杀死，好把这件事隐瞒下来。</p><p>  当然，像√2这样的“无理数”存在的事实，却不可能一扔了之，无理数是客观存在的，毕达哥拉斯是隐瞒不住的，这件事成为了这位确立了数学在人类知识体系中地位的大学问家的一个污点。另一方面，无理数的危机也带来了数学思想一次大的飞跃，它告诉人们，人类在对数字的认识上还具有局限性，需要有新的思想和理论来解释，认识本身不能有禁区，那些事先为科学设定的条条框框，最终都不得不被抛弃掉。</p><p>  从这个例子中，我们能学到什么呢？</p><p>  首先，在遇到数学和现实的矛盾时，我们需要仔细检查推理的过程是否有疏漏，这种情况占大多数。</p><p>  在排除了推导的错误后，接下来，两种情况必居其一：</p><p>  要么，我们的眼睛和我们的认知欺骗了我们，就如同我们以为所有的数都是有理数，但其实不是。这是常有的事情。</p><p>  要么，最初的假设错了或者说不够好。这种事情在历史上偶尔发生过，但是很少，我们后面在介绍非欧几何时会仔细讲到这种情况。这种情况我们通常不需要考虑。</p><p>  既然在推导没有错误时，通常是我们的观察或者认知欺骗了我们，那么我们就应该把危机看成是转机。人类在科技历史上，很多重大的发明发现恰恰来自于上述的矛盾。在数学史上，除了无理数被发现之外，几个重大的事件，比如无穷小概念的提出，对无穷大的重新认识，以及公理化集合论的确立，都和那些矛盾有关。这些矛盾有时看似造成了数学危机，但是，人们化解了危机之后，就拓展了认知，建立起新的理论。它们或者让数学本身进步了，或者在科学上做出重大的预言。</p><p>  几年前约翰·霍普金斯大学的天体物理学家亚当·里斯（Adam Riess）教授给我讲的一堂课，我至今记忆犹深，他让我坚信了对数学本身的信心。里斯等人通过计算，发现宇宙的质量是负数，这怎么可能？难道是数学错了，还是我们对宇宙的理解完全错了？</p><p>  里斯在做了仔细的检查后首先排除了推理有误的可能性，然后他们不得不承认数学的结论是对的，出错的是我们眼睛（包括观测的仪器）。于是，他们认定宇宙中一定存在我们看不见，更不了解的东西，那些就是所谓的暗能量，亚当·里斯等人后来因此获得了诺贝尔奖。</p><p>  在自然科学上，很多重大的发现，最初都不是直接和间接观测到的，而是根据数学推导出来的，比如说黑洞、引力波便是如此。在历史上，血液循环论、现代原子论最初都是建立在数学推导上的假说，然后才逐渐被实验验证了。</p><p>  世界上有很多我们不能依靠直觉和生活经验理解的事物，但是我们可以从数学出发，经过一步步推导得到正确的结论，我们甚至不需要亲力亲为地做一遍就知道我们的结论一定是正确的。这就如同你不需要会踢足球，才能评论足球一样，你只需要把握住一些准则就可以了，而数学就是这样的准则。</p><p><strong>要点总结：</strong></p><p>  从数学的定理出发，可以推导出很多针对现实世界的推论，从而改变我们对现实世界的看法，这就是数学的预见性。比如，毕达哥拉斯定理的一个直接结果指出了无理数的存在，它把人类对于数字的认识范围从有理数扩展到了无理数。</p><p>  当然，可能有读者朋友会想，那些预见性可能和我们相去甚远，其实不然，后面我们会举一些和大家相关的例子，比如如何识破庞氏骗局，为什么不能做空股票，等等。</p><blockquote><p>康德讲：“世界上只有两样东西是值得我们深深景仰的，一个是我们头上的灿烂星空，另一个是我们内心的崇高道德法则。”他所说的星空，其实包括数学这样的知识体系。对于很多云山雾罩的事情，我们只需要在逻辑上推演一遍，就能把问题的真相搞清楚了。</p></blockquote><p><strong>思考题：</strong></p><p>  我们都知道，整体要大于部分，因此10厘米长的线段上的点应该比5厘米长的多，但是如果我能用严格的逻辑证明它们上面的点一样多，你相信么？</p><p>  欢迎给我留言，并把文章分享出去，让更多的人感受到数学之美。我们下一讲再见。</p></details><h3><span id="04-shu-xue-si-wei-shu-xue-jia-ru-he-cong-luo-ji-chu-fa-xiang-wen-ti">04 ｜ 数学思维：数学家如何从逻辑出发想问题</span><a href="#04-shu-xue-si-wei-shu-xue-jia-ru-he-cong-luo-ji-chu-fa-xiang-wen-ti" class="header-anchor">#</a></h3><p><img src="/images/23.jpg" alt=""></p><p>  这一讲就来举一个发生在我们身边的例子，说明如何利用数学原理思考问题，并且久而久之在遇事时本能地用一个数学的头脑辅助判断。</p><details><summary>...</summary>&emsp;&emsp;当然，数学思维高深精妙，但是万法归一，最重要的那个原则就是，从逻辑出发想问题，这样就可以发现很多日常中被忽略的问题，从而找出真正答案。<p>  我们先从最近的一次金融危机讲起。在金融危机之后，英国女王问全世界的经济学家们，你们这么多人怎么没有一个预测到金融危机？这让学者们都很没面子。</p><p>  经济学家们当时确实是过于乐观了，所以很多暂时不会出问题的隐患被隐瞒了下来，因此大家会觉得没问题。不过当时有一些其实并不懂经济学的人，利用特殊的方法，嗅出了问题。</p><p>  比如巴菲特从直觉出发，觉得那些金融衍生品刻意包装，一定是为了掩盖很多真相，坚决不参与那场赌博。像这样的投资人并不少，其中最著名的是一个叫贝尔（Michael Burry）的医生，他数学很好，而且雇了一些数学家替他做事，靠坚守数学上的一些基本道理，成为那场豪赌中获利最丰厚的赢家。</p><p>  贝尔他们的逻辑其实很简单，就是我们常常说“复利”增长从数学上讲是无法长期为继的。比如说，财富每年增长7%，这个速度在很多人看来并不算快，但是如果两千多年前的陶朱公以及他的后人能维持这个财富增长速度，哪怕当年他只留下一个铜板，今天他的传人所拥有的铜钱的数量要超过宇宙中的原子的数量，这在现实中当然不可能。</p><p>  做投资的人都清楚，在一开始投资基数较小的时候，能够维持指数增长，一旦基数变大，就做不到了，还不切实际地想维持，就是拆东墙补西墙的庞氏骗局了。</p><p>  很多人觉得自己足够聪明不会上庞氏骗局的当。但是变相的庞氏骗局要识破就没那么容易了。2008年金融危机中的罪魁祸首CDS，就是奸商们包装的一个不容易看懂的庞氏骗局，接下来我们就来说说它。我们知道2008年金融危机的原因是美国房屋的次级贷款出了大问题，那它和CDS有什么关系呢？别着急，我们从次级贷款说起，然后你就明白什么是CDS了。</p><p>  让我们先回到克林顿当总统的时代。那时，克林顿政府为了让本来付不起首付的穷人也能买房子，允许银行提供购房首付的贷款。比如100万的房子，通常需要贷款80万，首付20万，但是假如有一个人叫林肯，他没钱支付首付，当时除了允许他把房子先抵押了，从A银行获得正常的80万贷款，还允许他以较高的利息从B银行获得首付20万的贷款。</p><p>  如果房价一直上涨，这没有问题，因为即使林肯付不起月供了，A银行也可以通过变卖房子收回自己的80万贷款，剩余的钱，还够B银行也能拿回自己的20万。B银行提供的就是次级贷款，由于它的风险显然比A银行大，因此利率也高，这样如果有个别几个人的贷款拿不回，它也能从其他购房者偿还的利息中填补漏洞。</p><p>  当然，B银行还有一个更稳妥的做法，就是从高利息（比如每年10%）中拿出一部分（比如1%），向C保险公司购买贷款者违约的保险。</p><p>  保险公司C根据历史数据发现房屋贷款收不回来的情况很少，只占房贷的2%左右，而它从B银行可以连续挣15年的钱（不考虑复利的因素），15年下来，担保10亿的房产就能收入1.5亿，成本只有2000万，这利润率高达650%的事情保险公司自然就答应了。</p><p>  接下来，投资银行D看到C公司做了这样一笔好买卖，非常眼红，就和C商量将这10亿美元的保险生意卖给自己，并愿意留给C公司20%的好处，即3000万美元。C公司想，1.5亿虽然多，但是要承担15年的保险义务，不如一次性得到3000万实在，就答应了。</p><p>  D公司是投资银行，更精明，将C公司为B银行作担保的业务，包装成证券，叫做CDS（信用违约交换），加价3000万美元卖给了另一家投资银行E。E公司可能将各种类似的CDS又打了一个包，以新的证券形式在市场上市了。</p><p>  就这样，在经过无数次包装后，CDS的内部结构大部分人已经看不懂了，但是人们总觉得自己可以从下家身上赚到钱。于是一同把CDS炒到了50万亿美元这么大的规模，这甚至超过当时美国房市本身的总值。</p><p>  这个骗局的本质是什么呢？就是大家炒来炒去，都是在赌一件事，就是今后15~30年，房价会一直快速上涨。</p><p>  然而，房价不可能永远快速上涨，特别是在经济本身没有上涨的前提下。一旦有大量房主还不上钱，或者不愿意还钱，这些CDS就变得一钱不值。更糟糕的是，给购房者提供次级贷款的银行，后面的保险公司以及很多购买了CDS的投资银行也都完蛋了，整个金融体制就垮了。</p><p>  这件事可以通过数学算出来，其实不只是刚才提到的贝尔，当时有不少人在CDS的骗局破灭之前，发现了问题，后来挣到了大笔的钱。只不过贝尔挣钱的比例太高，他的故事后来被拍成了电影《大空头》，他从此成为了名人。</p><p>  接下来我们就说说什么叫做具有数学的思维。它不是指算小账算得清楚，而是说善于基于数学知识，使用逻辑发现问题，或者预见到不得不做的事情。我们在生活中，有时不得不面对非常复杂的问题，里面有很多噪音难以一一滤出，这时就需要掌握一种工具让我们能够不受噪音影响作出正确的判断。而数学常常是我们可以信赖的工具。</p><p>  下面我和你分享一个我的经历。有一次在一个由政府组织的关于“一带一路”的座谈会上，几位领导问我，“吴教授，咱们关起门来讲，中国输出了那么多资本，最后钱能回来么？”</p><p>  我说，挣得回来，挣不回来，我不知道，因为这里面牵扯太多的因素。但是资本输出和帮助其它国家富裕这两件事都必须做，我可以从数学证明这两件事的必要性。他们很好奇这件事和数学有什么关系，于是我继续讲：</p><p>  中国在过去的四十年里，实现了每年8%的指数增长，除了中国人勤劳勇敢。另外有两个数学上的原因，一是因为最初的基数小，能够持续高速增长。二是过去国内市场空白一片，供不应求，国际上其它国家人均财富，比中国高很多，相比中国过去的生产能力，购买力近乎无限。</p><p>  但是40年后的今天，中国人均GDP已经达到了世界的平均水平，总的经济体量已经世界第二，占全世界的18%。那么中国还能不能维持过去的增长速度呢？从数学上讲，根本做不到。</p><p>  我们就假定中国经济能够按照每年6%的速度增长，这个速度虽然比过去慢了一点，但是比全世界3%的平均水平快很多。再过40年，中国GDP大约能增长10倍。而全世界经济增长的速度只有3%左右，再扣除中国的贡献，中国以外的国家和地区的增速只有2.34%左右，这样增长40年，只能增长1.5倍左右，那时中国GDP大约占到全世界50%。</p><p>  这时候矛盾就出现了，中国以外有全世界4/5以上的人口，总的财富仅仅和中国一样多。那时，全世界都没有足够的财富买得起中国不断制造的产品和不断提供的服务。这时只有两个办法，一个是提高世界其它地区的购买力和经济增长，另一个是让中国经济增长降到世界的平均水平。</p><p>  后者显然不是我们想要的，于是借钱给其它国家购买中国的产品和服务，当然中国可以换得一些战略资源，同时让世界其它国家也维持足够高的经济增长，以便它们能维持购买力，并且还得起钱，就是中国不得不做的事情了。而这就是“一带一路”要实现的目标。至于投资和贷款能否拿得回来，那要看操作的水平了。</p><p>  在历史上，19世纪的英国，二战后的美国，以及80年代的日本，都是资本输出国，因为你不输出资本，大家就买不起你的东西，而你也就无法维持体面的经济增长。中国10年前不提“一带一路”的事情，一是因为还没有必要性，二是因为自己的钱不多；近几年才提出，是因为今天中国正好从处在人均GDP低于世界平均水平到变成高于平均水平的转折点上。因此在商业和资本两个层面全球化就变得迫在眉睫了。</p><p>  我们在生活中，常常说“算笔账”这三个字。其背后其实就是说基于一些事实，用数学这个工具来考量，发现问题。为什么数学思维可以很容易地发现问题呢？因为我们常常用到在数学证明中的工具：矛盾律。就是说一个事物不能既有A属性，又没有A属性。比如我们上一讲在证明√2是无理数时说到，如果它是有理数P/Q，那么P和Q这两个整数，既不能同时是素数，又必须同时是偶数，这就违背了矛盾律。同样，中国既不可能拥有全世界所有的财富，还让世界其它地区买得起中国的商品，这也违背了矛盾律。</p><p><strong>要点总结：</strong></p><p>  通过数学的思维方式，发现生活中的问题，看清我们必须采取的行动，这就是学习数学的意义所在。这既可以被看成是认知的升级，也可以被认为是掌握了数学原理之后的灵活应用。当然，数学有很多它做不到的事情，下一讲我们进一步讲讲数学思维的边界。</p></details><h3><span id="05-shu-xue-bian-jie-cong-bi-da-ge-la-si-ding-li-dao-fei-ma-da-ding-li">05 ｜ 数学边界：从毕达哥拉斯定理到费马大定理</span><a href="#05-shu-xue-bian-jie-cong-bi-da-ge-la-si-ding-li-dao-fei-ma-da-ding-li" class="header-anchor">#</a></h3><p><img src="/images/24.jpg" alt=""></p><p>  我们前面讲了数学的预见性，以及数学思维的用处，但是这讲我想和你谈谈数学的局限性，大家可能会有一个疑问，就是这种局限性是来自于我们自己的数学知识不够，还是来源于数学本身的局限性呢？</p><details><summary>...</summary>&emsp;&emsp;应该讲这两方面的原因都有，第一部分因素在大家听完这门课后会补上很多，不用担心；第二部分则是我们这一讲要讲的内容。我们有必要了解数学本身的局限性，才能更好地使用它的原理和思维方式。今天我们还是从毕达哥拉斯定理的推广说起。<p>  在几何上有很多整数组满足毕达哥拉斯定理，它们就是勾股数，比如（3，4，5），（5，12，13）等。从代数上解释勾股数，就是方程 $ a<sup>{2}+b</sup>{2}=c^{2} $ 的整数解。</p><p>  当然，人类总是很好奇，人们就在想，如果上面方程中的平方变成立方，甚至任意N次方，它还有整数解吗？比如，是否有三个整数a，b，c，使得，$ a<sup>{3}+b</sup>{3}=c^3 $ ？</p><p>  这个问题困扰了人类几千年。后来有一个叫费马的数学爱好者就提出一个假说，说除了平方的情况，其他更高次方的方程都找不到整数解，它被称为费马大定理（或者费马最后定理）。</p><p>  虽然它被称为定理，但数学家们只是把它看成是猜想，或者假说，因为没有证明。我们前面讲到，猜想，哪怕用很多数据验证过了，只要没有证明，就无法成为数学大厦中的一块砖，就无法在它的基础上搭建新的东西。</p><p>  因此，在费马之后的几百年里，很多数学家都试图证明它，但是都不得要领。费马自己说他已经证明了这个定理，只是那张纸不够大写不下，但后人认为是费马搞错了。</p><p>  于是费马大定理就成了一道跨越了三个多世纪的超级难题。直到1994年，才由著名的英国旅美数学家怀尔斯证明出来，而这个过程也是一波三折。</p><p>  1986年，怀尔斯在做了十多年的准备后，觉得证明费马大定理的时间成熟了，终于决定将全部精力投入到该定理的证明上了。为了确保别人不受他的启发率先证明了这个著名的定理，他决定在证明出这个定理以前不发表任何关键性的论文。</p><p>  但是，如果一个人苦思冥想，推导的逻辑错了自己也看不出来，为了避免这种情况的发生，怀尔斯利用在普林斯顿大学教课的机会，不断地将自己部分的想法作为课程的内容讲出来，让博士生们来挑错。</p><p>  1993年6月底，怀尔斯觉得自己准备好了，便回到他的故乡英国剑桥，在剑桥大学著名的牛顿研究所举行三场报告会。为了产生爆炸性的新闻效果，怀尔斯甚至没有预告报告会的真实目的。因此，前两场报告其实人不多，但是这两场报告之后，大家都明白接下来他要证明费马大定理了。</p><p>  于是在举行最后一场报告时，牛顿研究所里挤满了人，据估计可能只有1/4的人能听懂讲座，其余的人来这里是为了见证一个历史性的时刻。</p><p>  很多听众带来了照相机，而研究所所长也事先准备好了一瓶香槟酒。当怀尔斯写完费马大定理的证明时，很平静地说道：“我想我就在这里结束”，会场上爆发出一阵持久的鼓掌声。这场报告会被誉为了20世纪该研究所最重要的报告会。</p><p>  不过故事到此并没有结束，数学家们在检查怀尔斯长达170页证明的逻辑之后，发现了一个小漏洞。怀尔斯开始认为这个小漏洞很快能补上，但是后来才发现这个小漏洞会颠覆整个证明的过程。</p><p>  怀尔斯又独立地工作了半年，但毫无进展，在他准备放弃之前，向普林斯顿大学的另一个数学家讲述了自己的困境。对方告诉他，他需要一位信得过的，可以讨论问题的助手帮忙。</p><p>  经过一段时间的考虑和物色，怀尔斯请了剑桥大学年轻的数学家泰勒来一同工作，最后在泰勒的帮助下怀尔斯补上了那个小漏洞。由于有了上一次带有乌龙性质的经历，怀尔斯这次有点怀疑自己是在做梦。于是他到外面转了20分钟，发现自己没有在做梦，这才喜出望外。</p><p>  由于怀尔斯在证明这个定理时已经超过了40岁，无法获得菲尔兹奖，因此国际数学大会破例给他颁发了一个特别贡献奖，这也是迄今为止唯一一个特别贡献奖。关于费马大定理证明过程的更多细节，大家可以听罗辑思维的第85期节目。</p><p>  那么证明这个古老的数学难题有什么意义呢？<strong>这个定理证明过程本身导致了很多数学研究成果的出现，特别是对于椭圆方程的研究。今天区块链技术用到的椭圆加密方法，就是以它为基础的。</strong></p><p>  在怀尔斯之前，有一批数学家，特别是日本的谷山丰，对这一系列理论做出了重大的贡献，怀尔斯的成功是在他们的工作基础之上的。今天的比特币可以讲完全是谷山丰理论的一次有意义的应用。而在怀尔斯之后，泰勒等人还在不断发展这方面的理论。</p><p>  对于三个世纪数学家们证明费马大定理的过程，我和大家分享我的三点体会：</p><ul><li><p>今天的数学（指纯粹数学，不是应用数学）真的很难，想在这方面取得突破性贡献不容易，怀尔斯从10岁开始就立志解决这个问题，他努力了30年。他最后的证明长达200页。但是，有了理论，使用它做有意义的事情，还是容易得多。比特币就是一个很好的例子。</p></li><li><p>数学是世界上最严密的知识体系，任何的推导不能有丝毫的纰漏。怀尔斯差点因为一个小的疏忽毁掉了整个工作，希望通过这一点，大家对数学的严密性有所体会。</p></li><li><p>数学走到今天这一步，是在一个个定理的基础上一点点搭建起来的，而今天的成就，又为明天的发展奠定了基础，这样数学就获得了可叠加的进步。</p></li></ul><p>  毕达哥拉斯定理是，a的平方+b的平方=c的平方的情形。费马大定理是，a的N次方+b的N次方=c的N次方的情形。因此，前者是起点，后者是一个普遍情况的延伸。接下来，如果我们沿着毕达哥拉斯定理和费马大定理继续往前拓展，会是什么情况呢？</p><p>  比如任意一个多项式方程 $ 2x^{2} + 3 y^{3} = z^{4} $ ，或者 $ x^{2} + 3 y^{3} - w^{5} = z^{4} $ ，请问它们有没有整数解？这个问题就是著名的希尔伯特第十问题（简称第十问题）。</p><p>  对于任意一个多项式方程，我们能否在有限步内，判定它是否有解？</p><p>  对于一些特例，我们知道有整数解，比如 $ x^{2} + y^{2} = z^{2} $ 就有；对于另一些特例，我们知道没有整数解，比如费马大定理所描述的情况。</p><p>  但是，对于更多的，一般性的不确定方程，我们不仅不知道怎么解，甚至无法判断一个方程有没有整数解。因此，1900年在巴黎举行的国际数学大会上，希尔伯特在提出23个著名的数学问题时，把它列为了第十个。</p><p>  第十问题其实隐含了一个更为深刻的认识论问题，就是对于大部分数学问题，我们能否找到答案？到目前为止，我们所能解决的数学问题其实只是所有数学问题中很小的一部分。</p><p>  当然，很多人会说尚未找到答案不等于没有答案。第十问题实际上在直接挑战数学的边界，也就是说，通过数学的方法，我们可能根本无法判断一些问题的答案存在与否。如果连答案是否存在都不知道，就更不用说通过数学的方法解决它们了。</p><p>  这样就为数学划定了一个明确的边界。从1900年之后，特别是在二战之后，欧美不少数学家致力于解决这个问题，因为这也涉及到计算机所能处理问题的边界。</p><p>  第十问题的解决颇具戏剧性。在上个世纪60年代，被认为最可能解决这个难题的是美国著名的女数学家朱莉娅·罗宾逊，她从博士一毕业就致力于研究这个问题，也取得了很多突破性的进展。</p><p>  虽然罗宾逊因为这方面的贡献成为了美国科学院第一位女院士，美国数学学会第一位女会长，她离解决这个问题最终还是差几步。1970年，俄罗斯天才的数学家尤里·马季亚谢维奇在大学毕业后一年就解决了这个问题，证明了这类问题是无解的，从此在世界上一举成名。</p><p>  纯数学这个学科除了需要一些运气之外，比拼的是人的智力，智力到哪个程度，成就就到哪个水平，这倒不是宿命论，而是说明人要根据自己的特长选择做事。</p><p>  第十问题的解决其实扑灭了人类的一丝希望，但是也让人类老老实实地在边界内做事情。人类过去常常希望找到一个工程问题的解析解，即答案是以一个公式的形式存在，这样套入任何数字，就得到了具体的答案。</p><p>  但是，很多问题最后证明找不到严格推导出来的解析解，当然这也不妨碍大家在工程上可以使用近似的数值解，解决实际问题。认清这一点，做事的方法也就改变了。</p><p>  搞流体力学和控制理论的人都知道，那里面有很多复杂的非线性方程要解决。在上个世纪，美苏两国走了两条不同的道路。前苏联因为数学水平较高，而计算机技术很落后，因此他们习惯于下硬功夫做很难的数学题，找到非线性问题的解析解。</p><p>  而在美国方面，数学水平高的人没有前苏联多，但是计算机技术先进，因此他们习惯于把很麻烦的非线性问题变成很多计算量大，但是却很简单的线性问题（或者其它数值计算问题），找到工程上能接受的近似解。</p><p>  那么谁取得的效果好呢？从结果来看，美国似乎更好些。关于什么是线性方程，我们后面会讲到，这里大家记住线性方程简单，非线性方程非常复杂即可。</p><p><strong>要点总结：</strong></p><p>  我们介绍了费马大定理的来龙去脉，它往前和毕达哥拉斯定理的关系，往后和希尔伯特第十问题的关系。我也和大家分享了我对这个定理被证明过程的体会。</p><p>  <strong>我们通过希尔伯特第十问题介绍了数学的边界，这是一个硬的边界，大家不要试图逾越。但是数学的边界有些时候不是我们解决问题的边界，因为世界上除了数学的方法，还有其他方法。</strong></p><p>  到目前为止，我们以毕达哥拉斯定理的产生和发展为线索，介绍了数学猜想到数学公理的推导过程，接下来的两讲，我们还是以毕达哥拉斯这个人为线索，谈谈数学的应用，以及在其它知识体系中的位置。我们下一讲再见。</p></details><h3><span id="06-huang-jin-fen-ge-bi-da-ge-la-si-ru-he-lian-jie-shu-xue-he-mei-xue">06 ｜ 黄金分割：毕达哥拉斯如何连接数学和美学</span><a href="#06-huang-jin-fen-ge-bi-da-ge-la-si-ru-he-lian-jie-shu-xue-he-mei-xue" class="header-anchor">#</a></h3><p><img src="/images/25.jpg" alt=""></p><p>  今天大家对毕达哥拉斯的了解，除了勾股定理，还有就是黄金分割。而他用数学指导艺术和音乐，也确立了数学在其它知识体系和人类文明成就中的中心地位。这一讲，我们就从黄金分割出发，进一步理解数学的用途。这个用途不仅仅是在思维方面，也能实实在在指导我们的工作。</p><details><summary>...</summary>&emsp;&emsp;我们先来看一张照片，感受一下黄金分割。<p><img src="/images/27.jpg" alt=""></p><p>  这是雅典卫城的帕特农神庙，它无论是在艺术史上，还是建筑史上地位都很高，如果你度量一下它正面的宽与高，正好符合我们所说的黄金分割。</p><p>  黄金分割大家并不陌生，你可能还会说出它的比例大约是1:0.618，也就是1.618。其实不仅帕特农神庙本身和里面很多雕塑的关键比例符合黄金分割，著名的雕塑《断臂的维纳斯》，它的身高和腿长的比例，腿和上身的比例也都符合黄金分割。符合这个黄金比例的雕塑或建筑就看上去很顺眼，很美观。</p><p>  那么黄金分割是如何确定的呢，这个比例为什么看起来顺眼呢？<strong>简单地讲，它的美感来自几何图形的相似性。</strong></p><p>  比如我画了一个符合黄金分割的长方形，它的长度是X，宽度是Y。如果我们用剪刀从中剪掉一个边长为Y的正方形（也就是图中灰色的部分），剩下来的长方形，长宽之比依然会符合黄金分割。</p><p><img src="/images/28.jpg" alt=""></p><p>  当然，我们还可以继续剪掉一个正方形（图中绿色的部分），剩下的长方形（图中透明的部分）的长宽依然会符合黄金分割的比例。也就是说，如果我们这样不断地切下去，剩余部分都是成同一比例的。</p><p>  黄金分割的这个比例很容易算出来。根据黄金分割上述的相似性质，我们可以很容易算出来X/Y的比例是1.618左右，更精确地讲，是√5加上1之后的和除以2，这是一个无理数，通常用希腊字母Ф来表示。</p><p>  黄金分割为什么漂亮？除了在几何上层层相似，这个相似性之外，它也反映了自然界的物理学特征。如果我们把刚才图中的长方形不断做切割，然后将每个被切掉的正方形的边用圆弧替代，就得到了这样一个螺旋线。由于这个螺旋线每转动同样的角度，得到的圆弧是等比例的，因此它也被称为等角螺线。如果你对比这个螺旋线和下面的蜗牛壳，是否觉得很相似？</p><p><img src="/images/29.jpg" alt=""><img src="/images/30.jpg" alt=""></p><p>  不仅蜗牛壳如此，龙卷风的性质乃至像银河系这样星系的形状都是如此。需要指出的是，这不是巧合，而是因为任何东西如果从中心出发，同比例放大，必然得到这样的形状。</p><p><img src="/images/31.jpg" alt=""><img src="/images/32.jpg" alt=""></p><p>  或许正是因为黄金分割反映了宇宙自身的一个常数，我们对它才特别有亲切感，所以哪个建筑或者画作如果有意无意满足了这个条件，它就显得特别美。除了帕特农神庙，埃菲尔铁塔等建筑的主要尺寸的比例，也正好符合黄金分割，甚至符合等角螺旋线。</p><p><img src="/images/33.jpg" alt=""></p><p>  类似的，《蒙娜丽莎》的主要结构部分也可以对应一条等角螺旋线。需要说明的是，无论是帕特农神庙的设计者，还是达·芬奇或者埃菲尔，他们都知道黄金分割，并且刻意使用了这个比例。</p><p><img src="/images/34.jpg" alt=""></p><p>  最先提出黄金分割的人是谁呢？古埃及人似乎早在4500年前就知道了这个比例的存在，因为大金字塔从任何一个面看上去，其正切面的斜边长和金字塔高度之比正好是黄金分割的比例。</p><p>  当然，没有证据表明他们算出了精确的比例公式，因为他们不知道有无理数存在。</p><p>  今天一般认为，算出黄金分割公式的还是毕达哥拉斯。虽然相传毕达哥拉斯是在一次听到一个铁匠打铁和谐而动听的声音后，研究出了黄金分割，但是我觉得这种说法缺乏依据。</p><p>  大家更认可的说法是，毕达哥拉斯学派的人在做正五边形和五角星的图形时，发现了黄金分割的比例。在正五角星中，每一个等腰三角形的斜边和底边的比例都是黄金分割1.618。</p><p><img src="/images/35.jpg" alt=""></p><p>  我们刚才说毕达哥拉斯还可能是从铁匠的打铁声中获得了黄金分割的启发，但是无从考证，不过毕达哥拉斯学派利用数学指导音乐是真实的事情。毕达哥拉斯认为，要产生让人愉快的音乐，就不能随机在连续的音调中选择音阶，而需要根据数学上的比例设计：</p><p>  首先，人们发现两根琴弦，如果它们的长度比是2:1，它们所奏出来的音节就相差一个8度，如果我们用简谱来记录，也就是1-2-3-4-5-6-7-i，高音1的音高是中音1的两倍。在这一个8度中最高音和最低音的频率之比也就是为2:1。</p><p>  接下来，将这8度又一分为二，按照4:3和3:2的比例，分出一个4度音和一个5度音，它们分别对应1-2-3-4和4-5-6-7-i。注意，由于4/3 x 3/2 = 2:1，因此一个4度音和一个5度音会还原成一个8度音。</p><p>  最后，每个4度音分成两个整声调，即分出2和3，5度音分为三个整声调，即分出5，6，7。这样就是按照比例设计的了。</p><p>  如果不按照比例分配音节是什么结果呢？我们听到的声音就如同噪音，而不是有规律的乐音。今天对耳蜗的解刨学研究发现，耳蜗的形状其实也是螺旋线的，和黄金分割的螺旋线非常吻合。这可能是按照黄金分割设定音律后，声音悦耳的原因。</p><p>  毕达哥拉斯和他的学派对音乐和美学的影响一直影响到柏拉图和亚里士多德，以及后来诸多文艺复兴的学者。</p><p>  数学不仅和音乐密切相关，也对建筑和绘画艺术产生了重大的影响。我们看从文艺复兴时期开始，到19世纪浪漫主义时期的西方油画，都会惊叹于它们的逼真。这个逼真的效果从哪里来？它源于艺术家们使用单点透视的方法，成功地将三维形象绘制到一个二维平面上。当然，这个绘画技术不是一天发明的。</p><p>  其实，早在古希腊时期，人们就发现了远处景物显得小，近处的显得大这样的特点，并且将这种特点反映到绘画中了，他们把这种方法叫做短缩法。但是，古希腊人并不知道物体在离开我们远去时，该遵循什么数学法则进行缩小。</p><p>  到了文艺复兴时期，佛罗伦萨的画家乌切洛沉溺于使用几何学技术将绘画变得逼真，在他为美第奇家族绘制的《圣罗马诺之战》中，我们可以看到明显采用透视法炫技的痕迹。</p><p>  大家可以仔细看看地上倒下的战士和旁边的长矛，都指向远方的消失点。他用透视法为绘画构建了立体的舞台。不过，如果你仔细看，会觉得这幅画中有不少别扭的地方，因为这幅画好像不止一个透视的方向。</p><p><img src="/images/36.jpg" alt=""></p><p>  那么是谁真正解决了透视法中的数学问题，并且将这种技巧给予了广大艺术家的呢？他是文艺复兴时期大名鼎鼎的建筑师和工程师布鲁内莱斯基，今天佛罗伦萨的圣母百花大教堂就是他的杰作。关于这座在建筑史上划时代建筑的建造过程，我们在《科技史纲60讲》中已经介绍了，这里就不再赘述了。</p><p>  布鲁内莱斯基所发明的单点透视法，完全符合我们视觉应有的几何学原理，具体讲就是相似三角形的原理，因此按照这样的方法画出来的画就非常逼真。下面我们就从视觉中的几何学原理出发，简单介绍一下单点透视法。</p><p>  假定我们前方100米和500米处各有一棵大树，它们都是50米高。我们知道近处的树在我们的眼睛里显得高，远处的显得小。那么看起来，它们的比例到底该是几比几呢？简单地讲，就是应该和距离成反比，即100米处50米高的树，放到500米处，应该显得只有10米高。如果放到无穷远处，则应该是0米高，也就是地平线上的一个点。对于其他的距离，我们看到的高度也是同样和距离成反比。这样，如果我们把各个距离之处50米高的大树连城一条线，就是我们得到的透视的视觉效果了。</p><p>  下图是我在电视剧《权力的游戏》的外景地（北爱尔兰）拍的照片。从照片可以看出，所有相同大小的景物，按照远近的比例缩小，在远处汇聚到一点。</p><p><img src="/images/37.jpg" alt=""></p><p>  理解了我们视觉的数学原理，就可以利用它创造出不同的艺术效果。比如在现实世界里，我们看到的是单点透视，因为人的眼睛不可能同时往两边看，但是我们可以在艺术创作中采用两点和多点透视。</p><p>  下图是两点透视的效果图，景物消失在一左一右两点上。我们通常目光只能集中在一个方向，看不了这么广的视角，但是你如果用鱼眼镜头拍照，就能拍出这样的效果。</p><p><img src="/images/38.jpg" alt=""></p><p>  我们在今后的课程中，还会讲到，艺术需要数学，也需要光学。印象派绘画的一大特点，就是很好地利用了当时人类在物理上对于色彩和亮度认识的进步。</p><p><strong>要点总结：</strong></p><p>  最后总结一下今天的内容，其实我们是在回答数学的用途。</p><p>  数学和艺术，以及其他的知识体系有着千丝万缕的联系，我们以黄金分割和透视法为例子介绍了这种关系。了解一些基本的数学知识和方法对我们做其他事情有很多好处。当然，有些人会讲，我们学不会那些数学上的道理啊，没关系，有些方法你只要记住就好。</p><p>  我们下一讲就从黄金分割出发，介绍优选法，大家只要掌握它的一些基本原则，就能直接使用了。</p></details><h3><span id="07-shu-xue-ying-yong-hua-luo-geng-hua-fan-wei-jian-de-shen-lai-zhi-bi">07 ｜ 数学应用：华罗庚化繁为简的神来之笔</span><a href="#07-shu-xue-ying-yong-hua-luo-geng-hua-fan-wei-jian-de-shen-lai-zhi-bi" class="header-anchor">#</a></h3><p><img src="/images/45.jpg" alt=""></p><p>  我们前面讲过，由于数学是一个纯粹依靠脑力进行研究的学科，而它的严密性又非任何自然科学可比，因此很多数学家们有一种高高在上的自我认知，你如果让他们来解决一些实际问题，他们可能会看不上眼。</p><details><summary>...</summary><p>  我在一次聚会中遇到一位数学家和一位数学基础非常好的理论物理学家。后者可能是想往数学上靠近一点，对数学家讲，我们也是搞数学的，数学家马上说，你们搞的那些东西怎么能算是数学？</p><p>  这类情况并不是个案，我见过很多持这种态度的数学家，他们甚至不觉得统计学是数学的一个分支。数学家好像每天研究的东西都深不可测，几乎成为了一种神乎其神的群体。</p><p>  但是，很多真正高水平的数学家，他们不仅能够研究复杂的理论问题，还能够为复杂的实际问题找到简单的，可重复使用的解决方法，比如我国老一辈著名的数学家华罗庚先生。华先生是20世纪唯一一位能够称得上是世界级的中国数学家，他在数论等方面有很多贡献。</p><p>  不过，绝大部分中国人都不知道华先生的贡献在哪里，只记住了他所推广的优选法。大家之所以记得住优选法，还是因为很多工业生产受益于此。</p><p>  在现实的世界里，有一大类的问题可以归结为数学上的最优化问题。小到大家平时发面蒸个馒头，一公斤面先要发酵多长时间，然后放多少克碱，或者做一盘菜放多少盐，多少糖；中到我们在投资时，为了同时兼顾风险和收益，股票配比占总资产的多少比较合适；大到设计一个火箭，燃料和氧气的配比多高最合适。这些问题从本质上讲都是最优化问题。</p><p>  当然，在很多时候决定好坏的因素不止一个，而衡量标准也不止一个。所以很多看起来简单的优化问题，往往在设计时就得非常复杂。</p><p>  在生活和工作中，在解决每一个复杂的优化问题时，都可以建立一个特定的数学模型，然后用一大堆工具和计算机刻意接近它。但是，对于大多数各行各业的从业者，并不具有足够多的数学知识，也搞不懂那么复杂的数学模型，他们仅仅是希望你给我几个简单的原则来遵守，几个简单的步骤来执行就好。</p><p>  于是1958年，华罗庚先生就率领了一大批数学家走出大学和科学院大门，到工农业生产单位去寻求实际问题进行研究，提出解决方案。</p><p>  华先生最先想到的是线性规划。所谓线性规划，就是用很多线性方程在多维空间里划定一个区域，在区域里找最佳值。</p><p>  下图中每一条直线就是一个限制条件，它们一同划定了一个蓝色的框框，线性规划就是一个简单的在蓝色框框中寻找最佳值的方法。当然，在实际应用中，经常是在高维空间，而非图中的二维空间里求解，但道理都是一样的。</p><p><img src="/images/46.jpg" alt=""></p><p>  线性规划的本质是将实际应用中那些复杂的非线性求解问题，变成很多个线性方程的问题。要直接解决前者那些复杂问题，需要数学家们做很多推导，显然在实际生产中办不到。而后者，说白了就是死算，当时虽然没有计算机，但是用计算尺还是能完成计算的。</p><p>  应该讲，华罗庚先生等人的工作，当时还是取得了一批应用成果的，但是不大，因为在工厂机关企业里，就是解线性方程这样简单的数学题，一般人也做不对。</p><p>  大部分数学家遇到这种情况，恐怕就直接埋怨一线工作的人数学水平低了。但是华先生却没有怪大家水平低，而是觉得自己依然没有把数学变得更简单，于是他进一步总结经验，制定出一套易于被人接受、应用面广的数学方法。他把这些方法称之为优选法。</p><p>  这种方法非常简单，对当时中国既缺乏数学人才，又缺乏计算机的企事业单位提高效率起到了巨大的作用。</p><p>  优选法有两个含义，首先它能够找到实际问题的最佳解。其次，它强调寻找最优解的方法本身最简单，或者说最优，具体来说，就是用最少的试验次数来找出最优解在哪里。</p><p>  假如我们蒸馒头，想试验一下一公斤面放多少碱合适。按照优选法来说，首先我们要找到这个问题的答案，当然你可以每次增加10%一次次地试验，但是这样可能试验的次数特别多。因此，优选法还希望只进行两三次试验，就找到合适的分量。</p><p>  优选法的原理就是基于我们前面介绍的黄金分割，因此华先生又称之为“0.618法”。为方便说明，我们就假定影响结果的变量（华先生称之为因子）只有一个，比如做馒头时放碱的量。</p><p>  我们假定1公斤面粉，放碱的重量范围为0～10克之间，精准度到0.1克。当然碱放得太多太少都不行。我们还假定用不同碱量做出来的馒头的口味是可以量化度量的：</p><p><img src="/images/47.jpg" alt=""></p><p>  根据优选法，第一次试验取在黄金分割点，也就是0～10克之间6.18克的位置。如果我们发现这样做出来的馒头碱多了，那么怎么办呢？根据华先生的优选法，第二次做试验选择从0到6.18克之间的黄金分割点。</p><p>  我们在前面讲了，黄金分割有一个特别好的性质，就是(1-0.618)/0.618=0.618，这样一来，0到6.18克的黄金分割点正好是10-6.18 = 3.82克的位置，这就使得这前后两次找到的黄金分割点，6.18和3.82中间出现了中间点，恰好是5.0克，也就是说5.0成了两次黄金分割点的对称点：</p><p><img src="/images/48.jpg" alt=""></p><p>  当然，你如果和没有多少数学基础的人来讲对称中轴之类的话，他未必听得懂。华先生用了一个非常生动形象的方法来解释这一特征，他称之为折纸法，即把第一个黄金分割点，点在一张纸上，然后把纸从中间对折一下，第二个黄金分割点的位置也显就出来了。</p><p>  优选法的效率可以从理论上严格证明。比如说做5次试验，就可以将范围缩小到原来的9%，6次可以将范围缩小到6%以下。</p><p>  华罗庚先生的优选法，给这一大类问题找到了一个结果比较令人满意的，步骤非常容易遵循的方法。</p><p>  上个世纪70年代，华先生出版了小册子《优选法平话》，后来又扩充了一些案例编写了《优选法平话及其补充》。这两本书用了极为通俗的语言和生活中的案例对优选法的原理和操作进行了描述，当时初中毕业的普通工人都能学会使用，于是优选法在中国得到了极大的普及。</p><p>  当然，在实际应用中，很多问题有多个变量，而不只是一个。优选法对这种问题设计了一种二维的折纸法，具体做法大致是这样：</p><ul><li>先确定第一个维度的黄金分割点；</li><li>再确定第二个维度的黄金分割点，这样就把二维空间划分为四个部分；</li><li>接下来确定第一个维度的第二个黄金分割点；</li><li>再确定第二个维度的第二个黄金分割点。</li></ul><p>重复第三、第四个步骤，直到找到最佳点。</p><p>  在数学上很容易证明，在一个平面区间里存在唯一的最佳点，这种方法很容易找到。对于有更多变量的问题，也可以沿着上述思路扩展，但是这时大家会发现，它其实就是线性规划的一个特例。</p><p>  **华罗庚先生的贡献在于找到了一种一线职工都很容易掌握和运用的数学方法解决实际问题，并且用非常通俗的语言把复杂的方法简单化。**这才体现出大师的水平。反观我们一些专家学者，喜欢故意把理论包装得高、大、上，然后哗众取宠。他们和真正的大师高下立判。</p><p>  学了知识，关键要使用好。黄金分割的妙处可以讲是上天赐予的，因此了解了它之后，在很多地方我会有意无意地使用这个比例。比如我拍照片时，喜欢将照片中的主角放在照片的黄金分割点处。</p><p>  下图是我在爱尔兰拍的海边风车，它在照片的黄金分割点。此外，天空的比例、海水的比例，也基本上符合黄金分割的原则。如果把风车放在画面的中央，看起来就显得呆板了，此外无论画面中天太多，或者水太多，都有失平衡。</p><p><img src="/images/49.jpg" alt=""></p><p>  在投资的配比上，我喜欢将60%～65%左右的资产放在回报高，风险也相对高点的股市上，这基本上符合黄金分割的比例。在剩余的大约38%的资产中，大约25%左右放在相对稳妥的债券上，这也大约是38%的黄金分割点。最后的百分之十几，则是各种复杂的组合投资。</p><p>  在很多需要作决定的事情上，我自觉或者不自觉地把作决定的时间放在黄金分割点或者反方向的黄金分割点上。</p><p>  比如需要更多一点时间作比较、作决定的事情，不妨往后放放，但是不要到最后一刻，比如出门度假寻找酒店和机票，你需要时间了解情况，并且货比三家，但是真到了最后一刻，要么酒店订不上了，要么机票太贵。</p><p>  另一种情况是，我们在作出决定后，需要较长的时间来实现我们的想法，我一般就把作决定的时间点放在0.382的地方，也就是反方向的黄金分割点上。比如要创业，就不要把大部分时间放在想做什么事情上，而需要花更多的时间来做。</p><p>  当然，每到具体的问题，一定存在比简单利用黄金分割更好的解决办法。但后者的好处是，在你对细节无法了解，甚至一辈子学不会的情况下，总要有一定的做事准则，得到不会太坏的结果，这其实就是数学在很多场合的作用。</p><p>  很多人抱怨数学不够灵活，其实任何无条件的硬性规定和原则都有这个特点，但是在绝大部分情况下，有准则总比没有好。这是我对数学，特别是对黄金分割的一些感悟，也算是对今天内容的总结。</p><p>  接下来三讲，我们还是从黄金分割出发，重新理解数列和级数。我们下一讲见！</p></details><h3><span id="08-shu-lie-he-ji-shu-yi-dang-xia-hen-chong-yao-dan-qu-shi-geng-chong-yao">08 ｜ 数列和级数（一）：当下很重要，但趋势更重要</span><a href="#08-shu-lie-he-ji-shu-yi-dang-xia-hen-chong-yao-dan-qu-shi-geng-chong-yao" class="header-anchor">#</a></h3><p><img src="/images/50.jpg" alt=""></p><p>  这一讲的主题是：数列和级数：要知道当下很重要，但趋势更重要。</p><details><summary>...</summary><p>  有人问我，是否通过学习数学提高了见识水平？公平地讲，很难找到某一个数学知识点，学了之后让见识马上提升，这种直接产生效果的知识我是没有遇到。但是通过学习一些数学知识和方法，帮助我形成了系统的做事方法，并且改进了看待世界的角度，这却不是虚言。</p><p>  今天和大家分享两点体会，第一点是我们如何举一反三，通过对单个事件，或者说对个案的研究，寻找出对一系列问题的通解，第二点是从很多孤立事件出发，看到并理解趋势和规律。</p><p>  为了说明这两点，在接下来的几讲里我们用数列这个专题作为例子，练习把握从个体到群体的规律。当然，讲数列还有一个目的，就是承上启下，它会用到前面讲的黄金分割的知识，并且为后面讲极限、无穷大和无穷小奠定基础。</p><p>  我们先来看一个具体的数列，给你这样一串数字：</p><center>1，1，2，3，5，8，13，……</center><p>  如果我来问大家下一个数字应该是什么，比较善于琢磨规律的人会指出，由于每一个数字（除了前两个）都是前面两个数字之和，因此下一个应该是21，即8+13。这个答案完全正确，这样一连串有规律的数字放到一起，就形成了我们要说的数列。</p><p>  上面这个数列，就是数学中鼎鼎大名的斐波那契数列。在这个数列中，我们是有规律可循的，根据数列中开头几个元素的具体数值，知道整个数列每一个位置元素的数值，就是提升自己从孤立事件里发现规律的能力。</p><p>  数列其实在今天中国的小学已经讲到，比如常见的两种数列分别是这样的：</p><center>1，2，3，4，5，6，7，……以及1，2，4，8，16，32，……</center><p>  前一种数列由于相邻两个数字（我们称之为元素）的差距都是1，因此被称为等差数列，后一种由于相邻两个数字的比值都是相同的（都是2），因此被称为等比数列。</p><p>  在学校里，老师会讲从1加到100怎么计算，也会讲到等比数列（也被称为几何数列）会增长很快。但是为什么要把这些数字放到一起研究，其实老师们是语焉不详的。当然即使老师讲，以小学生的理解能力也未必能体会。因此今天我们就从这里入手，讲讲数列和数字的关系。</p><p>  数列是一种工具。**它看似是一串数字，但这里重要的是彼此的关联，以及数字的规律，而不是数字本身。**那些规律和我们现实生活中一些事情的发展过程相关，于是这个工具就能够运用到我们真实的世界里了。</p><p>  比如我们后面要讲到的媒体转播的发散和收敛问题，以及利息问题，就和几何数列有关。以斐波那契数列为例，它其实反映出一个物种自然繁衍，或者一个组织自然发展过程中成员的变化规律。斐波那契数列最初是这样描述的：</p><blockquote><p>有一对兔子，它们生下了一对小兔子，前面的我们叫做第一代，后面的我们叫做第二代。然后这两代兔子各生出一对兔子，这样就有了第三代。这时第一代兔子老了，就生不了小兔子了，但是第二、第三代还能生，于是它们生出了第四代。然后它们不断繁衍下去。那么请问第N代的兔子有多少对？这个数列，就是1，1，2，3，5，8，13，21，……</p></blockquote><p>  如果我们稍微留心一下这个数列的增长速度，虽然它赶不上1，2，4，8，16这样的翻番增长，但其实也很快，也呈现出一种指数增长的趋势。在现实生活中，兔子的繁殖曾经就是这么迅猛。</p><p>  1859 年，一个名叫托马斯·奥斯汀的英国人移民来到澳大利亚，他喜欢打猎，但发现澳大利亚没有兔子可打，便让侄子从英国带来了24只兔子。</p><p>  这24只兔子到了澳大利亚后被放到野外，由于没有天敌，它们便快速繁殖起来。兔子一年能繁殖几代，年初刚生下来的兔子，年底就会成为“曾祖”。几十年后，兔子数量飙升至40亿只，这在澳大利亚造成了巨大的生态灾难。</p><p>  有人可能会问，为什么不吃兔子？澳大利亚人也确实从1929年开始吃兔子肉了，但是吃的速度没有繁殖的快。澳大利亚政府甚至动用军队捕杀，也收效甚微。</p><p>  最后，在1951年，澳大利亚引进了一种能杀死兔子的病毒，终于消灭了99％以上的兔子，可是少数大难不死的兔子产生了抗病毒性，于是“人兔大战”一直延续至今。从这个故事我想说的是，真遇上指数增长的事情，是非常可怕的。</p><p>  接下来，我们就定量地分析一下斐波那契数列增长有多快。我们不妨用Fn代表数列中第n个数，那么Fn+1就表示其中的第n+1个数。我们再用Rn，代表Fn+1和Fn的比值，也就是后一个数和前一个数的比值，你可以把它们看成是数列增长的相对速率。</p><p>  下面的表给出了斐波那契数列中前12个元素的数值，以及增长的速率。</p><p><img src="images/51.jpg" alt=""></p><p>  大家可以看出Rn这个比值，很快趋近于1.618了，这恰好是黄金分割的比例。这个结论说明，数学的各个知识点，可能存在某种天然的联系，这似乎是数学这套系统本身浑然天成的结果，因此很多人讲这其实就是数学之美的体现。</p><p>  我们课程从毕达哥拉斯，讲到黄金分割，然后通过黄金分割，由此把一些数学知识关联起来。这其实就是一个学习数学的技巧了，绝大部分时候不在于题做得有多难，而在于你闭上眼睛，能够用一两条关键的线索把各个知识点串联起来。</p><p>  通过上面这个比例，我们需要说明两件事情。首先，虽然这个数列最终的走向是收敛于黄金分割的比例，但是在一开始的几个数，并不符合这个规律。这在数学上不是偶然现象，很多时候，仅仅通过少数几个数字得到的所谓的“规律”，其实和采用大量数据后得到的规律完全是两回事，这一点要特别注意。</p><p>  其次，上述这个比率，几乎是一个企业扩张时能够接受的最高的员工数量增长速率，如果超过这个速率，企业的文化就很难维持了。企业在招入新员工时，通常要由一个老员工带一个新员工，缺了这个环节，企业的人一多就各自为战了。</p><p>  而当老员工带过两三个新员工后，他们都会追求更高的职业发展道路，不会花太多时间继续带新人了，因此带新员工的人基本也就是职级中等偏下的人，这很像兔子繁殖，只有那些已经性成熟而且还年轻的在生育。</p><p>  我们在谈到等比数列时，通常会想到指数爆炸，变得越来越大。但是还有另一类等比数列，它们的数字每一个都比前一个小，最终就会趋近于零。</p><p>  炒股的人有这样的经验，如果每次损失10%，用不了几次就损失一半了，这就是等比数列中每一个数字都在不断按比例衰减的结果。具体讲，大约6次，就会损失一半，大约13次就会损失3/4。</p><p>  再举一个例子，今天用于测定年代的碳-14测定法，利用的就是这个原理。碳-14是自然界里一种天然的元素，是宇宙射线照射大气的产物，因此它会不断产生，但是它有放射性，因此过一段时间会衰变掉一部分，于是它在自然界保持着一个动态平衡。</p><p>  生物体在活着的时候，会吸入大气中的碳-14元素（通过二氧化碳），因此它体内的比例就和自然界的比例相同。但是生物体一死，就不会再吸入碳-14了，因此体内碳-14的比例就会逐渐降低。</p><p>  根据生物遗骸体内碳-14的比例，结合碳-14衰变的速率（也称为半衰期），就能算出古代生物体距今的时间。所以，对于等比数列，我们一般理解的是快速上涨，但是它也可能代表不断地衰减。</p><p>  数列，其实讲的就是一个趋势。很多时候，我们不仅关心当前这个数有多大，或者我们有多少钱，多少资源，还关心明天它能变得多大，变得多快，这就是数列的意义。至于等差数列，其实是缓慢上涨的，即使每一个都比前面的大，到后来的增长也很不明显。</p><p>  也就是说，同样是增长的趋势，我们还需要关心积累的速度。比如说，一个刚工作的年轻人，一年挣10万元，能存20%的收入，他每年的工资增长10%。当地的房价是300万元，首付要20%也就是60万，那么他工作多少年能够付得起首付呢？</p><p>  这就要计算数列中每一个元素之和了，这个算出来的和，被称为级数。具体到这个问题，我们知道这位年轻人第一年能存2万元，第二年能存2.2万，然后是2.42万、2.66万、2.93万……假如他要存N年才能凑够首付，这个N最后算出来就是15年。</p><p>  计算公式：S（N）= 2（1 + 1.1 + 1.1^2 + 1.1^3 + …… + 1.1<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>)</p><p>  建议你亲自算一算这道题，这样你就更能体会为什么必须进步，而且要比同龄人更快地进步了。</p><p><strong>思考题：</strong></p><p>  如果房价保守估计，每年上涨3%，那年轻人又需要存多少年呢？</p><p><strong>要点总结：</strong></p><p>  我们通过数列（和级数），扭转一下大家对数学的认识：数学大部分时候研究的不是一个个孤立的数，而是要揭示一些规律和趋势。我们通过斐波那契数列介绍了几何数列可能会带来的指数爆炸问题；同时我们还介绍了另一种几何数列——不断递减的数列。通过斐波那契数列，将它和我们前面介绍的黄金分割关联起来。让大家体会到数学知识点的关联性。在数列这个领域，我们不仅关心趋势，还关心积累的效果，这是我们接下来两讲要讲的内容。</p><p>  我们下一讲再见。</p></details><h3><span id="09-shu-lie-he-ji-shu-er-chuan-xiao-pian-ju-de-shu-xue-yuan-li">09 ｜ 数列和级数（二）：传销骗局的数学原理</span><a href="#09-shu-lie-he-ji-shu-er-chuan-xiao-pian-ju-de-shu-xue-yuan-li" class="header-anchor">#</a></h3><p><img src="/images/52.jpg" alt=""></p><p>  今天，我们来讲讲数列的求和，也就是所谓的级数。在讲这个问题之前，我们来看一个传销的例子。</p><details><summary>...</summary><p>  传销通俗来说，就是拉人头发展下线，你拉别人进来，别人再拉新人进来，每次进人，你都有提成。这么一来，只要你的下线不断把新人拉进来，你什么都不用干，就能躺着拿钱了。大多数搞传销的老鼠会都是这么忽悠你的，我们今天从数学上看看这个看似没问题的“发财经”是否可行。</p><p>  我们先假定某个传销公司的提成方式只覆盖两层：</p><ul><li>每一个人入会需要缴纳1万元（或者买1万元的东西）；</li><li>发展一个直接下线，可以从后者的身上提成20%；</li><li>直接下线每发展一个下线，可以从下线的下线身上再提成20%的20%。</li></ul><p>接下来的问题是，张三入会了，他在什么情况下可能挣到钱？我们先分析两种情况：</p><p>  **情况1：**张三找到5个朋友也加入这个老鼠会，而他的每一个下线也发展了5个下线。这样，他付出1万元，而从每个直接的下线身上得到10000x20%=2000元，五个下线一共给他带来1万元。类似的，下线的下线也可以给他带来一共1万元，两者相加是2万元，张三赚1万元。</p><p>  **情况2：**张三找到3个朋友也加入这个老鼠会，而他的每一个下线也发展了3个下线，这样他的收入一共只有9600元，反而亏了400元。</p><p>  从这两个例子可以看出，要想在老鼠会中挣钱，并不是一件容易的事情。一个人可能会因为一时冲动，或者贪财而被卷进去，但是他要在朋友中找到5个和他同样糊涂或者贪财的人，并不容易。而且，由于朋友之间的朋友圈有很大的交集，通常的情况就是张三想发展的人，和他的朋友想发展的人都是一群人。</p><p>  接下来我们再看另一种情况，假设这个老鼠会对会员“特别好”，每一个会员可以自己拿下面所有层会员的提成，当然每往下一层，提成的比例要逐级指数递减。这样的话，如果层数不断加深，直到无穷，是否处在比较高层的人就有无限的钱可以拿了呢？也未必，这要看每一层的人能发展多少会员了。</p><p>  在上面第一种情况下，即张三成功地发展了五个下线，而每个下线也发展了5个，张三还真能拿无限多的钱，因为每一层都给他贡献了10000元，如果层数不断涨下去，他就能拿无限的钱。</p><p>  但是，在情况2时，也就是张三和他所有的下线（既包括直接的，也包括间接的）每人都发展了三个人。虽然张三挣的钱可以超过他付出的10000元，但却是有限的。具体来讲，他从下一层下线获得6000元，下面第二层获得3600元，第三层获得2160元，这样逐渐减少，最后无限加下去，总和并不是无穷大，而是一个有限的数，只有1.5万元。</p><p>  此外，让我们再看另一个可能性。</p><p>  **情况3：**张三和他所有的下线每人都发展了两个人，这样张三从各层下线挣到的钱的总数是：</p><center>4000 + 1600 + 640 + …… = 6666.67元</center><p>  虽然看上去他从无穷多的人身上挣到了钱，可是，这挣钱的效率衰减很快。他挣的钱还没有付出的本钱多。很多人误以为只要从无限多的人身上挣钱，就能挣很多钱，这其实是不了解级数这个概念而产生的误解。</p><p>  接下来我们就从理论上分析一下几何级数，也就是几何数列求和的问题，把这个问题搞清楚，上面那个老鼠会挣钱效率的问题就迎刃而解了。</p><p>  我们还是从老鼠会分配钱的方法入手。我们假设每一个人发展了K个下线，从每个直接下线分钱的百分比为p，从第二级下线分钱的比例为p<sup>2，那么第三级的比例为p</sup>3，因为要分3次，以此类推，逐级下降。</p><p>  如果每一个人交的会费为A，那么一个人能拿到的钱就是：</p><center>A*K*p + A*(K*p)^2 + A*(K*p)^3 + A*(K*p)^4 + ……</center><p>  这是一个等比级数，或者叫做几何级数。</p><p>  这么加下去等于多少呢？很显然，如果K*p&gt;=1，它就是无穷大，这也就是为什么当分成比例为20%时，每个人只要发展五个下线，从理论上讲，能挣无限多的钱。这时，上述的级数被称为发散的。</p><p>  但是，K<em>p&lt;1时，上面这个式子虽然加了无穷多项，但到后面都是零点几这样的小数的次方，只能是越乘越小，所以总和是一个有限的数（A</em>K<em>p/（1-K</em>p））。当然，K<em>p越接近于1，这个数越大，K</em>p越小，这个数越小。这时，上述级数被称为是收敛的。</p><p>  其实可以把每一项的“K*p”用r来表示。什么时候发散什么时候收敛，这个r是关键，它其实是后一个元素和前一个的比值，比如斐波那契数列，它的后一项比前一项，就是黄金分割1.618，至于翻番的指数数列，它就是2，因为我们知道翻番就是翻两倍。当r&gt;=1时，这个级数就发散，加起来无穷大。当r&lt;1时，它就收敛，加起来是一个有限的数。</p><p>  了解了级数的发散性和收敛性，对我们生活、工作和科研会有很多帮助，可以帮我们看清很多类似的迷局。下面我们就来看两个例子：</p><p>  例一，社交网络上的信息传播问题。</p><p>  在社交网络上，有时一篇文章会被不断地转发，然后大家就看到相关的事件被发酵了。这很好理解，我们常说，一传十，十传百，其实就是说当r=10的时候，一个人发出信息后，经过几何级数的增长，数量剧增的情况。</p><p>  但事实上，一条信息总是传着传着就死了。大部分公众号文章的阅读量都不过万。那么问题出在哪里呢？我们就用等比级数分析一下。</p><p>  我们假定订阅公众号的人中阅读了某篇文章的第一批读者数量是A0。大家读了之后觉得有价值，然后转发了的百分比为p，每一次转发，平均能有K个受众，而这些受众中打开阅读的比例为q，那么第二批读者就有A0<em>p</em>K<em>q个，我们把p</em>K<em>q用r代替，这就是前面的等比级数了，第三批有A0</em>r^2个读者，以此类推。如果r &gt; 1，那么这篇文章就霸屏了。</p><p>  但是如果r&lt;1，无论怎么传播，无论一开始花多少钱让A0变得很大，读的人数都有限。比如，第一批读者是5000人（不算少了），接下来r=1/2，最终所有的读者加起来，不到1万。如果r=0.9，那么读者数量就可以达到5万。</p><p>  我在2019年接受了大约50次采访，只有两篇报道不是标题党（甲子光年的一篇和澎湃新闻的一篇），这还是对媒体进行了严格筛选，并在我强烈要求不可以标题党的情况下发生的。</p><p>  从这里可以看出，标题党的问题只会比我遇到的更严重。但是从结果来看，标题党并没有帮助提升阅读量，因为真实的阅读量摆在那里。这里面根本的原因就是，一旦读者发现一篇文章是标题党，他就有上当的感觉，都未必会读完，更不要说转发了，这个时候转发传播的因子r就可能远远小于1，第二批读者要比第一批少很多，第三批更少，然后就渐渐趋于零了。</p><p>  不仅媒体如此，任何一个产品，要想成为爆款，都需要提高转发率p这个比例，也就是大家使用后满意，然后愿意主动宣传的比例。</p><p>  第二个例子是关于核裂变的链式反应的。</p><p>  我们知道，核裂变就是一个快速运动的中子撞击原子之上后，又会裂变为一些原子和中子，随即释放很多能量。如果每一个中子又撞上一个铀原子，那么就会释放更多的能量。这样一级级撞下去就形成了所谓的链式反应，所有的铀原子都被撞开，并释放出大量的能量，这就是原子弹的原理。</p><p>  但是，运动的中子随机撞上铀原子的原子核概率是很低的，大约是百万分之一，这就是天然铀矿不会变成原子弹的原因。我们假定第一批参加核裂变的原子数量是A0，那么第二批只有A0*r个。我们知道只有r&gt;1，链式反应才能继续，而且越来越剧烈。</p><p>  那么怎样才能提高r这个值呢？很简单，首先铀纯度要高，这样中子就有更多的机会撞到铀原子上。其次，铀块的体积要足够大，这样当中子错过了第一个铀原子时，它还有机会撞到其它铀原子上。</p><p>  能够让链式反应维持的最小铀块体积被称为临界体积，它其实就是保证r&gt;1的体积。原子弹的临界体积是多少起初大家并不清楚，而这又显然无法通过试验测量出来，因为搞不好就会产生核爆炸。所幸的是，奥本海默通过数学计算准确算出了这个临界体积，这才让曼哈顿计划得以成功。从这里我们又可以看到数学的预见性。</p><p><strong>要点总结：</strong></p><p>  首先，我们讨论了级数什么时候会是无穷大，什么时候是有限的。这里面扮演关键角色的是相邻两个元素的比例r，如果r&gt;=1，即后一个比前一个大，级数就是无穷大，就是发散的。反之，如果r&lt;1，它就是收敛的，多少项加到一起，它也是一个有限的数字。</p><p>  其次，我们在生活中，有些时候希望r&gt;1，比如我们要传播消息，但是有些时候我们希望r&lt;1，比如我们不希望谣言扩散，时间会让r逐步下降，这时要做的事情是千万不要挑起新的事端，火上浇油。</p><p>  通过介绍级数，我希望大家能够对趋势有量化的体会。下一讲我们介绍一个和大家投资、贷款相关的金融问题，有关利息的问题。我们下一讲再见。</p></details><h3><span id="10-shu-lie-he-ji-shu-san-cang-zai-li-xi-he-yue-gong-li-de-mi-mi">10 ｜ 数列和级数（三）：藏在利息和月供里的秘密</span><a href="#10-shu-lie-he-ji-shu-san-cang-zai-li-xi-he-yue-gong-li-de-mi-mi" class="header-anchor">#</a></h3><p><img src="/images/53.jpg" alt=""></p><p>  今天我们讲述两方面的内容，一来是应用前两讲讲的有关几何级数的知识，分析贷款利率方面的一些注意事项，特别是要防止陷入某些坑中。有些人不知不觉多付了几倍的利息却毫无知觉。二来讲讲利率和债券投资方面的关系。</p><details><summary>...</summary><p>  不过我要先做一个提示，这讲提到的数字和计算稍微有些多，不过都是些加减乘除，不会很难，而且我也会帮大家算好。希望你坚持听完，这样能帮你省下不少冤枉钱。</p><p>  我们先来说说贷款的问题。</p><p>  假定你买房要向银行贷款120万，年化利率是6%，那么月利率是0.486%，接近0.5%，为了方便起见，我们就算是0.5%。假如你一年还清，每个月还一次，一共十二次还款，也就是12期。在12期的贷款中，每个月所还的钱该是多少呢？</p><p>  有人可能会想，利率6%，一年还清，利息就是120万x6% = 7.2万。每个月既要还本金，也要还利息，本息平摊到12个月，每个月10万本金，6千利息，一共10.6万。</p><p>  这个算法对不对呢？今天很多P2P贷款公司，就是这么和大家算账的，一些不良中介，也是这么算钱的。但是，这其实多交了很多的利息。那么我们每个月应该付多少钱呢？这取决于两种常见的还款方式我们采用哪一种。</p><p>  第一种被称为等额本金偿付，这种方法顾名思义，就是每个月还的本金数相同。在这个例子中，总贷款120万，12个月还清，每个月要还10万本金。当然，你每个月还要还利息，但其实，利息是随着本金归还后，不断减少的。</p><p>  我们先看看第一个月，你要还全部贷款的0.5%作为利息，也就是120万x0.5%=6000元的利息。因此第一个月你需要还10.6万元，这和P2P公司对你的要求一样。</p><p>  但是到了第二个月，由于你所欠的本金只有110万了，这110万的利息是5500元，比第一个月120万时的利息少了500元，因此这个月你只需要还10.55万。以此类推，第3个月你只需要付100万本金的利息，最后到第12个月，这样你所需还的利息就逐渐减少了。</p><p>  这是一个等差级数，十二个月加起来是123.9万。其中利息3.9万，而在前面P2P贷款错误的计算方法中，你支付了7.2万的利息，多付出了3万多的利息。</p><p>  刚才说了第一种等额本金偿付，我们再说第二种支付方式：等额本息偿付，就是说把贷款的本金和利息都加起来，除以还款期数，这样每个月还的本金和利息都是相同的。在这种情况下，每个月还款中一部分被用于还了利息，剩下的才用于减少所欠的本金。那么每个月要付多少钱呢？</p><p>  等额本息偿付的本金和利息计算相对复杂。具体到这个例子每月要偿付本息103,279.72元，利息共支付39,356.59元。</p><p>  相比第一种支付方式，这种方法多支付了300多元的利息，但是它的好处是前几个月的月供较低，这对需要钱的年轻人来讲更有吸引力。今天大部分银行向客户提供的是这种支付方案。</p><p>  但是，通常没有人只贷款1年，一般期限都在15年以上。如果是15年，那就是180期贷款，贷款的年利率还是6%，那么每月的月供是10,126.28元，15年下来，要支付约622,730.75元，大约是本金120万的一半。</p><p>  如果利率降到4%，那么15年算下来，大约能省23万元的利息（只要支付397,725.92元），这不是一笔小钱。由于支付的利息降低，同样收入的人可以买更贵的房子。在这个例子中，支付同样的月供大约可以买136万的房子。也就是说，利息降一点，10多年下来能省很多钱。</p><p>  相反，如果利息涨到8%，维持月供不变，只能买大约105万的房子（120万的贷款就要支付864,208.50元的利息）。很多人在买房子时，会为省一万块钱来回来去讨价还价，但是他们在接受贷款利率时，常常在不知不觉中多付出0.5%甚至更高的利率，这其实是捡了芝麻丢了西瓜。</p><p>  今天绝大多数正规的银行，在给顾客贷款时，都是采用上述方法计算和收取利息的，可以讲是明码收费，是公平的。但是，很多民间的P2P公司提供贷款时，都有很多的坑，我们不妨来看一看。</p><p>  首先，它们贷款的利息就高，比如同样是贷款120万，12期还清。他们说每个月收1%的利息，很多人算不过账来，觉得年化利息就是12%，比银行6%的利息只多出一倍，还可以接受。其实（1+1%）^12 -1 = 12.68%，比银行的利息多出1.1倍。当然这还不是最大的坑。</p><p>  其次，它们采用我们一开始说的算法计算利息，你的借期是一年，它们会让你支付120万x12.68%=15.2万的利息。而银行等额本金偿付的方式才3.9万元。</p><p>  这还没完，很多P2P贷款公司要求你先支付利息，你借了120万，它只给你120万-15.2万 = 104.8万元，然后每个月它还按照你借了120万要求你归还本金，即每月10万元。当然，如果你想要拿到120万，就得向它更多地借款，需要在合同上写137.4万，当然还的利息也就多了，共计17.4万。</p><p>  这样算下来，你比向银行借款多付了将近3倍多的利息。也就是说，如果以等额本金偿付的方式正规地贷款，这相当于借了年息27%左右的高利贷。很多人问学数学有什么用，搞清楚这里面的猫腻，就是最现实的用途。</p><p>  当然，很多人会说，我还是算不清这里面的账，没关系，只要记住下面两个原则即可：</p><p>  借钱不要去所谓的P2P一类的机构。永远记住“卖的人比买的人精”，不要试图贪便宜。</p><p>  除了借款，我们很多时候还会把钱借给别人，还想拿到更高的利息收益。比如说你存银行或者买债券，当然银行通常把债券包装成理财产品，让你搞不清它的本质。实际上，这类固定收益的投资和买国库券是没有差别的，国库券风险很小，一般被认为是无风险利率，用来对比其他理财产品，我们就以它为例来说明。</p><p>  今天中国二手债券市场并不发达，大家很少交易二手国库券。但是在美国等发达国家，人们通常会有大约20%～30%的资产放在类似于国库券的债券上，而且二手债券交易频繁，很多中间商利用大家对微小利息变化带来的债券价值变化不敏感的弱点挣了很多钱。</p><p>  各国国债付利息的方式有两种，一种是到期后连本带息归还，还有一种是半年（或者一年）付一次利息。很多人觉得前者是利滚利，更合算，这其实是误解。因为当你在每半年拿到利息后，可以再买新的国库券，依然能实现利滚利。因此，这两种方式在投资上基本上是等价的，我们就以连本带息一次归还的债券来说明。</p><p>  假如你购买10000元十年期的国库券，（复利的）年息5%，10年后到期，你可以拿到6290元左右的利息，也就是说10年下来，你的投资获利62.9%，还是不错的。</p><p>  通常发行债券的机构会把它包装成年利率6.29%的单利金融产品，这样显得投资回报更高一些，也好计算一些。中国的国库券说的利息，都是折算后的单利利息，每年实际的回报要比标称的利息少一些。</p><p>  接下来我们看两种情况。第一种情况，如果你刚买了国库券，央行就加息0.5%，新的10年期国库券的（复利）利息变成了5.5%，你手上的国库券就瞬间贬值了。这是怎么回事呢？我们不妨假设你的邻居小明在加息后买了10000元的新国库券，他10年后大约能获得17080元，比你手上面值10000元的国库券多出了大约800元的利息。因此，我们可以得到第一个结论，加息意味着同样面值的债券实际价值的贬值 。</p><p>  另一种情况，你手上的国库券会升值，那就是降息。比如央行的利率降低了0.5%，相应10年期国库券的利率也下调到4.5%，这时你手上那10000元的国库券，就相当于10489元新发行的国库券，等于瞬间升值了5%左右。因此我们可以得到第二个结论，降息意味着同样面值债券的升值 。大家如果对里面的细节搞不太清楚，记住这两个结论就好。</p><p>  未来在中国，随着金融市场的完善，债券交易也会像股票交易一样普遍，大家都需要了解这方面的知识。而这里面核心的知识，就是复利增长的数学原理。</p><p><strong>要点总结：</strong></p><ul><li><p>我们通过对比正规银行收取利息的方式，和那些打擦边球钻空子的P2P收取利息方式的不同，说明在贷款这方面有非常多的坑，你一不小心就要多支付很多倍的利息。</p></li><li><p>我们通过利率和国库券等固定收益债券价值的关系，说明了利率的调整是如何影响到我们手头上投资产品的价格的。</p></li></ul><p>这两个例子实际上是我们这几天所讲述的数学知识的应用。大家既可以看到数学在生活中非常现实的用途，更应该看到它能够帮助我们更好地看待“趋势”这个概念。比如央行通过调整看似不多的利率，就会影响很多年债券价格的趋势。</p></details><h2><span id="mo-kuai-er-shu-xue-de-gai-nian">模块二 ｜ 数学的概念</span><a href="#mo-kuai-er-shu-xue-de-gai-nian" class="header-anchor">#</a></h2><h3><span id="11-ji-tu-tong-long-fang-cheng-zhe-ge-shu-xue-gong-ju-wei-shi-me-hen-qiang-da">11 ｜ 鸡兔同笼：方程这个数学工具为什么很强大</span><a href="#11-ji-tu-tong-long-fang-cheng-zhe-ge-shu-xue-gong-ju-wei-shi-me-hen-qiang-da" class="header-anchor">#</a></h3><p><img src="/images/54.jpg" alt=""></p><p>  从这讲开始，我们进入第二模块的学习，看看人类对数的认知，是如何从具体到抽象的。</p><details><summary>...</summary><p>  上学时，数学想要考高分，老师和家长总是会说，要多做题，题做得多了自然就会了。大部分人也确实通过题海战术取得了还可以的成绩，但是往往题目稍微改变就又不会了，而有些人，做题不多，成绩却很好，这其中的差别在哪里呢？</p><p>  我们先从一个大家最熟悉的鸡兔同笼问题讲起，这是现在小学生都要学习解决的数学题，它讲起来并不复杂，但是对于智力还在发育中的小学生，多少有点费劲。今天很多老师把做法教给学生们，大家长大后基本上也忘了，所以这样学数学基本上等于白学。</p><p>  鸡兔同笼这个问题是这样说的：</p><p>  在一个笼子里，有鸡和兔子，从上面数，数出来35个头，从下面数，数出来94只脚，请问鸡和兔子各有几只？</p><p>  这个问题最初出现在中国南北朝时期的《孙子算经》。《孙子算经》给了一个不算太好理解的解法，它是这么说的：</p><blockquote><p>将所有动物的脚数除以2，也就是94/2 = 47。每只鸡有一对脚，兔子有两对脚。假设所有的动物都是鸡的话，就应该有35对脚，但事实上有47对脚。如果将一只鸡换成一只兔子的话，用47减去35，得到12，说明需要有12只鸡被换成兔子，这就是兔子的数目。知道了兔子的数目，鸡的数目也就知道了。</p></blockquote><p>  不知道你听了这个解法是否明白了，我估计第一次听的人，听了之后至少要想几分钟，或者在纸上画一画，才能明白。上述方法是《孙子算经》里给的算法，它不缺乏巧妙性，但是太不直观。不直观的结果，就是无法让人举一反三，因为这个方法只针对这个特定的问题有效。比如我把问题改一下：</p><p>  假如有若干辆三轮车和汽车（四轮），一共有20辆，有65个轮子，请问有多少辆汽车，多少辆三轮车？</p><p>  这个问题就无法用上面的方法解决。因为无论先把车辆的轮子数除以3，或者除以4，都不可以，因为65既不能被3整除，也不能被4整除。</p><p>  这道题在古代就没法解了，中国古代有不少数学著作流传下来，里面解了不少问题，但是中国的这些数学论著相比欧洲的和阿拉伯的有一个大的缺陷，就是它们给出的都是一个个具体问题的解法，而不是一套系统的方法，因此再多解法也难穷尽所有的问题。</p><p>  今天小学里教的方法在通用性方面要比古代的方法好了不少。通常学校里会这么教：</p><blockquote><p>我们假定笼子里全是鸡，那么应该有35 x 2 =70条腿。但是现在有了94条腿，多出24条，就应该是由四条腿的兔子造成的。如果我们用一只兔子替换一只鸡，就会多出两条腿，那么替换24条腿需要多少只兔子呢？24 / 2 = 12，于是就有12只兔子，剩下的就是鸡。</p></blockquote><p>  这个方法可以直接解决上面的汽车和三轮车的问题，具体做法你可以想想，自己算一下：</p><blockquote><p>我们假定都是三轮车，那么应该有20 x 3 = 60个轮子。现在有了65个轮子，多出了5个，它们应该是汽车造成的。如果用一辆汽车换一辆三轮车，就会多出1个轮子。现在多出了5个轮子，因此应该有5辆汽车。</p></blockquote><p>  今天在学校里，如果遇上一个好老师能把鸡兔同笼问题讲透，孩子是能做出汽车和三轮车问题的。当然依然会有一些同学不会做，因为他们只是记住了鸡兔同笼算法，不会应用到其他问题上。</p><p>  这些学生要考满分，只好多做题，把三轮车的题目做一遍，再把其他相似的题目也做了，于是就很辛苦。但是即使能够灵活运用鸡兔同笼的解法，大部分人也还是不能解决所有这类问题，比如我再出一个题还是做不出来：</p><p>  红皮鸡蛋5元3个，白皮鸡蛋3元2个，小明花了19元，买了12个鸡蛋，问红皮的和白皮的各几个？</p><p>  这个问题其实是鸡兔同笼问题的变种，但是用上面改进的鸡兔同笼的解法也不管用。对于这个问题，有兴趣的同学可以在留言区讲讲你的解法，前提是不要用方程。</p><p>  那么能不能针对所有这些问题，提供一个寻找答案的思路呢？美国人的教法很有趣，下面我就和你分享一下。</p><p>  首先，在小学他们不教学生那些需要技巧的解法。对于鸡兔同笼问题，就是列表的笨办法。比如，在第一个例子中，他们先让学生们明白，兔子的数量不能超过94/4 = 24只，然后就列一张表，从24只开始往下试验，看看脚的数量有多少：</p><p><img src="/images/55.jpg" alt=""></p><p>  我当时看了他们的教科书，就想美国人真笨，果然数学学不好。</p><p>  但是发现他们再做其它相似的问题时，就可以从上述过程中受到启发，比如前面的鸡蛋问题，美国人也是列表：</p><p><img src="/images/56.jpg" alt=""></p><p>  事实上，只要是有整数解的各种二元一次方程的问题，都可以用列表这种笨办法解决。也就是说，美国小学的做法实际上是教给了大家一个很笨的，但是很通用的工具。这样，能解决一个就能解决很多，虽然办法很笨，很花时间，但总不至于让孩子们无从下手。</p><p>  至于那些解题技巧，他们很少在小学教，省得大家学不会，有挫败感。那些聪明的孩子，可以去上课外班。上述笨办法的另一个好处是，学生们在列表的过程中，更感受到数字变化的趋势，慢慢地就会知道大约从多少开始试验，而不是永远从零开始。</p><p>  相比之下，中国学校里教的那些聪明办法，常常和具体问题有关，除非是悟性很好的学生，普通孩子并不容易举一反三，因此家长总是责怪孩子笨。</p><p>  当然，在这一类问题中如果数字很大，列表就不太现实了。这时，老师会告诉大家，别着急，到了中学（或者小学高年级），学了解方程自然就会了。</p><p>  很多人在离开学校之后，除非辅导孩子，可能一辈子不会再解方程了，以至于会质疑为什么要在中学学习它。因为他们并不知道，方程就是用来解你之前不会的难题的，它是一个非常强大的解题工具，它可以让我们脑子想不清的很多数学问题变得非常直观、简单。</p><p>  还是以上面的鸡兔同笼问题为例。我们只要假设鸡有X只，兔子有Y只，然后列这样两个方程即可：</p><center>X+Y=35<p>2X+4Y=94</p></center><p>对于汽车和三轮车的问题，相应的方程是：</p><center>X+Y=20<p>3X+4Y=65</p></center><p>  对于鸡蛋的问题，我们可以把问题稍微变一下，也是一样的解法，解法我放进文稿了，你可以先自己试着做一下，再看答案。</p><p>  解：红皮鸡蛋3个一盒5元，白皮鸡蛋2个一盒3元，一共花了19元买了12个鸡蛋，问红皮和白皮的各几盒？我们假设它们为X和Y，就有下面的两个方程：</p><center>3X+2Y=12<p>5X+3Y=19</p></center><p>  X和Y分别是2和3，于是我们就知道两盒红皮鸡蛋有6个，白皮三盒也是6个。</p><p>  上述三组方程，对于高年级的学生来讲，做出来是分分钟的事情。如果你不教会他们方程这个工具，让他们苦思冥想，这几个问题还真有点绕脑筋。从这三个例子中，我们体会一下方程是什么，它是一种工具，这种工具有一整套合乎逻辑的解法，只要通过一个问题掌握这个解法，就能把成千上万的问题解决掉。这才是学习数学的正道，而不是做更多的题。</p><p>  那么如何把形形色色的题目抽象成同一类题目呢？这就涉及做数学应用题的核心关键了，就是要把用自然语言描述的现实世界的问题变成用数学语言描述的问题，比如列出方程。人的作用其实相当于一种翻译器，做练习题就是练习翻译，只要现实世界的问题变成了数学的问题，就能用现成的工具解决它们。</p><p>  学习数学也好，物理也好，其实关键不在于刷多少道题，而是在于理解它们中工具的作用，然后学会把生活中的问题用数学或者物理学的语言来表达，剩下的就交给工具了。</p><p>  多年前我问张首晟教授，为什么老一辈（当时50岁以上）的理论物理学家很少能再发表具有轰动性效应的论文？他说他们的数学工具不够先进，因为他们读研究生的时候学的数学和新生代科学家相比多有不足。</p><p>  对此我也深有体会。当我们掌握了中学的一些数学工具后，小学的各种数学难题就变得非常容易。当我们掌握了微积分这个工具后，很多中学的数学难题就不值一提了。我们常说，工欲善其事，必先利其器，这就是说明了工具的力量。</p><p>  中国古代在数学上有很多贡献，但大多集中在解决一个个具体的难题，而不是创造工具。相比之下，无论是古希腊还是后来的伊斯兰文明，在这方面贡献都要大得多。</p><p>  我们今天说的解方程，无论是有很多未知数的一次方程（比如我们前面给的三个方程组，它们的未知数的次数都只有一次），还是一元二次方程，比如X^2 + 2X = 3，在阿拉伯伟大的数学家花拉子密的著作《代数学》中都有详细的论述，只要读了他的这本书，一大堆数学问题就都会做了。</p><p>  相比之下，读那些只涉及到具体问题的书，就算读书破万卷，遇到新的问题还是没法解决，因此，学会把具体问题抽象成模型，才能解决更多更难的新问题。</p><p><strong>要点总结：</strong></p><p>  我们用鸡兔同笼问题，说明了数学的本质是工具。美国人为了强调数学的工具性，在小学教学生们笨办法，但是从工具的角度讲却是一个好工具，到了中学，就有解方程这个工具。</p><p>  相比之下，我们学了很多针对具体问题的解题技巧，其实用处远没有想象的大。在学习数学时，我们最需要做的，就是将生活中的某些问题，由自然语言翻译成数学语言，然后用相应的工具来解决。</p><p>  最后介绍一下下一讲的内容，数学发展到花拉子密的时候，已经有了解决一元二次方程的公式了。但是在接下来的几百年里，没有人能够找到诸如X^3 + X + 1 = 0这样的一元三次方程的解法。当然最终它的解法还是被发现了，至于是谁发现的，则是数学史上一桩著名的公案，而这个方法的发现，你还可以看到数字的概念是如何从实数扩展到虚数的。</p><p>  欢迎你把这篇文章分享到自己的家长群，帮助家长朋友们和自己的孩子一起重新理解数学。我们下一讲再见。</p></details><h3><span id="12-san-ci-fang-cheng-shu-xue-shi-shang-de-fa-ming-quan-zhi-zheng">12 ｜ 三次方程：数学史上的发明权之争</span><a href="#12-san-ci-fang-cheng-shu-xue-shi-shang-de-fa-ming-quan-zhi-zheng" class="header-anchor">#</a></h3><p><img src="/images/57.jpg" alt=""></p><p>  我们上一讲说了方程是一个能办具体问题，等量转化成类型问题的好工具，我们在中学也学了一元二次方程的解法，但是当学到一元三次方程时通常就被卡住了，因为没有通用解法，只有那些特殊方程用巧妙的办法才能把解凑出来。</p><details><summary>...</summary><p>  现在回想起来，大家可能有疑问，那一元三次方程的解法是否有现成的公式可以套用呢？确实有！但是为什么世界各国的中学都不讲呢？因为这个公式太复杂，而且大家今天有了计算机，只要理解这一类方程的意义，让计算机帮助解决就好了。</p><p>  但是在过去没有计算机，大家对这一类问题束手无策，因此只能靠技巧来解个别具体的方程。直到15世纪，人类还不知道它的通解，当时在欧洲，谁能解几个三次方程，就算得上是数学家了。</p><p>  欧洲早期最著名的大学是意大利的博洛尼亚大学，它也是全世界最早的大学。该大学里面有一个叫费罗的数学家，他有一个学生叫菲奥尔，这个学生既不聪颖，也不好学，看样子将来是找不到工作了。</p><p>  费罗临死前就对他说，你将来怎么办啊，要不为师传给你一些秘诀，你将来就拿它去找最有名的数学家挑战，如果赢了他，也便能在数学界扬名立万站住脚了。不久费罗老师就去世了。</p><p>  菲奥尔在老师死后，果然混得不太好，于是就拿出了老师的秘籍，去找一个叫做塔尔塔利亚的数学家挑战，“塔尔塔利亚”是意大利语“口吃”的意思，这个数学家的真名叫做尼科洛·丰塔纳，但是今天大家都很少提及他的真名，而用他的绰号。</p><p>  当时欧洲数学家之间盛行挑战，就是各自给对方出一些自己会做的难题，如果自己做出了对方的题，同时把对方难倒了，就算赢了。1535年，菲奥尔听说塔尔塔利亚会解一些三次方程，当时大家还不知道三次方程的通解，解具体的三次方程都靠玩技巧，就给他出了一堆难题，像这样的一些：</p><center>$ x^3+8x+2=0 $<p>$ 2x^3+7x+5=0 $</p></center><p>  看了这些题目你会发现，它们都大同小异，都是解三次方程，而这些方程中都没有二次项。我们不妨将这些三次方程称为第一类的三次方程。费罗老师给菲奥尔留下的“九阴真经”，其实就是这一类方程的解法，费罗在发现了这样方程的通解后，除了悄悄告诉了自己的女婿，以及这位不上进的学生，没让旁人知道。</p><p>  在拿到菲奥尔给的这些难题后，塔尔塔利亚也毫不客气地给对方出了一堆难题，也是求解三次方程，但形式上略有不同，诸如下面这样：</p><center>$ x^3+x^2-18=0 $</center><p>  它没有一次项，但是有二次平方项，我们不妨将它们称为第二类的三次方程。这一类三次方程的解法，塔尔塔利亚已经想出来了。双方约定30天为期，并且压上了一笔钱做赌注，于是比赛算是正式开始。</p><p>  菲奥尔看了一眼对方的题，知道自己做不出来，也就根本没打算做。然后他每天晚上跑到塔尔塔利亚的窗外去侦察，看看对方进展怎么样。菲奥尔的如意算盘是，对方也做不出来自己的题，于是双方打平，这样菲奥尔就一战成名，比肩塔尔塔利亚了。</p><p>  塔尔塔利亚并不知道这些，他就每天从早到晚在书房里做数学题。眼看30天的期限快到了，塔尔塔利亚还没有解出来，菲奥尔暗自高兴，这场比赛看似能打平。然而，皇天不负有心人，塔尔塔利亚最后经过努力解出了对方的难题，赢得了比赛，菲奥尔自然就退出了历史舞台。在这之后，塔尔塔利亚又花了6年时间，完全解决了一元三次方程的问题，这是后话了。</p><p>  从1535年开始，就有很多人想从塔尔塔利亚那里学习三次方程的解法，但是塔尔塔利亚就是不说。后来有一位叫做卡尔达诺的数学家，不断恳求塔尔塔利亚，想知道第一类和第二类一元三次方程的解法，后者受求不过，让卡尔达诺发下毒誓保守秘密后，将第一类三次方程的解法告诉了他。</p><p>  卡尔达诺有一个学生叫费拉里，这个人很厉害。这师徒俩在塔尔塔利亚工作的基础上，很快发现了所有一元三次方程的解法，我们可以把它称为是通解。他们俩自然兴奋不已。但是由于之前发了誓要保守秘密，因此他们不能向外宣布自己的发现，这让他们非常郁闷。</p><p>  几年后，也就是1541年，塔尔塔利亚也发现了所有的一元三次方程的解法，但是他依然保守秘密，不和别人说。</p><p>  1543年，也就是塔尔塔利亚和菲奥尔的挑战赛过去八年之后，卡尔达诺和费拉里访问了博洛尼亚，在那里他们见到了费罗的女婿，得知费罗早就发现了第一类和第二类一元三次方程的解法，这下让这师徒二人兴奋不已，因为觉得憋在心里的话终于可以说出来了。</p><p>  于是卡尔达诺决定不需要再恪守对塔尔塔利亚的承诺了，便于1545年将所有一元三次方程的解法发表了，这本书的中译名叫做《大术》（Arts Magn，就是《数学大典》的意思），这是过去关于代数学一本非常重要的书。</p><p>  在书中，卡尔达诺讲，费罗是第一个发现了一元三次方程的解法的人，他所给出的解法其实就是费罗的思想。同时在三次方程解法的基础上，费拉里还给出了一元四次方程的一般性解法。</p><p>  塔尔塔利亚知道了这件事，当然对卡尔达诺极为愤怒，认为他失信。失信在当时学术圈是一件了不得的事情。不过卡尔达诺解释道，他没有发表对方的工作，而发表的是费罗很多年前的工作，因此没有失信。</p><p>  这件事在当时就成为了一件很轰动的事情，而双方各执一词，旁人也分不出是非，于是只好采用“决斗”的方式来解决，当然，这种决斗是数学家们比拼智力，而非武力相向。</p><p>  卡尔达诺这一边决定由学生费拉里出战，他和塔尔塔利亚各给对方出了些难题，结果费拉里大获全胜。从此塔尔塔利亚就退出了学术圈。不过今天三次方程的标准���法公式依然被称为费拉里-塔尔塔利亚公式，大家并没有完全否认他的功绩。</p><p>  说到这里有人可能会问，既然一元三次方程有标准的解法公式，为什么我们中学的时候，老师不讲，而让我们费劲巴拉地用各种技巧来算呢？更糟糕的是，解每一道题的技巧都不一样，以至于我们学习得特别辛苦。</p><p>  要回答这个问题，我先把标准解法的公式，即费拉里-塔尔塔利亚公式给大家看一眼：</p><p><img src="/images/58.jpg" alt=""></p><p>  要算出它的第一个解，需要先算下面三个中间变量。</p><p><img src="/images/59.jpg" alt=""></p><p>  然后再根据这三个中间变量，按照下面的公式算出第一个解。</p><p><img src="/images/60.jpg" alt=""></p><p>  有了一个解，三次方程就可以简化为二次的，接下来就好解决了。</p><p>  我估计你看了上面这一堆密密麻麻的公式，头已经开始大了。因此，中学不教这个公式是对的，否则会把学生们都吓回去。但是，老师又不能完全不讲怎样解一元三次方程，于是学校就教了一大堆解特殊方程的方法，聪颖用功一点的学生学得多一些，成绩就好一些，条件差的学生学会的技巧就少一些。但是那些技巧你无论学多少，都很难举一反三。</p><p>  相比之下，我倒觉得美国中学的教法更好一些，它除了教学生们最简单的，谁都能学会的技巧，还有就是让学生们使用一种叫做Mathematica的软件工具来自动解决。</p><p>  根据我个人的体会，今天学习数学，重要的是把实际问题变成数学问题，然后知道如何利用各种软件工具来解决，而不是花很多时间学一大堆无法举一反三的技巧。讲到Mathematica，我还要说一句题外话，这款软件可以推导你能遇到的几乎所有数学公式，他的编写者沃夫兰姆是一位真正的天才。20岁便博士毕业了。</p><p>  因此我想对很多家长说，不要高估自己孩子的智商，当然，也不要埋没他们在某些方面的天赋。大部分人老老实实学好数学的基本方法，理解其中的思维方式最重要，不要苦练解题技巧。需要技巧的时候，我们应该善于利用沃夫兰姆的大脑，不要自己傻推公式。</p><p>  现在，我想让你再看一眼上面这一大堆密密麻麻的公式，把注意力集中在那个根号上。我们知道，如果根号里的数字是负数，那么它在过去是没有意义的。在解二次方程时，我们可对这个问题视而不见，直接宣布它没有实数解即可。</p><p>  但是三次方程是一定有实数解的（原因以后再讲），因此这个根号里面负数的问题就回避不掉，为此，数学家们就不得不正视这个问题，并且引入了虚数的概念。关于虚数我们明天会详细讲，今天只是通过这段历史，介绍它的来源和存在的必要性。</p><p><strong>要点总结：</strong></p><p>  首先，通过数学史上这段著名的公案，说明了数学定理发明的过程。通常先有引理，你可以把引理看成是一个简单、辅助性的定理，它们存在的目的是为了后面证明定理。在一元三次方程的解法里，无论是费罗对第一类三次方程，还是塔尔塔利亚对第二类三次方程的解法，只能算是引理，它们能解决部分问题，但不具有普遍意义，不能算定理。</p><p>  后来卡尔达诺、费拉里和塔尔塔利亚发现的对于任意三次方程的解法，则可以看成是定理，它是建立在引理之上的。定理具有里程碑的意义，但它不是凭空产生的。数学的发展是层层叠加的，学习数学也应该如此，理解这一点是学习好理科课程的关键。</p><p>  其次，我们要特别强调数学是个工具，学习数学是练习自己使用工具的能力，花很多时间在学习小的解题技巧上不值得。因此不要因为掌握不了一个小技巧而沮丧。最要注重学习的是概念，以及概念之间的联系，然后能够把现实的问题转化为数学问题。接下来怎么解决，工具是很多的。</p><p>  那么三次方程的解到底是怎么得出来的？这就需要人类再次抽象对数的认识，虚构出一个认知工具来，我们下一讲再见。</p></details><h3><span id="13-xu-shu-xu-gou-zhe-ge-gong-ju-you-shi-me-yong">13 ｜ 虚数：虚构这个工具有什么用</span><a href="#13-xu-shu-xu-gou-zhe-ge-gong-ju-you-shi-me-yong" class="header-anchor">#</a></h3><p><img src="/images/62.jpg" alt=""></p><p>  我们上一讲讲了一元三次方程的解法，说里面可能涉及到一种并不存在的虚数。也就是说它们自身的平方是负数。</p><details><summary>...</summary><p>  虚数在现实中显然不存在，我这讲会通过这个例子告诉你，数学家是如何虚构一个现实中不存在的概念，解决现实问题的。</p><p>  我们在初中学到平方根这个概念时，老师会说，只有正数和零才有平方根，没有哪个数字自己乘以自己会等于负数。在解二次方程时，我们可能会遇到根号里面有一个负数的情况，但是老师说，不用管它，我们就认定它无实数解即可。</p><p>  但是当学到了三次方程时，这个问题就回避不了了，因为根据上一讲介绍的公式，即使一个有实数解的三次方程，在求解的过程中，也会遇到要对负数开根号的情况。比如下面这个方程：</p><center>X^3-15X-4=0</center><p>显然X=4是一个解。</p><p>  但是，如果我们利用昨天说的费拉里-塔尔塔利亚公式算，得到的是这样一个解，听音频的朋友可以看一眼，你不用关注细节，只要留心里面有√-121就好。</p><p><img src="/images/63.jpg" alt=""></p><p>  于是给负数开根号这件事就绕不过去了。数学家们只好虚构出一个数，让它的平方等于-1，这个数我们常常把它写成字母i，就是拉丁语中imagini（相当于英语中的image）“影像”一词的首字母，它代表非真实、幻影的意思。</p><p>  有了这个人造的、虚幻的数，上面那个复杂的一堆根号的式子就能计算下去了，而且算出来就是4。你可能会问其中的虚数去哪里了，很有意思的是，它们正负抵消了，数学基础比较好的同学可以自己推导一下，算是留给你的思考题。</p><p>  这件事你如果细想是很有意思的。如果我们真实的世界里有一个三次方程，比如给一些限制条件后计算一个长方体的尺寸，也就是解三次方程的问题，卡尔达诺等人找到了一个公式，可以计算出问题的答案，但是算到一半你就遇到一堵墙越不过去了，于是你引入一个不存在的工具，用了一下就翻过墙了。</p><p>  这在哲学上其实很有意思，<strong>明明是现实世界的问题，而且在现实世界里也有答案，但是却无法直接得到，非要发明一个不存在的东西作为桥梁。</strong></p><p>  怎么能够形象地理解虚数这种抽象概念的作用呢？我们的数学课基本上不讲，老师只是说，记住它的定义就好，回头学生们就一头雾水了。我通常用三个例子来形容它的作用。</p><p>  一个是化学中的催化剂。我们知道，催化剂在化学反应完成前后是不改变的，它只是起到一个媒介的作用，但是没有它，化学反应要么特别慢，要么干脆进行不下去。</p><p>  另一个例子不算太确切，但是好理解，就是传话筒。我们经常看到这样的现象，夫妻俩吵架后，谁也不愿意和对方说话，但是都清楚这个交流不能中断，要继续下去，于是就找孩子带话，比如教孩子说：“去，和你妈说明天的家长会我去，她就不用去了。”孩子把这个意思传递后，又带回一句话：“妈妈说，你要是去开家长会，她就先回家做饭了。”</p><p>  这样传几次话，可能夫妻间的问题就解决了。在这个过程中，夫妻间的问题不涉及到孩子，孩子在传话时甚至不明白其中的含义，但是没有这个局外的传话筒，夫妻之间的问题可能就解决不了了。</p><p>  最后一个例子是虫洞。我们接下来就开一下脑洞。假如你和一个相爱的人在同一个宇宙中，但相隔几十光年，你想对她说一句我爱你，但哪怕你搭载光速飞船去找她，她听到的时候都已经老了。</p><p>  现在有一个虫洞，你可以从中穿过去，在瞬间到达另一个平行宇宙中，然后再从另一个虫洞穿回现在的宇宙，这也是瞬间的事情，这样你就能很快到她身边了。你们二人本来是在同一个宇宙中，但是却要依赖另一个和你们无关的宇宙来回穿越。</p><p>  虚数也是如此，在上面的式子中，我们把它创造出来，又把它正负相抵消，该得到实数的答案依然是实数的。从更广义的角度讲，很多数学工具都是如此，它们并非我们这个世界存在的东西，而是完全由逻辑虚构出来的。但是我们现实世界的事情，却要用这些虚构的工具来解决。</p><p>  那么虚数除了解三次方程还有什么用？它的用途可以归结为三个层面。</p><p>  **第一个层面是对于数学本身的影响。**引入虚数的概念后，数学的一些逻辑上可能的漏洞就被补上了。</p><p>  比如说，在实数的范围内，X^2+1=0是无解的，这样一来，有的多项式方程有解，有的无解，数学就不完美了。引入一个虚拟的概念，虚数i，就让所有的方程都变得有解了。更漂亮的是，引入虚数的概念后，所有的一元N次方程都会有N个解，没有例外。</p><p>  **第二个层面是作为工具的作用。**有了虚数之后，很多复杂的数学问题，可以用简单的方法解决，这就如同前面介绍的三次方程的解法问题。这个问题虽然引出了虚数的概念，但是并不是它最大的用途。虚数作为数学工具最大的用途，可能是便于将直角坐标变成极坐标。</p><p>  关于这两种坐标我们后面还会讲，简单地讲，在飞行、航海等场景里，极坐标更方便使用，比如我们说往两点钟的方向飞行20公里，这就是极坐标的描述方式。在极坐标的计算中，如果只用实数，非常复杂，如果引入虚数，就极为简单。</p><p>  **第三个层面是应用层面。**量子力学、相对论、信号处理、流体力学和控制系统的发展都离不开虚数。</p><p>  通过虚数这个例子，我首先想说的是，人类可能是唯一一个能够构想出不存在的事物的物种，这个能力对我们来讲非常重要。在我们生活的世界里，存在着大量的构想出来的东西。比如早期的人类要靠宗教崇拜团结起来，虽然最后一起去打仗，去探险的都是人，但是要没有宗教，人和人直接沟通，达不到团结的目的。</p><p>  今天虽然大家不太需要宗教了，但是很多虚拟的概念已经深入我们人心，比如法律、有限公司、法人团体等概念便是如此，它们在自然界中并不存在，只是人们脑子里构建出的概念，但是如果没有它们，这个社会就运行不下去。当我们习惯于使用这些虚构的概念后，就会把它们真实化，感觉和真的一样。</p><p>  为了让大家更好地理解这一点，我们不妨看一个法律学的概念——法人。</p><p>  在早期的罗马法中，提出了法律主体的概念，它最初只涉及到自由人，后来因为要处理经济纠纷，就把一些机构看成是法律的主体，当作人一样看待，这就是法人概念的来源。这些法人，其实就相当于数学中所说的虚数的概念。</p><p>  我们今天和一个公司打官司，其实在打官司的过程中接触到的还是人，但是你不会去告里面某个具体的人，而是针对这个虚构出的组织。当你打赢这个官司后，是里面具体的人执行对你的赔偿，但是你拿到的赔偿却是法人这个机构给你的。这就如同解方程时，我们需要借助于虚数，得到实数的解一样。</p><p>  今天，衡量一个人认知水平的一个方法，就是看他接受虚拟概念的能力有多强，如果他只停留在看得见摸得着的东西，这个人的水平就不是很高。我们经常说那些只知道买房置地，收藏奢侈品的人是土财主，其实也是这个道理。</p><p>  其次，虚数的出现，标志着人类对数这个概念认识的进步，特别是从形象思维到抽象思维的进步。</p><p>  人类早期认识的数字都是正整数，1，2，3，4……因为大家接触到的周围的世界就是这样实实在在一个又一个的东西。事实上除了古印度，其他文明在早期数字中都没有零这个数，因为零这个概念比较抽象，人类从有数字开始花了几千年才搞明白。</p><p>  接下来有了数字就要做运算，两个自然数相加或者相乘，结果还是自然数。但是，到做减法和除法时就出现了问题，因为2-3=？，2/3=？在自然数中找不到。于是人们就发明了负数和分数（就是有理数）的概念。这两个概念就比自然数要抽象一些了。</p><p>  很多人觉得数学越到后来越难学，就是没有能突破抽象思维的瓶颈。有了正负的概念，有了分数的概念，就形成了有理数的概念，加减乘除和乘方五种运算就都没有问题了。自从毕达哥拉斯定理被发现，人类就不得不面对开方这件事，就不得不定义出无理数。</p><p>  再往后，又因为要对负数开方，便发明了虚数的概念。实数和虚数合在一起，就形成了复数。我把人类认识数的过程用一张图表示出来，它是从中心往四周扩散的：</p><p><img src="/images/64.jpg" alt=""></p><p>  那么复数有什么用呢？为什么要搞出这么一个在现实世界中完全不存在的概念呢？仅仅是为了让开方运算变得完备么？当然不是。复数是一个非常强大的数学工具，使用这个建立在现实生活中所不具备的事实的基础之上的数学工具，可以解决很多现实世界里的问题。</p><p>  这句话可能听起来有点绕口，换一种方式讲是这样的，复数的基础在现实世界里并不存在，但是建立在不存在基础上的工具，却能解决实际问题。</p><p>  比如我们使用的三相交流电是实实在在地存在的，它里面的很多问题，用复数这个工具解决，要比用实数加上三角函数解决起来容易得多。实际上，涉及到电磁波的几乎所有问题，都需要使用复数这个工具来解决。</p><p>  对于今天的内容，你如果体会到像虚数这样媒介工具的作用，以及通过数字的扩展历史，体会到人类认知升级的过程，就算是掌握精髓了。</p><p>  下一讲，我们再继续突破认知，去理解无限的世界。欢迎你把文章分享到自己的家长群，帮助家长朋友们重新理解数学，帮孩子把数学变得更容易。我们下一讲再见。</p></details><h3><span id="14-wu-qiong-wo-men-wei-shi-me-nan-yi-li-jie-wu-xian-de-shi-jie">14 ｜ 无穷：我们为什么难以理解无限的世界？</span><a href="#14-wu-qiong-wo-men-wei-shi-me-nan-yi-li-jie-wu-xian-de-shi-jie" class="header-anchor">#</a></h3><p><img src="/images/65.jpg" alt=""></p><p>  我们在前几讲的课程中讲了人在数学上认知进步的过程，从具体数字、具体问题到用方程解决类型问题，用抽象的虚数解决现实问题。今天我们看看人类怎样进一步突破对数的认知局限，动态认识数的。当然，讲突破之前，先要讲讲人是如何受困于认知局限性的。</p><details><summary>...</summary><p>  庄子有句话：“夏虫不可以语于冰者，笃于时也。”意思是说，夏天的虫子无法理解冰雪，因为它受限于生命的时长，等不到能看见冰雪的冬天就死了。其实在庄子看来，人的生命也很短暂，认识也很有限。</p><p>  他说，“吾生也有涯，而知也无涯”，就是说用短暂、有限的生命，无法理解无限世界的事情。不过，人具有想象力，虽然看不到无限的事物，却能想象出一些规律，并且通过逻辑保留合理的。<strong>有些人做到了这一点，他们的认知水平就比其他人高出好几个层次了。</strong></p><p>  我们今天就从无穷大说起，说说认知升级的事情。</p><p>  说起无穷大，先要说大数字。小孩子们常常爱比谁说的数大，比如一个孩子说出一百，另外一个孩子说一万。别的孩子就问了，一万有多大？他说，一万就是一百个一百，别人只好不说话认输了，因为孩子们还是有基本逻辑的，知道一百个一百显然比一个一百多。</p><p>  当然，过两天输了的孩子跑去问家长，从家长那里知道一亿这个数，他就又赢回来了。这时，如果输了的孩子脑瓜子灵，会说出两亿来翻盘，最后孩子们就不断地喊，一亿亿亿亿亿亿……，最后是肺活量最大、气最长的那个孩子赢。</p><p>  接下来，可能又有孩子要回去问家长，家长告诉他无穷大，这回，他就可以回去秒杀那些一亿亿亿……不断喊下去的孩子们了。但是你要问他无穷大是多少，谁也说不出来，大家只是接受了这个虚构的概念，认为它是世界上最大的数。</p><p>  下面我就问大家一个问题，无穷大是一个数吗？它可以被看成是数轴的终点吗？它在数学上和某个具体的大数一样大吗？</p><p>  这些很基本的问题很多人在大学里学完高等数学其实也没有一个明确的概念，在绝大多数人心目中，无穷大是一个数，只是它比你能想象的数更大而已，人们依然会用理解一些具体数字的方式去理解它。无穷大的世界和我们日常认知的世界完全不一样。</p><p>  当然人类也是直到现代才开始正确认识无穷大。1924年，大数学家希尔伯特讲了一个旅馆悖论，让人们重新认识无穷大的哲学意义。他的悖论是这样讲的：</p><p>  假如一个酒店有很多房间，每一个都住满了客人，这时你去酒店问，还能给我安排一间房子吗？老板一定说：“对不起，所有的房间都住上了客人，没有办法安排您了。”</p><p>  但是，如果你去一家拥有无限多个房间的旅馆，情况可能就不同了。虽然所有的房间均已客满，但是老板还是能帮你“挤出”一间空房的。</p><p>  他只要这样做就可以了。他对服务生讲，将原先在1号房间的客人安排到2号房间，将2号房间原有的客人安排到3号房间，以此类推，这样空出来的1号房间就可以给你了。类似的，如果来了十个、八个人，也可以用这种方式安排进“已经满客”的酒店。</p><p>  接下来的问题来了，既然每个房间都被现有的客人占据了，怎么又能挤下新的客人？因此我们说这是悖论。但是“旅馆悖论”其实并不是真正意义上的数学悖论，它仅仅是与我们直觉相悖而已。</p><p>  在我们的直觉中，每个房间都被占据，和无法再增加客人是等同的，但这只是在有限的世界里的等价性，在无穷大的世界里，数学中的很多逻辑都需要重新梳理一遍。我们在有限的世界里得到的很多结论，放到无穷大的世界里，需要重新检验，有些能够成立，有些不成立。</p><p>  比如说在有限的世界里，一个数加上1就不等于这个数了，因为比它大1，但是在无穷大的世界里，这条结论就不成立，因为无穷大加1还是无穷大，就如酒店悖论中的那个酒店一样，再增加一个客人，酒店依然能够容纳得下。</p><p>  事实上，在希尔伯特做完那个报告后，全世界数学家不得不回去把所有的数学结论在无穷大的世界里又推导了一遍，看看有没有什么漏洞。</p><p>  在上面的问题中，客满的、无穷多房间的旅馆，不仅可以增加有限个客人，甚至能增加无限个新客人。那么当无限的客人来住店，怎么办呢？具体的做法是这样的，我们让原来住在第1间的客人搬到第2间，第2间的客人搬到第4间，第3间的搬到第6间。</p><p>  总之，就是让第N间的客人搬到第2N间即可。这样就腾出无数间的客房安排新的客人了。我们知道一万乘以2是两万，不等于原来的一万，但是无穷大乘以2还是无穷大，并不是两个无穷大。</p><p>  无限集合的性质与有限集合的性质并不相同。对于拥有有限个房间的旅馆，其偶数号房间的数量显然总是小于其房间总数的，比如1万个房间，偶数号的有5000间，不等于总数。然而，在无穷房间的旅馆中，偶数号房间的数量与总房间数量是相同的。</p><p>  类似的，我们可以证明一条长5厘米的线段上的点，和一条长10厘米线段上的点是“一样多”的。这个证明也很简单：</p><p><img src="/images/66.jpg" alt=""></p><p>  在图中，下面的线段长度是10厘米，上面的是5厘米。我们将它们平行放置，于是将它们两端相连（虚线），就会交会到一个点S处。接下来，对于10厘米长线上的任意一个点X，我们将X和S相连，就和5厘米短线有一个交点，我们假设为Y，这就说明长线上的任意点，在短线上都可以找到对应点。</p><p>  因此，短线上的点应该不少于长线上的点。这样，在无穷大的世界里，我们可以认为10厘米线段上点的数量和它的一个子集，即5厘米线段上的点是“相同的”。当然更准确的说法是基数相同。</p><p>  接下来就有一个问题了，不同类型的无穷大，比如整数的个数，或者10厘米长线段上的点数，它们彼此能比较么？答案是可以，这里面的细节我们省略了，在这里我直接给大家答案，就是一根很短的线段上的点数，要比所有的有理数数量都多，前者的基数比后者大。我知道这可能有点颠覆你的直觉，但这个结论是正确无疑的。</p><p>  讲到这里，我们一开始的问题，“无穷大是不是一个特别特别大的数？”现在有答案了。它不是一个具体的数，它和万亿、googol数（10的一百次方）等等都不同。它不是静态的，而是动态的，它反映一种趋势，一种无限增加的趋势。在增大的过程中，有的无穷大会比其它的更大，因为它变化的趋势比其他的无穷大更快，这一点我们后面会仔细讲。</p><p>  对于无穷大的概念，关键要理解它是动态变化到了最终尽头的描述。事实上，无穷大（和以后要介绍的无穷小）代表着一种新的科学世界观，就是让我们关注动态变化的趋势，特别是发展变化延伸到远方之后的情况。</p><p>  上面这些关于无穷大世界的特点可能有些颠覆你的认知，这并不是说你原先的认知有问题，而是说我们在有限世界里得到的认知太狭隘了，相比浩瀚的宇宙和人类的知识体系，我们的认知可能就如同夏天的虫子，受限于我们的生活环境。这也是我们比较接受通识教育的原因，因为这样可以让我们以最快速度走出我们认知的围墙。</p><p>  当然，有些同学可能会问，了解无穷大世界这件事情有什么现实的意义？它的意义很多，这里我不妨说一个具体的例子。</p><p>  我在《谷歌方法论》中讲到了关于计算机算法的衡量标准。假如有三个完全相同功能的算法，A、B和C。</p><ul><li>算法A要进行100,000*N次运算；</li><li>算法B要进行N^2次运算；</li><li>算法C要进行N次运算。</li></ul><p>请问哪种算法好？</p><p>  很多人会说，当然是算法C好，至于A和B，要看情况。如果N&lt;100,000，那么算法B更好，否则就是算法A好。比如，N是20万时，A方案就相当于10万<em>20万，B方案相当于20万</em>20万，可见B是很大的。</p><p>  但是，在计算机科学中，衡量两个算法的复杂度时，只会考虑这两种算法在处理近乎无穷大的问题上的表现，也就是N趋近于无穷大的情况。因为它关心的是，当问题越来越复杂后，每一种算法所需要消耗的计算机资源（比如计算时间）的增长趋势。这样一来，算法B显然是计算量最大的。</p><p>  至于两个算法在复杂度上只差出常数倍，在计算机科学上就认为它们是等价的。对计算机科学家们来讲，将一个算法从平方的复杂度降低到线性，这是捡西瓜的事情，将一个线性复杂度的算法的计算量再减小几倍，这是捡芝麻的事情。这些内容我们在后面会更仔细地分析。</p><p><strong>要点总结：</strong></p><p>  首先，我们通过希尔伯特旅馆悖论，说明生活在有限世界的人，其实很难想象无穷大的世界，在那里，很多规律和有限世界是不同的。比如说，在无穷大的世界里，部分可以完全和整体等价。</p><p>  因此，我们不能以有限的认知，去理解无限的事物，也不能把那些从很少的经验中得到的结论，放大后用于更大的场景。比如，有些人受过一两次骗，就得到一个结论，世界上没有一个是好人。这就陷入了以有限的经验理解无限事物的误区。</p><p>  接下来我们强调了，无穷大并非是一个静态的、具体的大数字，而是一个动态的、不断扩大的变化趋势，希望通过这个概念，提示大家能够以动态的眼光看待世界。</p><p>  至于无穷大这个概念的现实意义，我们举了计算机科学中算法复杂度的例子，量级的差异，要比同量级之间几倍的差异重要得多。我们在工作中，要优先考虑量级的提高，而不是捡芝麻的事情。</p><p>  接下来三讲，我会拿无穷小为例，详细解释什么是动态地看世界。我们下一讲再见。</p></details><h3><span id="15-wu-qiong-xiao-yi-ru-he-shuo-fu-gang-jing-zhi-nuo">15 ｜ 无穷小（一）：如何说服杠精“芝诺”？</span><a href="#15-wu-qiong-xiao-yi-ru-he-shuo-fu-gang-jing-zhi-nuo" class="header-anchor">#</a></h3><p><img src="/images/78.jpg" alt=""></p><p>  上一讲我们讲了无穷大，主要是从突破认知局限的角度来讲的。在接下来的三讲里，我们来讲讲无穷小。</p><details><summary>...</summary><p>  你可能会奇怪，为什么无穷小要花三讲来介绍？它不就是零么？有什么好讲的。如果你把无穷小看成是一个数，确实没什么好讲的。但遗憾的是，无穷小并不是一个确定的数，更不是零，它和无穷大一样，是一种趋势，一种帮助我们把握“动态”和“变化”的工具，也是一种新的认知世界的方式。</p><p>  一个人是小学数学水平，还是高等数学水平，不在于是否会做高等数学的练习题，而在于他在把握世界变化方面处在什么层次上，那么他是否掌握了无穷小这个概念，就是很好的检验标准。</p><p>  因此，从概念的来龙去脉到数学家最后的应用，我有必要花3讲，来为你解释清楚。</p><p>  世界上最初认认真真思考无穷小这个概念的，是公元前五世纪时古希腊的芝诺，后世虽然把芝诺说成是数学家，但其实他一生没有留下什么数学成果，因此对他的生平鲜有记载。</p><p>  由于他是一个“杠精”，喜欢和人辩论，而且还提出了好几个自己搞不清楚，别人也解释不了的问题，因此被亚里士多德写进了书中，后人才知道有这个人存在。</p><p>  我们不妨看看他的四个著名的悖论：</p><p><strong>悖论一（二分法悖论）：从A点到B点是不可能的。</strong></p><p>  看了这个命题，你会马上说，这怎么不可能？别着急，我们先来看看芝诺的逻辑。</p><p>  芝诺讲，要想从A到B，先要经过它们的中点，我假设是C点，而要想到达C点，则要经过A和C的中点，假设是D点……这样的中点有无穷多个，找不到最后一个。因此从A点出发的第一步其实都迈不出去。</p><p><strong>悖论二（阿喀琉斯悖论）：阿喀琉斯追不上乌龟。</strong></p><p>  我们知道阿喀琉斯是古希腊神话中著名的飞毛腿，但是芝诺讲如果他和乌龟赛跑，只要乌龟跑出去一段路程，阿喀琉斯就永远追不上了。按照我们的常识，芝诺的讲法当然是错的。不过我们还是听听他的逻辑。</p><p>  为了方便起见，我们简单地假设阿喀琉斯奔跑的速度是乌龟的10倍。如果乌龟先跑出10米。等阿喀琉斯追上了这10米，乌龟又跑出1米，等阿喀琉斯追上这1米，乌龟又跑出0.1米……总之阿喀琉斯和乌龟的距离在不断接近，却追不上。</p><p>  这两个悖论其实本质上是一个。我们如果从常识出发，觉得芝诺的观点不值一驳。我们从天安门出发，一步就走过了芝诺所说的无数中点，阿喀琉斯一步迈得大一点，不就超越乌龟了吗？在这里我们的常识当然没有错。</p><p>  但是，如果按照芝诺的逻辑来思考，他似乎也有道理，只是忽略了一些事实，因此要想驳倒他，让他心服口服，就不能绕过他的逻辑！在解释这个问题之前，我们再来看看他的另两个悖论。</p><p><strong>悖论三（飞箭不动悖论）：射出去的箭是静止的。</strong></p><p>  在芝诺的年代，运动最快的是射出去的箭。但是芝诺却说它是不动的，因为在任何一个时刻，它有固定的位置，既然有固定的位置，就是静止的。而时间则是由每一刻组成，如果每一刻飞箭都是静止的，那么总的说来，飞箭就是不动的。</p><p>  这个悖论，可能就比前两个难辩驳了。</p><p><strong>悖论四（基本空间和相对运动悖论）：两匹马跑的总距离等于一匹马跑的距离。</strong></p><p>  如果有两匹马分别以相同的速度往两个方向远离我们而去，我们站在原地不动。在我们看来，单位时间里它们各自移动了一个单位Δ（Δ通常表示增量），显然一匹马跑出去的总距离就是很多Δ相加。但是如果两匹马上有人，那么在彼此看来，对方在单位时间却移动了两个Δ长度，彼此的距离应该是很多两倍的Δ相加。</p><p><img src="/images/61.jpg" alt=""></p><p>  那么，如果Δ非常非常小，小到无限接近于零，芝诺就干脆认为Δ=0，0乘以任何数还是0，那么1Δ＝2Δ。但是左右两匹马跑出去的总距离怎么可能等于一匹马跑的距离呢？其实芝诺的错误就是把无穷小直接当做了0。</p><p>  听了这些问题不知道你有何感觉。我想，除了当年庄子和惠子也讨论过类似的问题之外，绝大部分时候中国人讲究的是要学以致用，因此，在古代，士大夫们是不屑于理会芝诺的这种没有用的傻问题。</p><p>  直到今天这种情况其实也没有太多的改变，我在大学时，一些老师还觉得这一类的问题是唯心主义的。但是正是这些问题，让古希腊文明和其它文明有所不同，而这种严守逻辑的思维方式，才让数学和自然科学成体系地发展。</p><p>  当逻辑和我们的经验有了矛盾时，<strong>有两个结果，一个结果是我们的经验错了</strong>。比如说，到底是地球围绕太阳转，还是太阳围绕地球转？在这件事上，我们的经验就错了。<strong>当然还有一个可能性就是，我们看似正确的逻辑，本身可能有问题，因为有概念的缺失，芝诺的这两个悖论就属于第二种。</strong></p><p>  在这种情况下，找到了所缺失的概念，或者分清了不该混淆的概念，数学或者科学就获得一次巨大的发展。我们前面讲的从毕达哥拉斯定理引出无理数的概念，也属于这一种。今天回答芝诺的问题其实很容易，因为有了无穷小的概念，以及微积分中关于导数的概念，这个缺失被补上了。</p><p>  今天我们就用无穷小的概念回答芝诺的第1、2和第4个悖论，由于第一个和第二个悖论其实是一回事，我们只讨论第二个，也就是阿喀琉斯和乌龟赛跑的例子。至于第三个悖论，我们下一讲讲到导数的时候会回答。</p><p>  话说在芝诺之后的上千年里，欧洲总有人不断地试图找出芝诺逻辑上的破绽，包括阿基米德和亚里士多德，但都没有给出好的回答。不过亚里士多德的思考还是道破了这几个悖论的本质，就是一方面距离是有限的，另一方面又可以把时间分成无穷多份，以至于有限和无限对应不上。</p><p>  直到牛顿、莱布尼茨等人发明了微积分，发明了无穷小量和极限的概念，才作出了比较圆满的解释。</p><p>  接下来，就让我们一层层抽丝剥茧，来解决这些悖论。</p><p>  我们知道，在阿喀琉斯悖论中，芝诺其实把阿喀琉斯追赶的时间分成了无限份，每一份逐渐变小却又不等于零。比如我们假设阿喀琉斯一秒钟跑10米，那么芝诺所分的每一份时间就是1秒、0.1秒、0.01秒，等等。如果我们把它们加起来，就是之前讲的等比级数。</p><center>S=1+0.1+0.01+0.001+……</center><p>  接下来的问题是，这样无限份的时间加起来是多少？假如每一份时间都存在一个最小的、具体的长度，那么这样子的无限份加起来显然就是无限大，这是矛盾所在。但是，如果我们能够定义一个被称为“无穷小”的量，它满足这样两个条件，芝诺的悖论就能够解决了。</p><ul><li>它不是零；</li><li>它的绝对值小于任何一个你能够给定的数。比如你说10<sup>-100（10的负100次方就是10的100次方分之一）非常小，那么我这个无穷小比你说的还小，如果你说再来一个更小的数10</sup>-10000，那么我这个无穷小依然比你的数字小。</li></ul><p>具体到芝诺悖论的例子中，这两个条件如何理解呢？当我们把时间分为无穷多份之后，到后来，不仅每一份是一个无穷小量，而且无穷多个无穷小量加起来依然是无穷小。</p><p>  那么怎么证明在上面的等比级数S中，无穷多个无穷小量加起来不会是无穷大呢？这在数学上有好几种方法可以证明，我们就不细讲了。在这里我们提示两个要点：</p><ul><li><p>无穷多个无穷小量加在一起可以有三种情况，分别是一个有限的数，无穷大，或者是无穷小，我们在后面介绍无穷大和无穷小的比较时会详细讲。</p></li><li><p>在这个具体情况中，无限个无穷小量加起来是一个有限的数，这一点我们在后面讲到极限的概念时会说明，S这个级数的极限是10/9。</p></li></ul><p>因此引入了无穷小的概念，就解决了阿喀琉斯悖论。可以讲，正是阿喀琉斯悖论帮助我们补上了数学上的一个缺失。</p><p>  至于第四个相对运动悖论，其实说起来就更简单了。芝诺所说的Δ，其实就是无穷小，虽然它趋近于零，但是不等于零，因此Δ≠2Δ。</p><p><strong>要点总结：</strong></p><p>  无穷小的本质是什么？它补上了关于数字在连续性方面的一个定义的缺失。我们随便画一个数轴，数轴上的每一个点都应该是连续的，当然数轴中间那个点是零。</p><p>  如果我要问你，在数轴上紧挨着零的那个点等于多少呢？你就没法回答了，你如果说是10<sup>-100，遇到一个抬杠的，会说10</sup>-1000离0点更近，只要你能说一个，他都可以和你抬杠。</p><p>  因此，我们定义一个新的概念，叫做无穷小，它无限接近零。从它的定义可以看出，无穷小不是一个具体的数，而是一个概念、一个趋势，就和无穷大一样。</p><p>  当我们的头脑开始接受数的概念可以超出一个具体的数，而是一个趋势时，我们的思维就进步了，我们看待世界也不会一个点一个点地去看了，而是一个趋势一个趋势地去看。</p><p>  举一个具体的例子，你可能听说过现代物理学上的弦论，它被认为是到目前为止最有可能统一相对论和量子力学的工具，相比今天建立在基本粒子上的物理学模型，弦论讲的就不是一个个具体的点，而是一个个趋势。</p><p>  牛顿和莱布尼茨等人虽然通过无穷小和极限的概念，解决了芝诺悖论，但是他们当时对无穷小以及极限的定义还不准确，以至于受到了大哲学家贝克莱的挑战。这一点我们下一讲再讲。</p><p>  欢迎你把课程分享到家长群，帮家长们重新理解数学背后的道理。</p></details><h3><span id="16-wu-qiong-xiao-er-niu-dun-he-bei-ke-lai-zai-zheng-shi-me">16 ｜ 无穷小（二）：牛顿和贝克莱在争什么？</span><a href="#16-wu-qiong-xiao-er-niu-dun-he-bei-ke-lai-zai-zheng-shi-me" class="header-anchor">#</a></h3><p><img src="/images/67.jpg" alt=""></p><p>  我们上一讲知道了芝诺提出的飞箭是静止的这个悖论，这和我们的常识是相违背的。这一讲，我们说说这些一千多年前的悖论是如何得到解释，以及它们的现实影响。</p><details><summary>...</summary><p>  利用无穷小这个概念，牛顿发明了“流数”的概念，用于研究函数的变化，从而找出物体运动瞬间的变化规律。</p><p>  在牛顿之前，物理学家们对很多物理概念其实搞不清楚，比如大家会混淆质量和重量，速度和加速度，动量和动能这些物理概念。牛顿第一次清晰地定义了这些物理量，其中一个重要的物理量就是速度。</p><p>  我们今天知道，如果你2小时走了10公里，速度V就是每小时5公里，更确切地讲，就是位移的距离ΔS=10公里除以完成这段位移的时间Δt2小时，即V=ΔS/Δt。这其实说的是平均速度。如果你按照这个平均速度从北京的颐和园走到香山公园，其实每分每秒的速度都是变化的。</p><p>  如果我们想知道某一时刻特定的速度怎么办呢？牛顿说，当间隔的时间Δt趋近于零的时候，算出来的速度就是那一瞬间的速度。</p><p><img src="/images/68.jpg" alt=""></p><p>  在图中，横轴代表时间变化，纵轴代表距离变化。从t0这个点出发，经过Δt的时间，走了ΔS的距离，因此在那个点的速度大约是ΔS/Δt。这个比值，就是图中那个红色三角形斜边的斜率。</p><p>  对比左图和右图，你会发现如果Δt减少，ΔS也会缩短，但是ΔS/Δt的比值就更接近t0那一瞬间的速度。极限的情况则是Δt趋近于零，那么时间-距离曲线在t0点切线的斜率就是t0的瞬间速度。由此，牛顿给出了一个结论，时间-距离曲线在各个点切线的斜率，就是各个点的瞬间速度。</p><p>  瞬间速度其实反映了在某个点距离的变化率。至于为什么我们想了解瞬间速度，因为在很多应用中我们只关心瞬间速度，而不是平均速度。比如我们关心子弹出膛的速度，命中目标的速度，汽车在出交通事故一瞬间的速度，等等，它们都是瞬间速度。</p><p>  有了瞬间速度的概念，我们就很好解释芝诺的第三个悖论，即飞箭是静止的这一悖论。芝诺其实混淆了两个概念，即瞬间位移量和瞬间速度的差别。芝诺注意到了当间隔时间Δt趋近于零的时候，箭头飞行的距离ΔS也趋近于零。但是，它们的比值，也就是速度，并不是零。就如同我们在图中画的，曲线的斜率并不是零。</p><p>  牛顿把上面这种数学方法推广到任意一个曲线。他将一个曲线在某一个点的变化率，定义成一个新的数学概念，这就是前面我们讲到的流数。今天我们在数学上称之为导数，因此以后我们就不再用“流数”这个名词了。导数是微积分的基础。</p><p>  导数这个概念的提出，把很多物理量之间的数学关系建立起来了。比如速度是位移曲线的导数，而另一个物理量加速度则又是速度的导数。类似的，动量就是动能的导数。此外，在经济学上，经济增长率，就是GDP的导数，而增长率增速，又是增长率的导数。</p><p>  今天在我们的生活中，导数或者说瞬间变化率，其实用得特别多，只是大家对这个名称未必很熟罢了。导数概念的提出，使得人类能够从掌握平均规律，进入到掌握瞬间规律。可以讲，没有导数的分析方法，人类只能体会变化，但体会不出加速变化。</p><p>  遗憾的是，虽然牛顿对于速度的定义在物理上很容易理解，并且被大家接受，但是在数学上却有一个小缺陷，就是对这个无穷小概念解释得不够清晰。具体讲，就是到底Δt能不能等于零？</p><p>  对此，牛顿以及微积分的另一个发明人莱布尼茨都有点含糊其辞。虽然说那个年代人的数学水平没有今天高，绝大部分人看不出问题，但是有一个讲究逻辑的学者却向牛顿提出了质疑。这个人叫贝克莱。</p><p>  贝克莱这个名字对熟悉哲学的人来讲是如雷贯耳，对非哲学专业的人来讲也未必陌生，因为他在中国哲学课中是“臭名昭著”的唯心主义哲学家的代表人物，他的一句名言是“存在就是被感知”，在我们的课程中被批评和嘲笑。当我在国内学习微积分和科学史时，贝克莱就成了一个被嘲笑的对象，被笑话为不懂微积分，孤立静止地看待世界。</p><p>  然而，在西方世界，贝克莱是很受尊敬的，他被认为是一位了不起的哲学家和学者，和约翰·洛克、大卫·休谟一同，被誉为经验主义哲学的三大代表人物。今天著名的加州大学伯克利分校里面“伯克利”三个字，其实就是贝克莱的名字。</p><p>  贝克莱讲“存在就是被感知”，可不是拍脑袋想出来的，而是做了科学研究的。这里面的细节我们就不多讲了，总之，贝克莱研究了人们如何在两个维度的视网膜上感知和觉察到有深处的第三维度图像，他的结论和今天生理学所给出的结论基本一致。</p><p>  贝克莱挑战牛顿，主要是两人的宗教观不同。贝克莱是一位天主教的大主教，而牛顿在骨子里有自然神论的倾向。恰好贝克莱对运动学也有不少研究，也非常讲究逻辑，他找到了牛顿的一个小漏洞，于是就挑战牛顿说，你说的无穷小的时间Δt到底是不是零啊？如果是零，它不能做分母，如果不是零，你的公式给出的还是一个平均速度，而不是瞬间速度。</p><p>  对于贝克莱的质疑，牛顿也不知道怎么回答，因为在那个年代，无论是他还是莱布尼茨，虽然用到了无穷小，但是也没有能对它进行准确的定义。你如果问牛顿什么是无穷小，牛顿可能会说，就是非常非常小，可以忽略不计。</p><p>  我们上一讲给出的无穷小的那种描述，其实是一百多年后柯西和魏尔斯特拉斯给出的。贝克莱提出的问题看似很小，却引发了第二次数学危机，第一次是前面讲到的发现无理数造成的危机，危机的根据就在于牛顿那个时代的人在逻辑上讲不清楚无穷小是什么。</p><p>  讲到这里，可能有人会想，这件事情这么重要么？是的！接下来我们就来分析一下这件事。我们要从两个角度来看这件事，第一是从数学逻辑的重要性来看，第二是从具体的无穷小这个概念本身来看。</p><p>  我们先从第一个角度来说明，那些抽象的话我们就不多说了，我们来看一个实际的例子，伽利略发现物体落地时间和重量无关的例子。</p><p>  伽利略是在牛顿之前最伟大的物理学家。我们今天知道他，主要不是了解他对物理学的贡献，而是比萨斜塔铁球实验的故事。他通过扔下两个铁球，发现它们同时落地，否定了亚里士多德过去的“重物要比轻的物体先落地”的论断。</p><p>  这个实验是否是他的学生虚构的，今天有争议。实际上，伽利略质疑亚里士多德的结论还真不是从做实验开始的，他是从简单的数学逻辑中找出了亚里士多德结论中的矛盾之处。</p><p>  伽利略的逻辑很有意思，既然亚里士多德说了重的物体比轻的物体能更快地落地，那么将10磅和1磅的两个球绑在一起，它们是比10磅的球更快落地还是更慢呢？</p><p>  如果你认为它们是两个球，一个快一个慢，一磅的要拖10磅的后腿，那么它们就要比单独一个10磅的球落地慢。但是，如果你认为它们是一个整体，一共11磅，就要更快。</p><p>  这就在逻辑上产生了矛盾。这个矛盾就推翻了亚里士多德的结论。这一类的例子我们在《科技史纲60讲》中举了很多，有兴趣的同学可以复习一下那门课。这些例子都说明，数学千万不能有逻辑错误，否则不仅是数学，很多人类的知识体系都会出问题。</p><p>  接下来我们从第二个角度，专门看看无穷小这个概念为什么如此重要呢？我们来梳理这里面的逻辑。</p><p>  我们前面讲了微积分的意义是，让人类的认知从静态或者宏观变化进入到把握瞬间动态变化和加速变化，这是人类认知的一大飞跃。有了它，近代的物理学和天文学，以及后来的古典经济学，才得以建立。</p><p>  但是，微积分是以导数为基础的，而无穷小又是导数的逻辑前提和基础。如果无穷小这个基础本身出问题，在上面建立起来的所有大厦都可能被推翻。因为，贝克莱提出的无穷小悖论，是一次实实在在的数学危机。</p><p>  解决第二次数学危机的，并不是牛顿、莱布尼茨等人。事实上，某个时代发现的危机，同时代的人常常是想不清楚的，需要后面的人发展新理论来解决。</p><p>  是19世纪的一大批数学家解决了这个问题，他们的名字我就不列举了，因为比较多。这里面特别要提一下的是法国伟大的科学家柯西和德国的魏尔斯特拉斯。关于他们的工作，我们下一讲再讲。</p><p>  这里我们简单地说一下他们二人在思维方式上比牛顿进步的地方，那就是他们把无穷小这个“概念”从过去人们理解的小得不能再小的数，看成了一个动态变化，往零这个点靠近的趋势。这其实是人类认知的一大飞跃。</p><p><strong>要点总结：</strong></p><p>  我们今天讲了平均速度和瞬间速度的关系和区别。牛顿用（流数）导数来定义瞬间速度，其实是描述了一个曲线或者物理量变化的趋势和速率。人类在早期的时候，只能认识到平均速度等概念，只有当人类理解了导数这个概念后，才能搞清楚瞬间变化的规律，特别是加速变化的规律，这是人类历史上一次很大的认知升级。</p><p>  牛顿在计算瞬间变化时，引入了无穷小这个概念，但是当时的人对它的确切含义想得不是那么清楚。因此，贝克莱就提出了质疑，即无穷小悖论，导致了第二次数学危机。对于贝克莱以及之前芝诺这样爱较真，但讲理的人，不要觉得他们讨厌，他们对数学的完善是有贡献的。</p><p>  数学不是实证科学，不能简单通过实验来证实，要在逻辑上非常完美，否则后果不堪设想。具体到第二次数学危机的解决，则是靠新时代的数学家的贡献。</p></details><h3><span id="17-wu-qiong-xiao-san-yong-dong-tai-he-ji-xian-de-yan-guang-kan-shi-jie">17 ｜ 无穷小（三）：用动态和极限的眼光看世界</span><a href="#17-wu-qiong-xiao-san-yong-dong-tai-he-ji-xian-de-yan-guang-kan-shi-jie" class="header-anchor">#</a></h3><p><img src="/images/69.jpg" alt=""></p><p>  我们上一讲讲到贝克莱对牛顿的挑战。看似不起眼的无穷小的概念，却引发了数学上第二次危机。 第二次数学危机，看似是围绕“无穷小”引发的争论，但从认识论上讲，是身处于渐变世界的人类，难以理解瞬间突变造成的。</p><details><summary>...</summary><p>  要解决这个问题，单纯围绕“无穷小”争来争去是不行的，要在认识上有所提升，具体讲，就是要认识极限这个概念。</p><p>  极限这个概念从字面上讲不难理解，因为我们会联想到生活中一个达不到的限度。但是这个理解是不精确的。比如我们知道，1/2+1/4+1/8+1/16…..是不断增加的，那么它能达到多少呢？事实上它的极限仅仅是1。</p><p>  如果你拿尺子在纸上画一条1厘米的线段，在一半也就是0.5厘米的位置标一下，在后一个0.5厘米的一半，也就是0.75厘米的位置再标一下，重复这个取一半的动作，最后无论多么精细，这些刻度加起来，总不能达到1厘米，1厘米就是它的极限。</p><p><img src="/images/70.jpg" alt=""></p><p>  今天很多人想自学微积分，但是基本上看到极限那里就卡壳了，因为脑子没有换成“动态的数学脑子”，还是静态地看问题。</p><p>  这也怪不得大家，因为伟大如牛顿、莱布尼茨，也不得不在极限这个概念上含糊其辞，由于他们给的概念都很绕口：</p><p>  <em>「牛顿认为极限是逐渐变小的量之间的最终比值。你如果回想一下我们上一讲所说的他对于速度的定义，其实就是时间和距离这两个逐渐变小的量之间的比值。牛顿认为，平均速度在时间间隔不断缩小后，极限就是瞬间速度。</em></p><p>  <em>莱布尼茨不是物理学家，他是数学家，更是哲学家和符号学家。因此他从纯逻辑的角度看待极限，他认为，如果任何一个连续变化都以一个极限为终结，那么在这个变化过程中的普遍规律，也适用于最终的极限。」</em></p><p>  那么我们到底应该怎么理解极限呢？我们回顾一个具体的例子，前面讲到的斐波那契数列前后两项之比，大家可以看到它趋近于黄金分割点，这个黄金分割点1.618……就是它的极限。</p><p><img src="/images/71.jpg" alt=""></p><p>从这个图中大家可以看到两点：</p><p>**首先，极限是客观存在，**比如图中的点就是围绕着黄金分割点波动。这一点大家其实并不难理解。</p><p><strong>其次，极限最大的特征是“无限逼近”，最后趋同。</strong></p><p>上述这种对极限的认知，来自于柯西，最终被魏尔斯特拉斯用数学的语言描述清楚了。</p><p>  柯西是19世纪法国数学界的集大成者，他在法国数学史上的地位，犹如牛顿在英国，高斯在德国，我们今天所学习的微积分，其实并不是牛顿和莱布尼茨所描述的微积分，而是经过柯西等人改造过的，严格得多的微积分。</p><p>  相比牛顿，他放弃了微积分在物理学上直接的应用场景，完全是从数学本身出发来重新定义微积分中那些含混的概念，把微积分打造成像欧几里得几何那样公理化的系统。</p><p>  这种更抽象的描述也意味着更准确、更普适。而且柯西和魏尔斯特拉斯比牛顿高明的地方在于，他们不是对概念进行静态的定义，而是进行了动态的描述。那么该如何去描述一个动态的概念呢？我们看看他们是怎么做到的。</p><p>  极限是微积分里最重要的定义之一，对极限进行准确的定义要分两步。第一步是把概念搞清楚，没有二义性，这件事是柯西完成的。</p><p>  第二步就是用数学的语言将它们表述出来，这就有点反人性了。因为虽然人类对自然语言有着天然的好感，而且我说什么你很容易直观地理解我的意思，但是在数学上这可能不够严密，以至于会导致很多悖论。</p><p>  在微积分的定义上，将柯西那些直观的观念，变成严格符合逻辑的数学语言的人，是德国数学家魏尔斯特拉斯。魏尔斯特拉斯对微积分的贡献很大。我们这里只说说他是如何定义极限的。</p><p>  我们先来看一个序列：</p><center>1，4/3，6/4，8/5，10/6……2N/（N+1）…….</center><p>  如果当N足够大时，它的值是多少？你可能会说是2；也可能说它趋近于2，但是比2小一点点，这两种说法都对。当然，更准确的说法是，它的极限是2，因为它无限逼近2。</p><p>  这就是柯西对极限给出的直观的定义。需要指出的是，柯西对极限的定义已经有了动态的概念，和牛顿、莱布尼茨他们说的“到头”不一样。</p><p>  但是，魏尔斯特拉斯却说，柯西，你的定义，还不够精确。</p><p>  柯西就说，那你能你上。</p><p>  于是魏尔斯特拉斯给出了他的定义法。</p><p>  首先，他肯定了极限是关于一个无限逼近的趋势的观点。但是在描述无限逼近的方法上，他采用了逆向思维。</p><p>  那魏尔斯特拉斯的逆向思维是什么意思呢？我们常人的想法，就是这个序列，当N越大时，它和2的差距越小，但是小到什么程度，就不容易量化说清楚。魏尔斯特拉斯的逆向思维是这样的，他先这么问大家：</p><p>  你们觉得误差多么小算是趋近了？大家可能就说了，总得小于一亿分之一吧。</p><p>  魏尔斯特拉斯就说，这容易做到，只要N大于一亿之后，这个序列和2的差距，就小于你说的一亿分之一了。</p><p>  这时，你可能说，且慢，一亿分之一的误差还是误差啊，在数学上它还是不等于2。</p><p>  魏尔斯特拉斯就说，没关系，你再说一个更小的数，我还能做到。于是你说10<sup>-100。魏尔斯特拉斯说，N大于10</sup>100就可以了。总之，不管你说的数多么接近，他都能做到。这就是无限逼近。</p><p>  上面这一段对话当然是我虚构的。魏尔斯特拉斯对极限的描述是这样的：</p><p>  任意给一个小的数字𝛆，如果总能找到一个数字M，当N比M大之后，上面那个序列和2的差距小于𝛆。于是，我们就说上面那个序列的极限的是2。</p><p>  有了对于一个数列极限的定义，魏尔斯特拉斯对函数的极限也作了类似的定义。比如我们看这样一个函数sin(x)/x，它的分子是一个正弦函数，分母就是变量自己。</p><p>  这个函数，当x趋近于0时，它等于多少呢？</p><p>  我们列一个表：</p><p><img src="/images/72.jpg" alt=""></p><p>  从表中可以看出x趋近于零的时候，这个函数值就趋近于1。</p><p>  我们知道x是分母，不能等于0，不过没关系，我们可以让它趋近于零。</p><p>  对于该函数在零附近的极限，魏尔斯特拉斯是这样定义的：</p><p>  <em>你只要给定一个很小的数字𝛆，我总能在0附近，设法找到一个范围，只要x落在这个范围内，算出来的函数的值和1的误差就比你给的𝛆要小。</em></p><p>  从这个定义中我们可以看出，极限也是一个动态的，对趋势的定义，而且使用了逆向思维。</p><p>  有了极限严格的定义，我们可以看出无穷小其实是一种特殊的极限，它也可以准确定义，我们这里就不再把它用数学的语言描述了，大家记住这个结论就可以了。</p><p>  有了对极限严格的定义，以及对于无穷小准确的定义，牛顿所说的速度问题，其实就是当时间在t0这个时刻间隔趋近于零的时候，距离和时间比值的极限，到此，贝克莱引出的无穷小悖论，以及之前所有的芝诺悖论才算彻底解决。</p><p>  当然，本来用大白话说的道理，变成了严格的数学语言，就让数学显得高冷了，有些人读起数学的语言（大量的公式）就觉得费劲，而老师的作用，就是再用大白话，把数学语言所写的知识，翻译成大家容易明白的内容。做不到这一点，那还不如让学生自己看书自学了。</p><p>  到此为止，我们关于极限的内容就讲完了。我们为什么要讲这件事？不是给大家一个比生活中所理解的极限更准确的定义，而是学会用动态的眼光，无限变化的眼光看待世界。</p><p>  人类认识极限、无穷大和无穷小这些在有限世界里难以理解的概念时，一开始也是一头雾水。这是因为人类受限于自己生活的有限世界。</p><p>  在有限的世界里，数字都是具体的，因此人们就会想当然地觉得无穷大就是非常大的数，无穷小就是反过来，但是这样以静止的眼光看待数，就会遇到一些数学悖论，这些悖论导致数学危机。</p><p>  危机的根源是什么呢？就是我们人类直观的认识和数学内在的逻辑的矛盾。解决这些矛盾的方法是什么呢？不是像毕达哥拉斯那样视而不见，甚至否认，而是先存疑，后完善。</p><p>  要完善数学上的那些“漏洞”，就要引入新的概念，把原来数学的体系扩大为新的体系。这里我对“漏洞”一词打了引号，因为它不是数学本身的漏洞，其实是我们人认识上的漏洞。</p><p>  为什么需要把数学体系扩大呢？因为任何封闭体系内所遇到的漏洞，在这个体系内是无法弥补的。用中国话讲，叫做“不识庐山真面目，只缘身在此山中”，这是我们人类发展到今天应有的智慧。而在扩大体系的过程中，最重要的是把问题的定义搞清楚。我们今天人和人之间在沟通中最重要的基础，就是对定义有共同认知。</p><p>  具体到对无穷世界的认识，以及对极限的认识，最初发现漏洞的人居然是芝诺这样胡搅蛮缠的大反角，牛顿和莱布尼茨为了弥补芝诺发现的漏洞，发明了无穷小的概念，但是他们的发明也有漏洞，被贝克莱抓住了。于是才有了后来柯西和魏尔斯特拉斯等人的贡献。</p><p>  魏尔斯特拉斯超出前人和常人的地方有两个，一个是他定量地描述出无限的趋势，另一个是他用逆向思维让大家理解了这种趋势的含义。定量和逆向思维，是我们今天应用的思维方式。</p><p>  人认识世界的过程，其实是人类认识世界的缩小版，前人摸索几百年的认知进步，我们可能通过学习和做事情，几年就体会出来了。结合这几天的内容，我把一个便捷的认知升级的过程总结如此：</p><ul><li>不要怕提出傻问题，符合逻辑的傻问题常常是认知升级的开始。</li><li>如果之前的知识解决不了那些看似傻问题的悖论，我们可能要跳出圈子了，因为在圈子里转永远解决不了问题。</li><li>当我们扩大我们的知识体系的时候，之前的傻问题可能有了答案。</li><li>但是不要指望一次就能完美地解决所有问题。我们的解决方案可能有漏洞，不要怕被别人指出来。当我们进一步弥补漏洞后，我们的认知就再次升级。</li></ul><p>下一讲，我们再来讨论一个进一步扩张我们思维认知的数学问题，就是看看无穷大、无穷小还能不能再比比大小。我们下一讲再见。</p></details><h3><span id="18-you-shi-me-bi-wu-qiong-da-geng-da-bi-wu-qiong-xiao-geng-xiao">18 ｜ 有什么比无穷大更大，比无穷小更小</span><a href="#18-you-shi-me-bi-wu-qiong-da-geng-da-bi-wu-qiong-xiao-geng-xiao" class="header-anchor">#</a></h3><p><img src="/images/73.jpg" alt=""></p><p>  我们讲无穷大是比任何数都大，那么世界上只有一个无穷大吗？如果有多个，能比较大小吗？类似的，无穷小就是无限接近于零，那么世界上会有不同的无穷小么？</p><details><summary>...</summary><p>  如果我们用静态的眼光看待这两个概念，答案都是否定的：无穷大和无穷小都是独一无二的。比如，无穷大再加上1，或者再乘以2，都是无穷大。</p><p>  但是，我们已经知道，它们其实不是具体的数字，而是数列或者函数变化的趋势，是动态的，因为必然有某些数列或者函数会比其他的增加更快，有些则相对慢一点的情况。</p><p>  同样，往无穷小方向变化也是类似。因此，无穷大或者无穷小应该有很多，而且可以通过比较它们之间的变化速率，来比较大小。</p><p>  我们先看两个无穷小的函数，来比比大小：f(x)=x和正弦函数g(x)=sin x。我们知道，当x趋近于零的时候，f（x）和g（x）都趋近于零，那么它们趋近于零的速率相同吗？我们看一眼下表。</p><p>  我曾经试图用图来对比这两个函数变化的趋势，但是由于两条曲线很快合并到一处，看不清楚，因此只能用表来表示。</p><p><img src="/images/74.jpg" alt=""></p><p>  从表中可以看出，x本身和正弦函数趋近于零的速率是惊人地一致。于是，我们可以得到这样一个结论，上述两个函数它们趋近于零的速率是相同的。</p><p>  接下来我们再看另一个趋近于零，速率不同的无穷小。我们对比一下上述的正弦函数g(x)=sin (x)和平方根函数h(x)=√x</p><p>  我们还是用一张表把它们趋近于零的速率描绘一下：</p><p><img src="/images/75.jpg" alt=""></p><p>  你会发现平方根函数h(x)相比正弦函数g(x)趋近于零的速率慢得多。这时候我们其实就比较出两个无穷小谁“更小”了。</p><p>  这里面我对“更小”两个字打了引号，因为我们这里说的比较大小其实不是具体数字大小的比较，而是趋势快慢的对比。当一个无穷小量比另一个以更快的速度趋近于零，我们就说第一个比第二个更小。</p><p>  具体到上面的例子，正弦函数在零附近，相比平方根函数，是更小的无穷小。当然，更准确的说法是，“高阶无穷小”。</p><p>  下面我给出了一些函数，它们在零附近都是无穷小，它们的阶数也越来越高：</p><ul><li>平方根</li><li>x本身、正弦函数</li><li>平方函数 x^2</li><li>立方函数 x^3</li><li>指数函数的倒数</li></ul><p>类似的，我们也可以对无穷大比较大小。你可能会问，无穷小是趋近于0，然后谁接近0的速率更快，谁就是更小。那么无穷大应该和谁去比较呢，它只能和另一个无穷大去比？其实如果两个无穷大，一个增加的速率比另一个更大，我们就说前面的相比后面的是高阶的。</p><p>  比如我们看这样一个例子，有两个函数：f(x)=x和平方根函数h(x)=√x</p><p>  当x趋近于无穷大时，它们都是无穷大，但是它们变化的速率不同，我也列举几个数字，放到下面这张表中，给大家一些直观的感受。</p><p><img src="/images/76.jpg" alt=""></p><p>  你会发现，第三行的平方根函数比上面的线性函数x增加的速率要慢很多，越到后来差距越大。当然还有比平方根函数增长更慢的函数，比如第四行的对数函数。至于增长更快的，也有很多，像平方函数就比线性函数更快，当然指数函数要快非常多。</p><p>  我们按照各个函数往无穷大方向增长的速率，从快到慢给出了下面这样一些例子：</p><ul><li>指数函数 10^x</li><li>幂函数 x^N，通常N=2，3，4……</li><li>自身 x</li><li>平方根 √x</li><li>立方根</li><li>对数函数lg（x）</li></ul><p>**特别需要指出的是，很多个低阶无穷大，加在一起增长的速率都比不上一个高阶的。**比如说10000x和x的平方相比谁大，当x趋向于无穷大时，后者要大得多。当然，x的立方又要比任意有限个x的平方大。</p><p>  当然，遇到一个较真的朋友会说，这些函数最后反正都趋近于无穷大，你比较它们有意义吗？答案是有的，因为无穷大本身的含义就是一种趋势，而不是一个数字。特别是在计算机科学出现之后，它的意义更明显。</p><p>  我们知道，计算机是一个计算速度极快的机器。对于小规模的问题，无论怎么算，也花不了多少时间。如果说它会遇到什么难题，那就是规模很大的问题。</p><p>  因此，计算机算法所关心的事情，是当问题很大时，不同的算法的计算量以什么速度增长。比如，我们把问题的规模想成是N，当N向着无穷大的方向增长时，计算量是高阶的无穷大，还是低阶的。</p><p>  假如算法A的计算量和N成正比，那么当N从10000增加到100万时，计算量也增加100倍；如果算法的计算量和N的平方成正比，事情就麻烦得多了，当N同样从10000增加100倍到100万时，计算量要增加10000倍。</p><p>  类似的，如果算法C的计算量是N的立方，则要增加100万倍。当然遇到极端的情况，计算量是N的指数函数，问题就无法解决了。相反，如果算法D的计算量是N的对数函数，那么太好了，无论N怎么增加，计算量几乎不增加。</p><p>  因此，计算机算法的精髓其实就是在各种无穷大中，找一个小一点的无穷大。一个好的计算机从业者，他在考虑算法时，是在无穷大这一端，考虑计算量增长的趋势，一个平庸的从业者，则是对一个具体的问题，一个固定的N，考虑计算量。</p><p>  前者可以讲是用高等数学武装起头脑，后者对数学的理解还在小学水平。我们上大学的目的首先是通过学习课程换脑筋，然后才是掌握知识点。</p><p>  那么对于无穷小，区别出高阶和低阶有意义吗？有意义，而且意义也很大。我们还是拿计算机算法举例子。很多时候我们要求计算的误差在经过一次次迭代后不断下降，往无穷小的方向走。</p><p>  比如我们控制导弹和火箭飞行的精度，要在微调中向着目标方向靠近。那么通过几次的迭代就趋近于目标方向，还是要经过很多次迭代才达到，这个差异就很大了。</p><p>  假如我们有一种控制的方法，它是按照下面一个序列将误差逐步消除：</p><center>1，1/2，1/3，1/4，……，1/1000……</center><p>这个序列最终发展下去是无穷小，但是如果我们想让误差小于1/1000，需要调整1000次。</p><p>  假如我们有办法让误差按照下面的序列消除：</p><center>1，0.1，0.01，0.001，……</center><p>那么只需要四次调整，就能做到误差小于1/1000。</p><p>  你可以想象，在高速飞行的火箭中，每一秒，火箭都能飞出去几公里到十几公里，如果需要调整一千次，在调整好之前，火箭早就偏出十万八千里了。因此，在很多计算机算法里，希望以高阶无穷小的速度接近零。</p><p>  无穷大和无穷小不仅能比较，而且也能计算。有些计算结论是一目了然的，比如无穷大和无穷大相加相乘，结果都是无穷大，而无穷小之间做加减乘，结果都是无穷小。这比较好理解。</p><p>  但是，无穷大除以无穷大，无穷小除以无穷小等于多少呢？那就要看分子和分母上的无穷大或者无穷小谁变化快了。比如说，当x趋近于零时，sin x是无穷小，根号 x 也是无穷小，那么sin x /√x等于几呢？</p><p>  我们前面讲过，前者变化快，以更快的速度趋近于零，后者变化慢，因此相除的结果就是0。如果反过来，根号 x在分子的位置，sinx在分母的位置，这个比值就是无穷大。</p><p>  对于无穷大的除法，情况也是类似。此外，如果一个无穷大乘以一个无穷小，结果可以是一个常数，也可以是零，或者无穷大，就看它们谁的阶数更高了。</p><p>  我们在前面讲芝诺悖论时提到，在等比数列中，无穷多个无穷小相加，结果是有限的，就是这个道理，因为不断变小的等比数列，会形成一个高阶无穷小。</p><p><strong>要点总结：</strong></p><p>  虽然无穷大和无穷小不是具体的数，但它们也能比较大小，比的不是具体的数值，而是变化的趋势。变化趋势快的，叫做高阶，变化趋势慢的，叫做低阶。通过它们的比较，我们把“比大小”这个概念的认知拓展了。</p><p>  这有什么意义呢？我给你打个比方，假如房价每年的增长是以几何级数上升的，当然你的收入增长也是如此，如果时间足够长，它们都往无穷大的方向发展。但是，如果房价每年涨3%，你的收入涨10%，只要你的生命足够长，你早晚买得起房子。</p><p>  如果你的收入增长是每年20%，这就是一个相对高阶的无穷大，你会很快买得起房子。相反，如果你的收入增长不到3%，相比房价的增长，它就是低阶无穷大，你永远买不起房子。</p><p>  无穷大和无穷小不仅可以比较，还可以做加减乘除运算。当然，这种运算和3+5=8这样确定性的运算不同，特别是在做乘除法时。我通常喜欢用“博弈”这个词形容一个无穷大和一个无穷小相乘的情况，因为结果是什么，就看谁的阶高了。</p><p>  这就好比你和你的女朋友，彼此的激情随着苯基乙胺浓度降低在不断减退，另一方面，亲情的却随着内啡肽的浓度上升会逐渐稳定，最后是成功，还是分手，就是无穷大和无穷小趋势的博弈。</p><p>  讲到这里，你可能会想，我为什么发此感慨，其实通过数学的逻辑，理解人生的一些道理，是把数学作为通识课讲的原因。下一讲我们就系统回顾一下这个模块的内容，我也和你分享一下数学对我的影响。我们下一讲再见。</p></details><h3><span id="19-fu-pan-shu-xue-gei-liao-wo-shi-me-qi-shi">19 ｜ 复盘：数学给了我什么启示？</span><a href="#19-fu-pan-shu-xue-gei-liao-wo-shi-me-qi-shi" class="header-anchor">#</a></h3><p><img src="/images/77.jpg" alt=""></p><p>  到上一讲为止，我们讲完了我们这门数学通识课的第二模块，这个模块可能是所有模块中最难的一个，如果你坚持听完了，恭喜你，微积分中最难理解的部分，你也就拿下了。</p><details><summary>...</summary><p>  在模块的一开始，我并没有说我要讲微积分，就是因为怕一些人知难而退。但是从大家的留言可以看出，经过我们系统地学习，大家开始理解和慢慢掌握高等数学的本质了。</p><p>  而对于那些过去学过微积分的人，可能会发现我的讲法和大学里完全不同，我并没有强调具体的知识点，而是在改变大家的一种思维方式，从孤立、静止地看待一个个数学定理，做一道道数学题，变成用动态发展的眼光，从趋势来理解世界。这个过程，就是人的认知从初等，到高等的过程。</p><p>  我回顾自己学习高等数学的道路，发现大家走过的弯路我也都走过，做了很多没必要的数学题。当时苏联吉米多维奇的《数学分析习题集》我大约做了三分之一（这套书里面有4000多道题），考试却不一定能考好。</p><p>  突然有一天我决定不做了，数学分析考成什么样就是什么样了，这时觉得有一种解脱。腾出时间后，把基本的概念理解清楚，结果成绩也不差。</p><p>  后来到了研究生时，学了数学系更底层的数学课，发现我过去完全学错了，不是老师内容讲得不对，而是没有学到该学的东西。那些题其实我根本不需要会做，如果将来遇到，要么查参考书，要么用计算机工具解决就可以了。</p><p>  关键是我在20岁之前，不理解应该用什么样的眼光来认识数学，看待数学里的那些概念和方法。后来当我懂得了高等数学本质上是对趋势的动态描述，是对各种相关性抽象的表述后，再回头看微积分，就觉得容易得不得了了。非常遗憾我在刚上大学时，没有人这么引导我。</p><p>  数学的世界，在很大程度上可以被看成是我们这个真实世界高度抽象的结果，它的概念是对我们生活中各种对象的浓缩，它的规律是我们生活中很多规律的抽象表述。因此在有了一些生活阅历后，再回过头来看看数学书，我有时会把一些零碎的想法和头绪理清楚。今天我和你分享我的9个体会：</p><p><strong>1.有穷和无穷</strong></p><p>  我们花了不少篇幅在讲无穷大，特别强调在无穷大的世界里，有限生活的不适用。这种感觉有时让我觉得个人的渺小和见识短浅。很多时候，处于很底层的人，是无法理解高层人的想法的。</p><p>  我们常说“贫穷限制了想象力”，其实贫穷不会限制想象力，贫穷的人可以胡思乱想，但是他们在某一些维度上的经验极少，以至于让人觉得是刘姥姥进大观园。</p><p>  十年前中国有一本关于罗斯柴尔德家族和美联储的阴谋论的书，我的一些做投资的朋友看了后说，这个作者一定是个穷人，不曾拥有过大钱，不知道世界上的钱放在哪里。</p><p>  这位作者缺的不是想象力，而是凭空想象的世界完全不靠谱。胡思乱想不会增加自己的智慧，倒是像苏格拉底那样，知道自己的知识有穷尽，而未知世界无穷尽，反而会更接近真理，更容易提高自己的认知。</p><p><strong>2.静态和动态</strong></p><p>  我们的世界需要静态，没有静态的稳定，我们就无法立足。但是，很多时候，我们做事情需要以动态作前提假设，这就如同在足球赛中，除了罚定位球，没有人给你机会站着不动从容射门的。从初等数学到高等数学，就是要把看数学的眼光，从一个个静态的数字、孤立的公式，上升到动态变化的趋势。</p><p>  比如我们在谈论无穷大这个概念时，我一再强调要把它看成是一个动态的趋势，而不是一个大数。我还特别讲了，x²这个函数，在无穷大的世界里，要比10000x大得多。中国有句话，叫做莫嫌少年贫，其实很有道理，我们看待一个年轻人，要看他成长的趋势，而不是现在有多少钱。</p><p>  很多人在创业时，喜欢凑热闹，找风口，生怕错过了机会。我对他们讲，如果那个时间窗只有几个月、半年，那根本不是机会，只是一次投机而已。这就是静态地看待时机。真正的大趋势，总是持续十几年甚至几十年，是不容易错过的，几十年复合增长下来，比任何投机获利都大，这就是对动态看世界的人的褒奖。</p><p><strong>3.精明与聪明</strong></p><p>  从静态和动态的关系，让我想到这个话题。</p><p>  有人觉得数学好的会算账，遇事可以精明不吃亏。但是过分精明的结果就是眼睛都盯在了眼前的利益上，看不到长期的利益，这样反而不聪明了。</p><p>  比如在投资方面，很多人喜欢寻找低买高卖的机会赚差价，他们有时会得手，但是失手的时候一般比得手更多，更糟糕的是，这些人永远无法把握长期增长的机会。事实上，任何一个向上持续增长的趋势，假以时日，都能涨得很多很快。</p><p><strong>4.现实与虚构</strong></p><p>  数学中很多工具都是建立在世界并不存在的虚构概念之上的，但是，将它们用于现实的社会非常有用，比如说无理数便是如此。人不仅要有形象思维，更要有抽象思维，能够通过抽象思维理解无理数，那么学习物理，做信号处理的工作，搞控制系统，都会很顺手。</p><p>  人是特别善于创造虚拟概念的物种，我们今天的生活其实离不开各种虚拟物作为实体的媒介。比如说，世界上的财富是真实的，但是度量它们的货币其实是人虚拟出来的。你不可能在买东西时把真实的财富带在身上，大家只把自己在银行账上的钱从一个虚拟的空间搬到另一个去而已。</p><p>  不仅钱是虚的，很多实实在在的商品虚拟意义也大于实际意义。据估计，个人手里的茅台酒在被喝掉之前，会被当作礼品转手不下十次，它就像数学中那些虚构的概念一样，而不是简单的酒精饮料，没有它们，真实世界的问题就不好解决。</p><p><strong>5.攒钱和赚钱</strong></p><p>  我在《硅谷来信》有一次谈到钱，讲到没有人靠攒钱发财的，发财要靠赚钱。今天攒钱，钱实际上在不断贬值，虽然各国公布的CPI看似并不高，但是CPI并不包括房价的上涨。我们在前面介绍指数函数时讲过，如果每年购买力萎缩10%，用不了几年购买力就少掉一半。</p><p>  但是，年轻人只要努力，一年收入增长20%，还是能做到的。事实上，在过去的30年里，北京计算机专业毕业生的入职年薪平均每年上涨17%，有经验的优秀从业者后来的增长速度更快。</p><p>  我们在前面的课程中讲了，往无穷小变化的趋势和往无穷大变化的趋势如果相乘，最后是清零，是常数，还是不断放大，就看谁的阶高了。</p><p>  通胀、房价上涨等因素都是将财富贬值到无穷小的力量，而且不是人为可控的因素；但是另一方面，收入的增长则是让财富往无穷大增长的力量，对每个人来讲最终就看哪个力量大了。因此，财富靠赚，而不靠攒。</p><p><strong>6.直觉和逻辑</strong></p><p>  我们的直觉常常是对的，但是这只是在我们熟悉或者能够感知到的世界里。世界的很多规律和我们的直觉不一致，比如我们说的芝诺悖论和贝克莱的无穷小悖论，就是因为我们的直觉和无穷小世界里的规律不一致所造成的。</p><p>  逻辑可以帮助我们分析清楚我们看不到的事情，甚至不存在的事情。在课程中，我们举了伽利略的例子，他之所以认定亚里士多德关于质量重的球先落地是错误的结论，是因为找到了这种说法的逻辑错误。这一类例子，在生活中不胜枚举。</p><p><strong>7.概念和表述</strong></p><p>  今天，交流在我们的生活中占据重要的位置。将一件事情表述清楚非常重要，很多时候，我们需要通过彼此能够理解的形象的比喻来说明，这就如同我们在讲述极限这个概念时用“越来越接近”描述。</p><p>  但是，在很多场合，这样形象的描述还不够，还需要用极为严格的语言表述，数学的语言是一种，法律的语言也是一种，更普遍地讲，任何专业的术语都是为了这个目的而出现的。做事专业，就需要掌握专业的术语。</p><p><strong>8.朋友和理性的对手</strong></p><p>  很多时候，取得小成就要靠朋友帮忙，但是要取得惊人的成就，就需要一个理性的对手。在数学的发展史上，芝诺、贝克莱，以及后面我们要讲到的罗素，都起到了反角的作用。正是他们给尚未完善的数学体系挑毛病，才让数学体系变得完美。</p><p>  我们在前面讲到金融危机时，似乎经济学家们没有预警，实际上当所有的人都在赞同同一个想法时，根本无法发现系统中的漏洞。因此，我们在工作中，对于那些理性的对手，即使不喜欢，我们也应该尊重他们的意见，因为那些看似不同的意见，恰恰是我们进步所需要的。</p><p><strong>9.荣誉和财富</strong></p><p>  科学是没有专利可言的，因为科学家们所发现的规律是客观存在的，只是他们发现了而已，因此科学很难直接带来财富。而技术是有专利可言的，因为他们是使用科学改变世界的方法。它们不能混为一谈。</p><p>  对科学家最大的褒赏是荣誉，因此今天科学家们争的是谁第一个发现某个规律，而不是保守秘密。</p><p>  我们在前面讲了三次方程解法被发现的故事。其中的费罗和塔尔塔利亚，他们试图把科学变成独占的成果，这是行不通的。今天绝大部分数学家，会知道卡尔达诺和费拉里对解方程的贡献，对费罗所知甚少。原因就是前者将这些方法告诉了世人。</p><p>  对于搞技术的人来讲，将科学变成改变世界的产品是他们所追求的，有可能带来财富。因此，技术是要独占的。虽然我们说科学无国界，但是技术从来就是有国界，不仅有国界，甚至有公司的边界。</p><p>  对于一个人来讲，他需要搞清楚的，就是自己想要什么。</p><p>  我学习微积分是三十多年前的事情了，很多具体的内容已经想不起来了，但是学习了之后，人的思维方式改变了。因此，从通识教育的目的来看，我应该算是达到了。今天借着复盘的机会，和你分享一下我从数学中得到的启发，希望能供你参考。</p><p>  也欢迎大家在留言区向我提问，我会在下一模块统一回答。下一模块我们会学习几何，看看一个公理体系是怎么建立起来的。我们下一讲再见。</p></details><h2><span id="mo-kuai-san-ji-he-xue-yi-qie-yuan-zi-gong-li-he-luo-ji">模块三 ｜ 几何学 一切源自公理和逻辑</span><a href="#mo-kuai-san-ji-he-xue-yi-qie-yuan-zi-gong-li-he-luo-ji" class="header-anchor">#</a></h2><h3><span id="20-ji-he-xue-wei-shi-me-shi-shu-xue-zhong-zui-gu-lao-de-fen-zhi">20 ｜ 几何学：为什么是数学中最古老的分支</span><a href="#20-ji-he-xue-wei-shi-me-shi-shu-xue-zhong-zui-gu-lao-de-fen-zhi" class="header-anchor">#</a></h3><p><img src="/images/79.jpg" alt=""></p><p>从这一讲开始，我们进入第三模块几何学的学习。</p><details><summary>...</summary><p>  虽然几何学被认为是中学最难学的数学分支，但是它却是继算术之后，最初发展起来的数学分支，比相对简单的代数学要早上千年。</p><p>  那么人类为什么要先难后易发展几何学分支呢？简单地讲是实际需要。几何这个分支的发展过程，反映出人类认知的进步过程，因此我们有必要简明地回顾几何的发展史，看看人类是怎么样总结规律的。</p><p>  我把几何学早期的发展分为三个阶段。</p><p>  <strong>第一阶段是从懵懂的感性认识上升到量化的感性认识的过程。</strong></p><p>  今天英语所说的“几何”一词geometry源于希腊语，它是由“土地”的词根（geo）和“丈量”（metry）一词合并而成。顾名思义，几何最初确实源于对土地的丈量。</p><p>  当然，几何学传到古希腊已经是很晚的事情了，它源于更早的古埃及文明的初期。早在6000年前，埃及人为了农业生产，就发明了天文学和几何学。</p><p>  我们知道文明的标志是城市、书写系统和冶金，在此之前，文明的标志则是农业。这部分内容，我在《科技史纲60讲》中介绍过，有兴趣的朋友可以回顾那门课的内容。</p><p>  无论是农耕还是建筑，都离不开土地丈量、基本图形尺寸的测量和计算，这方面知识积累多了，就形成了几何学的常识，注意我这里用的是“常识”，而不是“理论”。</p><p>  我们先来说说古埃及的农耕和几何学的关系。古埃及农业发达的基本条件有两个：</p><ul><li>完全依靠尼罗河洪水每年泛滥后带来的肥沃土地。它的农业生产过程是这样的：每年尼罗河洪水退去后，他们就在洪水淹过的土地上耕种，但是耕种之处又不能离河床太近。因此他们要计算河水在一年不同时间的边界。</li><li>有明确的播种和收获时间。既不至于播种太早，洪水依然没有退却，又不至于播种太晚，以至于误了农时。</li></ul><p>这些事在今天看来是再容易不过的了。比如我们可以到了春分节气左右播种，到了夏至左右收获就可以了。至于河水涨落的边界，我们记下12个月它涨落的边界变化即可。但是这两件事在古埃及并不容易，因为在没有准确的计时工具之前，我们人是无法通过身体感受来体会一年四季具体的时间的。</p><p>  找到每一年开始的基准时间，对于古埃及人来讲就是一道几何学问题。当时没有钟，所以了解时间就要靠观测星象，看看新的一年是不是又开始了。古埃及人把太阳和天狼星同时升起的那个时间算成一个大年（天狼星年）的开始。</p><p>  这个方法也是非常有道理的。由于地球围绕太阳转，每天同一时刻从地球上看天狼星的角度，会有不同。但是当地球转回到去年的位置，看天狼星的角度就相同了。</p><p><img src="/images/80.jpg" alt=""></p><p>  在图中，地球回到了能同时看到太阳和天狼星升起的公转位置时，就被确认为一年的开始。</p><p>  之所以选天狼星，是因为它是天上除了太阳最亮的恒星，而且在天上的位置是固定不变的（其实也在非常缓慢地变化）。古埃及人就算出来这样一个周期是1461天，地球就又回到了原来的位置，也就是我们今天的四年时间。</p><p>  由于古埃及没有闰年，它无法每四年校正一天，于是便采用了每1460个阳历年增加一年的方式来校正。也就是说古埃及的1461年，等于今天的1460年。古埃及人把这个1461年的大循环周期，叫做一个天狼星年。然后，古埃及人就按照这个周期，编制了一个八万多年的大历法，有了这个历法，什么时候播种，什么时候收获就清楚了。</p><p>  <strong>从这个例子可以看出古埃及人对几何学的角度和圆有了感性的认识。</strong></p><p>  促使古埃及几何学发展的是大规模的城市建设，包括建造大金字塔。在修建胡夫金字塔的年代（距今大约 4600 年），他们就知道了勾股定理，对圆周率也有了初步的了解，他们估算出的圆周率为3.16，和真实的值相差不到千分之一。</p><p>  他们在大金字塔上留下了很多几何关系，向我们表明他们的几何学成就。这可以认为是几何学发展的第一个阶段，从懵懂的感性认识上升到量化的感性认识。</p><p>  <strong>几何学发展的第二个阶段和第一个几乎是平行的，就是生活在今天伊拉克境内的美索不达米亚人发明了角度量化的度量。</strong></p><p>  我们知道平面几何所需要度量的最主要的对象，一个是长度，另一个就是角度，前者比较直观容易，后者比较难。美索不达米亚对几何学最大的贡献在于发明了量化度量角度的方法，就是我们今天360度的原则和角度上的60进位。</p><p>  美索不达米亚人对几何学的研究，也源于占星或者天文学的目的。占星在早期可不是算个人的运势，而是和农业生产有关，星空不同位置和地球上一年某个特定时间有着一一对应的关系。而在地球上一年特定的时间，植物和动物都会处于类似的生长繁衍阶段，因此古代美索不达米亚人就把天上星星的位置和地上发生的事情联系起来了。</p><p>  那么美索不达米亚人又是怎么标记星星的呢？早在苏美尔人统治那里的时期，他们就发现每个月看到的星空会有十二分之一的差异，于是他们就把天空分成了12份，每一份用一个有代表性的星座来代表，这就是今天12星座的由来。</p><p>  由于一个月大约有30天，于是他们就把一年看到的天空，又分为了12x30=360份，每一份就是我们今天说的一度角。我们今天学习几何学时可能会有一个疑问，一个圆为什么有360度，而不简单定义为100度？原因就来源于美索不达米亚早期的几何学。</p><p>  当然，以360度作为进位的基本单位太大、太复杂，他们选用了它的1/6，即60为进位单位。60这个数在数学上特别漂亮，因为它可以同时被1，2，3，4，5，6，10，12，15，20，30和60整除，因此使用很方便。60进制也就这样产生了。</p><p>  <strong>几何学发展的第三个阶段就是用书记录他们所发现的规律。这样知识就便于传播。</strong></p><p>  今天存世最早的几何书是古埃及的《莱茵德纸草书》，它成书于公元前1650年前后。不过该书的作者声称，书中的内容是抄自古埃及另一本更早的书，那本书写于公元前1860—公元前1814年之间。这样算下来，世界上最早的几何学文献应该在3800年前，这比殷墟甲骨文的历史都长。</p><p>  相比之下，代数的历史则短很多，到了古希腊时期才基本定型下来，相差了至少一千年。在人类的早期文明中，肯定有很多算术解决不了的问题，那么怎么办呢？说起来很有意思，古代文明的人会用几何学的方法来解决本该属于代数的问题。</p><p>  在美索不达米亚出土的泥板上，也记录了当时人们总结了非常多的几何学知识。比如在古巴比伦王国（公元前1894—公元前 1595年）留下来的大约 300 块泥板上，记载着有关各种几何图形的计算方法。</p><p>  比如在平面几何方面，他们掌握了各种正多边形边长与面积的关系。他们尤其对直角三角形和等腰三角形了解较多，并掌握了计算两者面积的方法，他们还知道相似直角三角形的对应边是成比例的，等腰三角形顶点垂线平分底边。</p><p>  值得一提的是，他们也知道了勾股定理，给出了很多组的勾股数，其中一组最大的勾股数是（18541，12709，13500），发现这么大的一组勾股数非常不容易。当然知道了勾股定理就有可能利用它来计算一个数的根号，美索不达米亚人也这么做了，他们算出根号2大约是1.41。此外，古巴比伦人还给出了一些角度的三角函数值。</p><p>  那么几何学又是怎么传到古希腊的呢？美索不达米亚有一个特别喜欢外出经商的民族——闪米特人，他们是今天犹太人和阿拉伯人的祖先。闪米特人的一支腓尼基人在地中海沿海和很多岛屿建立了殖民地，并且把美索不达米亚的科学传播到各地。</p><p>  直到毕达哥拉斯的时代，美索不达米亚人和腓尼基人建立的殖民城市，科学和艺术水平远高于希腊诸岛和本土。各地的人们都到那里学习数学、天文、科学和艺术，毕达哥拉斯也是留学生中的一员。受益于腓尼基人对知识的传播，数学，特别是几何学传到了希腊文明圈，并且在那里形成体系。</p><p>  在毕达哥拉斯学派的手中，几何学逐渐成为单纯基于逻辑推理的数学工具。到了公元前4世纪—公元前3世纪，古希腊数学家欧几里得等人完成了对几何学公理化体系的构建，并且写成了《几何原本》一书，关于这个公理化体系，我们明天再讲。</p><p>  通过早期几何学3000年的发展，我们可以看到它经历了三个阶段：首先，从懵懂的感性认识到量化的感性认识，其标志就是通过几何学确立了一年的长度。接下来，确立角度的单位。这两步都和天文学有关。</p><p>  最后，把知识总结记载下来。这个过程也是我们应该学会的认知过程。我们人通常缺的是第二步，对新的事物不知道如何定义度量单位，而没有这一步，总结出来的知识就难以准确描述，只能大概定量描述。</p><p>  当然，最后几何学变成一个公理化的知识体系，人类发现各种引理、定理和推论，主要是希腊人的功劳。这个过程反映出人类认识从具体到抽象，从简单事实，到完整理论的过程。</p><p>  那么为什么是古希腊人，而不是更早的古巴比伦人完成了几何学理论的构建呢？一般认为，希腊人对物质生活要求很低，把大部分时间用于了理性的思考和辩论，这让他们能够从知识点中抽象出概念，然后形成体系。</p><p>  另外，古希腊没有强权的政治，这让学者可以仁者见仁，智者见智，这才有利于科学的发展。这两点也给了我们一些启发。</p><p>  至于几何学公理化体系是如何建立的，有什么特点，它为什么特别重要，我们下一讲再讲。我们下一讲再见。</p><h3><span id="21-gong-li-ti-xi-ji-he-de-xi-tong-li-lun-cong-he-er-lai">21 ｜ 公理体系：几何的系统理论从何而来</span><a href="#21-gong-li-ti-xi-ji-he-de-xi-tong-li-lun-cong-he-er-lai" class="header-anchor">#</a></h3><p><img src="/images/81.jpg" alt=""></p><p>  说到几何学，大家就会想到欧几里得几何，以及他那本影响至今的数学书《几何原本》。这本书的完整性和严密性令人叹为观止，2000多年后的今天依然有不少人将它作为数学教材使用。那么欧几里得把零散的几何学知识通过公理化系统统一起来有什么意义呢？我们不妨先看看这样一个实例。</p><details><summary>...</summary><p>  在清朝末年，李善兰等人翻译了《几何原本》的全文之前，中国当时的数学家们估算圆周率还比不上1000多年前的祖冲之（祖冲之推算到小数点后7位）。类似的，同时期阿拉伯学者的水平，也未必能超过他们1000年前的祖先花拉子密。</p><p>  当然，你可以说祖冲之的方法失传了，不过失传本身就投射出那些学问很难学。其实类似的情况举不胜举，古代东方文明经常是后人不如前人，很多研究都得一遍遍从头再来，这导致了科学研究在上千年的时间里原地踏步。</p><p>  但是，《几何原本》传入中国之后，数学面貌就大为改观了。比如，曾纪鸿（曾国藩的小儿子）在李善兰的指导下，自己拿着这本书和入门的代数书学习之后，很快成为了数学大家，并一口气将圆周率推算出200位，这就是系统学习成体系的知识所带来的好处。同时也说明像《几何原本》这样的系统著作在传播知识上的便利性。</p><p>  那么为什么公理体系的数学理论那么厉害呢？简单地讲，再难的数学题，都可以通过一个个定理，不断地被拆解成一些比较简单的问题，并最终被拆解为几个基本的公理，只要把那些小问题解决了，难题就解决了。</p><p>  因此，掌握了这样一些基本方法，不仅各种应用难题都可以得到解决，而且还有可能推导出新的定理。具体到几何学，它就是建立在下面五条一般性的公理（也被称为一般性概念），和五条几何学公理（也被称为公设）之上的。其中五条一般性的公理分别是：</p><ul><li>如果a=b, b=c, 那么a=c；</li><li>如果a=b，c=d，那么a+c=b+d;</li><li>如果a=b，c=d，那么a-c=b-d;</li><li>彼此能重合的物体（图形）是全等的;</li><li>整体大于部分。</li></ul><p>看了这些公理，你可能会觉得它们都是大白话，但是在数学上，什么事情都不能想当然，都要有根据，如果一个结论实在找不到根据，它似乎又是符合事实的，只能称之为公理了。当然，如果是能够从其它公理推导出来的结论就不是公理，而是定理了。</p><p>  对于几何学来讲，它还需要一些和几何有关的公理支持它（它们也被称为公设，我在课中称之为几何公理），欧几里得给出了这样五条：</p><ul><li>由任意一点到另外任意一点可以画直线（也称为直线公理）；</li><li>一条有限直线可以继续延长；</li><li>以任意点为心，以任意的距离（半径）可以画圆（圆公理）；</li><li>凡直角都彼此相等（垂直公理）；</li><li>过直线外的一个点，可以做一条，而且仅可以做一条该直线的平行线（平行公理）。至于平行线，就是平面上永不相交的两条线。</li></ul><p>这五条公理读起来也是大白话，只有其中第五条是我根据它的含义用我的语言给你解释了一遍，原来的描述非常费解。对于前四条，数学家们都没有异议，对于第五条面对的挑战，我们后面讲。</p><p>  有了五条基本公理和五条几何公理，欧几里得又定义了一些基本的几何学概念，比如点、线、夹角等等，在这些基础之上，他把当时所知的所有几何学知识都装进了一个极为严密的知识体系。欧几里得构建公理化的几何学的过程是这样的：</p><ul><li>首先，遇到一个具体问题，要作相应的定义，比如什么是夹角；</li><li>其次，从定义和公理出发，得到相关的定理；</li><li>然后，再定义更多的概念，用公理和定理推导出更多的定理；</li></ul><p>这样，不断循环，几何学大厦就构成了。在构建几何学的体系中，逻辑是从一个结论通向另一个结论唯一的通道。</p><p>接下来，我们用两个例子，来进一步说明上述思路。</p><p>首先我们证明一个简单的定理——“对顶角相等”。这一个定理是这样说的：</p><p>L1（即AB）和L2（即CD）是两条直线，它们相交于O点，∠1和∠2被称为对顶角（这句话其实是对顶角的定义）。结论：∠1等于∠2：</p><p><img src="/images/82.jpg" alt=""></p><p>为了证明这个定理，我们先要证明一个引理：所有直线对应的角都相等，也就是我们所说的180度。大家看到这个引理可能会说，这不是显而易见的吗？在几何学中，除了公理之外，没有什么是显而易见的规律，所有的表述（statements）都需要证明。</p><p>  怎么证明这个引理呢？我们只能从定义和公理出发。我们要用到两个定义，即垂直的定义，以及直角的定义。垂直的定义是怎么说的？当一条直线L和另一条直线M相交后，左右两边的夹角相等，则称M和L垂直：</p><p>  在图中，L和M相交后，左右两个角都相等，于是M和L垂直。</p><p><img src="/images/83.jpg" alt=""></p><p>那么直角是怎么定义的呢？如果直线L和M垂直，那么夹角就是直角。从这两个定义我们可以得到什么结论呢：就是一条直线自身的角度，等于左右两个直角相加，这是显而易见的。</p><p>  接下来我们就可以利用垂直公理了。因为任何直角都相等（都是90度），而任何一条线对应的角是两个直角相加，于是，所有直线对应的角都相等（当然，严格地讲，得到这个结论还需要用一次一般性公理2）。</p><p>  有了这个引理，我们再回去证明对顶角相等。</p><p>  我们先看图中直线L1，这条直线对应的角是∠1和∠3两个角相加，至于直线L2，它也是两个角相加，即∠2+∠3。</p><p>  这时我们就可以利用前面证明的引理了，由于任何直线对应的角都相等，因此，∠1+∠3=∠2+∠3。</p><p>  再接下来，我们利用一般性公理的第3条，等式的两边都减去一个相等的量，它们依然相等。于是，我们将上面的式子两边减去∠3，就得出∠1和∠2相等的结论。</p><p>  到此，对顶角相等这件事才算证明完，就成为一条定理了。为了方便你理解这个证明过程的逻辑性，我把这个过程中用到的定义和公理，以及它们的前后依赖性，总结成一张流程图：</p><p><img src="/images/84.jpg" alt=""></p><p>看到我这个证明，你可能会说，真啰嗦，为什么不直接用量角器量一量∠1和∠2是否相等呢？正如我们在前面介绍毕达哥拉斯定理中所讲的，这样得到的结论不是数学的结论，最多算是实验科学的结论。</p><p>  在前面我们证明对顶角相等时，我们只用到了定义和几个基本的公理，没有加入任何主观的假设，也没有用到任何公理之外，看似是正确的客观假设。即使对于“凡直线对应的角都相等”这样直观的结论，我们也经过了严格的证明，这样我们得到的定理才坚实。</p><p>  对于上述定理的证明，我还要多说一句，无论在证明引理时，还是在证明后来的定理时，我都借助了和问题并不直接相关的媒介。在证明引理时，我采用了一条垂线，它在几何学上被称为辅助线；在证明定理时，我采用了一个辅助角（∠3）。</p><p>  它们都是我为了证明而虚构出来的东西，但是这些虚构的东西对证明实在的事情有帮助。大家如果回想一下我们之前讲到的虚数这个工具，结合今天使用的辅助线和辅助角，可能就更进一步理解数学中虚与实的关系了。</p><p>  接下来，我们再看看假如有了“对顶角相等”这个定理，还能得到什么其他的结论。我们用它来证明一个新的定理：内错角相等。</p><p>当然，在证明这个定理之前，需要先证明另一个定理，被称为“同位角相等”。这个证明我就省略了。同位角和内错角是怎么回事，大家看图，很容易理解。</p><p><img src="/images/85.jpg" alt=""></p><p>在图中，L1和L2是两条平行线，L3和它们相交，∠1和∠2是同位角。而∠2和∠3则被称为是内错角。我们要证明的定理说的是这两个角相等。</p><p>  现在我们有了“对顶角相等”，以及“同位角相等”这两个定理。从第一个定理出发，我们得知，∠1=∠3，从第二个定理出发，我们得知∠1=∠2。于是，我们应用一般性的公理中的第一条，得到∠2=∠3这个结论。这样我们就又证明了一个定理。</p><p>  通过上面这两个例子，我们可以看出那么复杂的几何学是如何一步步搭建起来的。这样构建一个知识体系有什么好处？对于很多具体的问题，古代东方文明直接解决具体问题的做法或许也行得通，但是问题和问题因为之间没有太强的逻辑关联，那些数学成就就无法形成体系，而且难以举一反三。</p><p>  古希腊人这种建立在公理和逻辑基础之上的学科体系，能够逐步通过定理建立起完整的理论大厦，后人可以不断在前人基础上进步，并且能够解决越来越多的具体问题，这就是为什么我们要学习几何的原因。</p><p>  在学习它的过程中，我们能体会一个公理系统的结构和构建过程，以便以后做事能事半功倍。事实上，现代的很多学科，包括人文学科，都受益于这种公理化体系的特点。</p><p><strong>要点总结：</strong></p><p>  整个几何学的基础是十条非常简单的公理，它的发展依靠对新定理的发现和通过逻辑推理证明这些定理。这种严格缜密的思维方式，在古代是古希腊文明所独有的。</p><p>  在几何学的发展过程中，除了欧几里得，他之前的数学家恩诺皮德斯起了很大的作用，后者明确指出了一般性问题和定理的区别，一般性问题解决得再多，对体系建立的帮助也不大，定理则不同，它们是搭建体系的基石。此后，几何学走向了正轨。</p><p>  最后，我来分享两点我的体会。首先是如何学习几何，它不在于多做多少题，做练习的目的是理解这个体系中每一个定理的来龙去脉，这样脑子里就有了几何学的导图，遇到新的问题就可以用类似的方法解决。</p><p>  其次，在任何时候，除了那些客观的、被验证了的，或者不证自明的道理，我们作决定时，不要加上过多的主观假设。我们常说，未经审视的人生没有价值，其实未经逻辑检验的结论，价值也不大。</p><p>  当然，讲到公理的作用，大家可能会想，如果一开始使用了一个错误的前提作为了公理，会是什么结果呢？这个我们下一讲再讲。下一讲见。</p></details><h3><span id="22-fei-ou-ji-he-xiang-dui-lun-de-shu-xue-ji-chu-shi-shi-me">22 ｜ 非欧几何：相对论的数学基础是什么</span><a href="#22-fei-ou-ji-he-xiang-dui-lun-de-shu-xue-ji-chu-shi-shi-me" class="header-anchor">#</a></h3><p><img src="/images/88.jpg" alt=""></p><p>我们上一讲讲到，整个几何学就是建立在五条一般性公理和五条几何学公理之上的，那些公理都是不证自明的，或者说无法证明的。</p><details><summary>...</summary><p>  那么万一公理有错，会是什么情况呢？这时会得到两种情况，首先如果某一条自己设定的新公理和现有的公理相矛盾，那么相应的知识体系就建立不起来。</p><p>  其次，如果那一条和现实世界并不相符的公理和其它的公理没有矛盾，那么就可以根据逻辑推出一个和之前不同的知识体系，这个体系也能自洽，但是可能和其它知识体系相矛盾。</p><p>  讲回到几何的那几条公理，对于那五条一般性公理，大家都没有疑问，对于几何公理（公设）的前四条，大家也都没有疑问，但是对于第五条，也就是“过直线外的一个点，可以做一条，而且仅可以做一条该直线的平行线。至于平行线，就是平面上永不相交的两条线。”这时就有人犯嘀咕了，会不会经过直线外的一点，能够做出很多条平行线，或者干脆一条也做不出来呢？</p><p>  当然，我们根据直觉会觉得，欧几里得的想法是对的，因为在现实生活中，我们对任意直线和线外的一点，不可能做不出一条平行线，更不可能做出两条来。但是，由于这个公理本身是无法验证的，又不算很直观，因此对它作其它的假设或许也有道理。</p><p>  在数学史上，有两个人就把几何学中的第五公理改了，然后依照逻辑，各自创立出一整套能够自洽的新的几何体系。</p><p>  第一个人叫做罗巴切夫斯基，他假定过直线外一个点，能够做该直线的任意多个平行线。如果我们承认他所作出的这个假设，并且应用由此而来的全部结论，那么空间就由我们平时熟悉的方方正正的形状，变成了马鞍形，也称为双曲面。</p><p>  在这样的空间里，三角形的三个角加起来就小于180度了。此外，很多欧几里得几何的结论在这个新的体系中都要修改，但需要指出的是，这个新的几何学体系本身是自洽的。今天它就以发明者罗巴切夫斯基的名字命名了，当然中国人为了简单起见，就称呼它为罗氏几何，类似的，欧几里得几何也被称为欧氏几何。</p><p>  第二个改变第五公理的人是著名数学家黎曼，他假定经过直线外任意一个点，一条平行线也做不出来，这样构建的几何学被称为黎曼几何。在黎曼几何中，空间被扭曲成椭圆球的形状。这个空间每一个切面是椭圆，因此它也被称为椭球空间。如果你在上面画一个三角形，它的三个角加起来大于180度。</p><p>  这个结论你其实在地球上很容易证实：你从北极出发往正南走100米，再往正西走100米，最后往正北走100米，你又回到了出发的原点，也就是北极点。你走过的这个三角形，三个角之和为270度。</p><p><img src="/images/87.jpg" alt=""></p><p>  此外，黎曼几何本身也是一个自洽的知识体系。黎曼几何和罗氏几何由于得出的很多结论都不符合欧氏几何，因此它们被统称为非欧几何。</p><p>  为什么数学家们要“吃饱了撑的”，把我们生活的三维扭曲成各种形状，这种虚构出来的几何学体系有用么？要知道，欧几里得所确定的公理已经经过了两千多年的实践检验。应该讲，罗巴切夫斯基和黎曼在构建各自的几何学体系时，也不知道它们有多少实际用途。</p><p>  不过，黎曼作为数学家，他希望一些涉及到曲面的数学问题在解决的时候简单一些。比如在一个三维的欧几里得空间，一个球面的方程是x<sup>2+y</sup>2+z^2=25，而在黎曼空间中，它就是R=5这么简单。虽然它们在数学上是等价的，但是形式上差异很大。黎曼就希望在解决球面和其它曲面的问题时，最好有形式上比较简单一致的表述方式。</p><p>  但是，在黎曼几何诞生之后的半个多世纪里，它也没有找到太多实际的用途，真正让它为世人知晓的并非其他数学家，而是著名的物理学家爱因斯坦。在爱因斯坦著名的广义相对论中，所采用的数学工具就是黎曼几何。</p><p>  根据爱因斯坦的理论，一个质量大的物体（比如恒星），会使得周围的时空弯曲，牛顿所说的万有引力被描述为弯曲时空的一种几何属性，即它的曲率。爱因斯坦用一组方程，把时空的曲率，其中的物质，能量和动量联系在一起。</p><p>  之所以采用黎曼几何这个工具，而不是欧氏几何来描述广义相对论，是因为时空和物质的分布是互相影响的，并不像牛顿力学里面所认为的时空是固定的。特别是在大质量星球的附近，空间被它的引力场弯曲了：</p><p><img src="/images/86.jpg" alt=""></p><p>  在这样扭曲的空间里，光线走的其实是曲线，而不是直线。1918年，爱丁顿爵士利用日食观察星光曲线的轨迹，证实了爱因斯坦的理论。这件事也让黎曼几何成为了理论物理学家们很常用的工具。</p><p>  比如，在过去30年中，物理学家对超弦的理论极度着迷，而黎曼几何（以及由它派生出的共形几何），则是这些理论的数学基础。此外黎曼几何在计算机图形学和三维地图绘制等领域有广泛的应用。特别是在计算机图形学中，今天计算机动画的生成离不开它。</p><p>  既然黎曼几何在很多应用中证实了它的“正确性”，而它的很多结论和欧几里得几何又不相同（比如三角形三个角之和大于180度），是否说明欧几里得几何是错的呢？如果不是，又该怎样理解这样两个不同的几何体系的共存呢？这个问题到了19世纪末已经被数学家们想清楚了。</p><p>  如果你重新看一遍欧几里得提出的那些公理，就会发现一个问题，他其实根本没有定义什么叫做平面。虽然我们在中学时把所学的欧几里得几何称为了平面几何，但是我们脑子里所想的平面其实是没有定义的，我不知道老师是出于什么原因，把这个问题一带而过了，可能是觉得十几岁的孩子不容易接受比较抽象的概念吧，干脆省略了。</p><p>  因此，学习了今天的内容后，我觉得大家应该有这样一种理性眼光，就是我们习以为常的事情，在没有明确说明之前，大家的认同其实会有误解。比如我们常常说深颜色，并不觉得这个概念不清晰，但是不同人理解的深颜色可能不同。</p><p>  事实上，对平面的认识也是如此。到了19世纪后，数学家们发现，如果对平面作如下明确的定义：满足平行公理的面被称为平面，那么欧氏几何的基础就更扎实了。</p><p>  罗巴切夫斯基等人一开始的工作，并不是想推翻平行公理，而是想看看它能否从其它四条几何公理中推导出来，结果这件事没做成，他们反而创造出了在双曲面上的几何，而黎曼则相反，创造出了椭球上的几何。</p><p>  需要指出的是，虽然非欧几何和欧氏几何在形式上很不相同，但却是殊途同归。同一个命题，可以在这三种系统的框架内相互转换，因此如果欧几里得几何没有矛盾，非欧几何也就自然没有矛盾。</p><p>  好了，现在有了三个等价的几何学“工具”，在解决具体问题时选用一个方便的工具，就成为了活学活用数学的技巧了。对于工具的差异，我们可以把它们理解成是一字改锥和十字改锥就可以了。并不是说使用十字改锥的工作一字改锥做不了，而是非常麻烦，而且做起来要非常精细，搞不好就会出错。</p><p>  当然，如果必须用一字改锥的地方，你用十字改锥，确实多有不便，不过你依然可以拿刀子把一字螺丝修成十字的，然后让十字改锥发挥作用，当然这种做法是多此一举。而爱因斯坦的过人之处在于他善于找到最方便的数学工具。</p><p>  数学的美妙之处在于它的逻辑自洽性和系统之间的和谐性。黎曼等人修改了一条平行公理，并没有破坏几何学大厦，而只是演绎出一个新的工具。不过，如果你胡乱修改其它的一条公理，比如你把垂直公理给改了，几何学大厦就崩塌了。</p><p>  事实上，罗巴切夫斯基和黎曼等人在考虑替换几何学公理时，不是随机乱找的，而是发现平行公理的描述比其他的都长很多，非常不直观，而且在整个几何学的公理和定理体系中，它很晚才被用到，也就是说，很多结论的获得并不需要这条公理，使用前面九条就够了。</p><p>  数学家们曾经怀疑它是否真的是一条独立的公理，或许它只是其它公理的推论而已呢？直到后来意大利数学家贝尔特拉米证明了平行公理和前四条几何公理一样是独立的。</p><p>  最后，和你分享一下这段历史对我在认知上的两点启发。</p><p>  首先，今天我们介绍的三种几何系统，其实它们90%的公理都是相同的，最后差出了一条看似最无关紧要的公理，但是，由此之后，发展出来的知识体系就完全不同了。</p><p>  我们时常在学习别人的经验时，觉得似乎自己学到了，但是做出来的东西就是不一样。大部分时候，这种差异来自于细节，可能就是10%。但是，我们常常会满足于90%的一致性，忽略了那一点差异，这就导致了结果完全不同。</p><p>  不过，话又说回来，当我们基于新的假设，创造出一个和别人不同的东西时，除非我们的假设很荒唐，否则那些与众不同的东西或许在特定场合有用。我非常喜欢李白的一句话，“天生我材必有用”，不必刻意强求和别人的一致性。作为人，基本的设定没问题，活出自己的精彩是对社会的贡献。</p><p>  其次，数学是工具，而这种工具可能有很多种，它们彼此甚至是等价的。在不同的应用场景中，有的工具好用，有的费劲，学数学关键是要学会在什么情况下，知道使用什么工具。</p><p>  下一讲，我们讲讲几何学在另一个维度的发展。我们下一讲再见。</p></details><h3><span id="23-jie-xi-ji-he-yong-dai-shu-fang-fa-jie-jue-geng-nan-de-ji-he-ti">23 ｜ 解析几何：用代数方法解决更难的几何题</span><a href="#23-jie-xi-ji-he-yong-dai-shu-fang-fa-jie-jue-geng-nan-de-ji-he-ti" class="header-anchor">#</a></h3><p><img src="/images/89.jpg" alt=""></p><p>这一讲我们学习解析几何，这是一种能解决几何难题的妙法。</p><details><summary>...</summary><p>  我们前面说了几何是最早出现的数学分支之一，一般来讲，人类的知识体系是从易到难建立的，但是几何学似乎要比后来出现的代数学来得难，这可能是人类逻辑推理的能力反而不如套用公式的能力强的原因。</p><p>  那么能否使用代数的方法解决几何学问题呢？也就是写出相应的直线或者曲线的方程，然后再解方程，因为解方程比作几何推论简单。</p><p>  这是一个非常大胆、极具创造性的想法，可以用“伟大”来形容。我想，即便让我活十辈子，我也想不出这样好的想法。想到这种伟大想法的人，也是一位伟大的人，他是法国思想家和数学家笛卡尔。</p><p>  解析几何因为要用到坐标，因此你也会偶尔看到坐标几何的说法，它和解析几何是一回事。在西方，很多时候它被称为笛卡尔几何，这是为了纪念笛卡尔，但是在国内我们可能是为了刻意抹去一些外国的人名，你很少看到这样的说法。</p><p>  不过这样一来，学生们对解析几何的来龙去脉就缺乏了解了。特别是我们所谓的平面直角坐标在西方一律被称为笛卡尔坐标，没有“平面直角坐标”这个词。如果你将来去那里的大学读书，和人家说平面直角坐标，没有人懂。</p><p>  因此，在这里我给家长一个建议，对于那些教科书中缺失了的数学名词里的外国人名，家长辛苦一点，到网上查一下，给孩子补上。</p><p>  讲回到解析几何，为什么笛卡尔要设计一种平面坐标，然后将几何图形放到坐标中用代数的方法研究呢？他的目的当然是为了把几何问题变简单，尤其是那些曲线、圆相关的几何问题。</p><p>  如果你还对初中的数学有印象，就会发现几何在引进圆之后，变得特别难，无论是证明还是计算都是如此，甚至那些内切、外切等概念都很容易混。如果你遇到的是椭圆怎么办？那你的头真的要大了。</p><p>  其实在笛卡尔之前，已经有人开始研究代数和几何的关系了，但是那时人们除了研究圆的规律，没有太多的几何学问题非要使用坐标和代数不可，因此偶然出现一些零星的方法形成不了知识体系。</p><p>  到了笛卡尔的时代，情况就变了。开普勒已经提出了行星运动的三定律，这三个定律都是基于椭圆轨道的，而不是当初哥白尼和伽利略基于圆形轨道的。更难的是，当时科学家和仪器商人们开始利用玻璃透镜制造望远镜，就需要研究光在曲面上的折射和反射问题。</p><p>  这些问题使用传统的几何学工具都很难解决。笛卡尔就是在这个基础之上发明了笛卡尔坐标，以及解析几何的。</p><blockquote><p>注：在笛卡尔之前，虽然有托勒密使用的球面坐标，也有了把平面按照水平和垂直线划分出区域的方法，但是没有人在平面上用两个彼此垂直的无限长的直线设定坐标的方法。因此后世就把这种坐标用他的名字命名了。</p></blockquote><p>  笛卡尔发明解析几何的过程很传奇，他身体一直不好，经常躺在病床上，据说他是看到房顶上绕着弧线飞来飞去的苍蝇，想到了把房顶画上格子，来追踪苍蝇的轨迹。</p><p>  当然，笛卡尔并非是因为看到苍蝇飞就灵机一动地发明了解析几何，而是在脑子里先有构造了解析几何体系的完整想法，并且很清楚如何将平面几何中的图形用代数的公式来描绘。</p><p>  我们先来看看直线和方程的关系。在代数中有二元一次方程，比如AX+BY+C=0。在平面坐标上，它代表一根直线，这样的一次方程也因此被统称为线性方程。在一些特殊的情况下，比如A=0，它就变成了水平线，反之，如果B=0，就变成了垂直线。如果A=B，直线就和水平、垂直方向都有45度的夹角。</p><p><img src="/images/90.jpg" alt="图一"></p><p>代数和几何被统一起来之后带来了很多好处。</p><p>  一方面，一些复杂的几何学问题可以变得很容易。比如在几何中有一个定理，三角形的三条中线交于一点，你要用单纯几何的办法证明它还得费点周章，但是用代数的方法在坐标系下证明它，就极为容易。这里限于篇幅的原因我就不给出推导的步骤了，大家记住这个结论就好。</p><p>  另一方面，解析几何也可以让很多原本看似抽象的代数问题变得很直观。比如我们前面在介绍鸡兔同笼和方程组问题时介绍了二元一次方程组，即每一个方程有两个未知数，方程中的未知数都只能是一次方，这样两个方程一组。但是，当时我们并没有讲这样两个方程所构成的方程组是否有解，事实上一些二元一次方程组无解。</p><p>比如：</p><ul><li>X-Y+3=0</li><li>2X-2Y=0</li></ul><p>就无解。</p><p>  另外，有一些方程组却有无数解。比如：</p><ul><li>X-Y+3=0</li><li>2X-2Y+6=0</li></ul><p>接下来问题来了。什么时候方程组有一个解，有无数解，或者根本无解呢？在初中，老师会教给你一些判断标准，这些标准能不能学会并且体会其中的道理，就看各个学生的悟性和理解力了。如果悟性和理解力不够，就看记忆力了。</p><p>  但是，这些能力都很难复制，张三的悟性给不了李四，李四记住了一个数学知识点，未必能记住下一个。其实学好数学靠的是有一套系统性的方法，和能够帮助理解的工具。对于解方程来讲，解析几何就是理解它们含义的工具。</p><p>  我们知道，任给一组X和Y，它们其实对应于平面坐标上的一个点。而一个二元一次方程则代表一根直线，方程组中的两个方程就对应于两根直线。</p><p>  如果这两个方程所代表的直线相交，如下图2所示。那么就说明有一点既在直线1上，又在直线2上，这个交点所对应的X和Y，也就是方程组的解。</p><p>  如果两条直线平行，就不可能有交点。这就说明不可能有一个点既在直线1上，也在直线2上，那么方程组就无解。</p><p>  当然，如果两条直线完全重合，那么就有无数个点既在直线1上，也在直线2上，相应的方程就有无数解。</p><p>  我们把上述三种直线之间的关系画在下面的坐标中。前后三张图中的情形，分别代表有一个解、无解和有很多解的情况。</p><p><img src="/images/91.jpg" alt="图二：一个解"></p><p><img src="/images/92.jpg" alt="图三：无解"></p><p><img src="/images/93.jpg" alt="图四：很多解"></p><p>当然，我们讲了，数学不能靠测量，解方程不能靠在图上画线，但是利用解析几何这个工具，我们可以很好地理解方程的本质，更好地学会解方程。</p><p>  接下来，我们就用解析几何这个工具，把之前讲到的一些知识点再串联起来。</p><p>  首先还要再说一次毕达哥拉斯定理，在笛卡尔坐标中，计算任何两个点之间的距离，必须要用到毕达哥拉斯定理。</p><p>  其次，我们把前面所说的一元二次方程和一元三次方程，同坐标系中的一些曲线对应起来。一元二次方程对应于抛物线，我在下图中画了三根抛物线。</p><p>  第一根抛物线和x轴，也就是横轴有两个交点，也就是说，有两个可能的x值，让方程等于零，这两个值就是相应方程的两个解。第二个则只有一个交点，因此相应的方程只有一个解，第三个干脆没有交点，因此对应的方程无解。</p><p><img src="/images/94.jpg" alt="图五：两个解的二次方程"></p><p><img src="/images/95.jpg" alt="图六：一个解的二次方程"></p><p><img src="/images/96.jpg" alt="图七：没有解的二次方程"></p><p>和二次方程不同的是，三次方程对应的曲线总是一头往负无穷大走，另一头趋向正无穷大，是下面这个图的形状。</p><p><img src="/images/97.jpg" alt="图八：三次方程曲线的形状"></p><p>当曲线从负无穷往正无穷变化时，它一定要经过零这个点。我们前面在介绍三次方程解法时留了一个未回答的问题，就是三次方程一定有实数解。今天我们用解析几何这个工具将它解决了。</p><p>  通过讲解解析几何发展的历史和它大致的内容，我们首先应该进一步深刻地理解为什么说数学是一种工具。解析几何这种工具在宇宙中是不存在的，完全是笛卡尔等人根据之前的数学理论，按照逻辑凭空构建出来的。</p><p>  但是它一旦出现，就能很方便地解决过去看似比较难的几何问题，也能解释为什么三次方程一定有实数解这样过去解释不了的问题。从这里，我希望大家能体会数学上的“虚”是可以为现实中的“实”服务这个普遍规律。</p><p>  接下来，我不知道你是否体会了“融会贯通”这四个字在学习数学过程中的含义。我们通过解析几何把之前很多知识点又串联了起来。学好数学，不是做很多超出自己理解能力的难题，而是把自己有能力理解的知识融会贯通起来。</p><p>  这样至少能保证数学考80分，而且以后想用的时候，还能把数学这个工具捡回来使用，否则刷再多的题，考试时遇到两道不会做的题，照样考不到80分，更糟糕的是考完试之后，收获几乎是零。</p><p>  当一个人40岁的时候，发现自己从6岁到大学毕业22岁这16年间，花了1/3的时间学的数学一点用没有，除了会算加减乘除全忘光了，岂不悲哀？早知是这样，何必要刷那些反正自己也理解不了的题呢？</p><p>  最后，还要强调学会使用工具的重要性，要把学习数学当成学习使用各种工具的练习。解析几何不但承前，而且启后，在它的基础上出现了微积分，笛卡尔也因此成为了牛顿所说的前面的巨人。这些内容，我们到了微积分模块再讲。</p><p>  下一讲，我们讨论一下几何学公理化体系的本质，以及如何使用构建公理化体系的思维方式。</p></details><h3><span id="24-wei-shi-me-ji-he-neng-wei-fa-lu-ti-gong-li-lun-ji-chu">24 ｜ 为什么几何能为法律提供理论基础？</span><a href="#24-wei-shi-me-ji-he-neng-wei-fa-lu-ti-gong-li-lun-ji-chu" class="header-anchor">#</a></h3><p><img src="/images/102.jpg" alt=""></p><p>**通过公理化系统建立起一个知识体系，体现出人类创造思想的最高水平，**如果大家通过这50讲的通识课，在这个水平上有所提高，甚至能够在一定的范围内实践这件事情，则是人生一大成就。</p><details><summary>...</summary><p>  我们前面讲了几何学是如何从知识点变成公理化系统的，并且讲述了它的好处，这个原则实际上适用于人类文明的各个方面。我们今天先讲两个和数学距离远一点的领域，然后讨论构建公理化知识体系的一般规律。</p><p>  我们讲的第一个例子是法律学。</p><p>  今天人们谈起罗马，会说罗马人一共三次征服了世界，第一次是靠武力，第二次是靠拉丁语， 而第三次则是靠罗马的法律体系，简称为罗马法。</p><p>  今天世界上大部分国家的法律体系都可以归根溯源到罗马法，或者和它有很大的相似性。比如法国著名的《拿破仑法典》，德国的宪法和民法典，日本的宪法和法律系统等等。</p><p>  那么罗马法和古代中国或者印度的法律有什么区别呢？其实在早期它们的区别并不大，罗马人留下来的最早的法律是“十二铜表法”（因写在12块牌子上而得名），它和古巴比伦《汉谟拉比法典》中的部分内容，以及后来汉朝萧何做的《九章律》等没有什么本质的区别。这就如同几个早期文明在几何学上的研究水平不相上下一样。</p><p>  但是，几百年后，经过从西塞罗到查士丁尼时期很多法学家的努力，他们为罗马法找到了最基本的根据。于是罗马法就脱胎换骨了，从此和古代文明中那些单纯反映统治者意愿的法律非常不同，成为了一种维持公平公正的系统性工具。</p><p>  在罗马法中，那些最基本的，不证自明的依据，就是自然法。著名法学家亨利·梅因说：“我找不出任何理由，为什么罗马法律会优于印度法律，假使不是有‘自然法’理论给了它一种与众不同的优秀典型。”</p><p>  而奠定罗马法学中自然法精神的西塞罗，则是这样明确而系统地阐述了自然法的哲学前提：“法律是自然的力量，是明理之人的智慧和理性，也是衡量合法与非法的尺度。”这句话其实就是我们今天说的一切都要以法律为准绳的另一种表述。</p><p>  西塞罗强调法律是理性和永恒的，这就如同我们所说的数学的定理是普遍实用的一样，他说：“法律乃是自然中固有的最高理性，它允许做应该做的事情，禁止相反的事情。当这种理性确立在人的心智之上并且得到实现，就是法律。”</p><p>  到了查士丁尼时期，法学家们在重要法学论著《法学阶梯》中，将自然法嵌入罗马法中的条文，并且从自然法的原则整理和构建了整个罗马法系统。</p><p>  那么什么是自然法呢？根据《法学阶梯》的描述，罗马法被明确地分为了：自然法、公民法和万民法（相当于国际法）三个部分。自然法是自然界“赋予”一切动物的法律，不论是天空、地上或海里的动物都适用，而不是人类所特有。</p><p>  比如说，自然法认为，传宗接代是自然赋予的权利，因此产生了男女的结合，这就是婚姻，为此引申出了婚姻法，从而也就有了抚养和教育子女的义务，这就如同母狮子要教小狮子捕食一样。今天大家所共有的动物保护意识和各国制定的动物保护法，就源于罗马法中的自然法原则。</p><p>  在公民法中，最基本的原则首先涉及到法律的主体是谁，他们的地位如何。根据自然的原则，万物皆平等，因此在罗马法中，凡是称得上是法律主体的“人”，都是平等的。当然在早期，罗马法律的主体只有自然人，而且不包括奴隶。</p><p>  到了共和时期，罗马出现了很多的社会团体。一些法学家认为：这些团体也应该像人一样具有独立的“人格”；团体中的个人和团体本身是两回事；个人财产和团体财产应该分开，团体的债务不应该转嫁给团体中的个人。这样一来，团体似乎应该和自然人一样，成为法律的主体。</p><p>  到了帝国时期，“法人”的概念在罗马法律中开始出现，上述的团体在法律上被赋予独立的“人格”。当然，随着越来越多的人获得自由，任何人都成为了法律的主体。到了近代，鉴于法律主体的平等性，妇女和少数族裔被授予了选举权。这些变化的理论基础，源于万物皆平等的自然法则。</p><p>  作为法律的主体，人自然要被赋予一些不可剥夺的基本权利，最初包括生命权和自由权（早期的法律主体都是自由民）等基本人权。</p><p>  此外在私有制出现之后，在西方的词汇里，除了有“我”、“你”、“他”这样的代词，还有了“我的”、“你的”、“他的”这些物主代词，���是个人对自己私有财产的所有权也成为了一条不可剥夺的权利，基于这些基本权利，逐渐演绎出后来的物权法、著作权法和专利法，等等。</p><p>  如果我们对比一下罗马法的体系和欧几里得的几何，就会发现它们的共性：都是建立在不证自明，而且符合自然原则的公理之上，通过自然的逻辑演绎创造出新的定理或者法律条文，并且在此基础之上不断扩展。这样的法律，就不会随着统治者的更换而改变，因此具有很强的生命力。</p><p>  在西罗马帝国和拜占廷帝国相继灭亡之后，罗马法却传了下来，并且在法国大革命后成为了欧洲各国现代法律的样本。在法国，虽然它的政体经常变化，至今已经是第五共和国了，但是它的民法典自拿破仑开始就没有什么变化，因为建立在罗马法基础之上的原则依然适用。德国在19世纪统一之后，第一部宪法和民法几乎就是直接将罗马法从拉丁语翻译成德语。</p><p>  我们知道几何是建立在公理之上的，而公理设定的细微差别会导致后来系统巨大的差异，在法律上这种现象也存在。</p><p>  美国建国的国父们，在《独立宣言》中特别把“追求幸福的权利”写进了这个带有宪法性质的文件。后来就出现了这样的情形，美国人一方面是清教徒，在上帝面前宣誓要对配偶一辈子忠诚和照顾，另一方面却随意离婚而毫无撒谎的羞愧，因为“追求幸福的权利”成了类似于公理的法则。至于法律的主体一开始如何定义，更是会影响到后面所有法律的内容和连带结果。</p><p>  1862年，美国南北战争时期，当时的总统林肯要说服国会通过《解放黑人奴隶宣言》，但是很多国会中的保守派议员反对，他们的理由是当初宪法并没有谈到废奴这一条。经过一系列的辩论，林肯也没有说服那些议员们。</p><p>  有一天，林肯想了一个新办法，他到国会讲演时，没有再带那些和法律有关的书籍文件，而是带了本欧几里得的《几何原本》。在国会里，林肯举起这本数学书讲，整个几何学的定理和推理都离不开其中一条公理，那就是所有的直角都相等。既然所有的直角都相等，那么为什么不能人人平等？</p><p>  当你否认了我们所说的直角公理，即使能构建出一个几何学体系，也是不完整，没有效用的。类似的，如果我们把人的不平等设定为法律的公理，那么构建出的社会也不会是平等的。就这样，林肯让反对《解放黑人奴隶宣言》的议员们语塞了，最终宣言被通过了。</p><p>  林肯找的这个关联是不是没有逻辑的瞎联系呢？不是的，他是告诉大家，一个好的体系，一定要构建在代表公平和正义的公理之上。</p><p>  接下来我们讲一个管理学的例子。</p><p>  我在给企业家们讲课时总是讲，创始人的任务一个是招人，另一个是树立企业文化和基因，包括价值观和做事的原则方法。关于招人的事情我们这里不讲，我们来讲讲后面一条。为什么创始人那么忙，还要做这些事情呢？</p><p>  如果我们把办公司看成是构建一个公理化的系统，那么创始人一开始确定的做事原则和价值观，就成为了企业立足的公理部分。那些公理一旦确立，后面的人就会演绎出各种不违背公理的行为规范。</p><p>  一开始设立什么样的公理，就有什么样的体系，这就好比欧几里得几何、罗氏几何以及黎曼几何后来差异很大一样。一个企业如果把客户放在第一位，那么当员工和客户有矛盾时，大家就要想想，是否必须牺牲掉一些自己的利益去满足客户？</p><p>  另一方面，如果把员工的利益放在第一位，那么即使再困难，也要保证员工的利益，当然，也可以把投资人的利益放在第一位。</p><p>  我在《谷歌方法论》中讲这三类公司之间并没有好坏之分，坚持做到一点，就是好公司，这就如同欧几里得几何、罗氏几何以及黎曼几何没有对错之分一样。</p><p>  我还举了三个例子，像阿里巴巴这样的公司就强调客户优先，你经常会看到它处分员工和高管的新闻，但是没有看到它怼客户的新闻。星巴克则正好相反，宁可怼顾客，也要对自己的员工好。至于苹果、微软等公司，则是优先对投资人负责，所以巴菲特很喜欢，而且这两家公司股价的表现确实好。</p><p>  在几何上，公理之间必须具有一致性，不能产生矛盾。我们不能把欧氏几何、罗氏几何和黎曼几何对平行公理的三种不同假设放在一起，去构建一个同时符合这三个公理的系统。</p><p>  类似的，在管理上，你也不可能定出三个彼此矛盾的原则，比如喊什么“顾客第一，员工第一和投资人第一”的口号，这种矛盾的价值观发展不出任何有意义的价值体系。最后的结果必然是，每一个无所适从的人都以“老子的利益天下第一”为原则去做事情。</p><p>  从今天的内容你可以看出，培养一种讲究数学逻辑的、理性的思维方式，可以让我们在很多地方受益。</p><p>  作为这一模块内容的总结，我最后想再讲两句学习数学的方法和目的。在学习方法上，要从靠悟性和理解力，靠刷题提高覆盖率，转变为靠系统性的方法，融会贯通地理解知识，要练习从基本的假设，也就是我们所说的已知条件出发，采用逻辑客观地推导出结论。要把数学从单纯的脑力练习，变成掌握工具的练习。</p><p>  下一讲，我会回答大家的一些典型提问。我们下一讲再见。</p></details><h3><span id="wen-da-shu-xue-de-ji-xian-he-sheng-huo-de-ji-xian-shi-yi-hui-shi-ma">问答 ｜ 数学的“极限”和生活的“极限”是一回事吗？</span><a href="#wen-da-shu-xue-de-ji-xian-he-sheng-huo-de-ji-xian-shi-yi-hui-shi-ma" class="header-anchor">#</a></h3><p><img src="/images/98.jpg" alt=""></p><p><em>吴军</em></p><blockquote><p>这一讲我来回答大家的几个典型问题，一起巩固学过的知识，加深对它们的理解。</p></blockquote><p><em>长梦之河</em></p><blockquote><p>老师好，既然工具很重要，那么为什么在小学不教授像二元一次方程[]这样的先进工具来解决鸡兔同笼的问题，还偏偏要用老工具呢？</p></blockquote><details><summary>...</summary><p><em>吴军</em></p><p>  这个问题其实在课程里说了。</p><p>  除了个别天才，小学生的接受能力其实非常有限。好的教学是根据学生们的接受能力讲授内容，如果明明知道很多学生的接受能力没有达到理解二元一次方程的水平，还硬要往多了教，往深了讲，学生们最好的情况是在不理解的情况下背下来一些方法，差一点的情况是完全蒙了。</p><p>  从我们很多读者在这门课的留言中可以看出，很多人都有这样痛苦而失败的经历。就算很多人背下来了，当时能做几道题，以后也都忘了，而且由于把数学学成了一门需要死记硬背和刷题的课程，会一辈子烦这门课。因此，不看对象过分拔高，害处远远大于好处。</p><p><em>杨进</em></p><blockquote><p>微积分中的极限与我们日常生活中说的极限有什么区别？用动态和极限的眼光看世界是怎样的一种视角？它们具体在生活中的表现方式又是怎样的？谢谢老师。</p></blockquote><p><em>吴军</em></p><p>微积分中所说的极限和生活中所说的极限有两点是相同的，即：</p><p><strong>1.都有不断逼近，或者趋近的含义。</strong></p><p>  比如说你健身时负重深蹲的极限是80公斤，不是说你一上来就能负重这么多，而是说你从50公斤开始练习，可能三个月后能够接近这个范围。因此，从动态看问题这方面讲，两者有相通的地方。</p><p><strong>2.它们都有一定的预见性，比如知道事情发展下去，一定是某个结果。</strong></p><p>  但是它们又有这样两个不同之处。</p><p>**1.在生活中我们有时说的“某某极限”其实并非数学上极限的概念，它们更像是数学中所说的上界，**或者下界，那才是无法突破的意思。比如我们刚才说的深蹲的极限是80公斤，但是如果你想越过它，可能腿或者腰就要受伤了，这其实是数学里上界的意思，也就是说，一个无法超越的边界。</p><p>  数学上的极限强调的是，在很长的时间，或者很远处，它最终的趋势并非不能突破，比如我们说斐波那契数列后面和前面两项的比值R，它在黄金分割1.618……附近浮动，有时会大于黄金分割值，有时又小于这个值，并没有无法突破的意思。</p><p>  在数学上，那些无法突破的边界被称为上界。有些时候，极限是一种上界，比如1/2+1/4+1/8+……= 1，1既是极限，也是上界。但是更多的时候，它们是两回事。</p><p>**2.数学上的极限是绝对的、明确的，生活中却未必。**比如你以为你跑百米的极限是13秒，但是你可能后来发现其实是12.5秒。随着能力和见识的提高，原本的天花板可能就被突破了。在数学上可没有这么一说。关于这一点，你可以回顾我的《谷歌方法论》第8封信，关于做事情的三条边。</p><p>  数学上的很多概念和方法，可以帮助我们理解现实生活中的事情，但是它们并不一定能和现实问题划等号。毕竟，世界上有很多问题并非数学问题，这一点我们在课程中也强调过了。</p><p><em>春子</em></p><blockquote><p>说到无穷大，最近刚看到大栗博司在他的书《超弦理论》中提及欧拉的一个公式，1+2+3+4+……+∞=-1/12 ，并在书末附带了初等数学证明和高等数学证明，仍觉得难以认同。不知道吴老师是否有点开迷雾的理解方法？</p></blockquote><p><em>吴军</em></p><p>  这看似荒唐的结论，道出了数学和实验科学的区别。</p><p>  这个问题在2018年黎曼猜想乌龙事件时，我在《谷歌方法论》专栏里大致介绍了一下。（第196封信 | 黎曼猜想和认识的延展）</p><p>  当时大家缺乏对数学一些背景知识的了解，因此无法讲得很透。这回我们学了很多数学的道理，能够讲得比较清楚了。</p><p>  在上面的问题中，首先涉及到数学上一个被称为“延拓”的概念。什么是延拓呢？比如我们过去做减法，2-3的结果就不是自然数了，因此最早人们只能规定，减法必须是大数减去小数，不能反过来。</p><p>  但是，后来人们就在想，如果我维持减法的逻辑，能否扩展一下数的范围，看看在这样的逻辑下，得到什么结果呢？于是人们就拓展出负数，而且根据和大数减小数完全一样的逻辑，得到了-1这个结果。这就是将减法这种运算延拓到更大的定义空间。</p><p>  类似的，我们前面讲了，将-1的平方根定义为虚数i，也是对开方运算的“延拓”。注意，延拓的要求是计算的逻辑和原来完全相同。你可以简单地把延拓理解为在想象的世界里，一次合乎逻辑的认知升级。</p><p>  上面那个问题，其实也涉及到级数（也就是数列相加）这个运算的延拓。我们在前面讲过，一个等比级数，如果比值小于1，它最终的和就是一个有限的数。但是对于下面这个级数，即调和级数：</p><center>Z＝1/1＋1/2＋1/3＋1/4＋……</center><p>无限地加下去，结果等于多少呢？看似它后面的各项越来越小，但是总和并不会收敛到一个有限的数，而是无穷大。以后，人们发现，各种计算级数的方法，能够使用的前提就是，最终加起来需要是一个有限的数。如果是无穷大，那些方法算出来的结果没有意义，这就如同要规定被减数必须大于减数一样。</p><p>  对于上面这一类调和级数，欧拉发现稍微作一点调整，它就会收敛，比如我们计算：</p><p><img src="/images/99.jpg" alt=""></p><p>欧拉发现，它是一个有限的数，恰巧等于圆周率π^2/6。</p><p>  再接下来，欧拉把这一类的级数再次推广，让级数中的每一项可以是任意的s次方。</p><p><img src="/images/100.jpg" alt=""></p><p>即整数倒数的s次方之和，这里面s可以是任何数。这个函数后来被称为了黎曼Zeta函数（并没有用欧拉的名字命名），但是它通常的解法却被称为了欧拉乘积公式。</p><p>  欧拉发现只要s大于1，上面这个级数就是收敛的，存在有限的答案。如果s等于1，即前面的调和级数，级数和就是发散的，结果是无穷大。当然，如果s小于1，肯定更是发散的了，因为这时的数值比调和级数要大。于是，按照我们一般的做法，就是为这种Zeta函数画一个有意义的定义域，即s必须大于1。</p><p>  但是欧拉作为历史上有名的大数学家是很有想象力的。欧拉就想了，如果让s变成了负数，然后还是用s&gt;1的逻辑来计算相应的级数，会是什么样的结果呢？</p><p>  这种想法在我们的现实世界里是很荒唐的。这就如同大家在小时候如果问老师2-3等于几，大部分老师都会说，别管它，只能是大数减小数，不能倒过来。</p><p>  但是，欧拉没有去管这件事有没有现实的意义，他只是按照过去的逻辑算了算，就得到一些有趣的结论，比如s＝-1，这个级数其实就是：</p><p>  Z（-1）= 1+2+3+4+……，即正整数之和，算出来的结果居然是-1/12。</p><p>  至于这个结论是如何产生的，你不用太关心，当我们把级数的定义范围从必须收敛，延拓到可以不收敛时，就能够得到上述这个符合逻辑，却不符合常识的结论。欧拉其实还得到很多荒唐的结论，我列出了几个：</p><p><img src="/images/101.jpg" alt=""></p><p>从这件事我要强调两点：</p><ul><li>欧拉的这种做法符合逻辑。在数学上，一旦设定好了前提，不论通过什么逻辑得到什么结果，都是合理的，这是数学和自然科学本质的差别。</li><li>但是，在我们通常讨论级数的定义域中，那些结论并不成立。因此大家使用那些结论要特别小心，要注意条件。</li></ul><p>在欧拉之后，对黎曼Zeta函数的定义又作了延拓，把定义域从实数的范围扩展到复数，并且提出了著名的黎曼猜想，也就是在复数的范围内，讨论Zeta函数在什么时候等于零。</p><p>  我们前面讲了，Z（-2）=0，其实Z（-4），Z（-6）都等于零。除此之外，还有什么情况可以让Zeta（s）=0呢？黎曼给出了他的想法，说这些让Zeta函数等于零的复数解，都在复数平面的一条直线上，这就是黎曼猜想。</p><p>  这个问题的细节大家不必关心，只要记住一个事实就可以了，即黎曼猜想和我们今天寻找大素数，改进加密有关。当然，人们认识到这一点，是在黎曼提出那个看似没有太多实际意义的猜想近一百年之后的事情。</p><p>  从这个例子可以看出数学和自然科学的差别。很多看似荒唐的，却完全符合逻辑的数学结论，并非一点用途没有，很多时候几十、几百年后，我们会发现它们的实际用途。从欧拉看似荒唐地将Zeta函数作延拓，到后来的黎曼猜想，一开始都是单纯的数学加逻辑的游戏，可是我们今天发现它们其实也有用。</p><p><em>吴军</em></p><blockquote><p>以上问答就是今天的全部内容，主要回答了最后一个问题，如果你之前听过我的《谷歌方法论》，是否对黎曼猜想的相关内容有新的认识呢？欢迎你继续提问和思考，坚持学习与留言。我们下一模块见！</p></blockquote></details><h2><span id="mo-kuai-si-dai-shu-xue-yong-shu-liang-miao-hui-shi-jie">模块四 ｜ 代数学 用数量描绘世界</span><a href="#mo-kuai-si-dai-shu-xue-yong-shu-liang-miao-hui-shi-jie" class="header-anchor">#</a></h2><h3><span id="25-han-shu-shang-cong-jing-tai-dao-dong-tai-cong-ge-ti-dao-qu-shi">25 ｜ 函数（上）：从静态到动态，从个体到趋势</span><a href="#25-han-shu-shang-cong-jing-tai-dao-dong-tai-cong-ge-ti-dao-qu-shi" class="header-anchor">#</a></h3><p><img src="/images/103.jpg" alt=""></p><p>从这一讲起我们进入有关代数的模块。在这个模块里，我们还是要培养以动态视角看世界的能力，批量处理问题的能力，并且理解因果关系的本质。</p><details><summary>...</summary><p>  代数的发展是从列方程和解方程开始的，那些内容我们已经在第二模块中介绍了，因此今天我们就从代数中第二个重要的概念和工具——函数讲起。这一讲的主题是拥有从静态到动态，从个别到趋势的视角。</p><p>  “函数”这个词我们经常听到，在初中数学里也讲过函数的概念，但是我不清楚你是否还记得它的定义。如果不记得了，并非你的水平不行，更可能是我们的教科书编写得有问题，不容易理解和记忆。我从初中数学书里摘录出了函数的定义，很绕口：</p><p>  在一个变化过程中，有两个变量x与y，如果对于x的每一个值，y都有唯一的值与它对应，那么就说x是自变量，y是x的函数（因变量）。</p><p>  这个定义虽然算不上十分严格，但还是比较准确的。不过我估计你如果原来不懂什么是函数，读了这句话后更糊涂了，因为它为了讲述一个概念，又引入了一堆新概念，比如“变化过程”、“自变量”、“对应”等等。</p><p>  这样的定义让我想起了费曼对一些物理学课本的批评，他的大意是这样的，那些看似严谨的定义，不过是用一些词解释另一些词，学生们就算把它们背得滚瓜烂熟，照样体会不了其中的含义。</p><p>  那么函数是什么？其实我们在前面已经讲到了很多函数。比如我们说到的抛物线，笛卡尔坐标系上的一根直线，在数列中位置和相应元素的关系，它们都是函数。此外我们前面还提到过指数函数、对数函数等等。</p><p>  在生活中，函数也是随处可在，比如在一个单位里，员工和他的工资之间，就是一种函数关系。函数的值也并非一定是数字，可以是其他的数据，比如单位里每一个人的父亲是谁，这也是一种函数。从这些例子中，我们可以发现函数的四个共性：</p><p>  **首先，这些函数里面都有变量，**函数讲的不是3+5，或者2x9这些具体确定的事情。像y=x^2这样的抛物线，x就是变量。像单位里每个人的工资这样的函数，人就是变量。</p><p>  **第二，它们都有一种对应关系。**比如一个等比数列1，2，4，8，16，……，2<sup>n，……序号n，和相应的元素2</sup>n，就是一种对应关系，2^n就是n的指数。</p><p>  再比如，我们在介绍解析几何时，讲过一个二元一次方程AX+BY+C=0，它代表一条直线，这也是一个函数，我们每设定一个X值，就能算出一个Y值，这就有了X和Y之间的对应关系。至于某某的父亲是谁，也是一种对应关系。</p><p>  **第三，上述的对应关系，都必须是确定的，**也就是说，在一个函数中，一个变量只能对应一个值，而不是多个值。比如在等比级数数列中，一个位置上只有一个数，第三个元素不能既是4，又是8。</p><p>  同样，一个人这一年的年薪不能既是10万，又是20万。当然你可以说我的工资比去年涨了，但是在一个特定的时间，它是确定的。</p><p>  **第四，也是最后一个特性，函数所对应的关系可以通过数学的方法，或者其它方法算出来。**比如，在二元一次方程里，给定一个X的值，就能算出一个Y值。在一个单位的档案里，给定人，就能查出他的工资。</p><p>  了解了函数的这四个特性，我们可以看出函数是一种特殊的对应关系，任何一个变量只能对应一个函数值，当一个变量对应了很多数值，这样的对应关系就不是函数。如果我要问你北纬二十度的城市是哪个，你可以找出一大堆，这就不是函数。</p><p>  虽然我们在前面举函数例子时，举了各种各样的函数，但是人们最初研究函数只是用它来描述数学上一些曲线的变化规律。提出函数这个概念的人就是著名数学家莱布尼茨。他在研究微积分时，常常要确定曲线上每一个点的一些性质，比如它附近的点是否连续，或者曲线在这里的斜率是多少。</p><p>  当时大家已经普遍利用坐标系（笛卡尔坐标系）这个工具，将曲线画在上面，坐标系的横轴是x轴，纵轴是y轴，因此，大家通常就把函数关系理解成y随着x变化的走势。</p><p>  比如说，在一个坐标系里，如果x每增加一个单位，y也增加一个或k个单位，那么这种函数关系就是线性的，因为这些点在坐标里画出来就是一条直线。如果x每增加一个单位，y就翻一番，这种函数关系就是指数的，画出来就是一条向上的曲线。</p><p>  在中文里，“函数”这个词是清末数学家和翻译家李善兰创造出来的。李善兰在翻译西方数学著作时，就根据函数的这种对应变化关系，发明了这个名词，他讲：“凡此变数中函（包含的意思）彼变数者，则此为彼之函数。”</p><p>  意思是说，凡是这个变量中包含另一个变量，这个变量就称为另一个变量的函数。也就是说，如果y随x变化，y就是x的函数。李善兰的解释并不准确，但是颇为形象。</p><p>  函数概念的提出在数学史上有划时代的意义。在此之前，人类最初是对一个个的数直接进行计算，后来虽然有了方程式这个工具，但是方程并没有用来表示变量之间的关系，而是作为解题的工具。</p><p>  到了科学启蒙时代，两件事对函数的出现起到了至关重要的作用，一个是解析几何，这让数学家们可以用曲线把一些方程式联系起来，从而大家可以看到一些变量变化的趋势；另一个是天文学和物理学的发展，需要用公式和曲线表示时间和运动轨迹之间的关系。</p><p>  莱布尼茨可以说是生逢其时，他出生得足够早，还没有人提出函数的概念，同时又足够晚，以至于各种准备工作都具备了。</p><p>  有了函数，人类在认识上有了三方面的进步。</p><p>  **首先，我们就很容易看出两个变量之间是怎样相互影响。**比如你看下面这张图，上面有两个长相差不多的西瓜，后一个的直径比前一个大1/4，从图片上看，它们的差别好像不是很大。</p><p>  我问过很多人，如果第一个西瓜卖30块钱，第二个你愿意出多少钱？大部分人给我的答案是，最多多出50%的钱吧。其实第二个的重量比前面一个多出了一倍，也就是说大约值60元。</p><p><img src="/images/104.jpg" alt=""></p><p>这个例子说明，我们都知道圆的周长是半径的2π倍，这是一种线性关系，比较好理解。不过圆的面积和半径的关系就是平方关系，理解起来就要费点劲了。比如圆的半径从1变到2，面积就从原来的1倍变到4倍，如果半径再增加到3倍，面积就是原来的9倍。</p><p>  再往后，球的体积和半径的关系是三次方，半径从1变成2，体积就是原来的8倍，这就更难理解了。虽然人有时能够感觉立方关系的变化比线性的快，但是对于到底增长有多快没有概念。</p><p>  人对变量之间关系的感觉其实不准确，而函数帮我们弥补了这个先天不足。</p><p>  其次，函数的第二个意义是让我们从对具体事物、具体数的关注，变成了对趋势的关注，而且可以非常准确地度量变化趋势所带来的差异。</p><p>  比如我们说，过去几十年中国经济增长较快，经常在8%以上，即使是2017年，依然有6.9%。对于这些数据，其实老百姓没有概念。</p><p>  GDP的增长是时间的一个函数，我用世界银行公布的过去50多年的数据画了这样一张图，图中蓝线是中国经济增长率曲线，另外两条是印度和美国的。从图中你可以看出中国整体上增长不仅比美国快很多，而且大部分时候比快速增长的印度也高不少。这是横向对比。</p><p>  如果纵向对比，你会发现中国自从改革开放后，比以前也好不少，60年代初的三年困难时期，以及文革时期，中国是负增长。但是在改革开放后，这种情况就再没有发生了。</p><p>  很多人平时会对一件事过分敏感，要么因为一个好消息过分乐观，要么因为一个坏消息过分悲观，当我们对函数，而不是一个个具体的数有概念后，我们的见识就容易提高。</p><p><img src="/images/105.jpg" alt=""></p><p>善于做报告的人都知道，在PPT中最好不要直接引用数据，而要把它们变成曲线或者直方图。曲线和直方图其实就是对函数的一种形象表示，它们可以让那些原本对趋势不敏感的听众，实实在在感受到变化。</p><p>  函数的第三个意义在于帮助我们通过学习几个例题，掌握解决一系列问题的方法。比如我们知道了投掷和抛射一个物体，当初速度一定时，最后它飞行的距离是抛射角度的函数，那么我们就能算出不同角度下，抛射的距离。</p><p>  了解了这个函数关系，无论是对从事投掷项目的运动员，还是炮兵或者狙击手，都有指导意义。特别是对后者，他们能够通过控制角度，决定落点。如果我们找不到这样的函数关系，靠做实验的方法达到目的，是不现实的。</p><p>  事实上，最初设计电子计算机的目的，就是根据弹道的函数，计算远程火炮弹道轨迹的，当然，这个函数中不只有角度一个变量，炮弹的速度、空气的阻力和风向等都是变量。</p><p><strong>要点总结：</strong></p><p>  函数反映出两种变量之间的关系，其中一种变量随着另一种变化，因此在科学史上它提升了人类的认知，将我们从对单个数字、变量的关注，引向了趋势。没有函数，我们其实很难从个别数据样点，体会整体的变化。因此我们的思维方式要从常数思维到变量思维，再到函数思维。</p><p>  函数还为同一类问题提供了具有普遍性的答案。当我们对函数中不同的变量代入不同的数值时，就会得到相应的结果，这就让人们有了一通百通的可能性。</p><p>  下一讲，我们讲讲函数的决定性和变量之间的相关性，看看变量和函数之间的因果关系。</p><h3><span id="26-han-shu-xia-ru-he-tong-guo-gong-shi-li-jie-yin-guo-guan-xi">26 ｜ 函数（下）：如何通过公式理解因果关系</span><a href="#26-han-shu-xia-ru-he-tong-guo-gong-shi-li-jie-yin-guo-guan-xi" class="header-anchor">#</a></h3><p><img src="/images/106.jpg" alt=""></p><p>我们上一讲在讲函数时说，在函数中，一个变量先变化，另一个随着它变化。比如圆的半径R增加一倍，面积S增加到原来的4倍，后者随着前者变化。</p><details><summary>...</summary><p>  如果我们把这个关系上升为抽象的逻辑关系，那么就是半径变化是因，面积变化是果。我们用这样一个箭头代表确定性的因果关系 R→S，用下面这样一个函数来表示：</p><center>S=πR^2</center><p>通常，我们称R是自变量，S是因变量，或是自变量R的函数，因变量和函数通常说的是一回事。</p><p>  如果把上面这种函数关系形象地用曲线表示下来，那么它就是半根抛物线：</p><p><img src="/images/107.jpg" alt="注：这段曲线只有右半边，没有左半边，因为圆的半径不能是负数"></p><p>从这个例子可以看出，函数中的自变量，虽然从名称上来看，似乎自己怎么变都行，但其实它有一些特定的限制条件或者范围，比如圆的半径必须大于等于零就是限制条件。我们在之前讲到的几何数列中每一个数，可以表示成2<sup>N（或者r</sup>N），但是，这个N必须是整数，比如1，2，3，4等等，不能是半个，这就是限制条件。</p><p>  自变量的取值范围或者限制范围，我们称之为函数的定义域。这里面的域，就是疆域的意思，它表明一个函数所描述的变化规律是有范围限制的。当一个函数的定义域确定之后，因变量，也就是函数值也就受到了相应的限制。</p><p>  比如说几何数列2^N，取值只能是2，4，8，16……这些特定的整数，不可能是2.5这样的小数数字，甚至不可能是3。函数值的变化范围，我们称之为值域，这个名字顾名思义，也很好理解。</p><p>  类似的，我们上一讲所说的现实生活中遇到的各种函数，也能确定因果关系，定义域和值域。</p><p>  比如班上每一个人的身高，因果关系就是人决定身高，也就是说“人→身高”。函数的定义域是特指班上的人，不是所有的人，他们的身高也在有限范围之内，比如从1.5米到1.9米，而不是任何的高度。你如果算出一个人的身高是10米，说明一定是什么地方搞错了。</p><p>  对于函数，**很多人常犯的错误在于没有考虑定义域，滥用函数关系，**比如不能假设圆的半径是负数，然后套用S= πR^2这样的函数去计算面积。类似的，在生活中，很多函数使用起来也要考虑定义域。</p><p>  比如对于那些平时成绩在90分以上的学生，如果老师每多教10%的内容，他们就能多学会5%，这看似多教是有好处的。但这个函数是有定义域的，对于成绩70分以下的人，这个变化规律可能就不成立了，教得越多，成绩越差。因此，使用任何规律之前要看条件是否相符，不能错误地套用了公式。</p><p>  讲到函数中的因果关系，有两点需要明确指出。</p><p>  **首先，数学上的因果关系和生活中的可能不完全相同。**在物理学等自然科学上，因果关系常常是单方向的。</p><p>  比如你从比萨斜塔上坠下一个球，它就以自由落体的加速度往下坠落，落地时会有一个速度，这个速度是地球重力加速度导致的，因此加速度是速度的因，而不是反过来，这是非常明确的。再比如，张三在20米外观看这件事，那么你先扔了球，他才看见，这也是因果关系，不可能倒过来。</p><p>  但是数学函数中的因果关系未必如此。在一个函数中，自变量和因变量的角色是可以互换的。我们前面说，给定圆的半径，我们通过一个计算面积的函数S=πR^2，算出面积，因果关系是半径→面积。</p><p>  但是在现实生活中也有反过来的情况，比如一家四口人到必胜客吃午饭，需要先根据每一个人的饭量，确定面积是多大的披萨饼才够吃，然后根据R=√（S/π）再算出半径（直径），看看是买14寸的、16寸的，还是18寸的。这时面积就是自变量，半径就是因变量了。因果关系变成了面积→半径。</p><p>  我们同样可以用x坐标代表面积，y坐标代表半径，画一条曲线，就是下面这个形状，如果你对比前一图，会发现两条曲线形状相似，只是翻转了一下。更准确地讲，它和原来的曲线是相对45度角的对角线对称的。</p><p><img src="/images/108.jpg" alt=""></p><p>为了更完整地描述和研究这种把因和果置换后的函数关系，数学家们提出了反函数的概念，比如y =√(x/π)和y=πx^2就是互为反函数。在笛卡尔坐标系中，反函数的图和原来函数的图就总是相对45度角的对角线对称。</p><p>  比如下图是对数函数（蓝线）和指数函数（绿线）的关系图，它们相对对角线红线是对称的。</p><p><img src="/images/109.jpg" alt=""></p><p>为什么对数函数和指数函数会互为反函数呢？我们不妨从两个角度看同一件事情就知道了。</p><p>  比如你购买国库券10000元，以6%的年息复合增长，请问12年后你的本息一共是多少呢？我们知道X年后的本息Y是一个指数函数：Y=10000*(1.06)^X，代入X=12，大约是20122元。也就是说大约12年后投资翻了一番。</p><p>  如果我们倒过来问这个问题，今天买10000元国库券，多少年后才能本息翻一番，那么这就是对数函数的问题了，我们把X作为若干年后的本息总数，Y作为时间，这样 Y=log（X/10000），算出来大约是11.896年，也就是12年左右。因此，指数函数和对数函数互为反函数。</p><p>  说到投资，这里给大家讲一个计算回报的简单方法——72定律。假如你的投资回报率是每年R%，那么多少年投资才能翻一番呢？基本上是72/R年。刚才的情况是R=6，大约是12年，如果提高到8%，只要9年就够了。</p><p>  别看这2%的差异并不显大，如果我们把时间放大到36年，也就是一代人的时间，那么回报就是翻番三次和翻番四次的差异了。因此一个人善于理财，还是不善于理财，到退休的时候，财富很容易差出一倍。</p><p>  <strong>接下来我们谈谈数学上因果关系的第二个注意事项，当一个函数的变化由两个，或者更多的变量决定时，单个变量和函数之间的因果关系，并不是函数值变化的必然原因。</strong></p><p>  比如说，我们要计算圆柱体的体积V，它和圆柱半径R的平方成正比，和圆柱的高度h成正比，即</p><center>V=πR^2*h</center><p>这时，如果高度增加一倍，体积一定增加一倍吗？我们只能说，有可能，但是前提是半径要保持不变。反过来从结果看，如果体积增加了一倍，我们也并不知道是否是高度变化所引起的。</p><p>  如果我们把体积V，半径R和高度h的关系画在一个三维的图中，那么大概是下面这张图的样子。从图中你可以看出，决定体积的因素很复杂。</p><p><img src="/images/110.jpg" alt=""></p><p>在多变量的情况下，我们只能得到这样的结论，就是体积的变化和高度的变化是正相关的，而且相关性是100%，也就是说，在其它条件不变的前提下，一个变大，另一个也必然变大。类似的，体积变化和半径变化也是100%正相关的。</p><p>  在生活中，很多人经常把正相关性、因果关系和必然性相混淆。比如说，每年的平均投资回报率和最后拿回来的钱总数是正相关的，这点毫无疑问。但是在投资时，总是找那些回报率高的项目或者投资产品，20年后拿回来的钱一定多么？</p><p>  不一定，因为最后能拿回来多少钱，不仅看平均回报率，还要看投资风险，一些高回报的项目也是高风险的。也就是说，平均回报率高，和拿回来的钱多并不形成因果关系。</p><p>  很多人看到别人投资高风险、高回报的项目发了财，觉得这种好事情也能摊到自己身上，可是等自己真拿出真金白银投资时，高回报没有起作用，高风险却应验在自己身上了。了解了相关性和必然性的差别，能让我们少犯错误。</p><p>  在上面计算圆柱体积这个例子中，我们还只有两个变量，在很多实际问题中，影响结果的变量非常多。比如在经济学上，美国政府和研究机构公布的各种和经济有关的指标有上万个，试图根据几个指标就预测今后的趋势近乎不可能。</p><p>  在生物体中，情况更加复杂。经济学上的很多指标好歹还是明确的正相关或者负相关，而生物上很多体征和指标，同我们要找的疾病、遗传，或者新陈代谢的相关性是非常模糊的。在这种情况下，我们把相关性误解为有因果关系的必然性，是非常危险的。</p><p>  但是，我们也不能因为很难确定必然性，就放弃对相关性的探究。只有当我们发现了影响结果的各种变量，并且搞清楚它们和结果之间的相关性，才能对最后结果的走向有一个全面完整的了解。</p><p>  比如，当我们知道了决定圆柱体质量的三个因素，即它的半径、高度，以及材料的密度之后，虽然每一个因素都不构成质量增加的因果关系，但是在不同场合，我们就知道该如何调整尺寸和选取材料来达到目的。</p><p>  学术研究的主要目的，已经从过去那种寻找确定性，变成了挖掘尚未人知的，能影响结果的变量，并且寻找它们和结果之间的相关性。在研究某一个变量的影响时，我们通常要屏蔽其它变量的作用。</p><p>  比如我们研究体积和尺寸的关系，先要假定半径是不变的，才能知道高度的影响。但这样一来，绝大部分学术研究，特别是人文和社会学科的研究，都不得不集中在几个视角，搞清楚特定变量的影响。这并非研究人员缺乏全局观，而是整个学术界其实给他们的分工就是如此。</p><p>  今天很多学术专著，也是从特定视角看待问题。万维钢老师讲过一句话，人文和社会学科与自然科学领域的特点完全不同，前者更像是江湖，学者们彼此很难互相说服，这其实非常准确地描述了学术界的特点。</p><p>  了解了这个特点，我们在看学术专著时，就不要把它当作对某个结论全面的论述，而把它们当成是揭示某种相关性的著作就好。</p><p><strong>要点总结：</strong></p><p>  只有一个变量的函数，自变量和函数值之间有因果关系，一个变化导致另一个变化。但是，函数的使用要考虑使用范围，对于任何规律其实都是如此。</p><p>  由多个变量决定函数值的函数，每个变量和函数值有相关性，有些还是百分之百的正相关，但是它们没有决定性，也没有必然的因果关系，切忌把相关性和因果关系混为一谈。今天的学术研究通常只能在几个维度研究相关性，因此对于研究的结论，我们要全面看待。</p><p>  函数的学习就告一段落，下一讲我们学代数模块的新内容“向量代数”。我们下一讲见！</p><h3><span id="27-xiang-liang-dai-shu-shang-fang-xiang-bi-nu-li-geng-chong-yao-shi-ji-tang-ma">27 ｜ 向量代数（上）：“方向比努力更重要”是鸡汤吗？</span><a href="#27-xiang-liang-dai-shu-shang-fang-xiang-bi-nu-li-geng-chong-yao-shi-ji-tang-ma" class="header-anchor">#</a></h3><h3><span id="28-xiang-liang-dai-shu-xia-ru-he-tong-guo-xiang-liang-jia-jiao-li-jie-wei-du">28 ｜ 向量代数（下）：如何通过向量夹角理解“维度”？</span><a href="#28-xiang-liang-dai-shu-xia-ru-he-tong-guo-xiang-liang-jia-jiao-li-jie-wei-du" class="header-anchor">#</a></h3><h3><span id="29-xian-xing-dai-shu-ju-zhen-dao-di-zen-me-yong">29 ｜ 线性代数：“矩阵”到底怎么用？</span><a href="#29-xian-xing-dai-shu-ju-zhen-dao-di-zen-me-yong" class="header-anchor">#</a></h3><h2><span id="mo-kuai-wu-wei-ji-fen">模块五 ｜ 微积分</span><a href="#mo-kuai-wu-wei-ji-fen" class="header-anchor">#</a></h2><h3><span id="30-wei-ji-fen-shang-ru-he-cong-hong-guan-bian-hua-liao-jie-wei-guan-qu-shi">30 ｜ 微积分（上）：如何从宏观变化了解微观趋势</span><a href="#30-wei-ji-fen-shang-ru-he-cong-hong-guan-bian-hua-liao-jie-wei-guan-qu-shi" class="header-anchor">#</a></h3><p><img src="/images/39.jpg" alt=""></p><p>  我们在前面讲到，线性代数和微积分是高等数学中最重要的两门课，前者有很强的实用价值，后者能提高思维水平，虽然大家平时在工作中未必有机会直接使用它。就拿我来说，工作后用线性代数的机会可能是微积分的100倍。</p><details><summary>...</summary><p>  但是，学没学过微积分，思维方式会不同，眼中的世界也会有差别。因此，作为数学通识课，我们还是有必要解释微积分的思想，但是我们也就是停留在它的思想方法上，而非细节上。</p><p>  微积分有两位主要的发明人，牛顿和莱布尼茨。牛顿发明微积分的一个重要原因是，他需要一个数学工具解决力学问题，比如如何计算速度。可能有人会说，这还不容易，在小学我们就教了，就是距离除以时间。</p><p>  没有错，我们从小学到中学都是这么教的，但这只是一段时间𝛥t的平均速度。如果我要问你，在某一时刻的瞬间速度是多少？你就不知道了，或者只能拿平均速度来近似瞬间速度。或者说，拿宏观的规律近似微观的。</p><p>  但是在很多场合，我们要了解的是瞬间速度，而不是平均速度。比如一个警察抓超速，依据的就是驾驶者的瞬间速度，而不是他一路开过来的平均速度。对于瞬间速度，牛顿之前的科学家并没有太多的了解，当然也不会计算了。</p><p>  <strong>那么牛顿是怎么解决这个问题的呢？他采用了无限逼近的方法。具体的想法是这样的：</strong></p><p>  首先我们回到速度的定义，就是一段时间里的位移量𝛥S除以相应的时间𝛥t，我们可以写成速度v=𝛥S/𝛥t。我把这种关系用一个示意图表示出来：</p><p><img src="/images/41.jpg" alt=""></p><p>  在左边的图中，横轴是时间轴，纵轴是位移，那条曲线是位移随着时间变化的函数S(t)。我在图中标记了从t0开始的一段时间𝛥t，以及相应的位移量𝛥S，它们构成一个直角三角形的两条直角边。位移量除以时间，就是斜边的斜率。</p><p>  当时间间隔𝛥t逐渐变小时，这个比值会变化，会越来越反映出在t0点附近的速度。我们在前面介绍了极限的概念，当𝛥t趋近于0时，那条反映速度的斜线，就是曲线在t0点的切线，牛顿就把那个切线的斜率，定义为在t0点的瞬间速度。我们不妨这么写，v(t0)=𝛥S/𝛥t，当𝛥t→0（趋近于0）时。</p><p>  通过上述方式，牛顿就从平均速度出发，定义了瞬间速度，也就是说，某个时刻的瞬间速度，是这个时刻附近一个无穷小的时间内的平均速度。</p><p>  如果我们用曲线来考察这种瞬间变化，那么瞬间速度就是距离函数曲线在某个点切线的斜率。由于在每一个时间点，切线的斜率是变化的，因此如果把各个点的切线斜率画出来，它也是一条函数曲线。</p><p>  牛顿把这个由每个点切线斜率构成的函数，称为原来函数的流数，我们今天称之为导数。通常我们用y=f(x)表示原函数，用y=f’(x)表示它的导数。在上面的例子中，位移的变化函数S(t)是原函数，速度变化的函数v(t)则是原函数的导数，我们可以写成v(t)=S’(t)。</p><p><img src="/images/40.jpg" alt=""></p><p>  正如同速度反映的是距离的变化速率，一个函数的导数所反映的也是原函数变化的速率，比如在上面的图中，我们可以看出原函数增长越来越慢，因此它的导数，也就是增速，是逐渐下降的。</p><p>  现在我们回顾一下函数这个概念，它反映的是一个变量随着另一个变量的变化，而导数这个概念，则反映函数变化的快慢。比如抛物线函数y=x^2，它在x=1这个点，导数是2，也就是说x增加一小份（无穷小），y要增加两小份。</p><p>  相比之下，直线y=x在同一个点的增速就要慢一点，它的导数是1，也就是说x增加一小份，y也增加一小份，因此我们说抛物线在x=1这个点的变化比直线更快。·</p><p>  对于同一根曲线，我们前后也能对比，比如抛物线在x=2这个点的导数是4，因此我们说，它在x=2时，比x=1时，变化更快。</p><p>  我们过去也会说，某个函数变化快，某个函数变化慢，但是这些都是宏观的描述，没有量化度量。导数解决了这个问题。我们还说，某个函数，越变越快，这也只是宏观的、定性的分析。</p><p>  有了导数的概念之后，我们就可以准确地度量任意一个函数在某一个点的变化。因此导数的本质是对变化快慢的准确量化度量。</p><p>  <strong>导数是微积分中最重要的概念之一，从导数出发我们稍微往前走一小步，就进入到微积分的微分了。</strong></p><p>  什么是微分呢？它其实就是在前面有关速度的例子中，𝛥t趋近于零时，𝛥S的值。对此一般性的函数，我们用dx表示自变量趋于零的情况，用dy表示函数的微分。</p><p>  如果我们对比一下导数的定义f’(x) = 𝛥y/𝛥x，其中𝛥x趋近于零，以及微分的定义dy =f’(x)dx，就可以看出它们讲的其实是一回事，因为𝛥x和𝛥y趋近于零之后，就是dx和dy。有时人们直接将导数写成f’(x) =dy/dx。</p><p>  如果我们孤立地看微分dy，它是个无穷小，搞出这样一个新概念有什么必要呢？我们用一个具体的例子，也就是有关圆柱体积变化趋势的例子来说明。</p><p>  我们知道，圆柱体的体积：V=𝛑R^2 h，如果我要问，这个体积随半径变化快，还是随高度变化快？在没有微分这个概念时，一般人根据直觉，会觉得随半径变化快，因为是平方关系，而它随高度变化只是线性关系。</p><p>  但真实情况是什么样呢？我们可以把体积函数分别对半径和高度各做一次微分，得到下面两个结果：</p><p>  体积对半径R微分：dV/dR=2𝛑Rh</p><p>  体积对高度h微分：dV/dh=𝛑R^2</p><p>大家不必关心细节，了解一下这样两个结论：</p><ul><li>由于半径增加所带来的体积增量，和圆柱体当前的半径成正比，也和它的高度成正比。</li><li>由于高度增加所带来的体积增量，和圆柱体当前半径的平方成正比，但和它的高度无关。</li></ul><p>  这时，你如果对比一下两个微分函数就会发现，哪个变化的速率快，还真不好说。假如R等于10，h也等于10，体积就随半径变化快。如果R=10，h只有1，那就是随着高度变化快。</p><p>  假如你是一个工程师，要建造一个巨大的储油罐，无论你增大半径，还是增加高度，都有相当的工程难度。现在你的研发经费有限，只能在一个维度，增大储油罐的体积，你应该怎么做呢？</p><p>  如果你没有学过微积分，你可能会觉得该增加半径。但是听了今天的课程之后你就知道，在这个储油罐比较“扁平”时，应该增加高度。总的来讲，当高度没有达到半径的1/2时，都应该增加高度。</p><p>  我们在工作和生活中，其实经常遇到这样的问题，一个函数取决于很多变量，这时我们不知道该在哪个方向改变，怎样才能以最快的速度进步。微分这个工具，其实给解决这一类的问题提供了很好的方法。它引出了一个梯度的概念，利用梯度，我们就能解决这个问题了。</p><p>  梯度是微分的一个扩展。在上面的圆柱体问题中，对圆柱体函数，我们可以针对半径求微分dV/dR，也可以针对高度求微分dV/dh。如果我们把这两个微分的结果放到一起，就是梯度，也就是说圆柱体积函数的梯度是（2𝛑Rh，𝛑R^2）。</p><p>  梯度的物理含义可以这样理解，如果你去登山，怎样沿着最陡的方向，最快地爬到山顶呢？梯度函数告诉你在任意一点，往不同方向走的上升速度是不一样的，因此你很容易找到前进的目标。在圆柱体函数中的梯度是上面那个式子，我们在前面得到的结论是，只要高度小于1/2的半径，就应该优先增加高度。</p><p>  如果是一个长方体，情况又如何呢？我们先把体积函数写出来，体积等于长乘以宽乘以高度，即 V=L<em>W</em>H。接下来，我们可以用微分计算出它的梯度函数。</p><p>  这里面过程我就省略了，我直接给出答案。这时体积的梯度为 （宽度乘以高度，长度乘以高度，长度乘以宽度），一共三个分量。这时你会发现，长宽高，哪个最小，就应该优先增加哪一个。</p><p>  比如说，长为10，宽和高分别是4和6，这时梯度函数为（24，60，40），你应该增加宽度。这其实和我们的直觉是一致的，如果我们这样不断优化，最后的结果是长方体变成立方体时，体积达到最大。</p><p>  不只是数学问题，其实很多时候，我们都面临在限制要素中作选择的问题。很多时候，我们总想全方位改进自己，但是人的精力和资源有限，因此在某一时刻，可能只能向一个方向努力。</p><p>  希望梯度这个概念在你选择方向时能够给你启发。很多人从直觉出发，觉得该补短板，另一些人则觉得，该把长板变得更长。第一类人会和你讲木桶理论，第二类人会和你讲长板理论，每一类都有很多成功的例子，也有很多失败的教训。</p><p>  于是很多人就不知道该用哪一个理论了。事实上你今天学了梯度理论后，就很容易作决断了，那就是在任何时刻算出梯度，然后沿着最陡，但是收益最大的路径前进就好。</p><p>  在增加长方体体积时，显然是在采用补短板的策略，但是在增加圆柱体体积时，就看情况而定了，如果高度太低，它是严重的短板，需要弥补，但是只要它超过圆柱体半径的一半时，就要增加长板（半径）的优势了。</p><p>  如果说你有一个目标函数，它可能受到多个变量的影响，那是你长期进步的趋势，但是在每一个时刻，你需要计算一下那个函数针对各个变量的微分，也就是梯度函数，找到进步最显著的方向去努力。这就是通过宏观趋势把握微观变化。</p><p><strong>要点总结：</strong></p><p>  我们从导数出发，介绍了微分的概念，它是我们从函数的宏观趋势，把握每一个点细节变化的工具。然后我们介绍了多变量函数的微分，也就是梯度的概念，并且说明了如何在有大量不确定性，或者说大量的变量中找到前进方向的方法，具体讲就是往坡度最高的方向努力。因此，微积分给我们的第一个思维提升就是练习从宏观趋势中把握微观变化的趋势，让我们认清每一步的方向。</p><p>  下一讲，我们还讲微积分，透过微积分讨论企业增长里的奇点和连续性。我们下一讲再见。</p></details><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>N-1 <a href="#fnref1" class="footnote-backref">↩</a></p></li></ol></section></details></details></details>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="吴军,数学,电子书" scheme="https://hejtao.netlify.com/tags/%E5%90%B4%E5%86%9B-%E6%95%B0%E5%AD%A6-%E7%94%B5%E5%AD%90%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>MySQL是怎样运行的：从根儿上理解 MySQL</title>
    <link href="https://hejtao.netlify.com/2019/09/20/2019-9-20/"/>
    <id>https://hejtao.netlify.com/2019/09/20/2019-9-20/</id>
    <published>2019-09-19T16:00:00.000Z</published>
    <updated>2019-11-28T13:22:23.157Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><div class="toc"><!-- toc --><ul><li><a href="#chong-xin-ren-shi-mysql">重新认识MySQL</a><ul><li><a href="#ke-hu-duan-fu-wu-qi">客户端 + 服务器</a></li><li><a href="#qi-dong-fu-wu-qi-cheng-xu">启动服务器程序</a><ul><li><a href="#unix">UNIX</a></li><li><a href="#windows">Windows</a></li></ul></li><li><a href="#qi-dong-ke-hu-duan-cheng-xu">启动客户端程序</a></li><li><a href="#ke-hu-duan-yu-fu-wu-qi-de-tong-xin">客户端与服务器的通信</a><ul><li><a href="#tcp-ip">TCP/IP</a></li><li><a href="#ming-ming-guan-dao-he-gong-xiang-nei-cun">命名管道和共享内存</a></li><li><a href="#unix-yu-tao-jie-zi-wen-jian">UNIX域套接字文件</a></li></ul></li><li><a href="#fu-wu-qi-chu-li-ke-hu-duan-qing-qiu">服务器处理客户端请求</a></li><li><a href="#cun-chu-yin-qing">存储引擎</a></li></ul></li><li><a href="#qi-dong-xuan-xiang-he-xi-tong-bian-liang">启动选项和系统变量</a><ul><li><a href="#zai-ming-ling-xing-shang-shi-yong-xuan-xiang">在命令行上使用选项</a></li><li><a href="#pei-zhi-wen-jian-zhong-shi-yong-xuan-xiang">配置文件中使用选项</a><ul><li><a href="#windows-1">Windows</a></li><li><a href="#unix-1">UNIX</a></li></ul></li><li><a href="#xi-tong-bian-liang">系统变量</a><ul><li><a href="#cha-kan-xi-tong-bian-liang">查看系统变量</a></li><li><a href="#she-zhi-xi-tong-bian-liang">设置系统变量</a></li></ul></li><li><a href="#zhuang-tai-bian-liang">状态变量</a></li></ul></li><li><a href="#zi-fu-ji-he-bi-jiao-gui-ze">字符集和比较规则</a><ul><li><a href="#zi-fu-ji-de-zhuan-huan">字符集的转换</a></li></ul></li><li><a href="#innodb-ji-lu-cun">InnoDB记录存</a><ul><li><a href="#innodb-ye">InnoDB页</a></li><li><a href="#innodb-xing-ge-shi">InnoDB行格式</a><ul><li><a href="#compact-xing-ge-shi">Compact行格式</a></li><li><a href="#xing-shu-ju-yi-chu">行数据溢出</a></li><li><a href="#xing-yi-chu-de-lin-jie-dian">行溢出的临界点</a></li></ul></li></ul></li><li><a href="#innodb-shu-ju-ye">InnoDB数据页</a><ul><li><a href="#shu-ju-ye-jie-gou">数据页结构</a></li><li><a href="#ji-lu-zai-ye-zhong-de-cun-chu">记录在页中的存储</a><ul><li><a href="#ji-lu-tou-xin-xi">记录头信息</a></li></ul></li><li><a href="#page-directory">Page Directory</a></li><li><a href="#page-header">Page Header</a></li><li><a href="#file-header">File Header</a></li><li><a href="#file-trailer">File Trailer</a></li></ul></li><li><a href="#b-shu-suo-yin">B+树索引</a><ul><li><a href="#wu-suo-yin-cha-zhao">无索引查找</a><ul><li><a href="#zai-ye-nei-cha-zhao">在页内查找</a></li><li><a href="#zai-duo-ye-zhong-cha-zhao">在多页中查找</a></li></ul></li><li><a href="#suo-yin">索引</a><ul><li><a href="#mu-lu-xiang">目录项</a></li><li><a href="#yong-ye-cun-fang-mu-lu-xiang">用页存放目录项</a></li><li><a href="#ju-cu-suo-yin">聚簇索引</a></li><li><a href="#er-ji-suo-yin">二级索引</a></li></ul></li></ul></li><li><a href="#b-shu-suo-yin-de-shi-yong">B+树索引的使用</a><ul><li><a href="#he-li-shi-yong-suo-yin">合理使用索引</a><ul><li><a href="#quan-zhi-pi-pei">全值匹配</a></li><li><a href="#pi-pei-zuo-bian-de-lie">匹配左边的列</a></li><li><a href="#pi-pei-lie-qian-zhui">匹配列前缀</a></li></ul></li><li><a href="#hui-biao-de-dai-jie">回表的代价</a><ul><li><a href="#er-ji-suo-yin-hui-biao-or-quan-biao-sao-ma">二级索引 + 回表 or 全表扫码</a></li><li><a href="#fu-gai-suo-yin">覆盖索引</a></li></ul></li><li><a href="#he-li-di-jian-li-suo-yin">合理地建立索引</a></li></ul></li><li><a href="#mysql-de-shu-ju-mu-lu">MySQL的数据目录</a><ul><li><a href="#shu-ju-ku-he-wen-jian-xi-tong-de-guan-xi">数据库和文件系统的关系</a></li><li><a href="#shu-ju-mu-lu">数据目录</a><ul><li><a href="#shu-ju-mu-lu-he-an-zhuang-mu-lu-de-qu-bie">数据目录和安装目录的区别</a></li><li><a href="#cha-zhao-shu-ju-mu-lu">查找数据目录</a></li></ul></li><li><a href="#shu-ju-mu-lu-de-jie-gou">数据目录的结构</a><ul><li><a href="#shu-ju-ku-zai-wen-jian-xi-tong-zhong-de-biao-shi">数据库在文件系统中的表示</a></li><li><a href="#biao-zai-wen-jian-xi-tong-zhong-de-biao-shi">表在文件系统中的表示</a></li></ul></li><li><a href="#wen-jian-xi-tong-dui-shu-ju-ku-de-ying-xiang">文件系统对数据库的影响</a></li><li><a href="#mysql-xi-tong-shu-ju-ku-jian-jie">MySQL系统数据库简介</a></li></ul></li></ul><!-- tocstop --></div><p>本文为敝人的学习记录，感兴趣的请在掘金小册购买同名原著 😎</p><h2><span id="chong-xin-ren-shi-mysql">重新认识MySQL</span><a href="#chong-xin-ren-shi-mysql" class="header-anchor">#</a></h2><h3><span id="ke-hu-duan-fu-wu-qi">客户端 + 服务器</span><a href="#ke-hu-duan-fu-wu-qi" class="header-anchor">#</a></h3><p>MySQL服务器进程(也叫数据库实例)MySQL客户端进程</p><p>进程：进程号(PID，由操作系统随机分配)、进程名称</p><p>MySQL服务器进程的默认名称为mysqld，MySQL客户端进程的默认名称为mysql</p><h3><span id="qi-dong-fu-wu-qi-cheng-xu">启动服务器程序</span><a href="#qi-dong-fu-wu-qi-cheng-xu" class="header-anchor">#</a></h3><h4><span id="unix">UNIX</span><a href="#unix" class="header-anchor">#</a></h4><p>使用安装目录下(比如 <code>/usr/local/mysql/bin/</code>):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld_safe</span><br></pre></td></tr></table></figure><p><code>mysqld_safe</code>是一个启动脚本的命令，调用了<code>mysqld</code>，并启动一个监控进程(重启，日志)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql.server start</span><br><span class="line">ysql.server stop</span><br></pre></td></tr></table></figure><p><code>mysql.server</code>是一个链接文件， 会调用<code>mysqld_safe</code></p><h4><span id="windows">Windows</span><a href="#windows" class="header-anchor">#</a></h4><p>使用安装目录下(比如 <code>D:\Program Files\mysql-5.7.26-winx64\bin\</code>) <code>mysqld.exe</code> 可执行文件</p><p>使用 Windows服务。把某个程序注册为Windows服务的格式：&quot;可执行文件路径&quot; --install [-manual] [服务名称]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\Program Files\mysql-5.7.26-winx64\bin\mysqld --install [MySQL_Service]</span><br><span class="line">net start MySQL_Service</span><br><span class="line">net stop MySQL_Service</span><br></pre></td></tr></table></figure><h3><span id="qi-dong-ke-hu-duan-cheng-xu">启动客户端程序</span><a href="#qi-dong-ke-hu-duan-cheng-xu" class="header-anchor">#</a></h3><p>mysql -h主机名  -u用户名 -p密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -hlocalhost  -uroot -p123abc</span><br><span class="line">mysql -u root -p</span><br><span class="line">mysql --host=localhost  --user=root --password=123abc</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1863961-c583b0a1eabe5ff6.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>退出客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br><span class="line">exit</span><br><span class="line">\q</span><br></pre></td></tr></table></figure><h3><span id="ke-hu-duan-yu-fu-wu-qi-de-tong-xin">客户端与服务器的通信</span><a href="#ke-hu-duan-yu-fu-wu-qi-de-tong-xin" class="header-anchor">#</a></h3><p>本质是两个进程间的通信</p><h4><span id="tcp-ip">TCP/IP</span><a href="#tcp-ip" class="header-anchor">#</a></h4><p>每台计算机都有一个唯一的IP地址每个进程向操作系统申请一个端口号(0~65535)通过IP地址 + 端口号来与某个进程通信MySQL服务器进程的默认端口号为3306，自定义MySQL服务器进程的端口号如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld -P3307</span><br></pre></td></tr></table></figure><h4><span id="ming-ming-guan-dao-he-gong-xiang-nei-cun">命名管道和共享内存</span><a href="#ming-ming-guan-dao-he-gong-xiang-nei-cun" class="header-anchor">#</a></h4><p>Windows系统中的进程间通信方式</p><p>命名管道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysqld --enable-named-pipe</span><br><span class="line"></span><br><span class="line">mysql --pipe</span><br><span class="line">or</span><br><span class="line">mysql --protocol=pipe</span><br></pre></td></tr></table></figure><p>共享内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqld --shared-memory</span><br><span class="line"></span><br><span class="line">mysql --protocol=memory</span><br></pre></td></tr></table></figure><h4><span id="unix-yu-tao-jie-zi-wen-jian">UNIX域套接字文件</span><a href="#unix-yu-tao-jie-zi-wen-jian" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --protocol=socket</span><br></pre></td></tr></table></figure><p>服务器程序默认监听的套接字文件路径为<code>/tmp/mysql.sock</code>，指定套接字文件路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqld --socket=/tmp/a.txt</span><br><span class="line">mysql -hlocalhost -uroot --socket=/tmp/a.txt -p</span><br></pre></td></tr></table></figure><h3><span id="fu-wu-qi-chu-li-ke-hu-duan-qing-qiu">服务器处理客户端请求</span><a href="#fu-wu-qi-chu-li-ke-hu-duan-qing-qiu" class="header-anchor">#</a></h3><p><img src="https://upload-images.jianshu.io/upload_images/1863961-a6bef812a91553aa.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3><span id="cun-chu-yin-qing">存储引擎</span><a href="#cun-chu-yin-qing" class="header-anchor">#</a></h3><p><img src="https://upload-images.jianshu.io/upload_images/1863961-b31ff09869340b51.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><code>XA</code>列代表是否支持分布式事务<code>Savepoints</code>代表是否支持部分事务回滚</p><h2><span id="qi-dong-xuan-xiang-he-xi-tong-bian-liang">启动选项和系统变量</span><a href="#qi-dong-xuan-xiang-he-xi-tong-bian-liang" class="header-anchor">#</a></h2><h3><span id="zai-ming-ling-xing-shang-shi-yong-xuan-xiang">在命令行上使用选项</span><a href="#zai-ming-ling-xing-shang-shi-yong-xuan-xiang" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqld --skip-networking</span><br><span class="line">mysqld --default-storage-engine=MyISAM \\ 等号两边不能有空格</span><br></pre></td></tr></table></figure><p>使用<code>mysql --help</code>可以看到mysql程序支持的启动选项使用<code>mysqld --verbose --help</code>查看mysqld支持的启动选项</p><h3><span id="pei-zhi-wen-jian-zhong-shi-yong-xuan-xiang">配置文件中使用选项</span><a href="#pei-zhi-wen-jian-zhong-shi-yong-xuan-xiang" class="header-anchor">#</a></h3><h4><span id="windows">Windows</span><a href="#windows" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%WINDIR%\my.ini</span><br><span class="line">%WINDIR%\my.cnf</span><br><span class="line"></span><br><span class="line">C:\my.ini</span><br><span class="line">C:\my.cnf</span><br><span class="line"></span><br><span class="line">BASEDIR\my.ini  \\ MySQL安装路径</span><br><span class="line">BASEDIR\my.cnf</span><br><span class="line"></span><br><span class="line">defaults-extra-file命令行指定的额外配置文件路径，如</span><br><span class="line">mysqld --defaults-extra-file=C:\Users\chiangtao ho\my_extra_file.txt</span><br><span class="line"></span><br><span class="line">%APPDATA%\MySQL\.mylogin.cnf登录路径选项（仅限客户端）</span><br></pre></td></tr></table></figure><h4><span id="unix">UNIX</span><a href="#unix" class="header-anchor">#</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/etc/my.cnf</span><br><span class="line">/etc/mysql/my.cnf</span><br><span class="line">SYSCONFDIR/my.cnf</span><br><span class="line">$MYSQL_HOME/my.cnf特定于服务器的选项（仅限服务器）</span><br><span class="line"></span><br><span class="line">defaults-extra-file</span><br><span class="line"></span><br><span class="line">~/.my.cnf用户特定选项</span><br><span class="line"></span><br><span class="line">~/.mylogin.cnf用户特定的登录路径选项（仅限客户端）</span><br></pre></td></tr></table></figure><h3><span id="xi-tong-bian-liang">系统变量</span><a href="#xi-tong-bian-liang" class="header-anchor">#</a></h3><h4><span id="cha-kan-xi-tong-bian-liang">查看系统变量</span><a href="#cha-kan-xi-tong-bian-liang" class="header-anchor">#</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">like</span> <span class="string">'max_connections'</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'default%'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>系统变量的单词之间必须使用下划线_连接</p></blockquote><h4><span id="she-zhi-xi-tong-bian-liang">设置系统变量</span><a href="#she-zhi-xi-tong-bian-liang" class="header-anchor">#</a></h4><p>变量的作用范围<strong>GLOBAL</strong>：全局变量，影响服务器的整体操作<strong>SESSION (LOCAL)</strong>：会话变量，影响某个客户端连接的操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> default_storage_engine = MyISAM;</span><br><span class="line"><span class="keyword">SET</span> @@GLOBAL.default_storage_engine = MyISAM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">SESSION</span> default_storage_engine = MyISAM;</span><br><span class="line"><span class="keyword">SET</span> @@SESSION.default_storage_engine = MyISAM;</span><br><span class="line"><span class="keyword">SET</span> default_storage_engine = MyISAM; \\ 默认作用范围是LOCAL</span><br></pre></td></tr></table></figure><blockquote><p>那我们的SHOW VARIABLES语句默认查看的是SESSION作用范围的系统变量并不是所有系统变量都具有GLOBAL和SESSION的作用范围</p></blockquote><h3><span id="zhuang-tai-bian-liang">状态变量</span><a href="#zhuang-tai-bian-liang" class="header-anchor">#</a></h3><p>与系统变量类似，状态变量也有GLOBAL和SESSION两个作用范围的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span> <span class="keyword">LIKE</span> <span class="string">'thread%'</span>;</span><br></pre></td></tr></table></figure><h2><span id="zi-fu-ji-he-bi-jiao-gui-ze">字符集和比较规则</span><a href="#zi-fu-ji-he-bi-jiao-gui-ze" class="header-anchor">#</a></h2><p>查看字符集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CHARSET</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span>;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1863961-7c37618995aa0d2a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>Default collation</strong>表示字符集默认的比较规则<strong>Maxlen</strong>代表该字符集表示一个字符最多需要几个字节</p><p>查看比较规则<img src="https://upload-images.jianshu.io/upload_images/1863961-434c1321853a6064.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-28b9ac453cbdcce8.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>MySQL中utf8是utf8mb3的别名，所以在MySQL中utf8就意味着使用1~3个字节来表示一个字符，如果大家有使用4字节编码一个字符的情况，比如存储一些emoji表情，使用utf8mb4</p></blockquote><p>MySQL有4个级别的字符集和比较规则，分别是：服务器级别 <code>character_set_server</code>, <code>collation_server</code></p><p>数据库级别 <code>character_set_database</code>, <code>collation_database</code></p><p>表级别</p><p>列级别</p><blockquote><p>编码和解码使用的字符集不一致将导致乱码</p></blockquote><h3><span id="zi-fu-ji-de-zhuan-huan">字符集的转换</span><a href="#zi-fu-ji-de-zhuan-huan" class="header-anchor">#</a></h3><p><code>character_set_client</code> 服务器解码请求语句时使用的字符集</p><p><code>character_set_connection</code>服务器处理请求时会把请求字符串从<code>character_set_client</code>转为<code>character_set_connection</code></p><p><code>character_set_results</code>服务器向客户端返回数据时使用的字符集</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-d6053a1496be0af5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>通常把 <code>character_set_client</code> 、<code>character_set_connection</code>、<code>character_set_results</code> 这三个系统变量设置成和客户端使用的相同的字符集</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">NAMES</span> 字符集名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> character_set_client = 字符集名;</span><br><span class="line"><span class="keyword">SET</span> character_set_connection = 字符集名;</span><br><span class="line"><span class="keyword">SET</span> character_set_results = 字符集名;</span><br></pre></td></tr></table></figure><h2><span id="innodb-ji-lu-cun">InnoDB记录存</span><a href="#innodb-ji-lu-cun" class="header-anchor">#</a></h2><h3><span id="innodb-ye">InnoDB页</span><a href="#innodb-ye" class="header-anchor">#</a></h3><p>InnoDB是一个将表中的数据存储到磁盘上的存储引擎。磁盘读写的速度比内存的读写速度差了几个数量级，因此设计InnoDB时将数据划分为若干个页并以页作为磁盘和内存之间交互的基本单位，页的大小一般为 16 KB。</p><h3><span id="innodb-xing-ge-shi">InnoDB行格式</span><a href="#innodb-xing-ge-shi" class="header-anchor">#</a></h3><p>4种行格式:</p><p>Compact</p><p>Redundant</p><p>Dynamic</p><p>Compressed</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 ROW_FORMAT=行格式名称</span><br></pre></td></tr></table></figure><h4><span id="compact-xing-ge-shi">Compact行格式</span><a href="#compact-xing-ge-shi" class="header-anchor">#</a></h4><p><img src="https://upload-images.jianshu.io/upload_images/1863961-769f50ea36079f99.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>所有变长字段的真实数据占用的字节长度都被存放在<strong>变长字段长度列表</strong>把值为NULL的列统一存储到<strong>NULL值列表</strong>中<strong>记录头信息</strong>是由固定的5个字节组成</p><blockquote><p>MySQL会为每个记录默认的添加一些列（隐藏列），包括：<strong>row_id</strong>（DB_ROW_ID）、<strong>transaction_id</strong>（DB_TRX_ID）、<strong>roll_pointer</strong>（DB_ROLL_PTR）。</p></blockquote><h4><span id="xing-shu-ju-yi-chu">行数据溢出</span><a href="#xing-shu-ju-yi-chu" class="header-anchor">#</a></h4><p><img src="https://upload-images.jianshu.io/upload_images/1863961-a7e5ed104feb0ad1.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>对于MySQL的每条记录，除了BLOB或者TEXT类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节。这个65535个字节除了列本身的数据之外，还包括一些其他的数据，即</p><ul><li>真实数据本身</li><li>真实数据占用字节的长度标识（&lt;= 2 bytes）</li><li>NULL值标识（&lt;= 1 byte），当列都有NOT NULL属性时为0</li></ul><p>因此，上图中设置变长类型<code>VARCHAR(M)</code>（M表示允许的字符数量）M=65535时导致了溢出。</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-0e1da580a7f2aa45.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>真实数据：65533 = 65529(c1)+ 4(c2)长度标识：2NULL值标识：1共65536 &gt; 65535溢出。</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-f0eb4612f6ec51fd.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>更换字符集后溢出。</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-58720a826df6d70e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>VARCHAR(M)类型的列就最多可以存储65533个字节，而一个页的大小一般是16KB，也就是16384字节，因此在Compact和Reduntant行格式中，在本记录只会存储该列的前768个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中；而在Dynamic和Compressed行格式中，记录中只存储其他页的地址。</p><h4><span id="xing-yi-chu-de-lin-jie-dian">行溢出的临界点</span><a href="#xing-yi-chu-de-lin-jie-dian" class="header-anchor">#</a></h4><p>MySQL中规定一个页中至少要存放两行记录</p><ul><li>每个页除了存放记录外，也需要存储一些额外的信息，这些额外信息加起来需要132个字节</li><li>每个记录的额外信息需要27字节<ul><li>真实数据的长度标识 1B</li><li>NULL值标识 1B</li><li>记录头信息 5B</li><li>row_id 6B</li><li>transaction_id 6B</li><li>roll_pointer 7B</li></ul></li></ul><blockquote><p>不溢出的临界条件：132 + 2×(27 + n) &lt; 16384</p></blockquote><h2><span id="innodb-shu-ju-ye">InnoDB数据页</span><a href="#innodb-shu-ju-ye" class="header-anchor">#</a></h2><h3><span id="shu-ju-ye-jie-gou">数据页结构</span><a href="#shu-ju-ye-jie-gou" class="header-anchor">#</a></h3><p><img src="https://upload-images.jianshu.io/upload_images/1863961-7b48bacba1c08eed.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3><span id="ji-lu-zai-ye-zhong-de-cun-chu">记录在页中的存储</span><a href="#ji-lu-zai-ye-zhong-de-cun-chu" class="header-anchor">#</a></h3><p><img src="https://upload-images.jianshu.io/upload_images/1863961-c4157ce34c34235e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4><span id="ji-lu-tou-xin-xi">记录头信息</span><a href="#ji-lu-tou-xin-xi" class="header-anchor">#</a></h4><p>以 page_demo 表为例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> page_demo(</span><br><span class="line">    c1 <span class="built_in">INT</span>,</span><br><span class="line">    c2 <span class="built_in">INT</span>,</span><br><span class="line">    c3 <span class="built_in">VARCHAR</span>(<span class="number">10000</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (c1)</span><br><span class="line">) <span class="keyword">CHARSET</span>=<span class="keyword">ascii</span> ROW_FORMAT=<span class="keyword">Compact</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/1.PNG" alt=""></p><p>由于指定 c1 为主键，所以在行格式中就没有隐藏列 row_id。</p><p>插入数据4条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> page_demo <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="string">'aaaa'</span>),</span><br><span class="line">    (<span class="number">2</span>, <span class="number">200</span>, <span class="string">'bbbb'</span>),</span><br><span class="line">    (<span class="number">3</span>, <span class="number">300</span>, <span class="string">'cccc'</span>),</span><br><span class="line">    (<span class="number">4</span>, <span class="number">400</span>, <span class="string">'dddd'</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/2.PNG" alt=""></p><ul><li><p>delete_mask</p><p>标记当前记录是否被删除，值为0的时候代表记录没有被删除，1则被删除了；所有被删的记录会组成一个<strong>垃圾链表</strong>，新记录插入到表时可以覆盖这些被删除的记录占用的存储空间。</p></li><li><p>n_owned</p><p>见<a href="#page-directory">Page Directory</a></p></li><li><p>heap_no</p><p>表示当前记录在本页中的位置，从上图中可以看出，插入的4条记录在本页中的位置分别是：2、3、4、5。最小记录和最大记录分别为0、1。</p><p><img src="/images/3.PNG" alt=""></p></li><li><p>record_type</p><p>记录类型，共4种：</p><p>0：普通记录</p><p>1：B+树非叶节点记录 （或目录项记录，见<a href="#mu-lu-xiang">目录项</a>）</p><p>2：最小记录</p><p>3：最大记录</p></li><li><p>min_rec_mask</p><p>代表B+树的每层非叶节点中的最小记录 （或者主键值最小的目录项记录的min_rec_mask值为1）</p></li><li><p>next_record</p><p>表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量。例如第一条记录的next_record值为32，意味着从第一条记录的真实数据的地址处向后找32个字节便是下一条记录的真实数据。记录按照主键从小到大的顺序形成了一个单链表</p><p><img src="/images/4.PNG" alt=""></p></li></ul><p>如果删除第二条记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> page_demo <span class="keyword">WHERE</span> c1 = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/5.PNG" alt=""></p><p>删除第2条记录前后的主要变化：</p><ul><li>第2条记录的delete_mask值设置为1；</li><li>第2条记录的next_record值变为了0，意味着该记录没有下一条记录了；</li><li>第1条记录的next_record指向了第3条记录；</li><li>最大记录的n_owned值从5变成了4。</li></ul><h3><span id="page-directory">Page Directory</span><a href="#page-directory" class="header-anchor">#</a></h3><p>设计页目录是为了方便快速查找记录，就像书的目录那样，创建 page directory 的步骤：</p><ul><li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组；</li><li>每个组内最大的那条记录的头信息的 n_owned 表示组内记录的数量；</li><li>将每个组的最大的那条记录的地址偏移量（也称槽，slot）集中起来存放，构成 Page Directory；</li></ul><p><img src="/images/6.PNG" alt=""></p><p>InnoDB规定最小记录所在的分组只能有 1 条记录，最大记录所在的分组的记录条数在 1~8 条之间，其它分组中记录的条数则在是 4~8 条之间。</p><p>利用页目录查找指定主键的记录的过程分为两步：</p><ul><li>通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录；</li><li>通过记录的 next_record 属性遍历组中的各个记录。</li></ul><h3><span id="page-header">Page Header</span><a href="#page-header" class="header-anchor">#</a></h3><p>存储数据的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等。</p><h3><span id="file-header">File Header</span><a href="#file-header" class="header-anchor">#</a></h3><p>不同类型的页都会以File Header作为第一个组成部分，它记录了针对各种页都通用的一些信息。索引页（数据页）通过 file header 构成双向链表</p><p><img src="/images/7.PNG" alt=""></p><h3><span id="file-trailer">File Trailer</span><a href="#file-trailer" class="header-anchor">#</a></h3><p>与file header一样对不同类型的页通用，主要用于校验页数据的完整性。</p><h2><span id="b-shu-suo-yin">B+树索引</span><a href="#b-shu-suo-yin" class="header-anchor">#</a></h2><h3><span id="wu-suo-yin-cha-zhao">无索引查找</span><a href="#wu-suo-yin-cha-zhao" class="header-anchor">#</a></h3><h4><span id="zai-ye-nei-cha-zhao">在页内查找</span><a href="#zai-ye-nei-cha-zhao" class="header-anchor">#</a></h4><ul><li><p>以主键查找依据页目录（槽）采用二分查找定位分组，再遍历分组</p></li><li><p>以主键以外的列查找遍历页内的记录链表</p></li></ul><h4><span id="zai-duo-ye-zhong-cha-zhao">在多页中查找</span><a href="#zai-duo-ye-zhong-cha-zhao" class="header-anchor">#</a></h4><ul><li>定位记录所在的页</li><li>页内查找</li></ul><h3><span id="suo-yin">索引</span><a href="#suo-yin" class="header-anchor">#</a></h3><p>建立索引是为了快速定位记录所在的数据页。</p><ul><li>对数据页进行排序。即让下一个数据页的记录的主键值大于上一个页的记录的主键值，因此在插入新的记录时涉及数据页间的记录的调整<img src="/images/8.PNG" alt=""></li></ul><blockquote><p>对页进行排序后，全部记录的主键值就构成了一个递增的序列，从而可以利用二分法实现快速查找。</p></blockquote><ul><li>对每个页设置目录项</li></ul><h4><span id="mu-lu-xiang">目录项</span><a href="#mu-lu-xiang" class="header-anchor">#</a></h4><p>目录项包括</p><ul><li>数据页中的记录的最小主键值，用key来表示；</li><li>页号，用page_no表示。</li></ul><p><img src="/images/9.PNG" alt=""></p><h4><span id="yong-ye-cun-fang-mu-lu-xiang">用页存放目录项</span><a href="#yong-ye-cun-fang-mu-lu-xiang" class="header-anchor">#</a></h4><p><img src="/images/10.PNG" alt=""><img src="/images/11.PNG" alt=""><img src="/images/12.PNG" alt=""></p><p>用户记录都存放在B+树的叶节点上，而目录项都存放在非页节点上。</p><h4><span id="ju-cu-suo-yin">聚簇索引</span><a href="#ju-cu-suo-yin" class="header-anchor">#</a></h4><p>特性包括：</p><ol><li>依据记录的主键值排序<ul><li>页内的记录是按照主键的大小顺序排成一个单向链表</li><li>数据页根据主键大小顺序排成一个双向链表</li><li>存放目录项记录的页根据主键大小分为不同的层次</li></ul></li><li>B+树的叶节点存储的是完整的记录，即记录的所有列的值（包括隐藏列）</li></ol><h4><span id="er-ji-suo-yin">二级索引</span><a href="#er-ji-suo-yin" class="header-anchor">#</a></h4><p>依据记录的其它列（比如c1）的值排序形成的B+树。将聚簇索引的主键值换为c1的值，此外，叶节点存储的不是完整的记录而只有主键和c1。</p><blockquote><p>通过二级索引来查找完整记录：通过二级索引找到主键值之后再通过聚簇索引查找完整记录。</p></blockquote><h2><span id="b-shu-suo-yin-de-shi-yong">B+树索引的使用</span><a href="#b-shu-suo-yin-de-shi-yong" class="header-anchor">#</a></h2><h3><span id="he-li-shi-yong-suo-yin">合理使用索引</span><a href="#he-li-shi-yong-suo-yin" class="header-anchor">#</a></h3><p>考虑表 person_info</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_info(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    birthday <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    phone <span class="built_in">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    country <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">    <span class="keyword">KEY</span> idx_name_birthday_phone (<span class="keyword">name</span>, birthday, phone)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>idx_name_birthday_phone 为二级索引<img src="/images/13.PNG" alt=""></p><h4><span id="quan-zhi-pi-pei">全值匹配</span><a href="#quan-zhi-pi-pei" class="header-anchor">#</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span> <span class="keyword">AND</span> birthday = <span class="string">'1990-09-27'</span> <span class="keyword">AND</span> phone = <span class="string">'15123983239'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>由于查询优化器的存在，调换name、birthday、phone这几个搜索列的顺序<strong>不影响</strong>查询的执行过程。</p></blockquote><h4><span id="pi-pei-zuo-bian-de-lie">匹配左边的列</span><a href="#pi-pei-zuo-bian-de-lie" class="header-anchor">#</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span>;</span><br></pre></td></tr></table></figure><p>可以使用索引idx_name_birthday_phone，而</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> birthday = <span class="string">'1990-09-27'</span>;</span><br></pre></td></tr></table></figure><p>不能使用索引idx_name_birthday_phone。</p><h4><span id="pi-pei-lie-qian-zhui">匹配列前缀</span><a href="#pi-pei-lie-qian-zhui" class="header-anchor">#</a></h4><p>比如查询名字以 As 开头的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'As%'</span>;</span><br></pre></td></tr></table></figure><h3><span id="hui-biao-de-dai-jie">回表的代价</span><a href="#hui-biao-de-dai-jie" class="header-anchor">#</a></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> &gt; <span class="string">'Asa'</span> <span class="keyword">AND</span> <span class="keyword">name</span> &lt; <span class="string">'Barlow'</span>;</span><br></pre></td></tr></table></figure><p>二级索引搜索到的结果（即值在Asa～Barlow之间的记录）在磁盘中的存储是相连的，集中分布在一个或几个数据页中，因此可以很快从磁盘中读出，这种读取方式可以称为顺序I/O。而回表是根据不连续的id值到聚簇索引中读出完整的用户记录（可能分布在不同的数据页中），这种读取方式可以称为随机I/O。一般情况下，顺序I/O比随机I/O的性能高很多。</p><h4><span id="er-ji-suo-yin-hui-biao-or-quan-biao-sao-ma">二级索引 + 回表 or 全表扫码</span><a href="#er-ji-suo-yin-hui-biao-or-quan-biao-sao-ma" class="header-anchor">#</a></h4><p>需要回表的记录越多，使用二级索引的性能就越低，甚至不如使用聚簇索引全表扫码；</p><p>使用<code>LIMIT</code>限制回表次数，使优化器倾向于使用二级索引 + 回表的方式执行查询。</p><h4><span id="fu-gai-suo-yin">覆盖索引</span><a href="#fu-gai-suo-yin" class="header-anchor">#</a></h4><p>如果需要查询的列包含在二级索引中，就可以避免回表查询，这种只需要用到索引的查询方式称为索引覆盖。例如对于索引idx_name_birthday_phone</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, birthday, phone <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> &gt; <span class="string">'Asa'</span> <span class="keyword">AND</span> <span class="keyword">name</span> &lt; <span class="string">'Barlow'</span></span><br></pre></td></tr></table></figure><h3><span id="he-li-di-jian-li-suo-yin">合理地建立索引</span><a href="#he-li-di-jian-li-suo-yin" class="header-anchor">#</a></h3><ul><li><p>只给搜索、排序、分组的列创建索引</p><p>即只给出现在 WHERE、ORDER BY、GROUP BY 子句中的列创建索引；</p></li><li><p>列的方差越大越适合建立索引</p><p>列的数据越分散，越适合索引查询。举个极端的例子，数据都相同的列，对这样的列建立索引毫无意义；</p></li><li><p>列的数据类型越小越适合建立索引</p><p>比较数据大小更快，占用的存储空间更小；</p></li><li><p>索引字符串的前缀</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_info(</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    birthday <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    phone <span class="built_in">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    country <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">KEY</span> idx_name_birthday_phone (<span class="keyword">name</span>(<span class="number">10</span>), birthday, phone)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中 name(10) 表示在建立的B+树索引中只保留记录的前10个字符的编码，但是该索引不支持 name 排序</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">name</span> <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>让索引列在比较表达式中单独出现</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WHERE my_col * 2 &lt; 4</span><br><span class="line">WHERE my_col &lt; 4/2</span><br></pre></td></tr></table></figure><p>如果列是以某个表达式或者函数调用形式出现是用不到索引的，比如上面的<code>my_col * 2</code>；</p></li><li><p>开启主键AUTO_INCREMENT属性</p><p>可减少页分裂和记录移位的次数。</p></li></ul><h2><span id="mysql-de-shu-ju-mu-lu">MySQL的数据目录</span><a href="#mysql-de-shu-ju-mu-lu" class="header-anchor">#</a></h2><h3><span id="shu-ju-ku-he-wen-jian-xi-tong-de-guan-xi">数据库和文件系统的关系</span><a href="#shu-ju-ku-he-wen-jian-xi-tong-de-guan-xi" class="header-anchor">#</a></h3><p>InnoDB、MyISAM等存储引擎都是把表存储在磁盘上。操作系统通过文件系统管理磁盘。</p><p>InnoDB、MyISAM等存储引擎 $ \Leftrightarrow $ 文件系统 $ \Leftrightarrow $ 磁盘</p><h3><span id="shu-ju-mu-lu">数据目录</span><a href="#shu-ju-mu-lu" class="header-anchor">#</a></h3><h4><span id="shu-ju-mu-lu-he-an-zhuang-mu-lu-de-qu-bie">数据目录和安装目录的区别</span><a href="#shu-ju-mu-lu-he-an-zhuang-mu-lu-de-qu-bie" class="header-anchor">#</a></h4><p>数据目录是用来存储MySQL在运行过程中产生的数据，要与MySQL的安装目录区别开来。</p><h4><span id="cha-zhao-shu-ju-mu-lu">查找数据目录</span><a href="#cha-zhao-shu-ju-mu-lu" class="header-anchor">#</a></h4><p><img src="/images/14.PNG" alt=""></p><h3><span id="shu-ju-mu-lu-de-jie-gou">数据目录的结构</span><a href="#shu-ju-mu-lu-de-jie-gou" class="header-anchor">#</a></h3><h4><span id="shu-ju-ku-zai-wen-jian-xi-tong-zhong-de-biao-shi">数据库在文件系统中的表示</span><a href="#shu-ju-ku-zai-wen-jian-xi-tong-zhong-de-biao-shi" class="header-anchor">#</a></h4><p>每新建一个数据库，MySQL执行了：</p><ul><li>在数据目录下创建一个和数据库名同名的子目录；</li><li>并在该子目录下创建一个db.opt文件，这个文件中包含了该数据库的各种属性，比方说该数据库的字符集和比较规则等。</li></ul><p>查看数据库<img src="/images/15.PNG" alt="">查看数据目录<img src="/images/16.PNG" alt=""></p><p>除了information_schema这个系统数据库外，其他的数据库在数据目录下都有对应的子目录。</p><h4><span id="biao-zai-wen-jian-xi-tong-zhong-de-biao-shi">表在文件系统中的表示</span><a href="#biao-zai-wen-jian-xi-tong-zhong-de-biao-shi" class="header-anchor">#</a></h4><p>每个表包含两部分信息：</p><ul><li><p>表结构的定义</p><p>用<code>表名.frm</code>文件来描述表结构</p></li><li><p>表中的数据</p><p>InnoDB: 数据存在独立表空间(file-per-table tablespace)中，即 <code>test.ibd</code> 文件</p><p>MyISAM: <code>表名.MYD</code>表示表的数据文件、<code>表名.MYI</code>表示表的索引文件</p></li></ul><h3><span id="wen-jian-xi-tong-dui-shu-ju-ku-de-ying-xiang">文件系统对数据库的影响</span><a href="#wen-jian-xi-tong-dui-shu-ju-ku-de-ying-xiang" class="header-anchor">#</a></h3><ul><li><p>数据库名和表名不得超过文件系统所允许的最大长度</p></li><li><p>特殊字符</p><p>MySQL会把数据库名和表名中除<strong>数字</strong>和<strong>拉丁字母</strong>外的所有字符在文件名里都映射成 @+编码值的形式，如<code>test?.frm</code> $ \rightarrow $ <code>test@003f.frm</code></p></li><li><p>文件大小受文件系统限制</p></li></ul><h3><span id="mysql-xi-tong-shu-ju-ku-jian-jie">MySQL系统数据库简介</span><a href="#mysql-xi-tong-shu-ju-ku-jian-jie" class="header-anchor">#</a></h3><ul><li><p>mysql</p><p>存储了MySQL的账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息、以及时区信息等</p></li><li><p>information_schema</p><p>这个数据库保存着MySQL服务器维护的所有其他数据库的信息，比如表、视图、触发器、列、索引等</p></li><li><p>performance_schema</p><p>这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，包括统计最近执行的语句，执行时间，内存使用情况等</p></li><li><p>sys</p><p>这个数据库主要是通过视图的形式把information_schema和performance_schema结合起来</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="MySQL, 长文" scheme="https://hejtao.netlify.com/tags/MySQL-%E9%95%BF%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>SQL Notes</title>
    <link href="https://hejtao.netlify.com/2019/09/05/2019-9-5/"/>
    <id>https://hejtao.netlify.com/2019/09/05/2019-9-5/</id>
    <published>2019-09-04T16:00:00.000Z</published>
    <updated>2020-03-23T07:26:40.457Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><div class="toc"><!-- toc --><ul><li><a href="#lian-biao-cha-xun">联表查询</a></li><li><a href="#zi-fu-ti-huan">字符替换</a></li><li><a href="#zheng-ze-cha-xun">正则查询</a></li><li><a href="#dao-ru-sql-wen-jian">导入SQL文件</a></li><li><a href="#pai-xu">排序</a></li></ul><!-- tocstop --></div><h4><span id="lian-biao-cha-xun">联表查询</span><a href="#lian-biao-cha-xun" class="header-anchor">#</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> library.id, library.name, r.reader_sum, b.book_sum <span class="keyword">FROM</span> </span><br><span class="line"><span class="keyword">library</span> </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">( <span class="keyword">SELECT</span> library_id, <span class="keyword">count</span>(*) <span class="keyword">AS</span> reader_sum <span class="keyword">FROM</span> reader <span class="keyword">WHERE</span> library_group_id = <span class="number">10</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> library_id ) <span class="keyword">AS</span> r</span><br><span class="line"><span class="keyword">ON</span> r.library_id = library.id </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line">( <span class="keyword">SELECT</span> library_id, <span class="keyword">count</span>( * ) <span class="keyword">AS</span> book_sum <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> library_group_id = <span class="number">10</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> library_id ) <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> b.library_id = library.id;</span><br></pre></td></tr></table></figure><h4><span id="zi-fu-ti-huan">字符替换</span><a href="#zi-fu-ti-huan" class="header-anchor">#</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">account</span> <span class="keyword">SET</span> grade = <span class="keyword">replace</span>(grade,<span class="string">'級'</span>,<span class="string">'级'</span>);</span><br></pre></td></tr></table></figure><h4><span id="zheng-ze-cha-xun">正则查询</span><a href="#zheng-ze-cha-xun" class="header-anchor">#</a></h4><p><img src="https://upload-images.jianshu.io/upload_images/1863961-2bcf89b08ee87c02.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">account</span> <span class="keyword">WHERE</span> grade REGEXP <span class="string">'級'</span>; <span class="comment">-- 查询包含</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> <span class="keyword">name</span> REGEXP <span class="string">'^[aeiou]|ok$'</span>; <span class="comment">-- aeiou开头，或ok结尾</span></span><br></pre></td></tr></table></figure><h4><span id="dao-ru-sql-wen-jian">导入SQL文件</span><a href="#dao-ru-sql-wen-jian" class="header-anchor">#</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @@global.max_allowed_packet = <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @@global.sql_mode =<span class="string">'ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'</span>;</span><br><span class="line"><span class="keyword">SET</span> @@sql_mode =<span class="string">'ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'</span>;</span><br></pre></td></tr></table></figure><h4><span id="pai-xu">排序</span><a href="#pai-xu" class="header-anchor">#</a></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> library_id = <span class="number">257</span> <span class="keyword">AND</span> (title REGEXP <span class="string">"我"</span> <span class="keyword">OR</span> author REGEXP <span class="string">"我"</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">LOCATE</span>(<span class="string">"我"</span>, <span class="keyword">CONCAT</span>(title, author)), <span class="keyword">LENGTH</span>(title), <span class="keyword">LENGTH</span>(author);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">IN</span> (<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">field</span>(<span class="keyword">id</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span></span><br><span class="line">( <span class="keyword">SELECT</span> isbn13, cn_title, <span class="keyword">count</span>(*) total <span class="keyword">FROM</span> book_info <span class="keyword">WHERE</span> isbn13 != <span class="string">''</span> <span class="keyword">AND</span> <span class="keyword">source</span> <span class="keyword">IN</span> (<span class="string">'yidi'</span>, <span class="string">'guotu'</span>, <span class="string">'douban'</span>, <span class="string">'dangdang'</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> isbn13, cn_title ) t1</span><br><span class="line"><span class="keyword">WHERE</span> total &gt; <span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> total <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="SQL" scheme="https://hejtao.netlify.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>麻省理工 MapReduce 实验</title>
    <link href="https://hejtao.netlify.com/2019/04/30/2019-4-30/"/>
    <id>https://hejtao.netlify.com/2019/04/30/2019-4-30/</id>
    <published>2019-04-29T16:00:00.000Z</published>
    <updated>2019-11-11T19:59:33.204Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><div class="toc"><!-- toc --><ul><li><a href="#mapreduce-zhi-xing-gai-shu">MapReduce执行概述</a></li><li><a href="#xu-yan-shou-xi-yuan-dai-ma">序言：熟悉源代码</a></li><li><a href="#part-i-map-reduce-shu-ru-he-shu-chu">Part I: Map/Reduce 输入和输出</a></li><li><a href="#part-ii-single-worker-dan-ci-tong-ji">Part II: Single-worker单词统计</a></li><li><a href="#part-iii-fen-bu-shi-mapreduce-ren-wu">Part III: 分布式 MapReduce 任务</a></li><li><a href="#part-iv-worker-cuo-wu-chu-li">Part IV: worker错误处理</a></li></ul><!-- tocstop --></div><p><a href="http://nil.csail.mit.edu/6.824/2018/labs/lab-1.html" target="_blank" rel="noopener">原文链接</a></p><h3><span id="mapreduce-zhi-xing-gai-shu">MapReduce执行概述</span><a href="#mapreduce-zhi-xing-gai-shu" class="header-anchor">#</a></h3><p><a href="http://nil.csail.mit.edu/6.824/2018/papers/mapreduce.pdf" target="_blank" rel="noopener">论文地址</a><img src="https://upload-images.jianshu.io/upload_images/1863961-e3049b9f4645a329.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/840" alt=""></p><p>通过自动将输入数据划分为$M$个片段，Map调用分布在多台机器上。 不同片段的输入数据可以由不同的机器并行处理。 Reduce调用的分布式则通过使用分区函数(即 $hash(key)$  $mod$  $R$)将键空间划分为$R$个部分来实现，$R$的大小和分区函数由用户指定。上图显示了MapReduce操作的总体流程。 当用户程序调用MapReduce函数时，会发生以下操作序列(图中的编号标签对应于下面的数字)：</p><ol><li>用户程序中的MapReduce库首先将输入文件拆分为16MB到64MB(用户可通过参数设置)的$M$个片段。 然后，它会在一组计算机上启动该程序的许多副本；</li><li>master为副本之一，其余的是由master分配工作的workers。 有$M$个Map任务和$R$个Reduce任务需要分配。master为每个空闲的worker分配一个Map任务或Reduce任务；</li><li>被分配Map任务的worker读取相应输入片段。 它从输入片段中解析键/值对，并将键/值对传递给用户定义的Map函数。 Map函数生成的中间键/值对缓存在内存中；</li><li>内存中的键\值对被周期性地写入到本地磁盘，并通过分区函数划分为$R$个分区。 键\值对在本地磁盘的位置将被传回到master，master再将位置信息转发给Reduce worker；</li><li>当Reduce worker收到来自master的位置信息后，它使用远程过程调用(RPC)从Map worker的本地磁盘读取缓冲数据。 当Reduce worker读取了所有中间数据时，它会根据中间键进行排序，以便将所有相同的中间键组合在一起。 之所以需要排序是因为通常有许多不同的键映射到同一个reduce任务。 如果中间数据量太大而无法容纳在内存中，则使用外部排序；</li><li>Reduce worker对排好序的中间数据进行遍历。对遇到的每个唯一中间键，它将键和相应的一组中间值传递给用户的Reduce函数。 Reduce函数的输出附加到此Reduce分区的最终输出文件。</li><li>完成所有Map任务和Reduce任务后，master会唤醒用户程序。 此时，用户程序中的MapReduce()将返回用户代码。</li></ol><h3><span id="xu-yan-shou-xi-yuan-dai-ma">序言：熟悉源代码</span><a href="#xu-yan-shou-xi-yuan-dai-ma" class="header-anchor">#</a></h3><p>提供的Map/Reduce代码支持两种操作模式，即串行和分布式。 在前者中，map和reduce任务每次执行一个：首先是第一个map任务执行完成，然后是第二个，然后是第三个，等等。当所有map任务完成后，执行第一个reduce任务，然后是第二个，等等。这种模式虽然不快，但方便调试。 分布式模式运行着许多worker线程，这些线程先并行执行map任务，然后reduce任务。 这要快得多，但也难以调试。mapreduce包提供了一个简单的Map/Reduce库。 应用程序通常调用<code>master.go</code>中的<code>Distributed()</code>来启动分布式模式，而调用<code>master.go</code>中的<code>Sequential()</code>来获取调试的串行执行。</p><p>代码如下执行：</p><ol><li>该应用程序提供了许多输入文件、一个<strong>map函数</strong>、一个<strong>reduce函数</strong>和<strong>reduce任务的数量</strong>（$nReduce$）；</li><li>创建master。 master启动一个RPC服务器(参见<code>master_rpc.go</code>)，并等待worker注册(使用RPC调用<code>Register()</code>，在<code>master.go</code>中定义)。 当任务变得可用时(在步骤4和5中)，<code>schedule()</code>(位于schedule.go)决定如何将这些任务分配给workers以及如何处理worker故障；</li><li>master将每个输入文件视为一个  Map任务，并为每个Map任务至少调用一次(at-least-once)<code>doMap()</code>(<code>common_map.go</code>)，可以通过直接使用<code>Sequential()</code>或通过向worker (<code>worker.go</code>)发出DoTask RPC来实现。每次调用<code>doMap()</code>都会读取适当的文件，调用该文件中的map函数，并将生成的键/值对写入$nReduce$个中间文件。doMap() 对每个键哈希化以便挑选中间文件和 将会处理键的reduce任务。 完成所有map任务后，将会有$nMap \times nReduce$个文件。 每个文件名都包含一个前缀，map任务编号和reduce任务编号。 如果有两个map任务和三个reduce任务，map任务将创建如下六个中间文件：<code>mrtmp.xxx-0-0</code><code>mrtmp.xxx-0-1</code><code>mrtmp.xxx-0-2</code><code>mrtmp.xxx-1-0</code><code>mrtmp.xxx-1-1</code><code>mrtmp.xxx-1-2</code>每个worker必须能够读取由任何其他worker写入的文件以及输入文件。 现实部署利用分布式存储系统(如GFS)来允许此读取，即使workers在不同的计算机上运行。 在本实验中，您将在同一台计算机上运行所有workers，并使用本地文件系统；</li><li>接下来master为每个reduce任务至少调用一次(at-least-once) <code>doReduce()</code>(<code>common_reduce.go</code>)。 与<code>doMap()</code>一样，可以直接或通过worker来完成。 用于reduce任务r的`doReduce()从每个map任务中收集第$r$个中间文件，并为这些文件中出现的每个键调用reduce函数。 reduce任务生成$nReduce$个结果文件；</li><li>master调用<code>mr.merge()</code>(<code>master_splitmerge.go</code>)，将上一步生成的所有$nReduce$个文件合并为单个输出；</li><li>master向每个woker发送Shutdown RPC，然后关闭自己的RPC服务器。</li></ol><blockquote><p>说明：在后续的练习中，您必须编写/修改<code>doMap()</code>，<code>doReduce()</code>和<code>schedule()</code>，它们分别位于<code>common_map.go</code>、<code>common_reduce.go</code>和<code>schedule.go</code>中。 您还必须在<code>../main/wc.go</code>中编写map函数和reduce函数。</p></blockquote><h3><span id="part-i-map-reduce-shu-ru-he-shu-chu">Part I: Map/Reduce 输入和输出</span><a href="#part-i-map-reduce-shu-ru-he-shu-chu" class="header-anchor">#</a></h3><p>提供的Map/Reduce实现缺少部分代码。 在编写第一个Map/Reduce函数对之前，您需要修改sequential的实现代码。 特别是，提供的代码缺少两个关键部分：分配一个map任务输出的函数，以及收集一个reduce任务所有输入的函数。 这些任务分别由<code>common_map.go</code>中的<code>doMap()</code>函数和<code>common_reduce.go</code>中的<code>doReduce()</code>函数执行。</p><p>为了帮助您确定是否正确实现了<code>doMap()</code>和<code>doReduce()</code>，我们为您提供了一个Go测试套件(<code>test_test.go</code>)用于检查文件中实现。 例如测试修改后的sequence实现代码，请运行：<code>go test -run Sequential</code>or<code>go test -v -run Sequential</code></p><p><strong>解答：</strong>该部分任务只需要补全<code>common_map.go</code>中的<code>doMap()</code>和<code>common_reduce.go</code>中的<code>doReduce()</code>的代码，补全的结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mapreduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"hash/fnv"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doMap</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">jobName <span class="keyword">string</span>, // the name of the MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">mapTask <span class="keyword">int</span>, // which <span class="keyword">map</span> task this is</span></span></span><br><span class="line"><span class="function"><span class="params">inFile <span class="keyword">string</span>,</span></span></span><br><span class="line">nReduce int, // the number of reduce task that will be run ("R" in the paper)</span><br><span class="line">mapF <span class="function"><span class="keyword">func</span>(<span class="params">filename <span class="keyword">string</span>, content <span class="keyword">string</span></span>) []<span class="title">KeyValue</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// doMap manages one map task: it should read one of the input files</span></span><br><span class="line"><span class="comment">// (inFile), call the user-defined map function (mapF) for that file's</span></span><br><span class="line"><span class="comment">// content, and partition mapF's output into nReduce intermediate files.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// There is one intermediate file per reduce task. The file name</span></span><br><span class="line"><span class="comment">// includes both the map task number and the reduce task number. Use</span></span><br><span class="line"><span class="comment">// the filename generated by reduceName(jobName, mapTask, r)</span></span><br><span class="line"><span class="comment">// as the intermediate file for reduce task r. Call ihash() (see</span></span><br><span class="line"><span class="comment">// below) on each key, mod nReduce, to pick r for a key/value pair.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// mapF() is the map function provided by the application. The first</span></span><br><span class="line"><span class="comment">// argument should be the input file name, though the map function</span></span><br><span class="line"><span class="comment">// typically ignores it. The second argument should be the entire</span></span><br><span class="line"><span class="comment">// input file content. mapF() returns a slice containing the</span></span><br><span class="line"><span class="comment">// key/value pairs for reduce; see common.go for the definition of</span></span><br><span class="line"><span class="comment">// KeyValue.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Look at Go's ioutil and os packages for functions to read</span></span><br><span class="line"><span class="comment">// and write files.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Coming up with a scheme for how to format the key/value pairs on</span></span><br><span class="line"><span class="comment">// disk can be tricky, especially when taking into account that both</span></span><br><span class="line"><span class="comment">// keys and values could contain newlines, quotes, and any other</span></span><br><span class="line"><span class="comment">// character you can think of.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// One format often used for serializing data to a byte stream that the</span></span><br><span class="line"><span class="comment">// other end can correctly reconstruct is JSON. You are not required to</span></span><br><span class="line"><span class="comment">// use JSON, but as the output of the reduce tasks *must* be JSON,</span></span><br><span class="line"><span class="comment">// familiarizing yourself with it here may prove useful. You can write</span></span><br><span class="line"><span class="comment">// out a data structure as a JSON string to a file using the commented</span></span><br><span class="line"><span class="comment">// code below. The corresponding decoding functions can be found in</span></span><br><span class="line"><span class="comment">// common_reduce.go.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   enc := json.NewEncoder(file)</span></span><br><span class="line"><span class="comment">//   for _, kv := ... &#123;</span></span><br><span class="line"><span class="comment">//     err := enc.Encode(&amp;kv)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Remember to close the file after you have written all the values!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code here (Part I).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取输入文件</span></span><br><span class="line">content, err := ioutil.ReadFile(inFile)  </span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doMap读取输入文件错误"</span>,err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//map操作</span></span><br><span class="line">kvPairs := mapF(inFile, <span class="keyword">string</span>(content))  <span class="comment">//调用mapF，返回键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将键值对写入到中间文件</span></span><br><span class="line">tmpFiles := <span class="built_in">make</span>([] *os.File, nReduce)  <span class="comment">//R个中间文件</span></span><br><span class="line">encoders := <span class="built_in">make</span>([] *json.Encoder, nReduce)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nReduce; i++ &#123;</span><br><span class="line">tmpFileName := reduceName(jobName, mapTask, i)  <span class="comment">//中间文件名,mrtmp.test-mapTask-i</span></span><br><span class="line"></span><br><span class="line">tmpFiles[i], err = os.Create(tmpFileName)  <span class="comment">//创建中间文件mrtmp.test-mapTask-i</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doMap生成中间文件错误"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> tmpFiles[i].Close()</span><br><span class="line"></span><br><span class="line">encoders[i] = json.NewEncoder(tmpFiles[i])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doMap编码错误"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ , kv := <span class="keyword">range</span> kvPairs &#123;</span><br><span class="line">hashKey := ihash(kv.Key) % nReduce  <span class="comment">//根据键将键值对分成R组</span></span><br><span class="line"></span><br><span class="line">err := encoders[hashKey].Encode(&amp;kv)  <span class="comment">//将R个键值对写入R个中间文件</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doMap编码错误"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ihash</span>(<span class="params">s <span class="keyword">string</span></span>) <span class="title">int</span></span> &#123;</span><br><span class="line">h := fnv.New32a()</span><br><span class="line">h.Write([]<span class="keyword">byte</span>(s))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(h.Sum32() &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mapreduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doReduce</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">jobName <span class="keyword">string</span>, // the name of the whole MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">reduceTask <span class="keyword">int</span>, // which reduce task this is</span></span></span><br><span class="line"><span class="function"><span class="params">outFile <span class="keyword">string</span>, // write the output here</span></span></span><br><span class="line">nMap int, // the number of map tasks that were run ("M" in the paper)</span><br><span class="line">reduceF <span class="function"><span class="keyword">func</span>(<span class="params">key <span class="keyword">string</span>, values []<span class="keyword">string</span></span>) <span class="title">string</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// doReduce manages one reduce task: it should read the intermediate</span></span><br><span class="line"><span class="comment">// files for the task, sort the intermediate key/value pairs by key,</span></span><br><span class="line"><span class="comment">// call the user-defined reduce function (reduceF) for each key, and</span></span><br><span class="line"><span class="comment">// write reduceF's output to disk.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You'll need to read one intermediate file from each map task;</span></span><br><span class="line"><span class="comment">// reduceName(jobName, m, reduceTask) yields the file</span></span><br><span class="line"><span class="comment">// name from map task m.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your doMap() encoded the key/value pairs in the intermediate</span></span><br><span class="line"><span class="comment">// files, so you will need to decode them. If you used JSON, you can</span></span><br><span class="line"><span class="comment">// read and decode by creating a decoder and repeatedly calling</span></span><br><span class="line"><span class="comment">// .Decode(&amp;kv) on it until it returns an error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You may find the first example in the golang sort package</span></span><br><span class="line"><span class="comment">// documentation useful.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// reduceF() is the application's reduce function. You should</span></span><br><span class="line"><span class="comment">// call it once per distinct key, with a slice of all the values</span></span><br><span class="line"><span class="comment">// for that key. reduceF() returns the reduced value for that key.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// You should write the reduce output as JSON encoded KeyValue</span></span><br><span class="line"><span class="comment">// objects to the file named outFile. We require you to use JSON</span></span><br><span class="line"><span class="comment">// because that is what the merger than combines the output</span></span><br><span class="line"><span class="comment">// from all the reduce tasks expects. There is nothing special about</span></span><br><span class="line"><span class="comment">// JSON -- it is just the marshalling format we chose to use. Your</span></span><br><span class="line"><span class="comment">// output code will look something like this:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// enc := json.NewEncoder(file)</span></span><br><span class="line"><span class="comment">// for key := ... &#123;</span></span><br><span class="line"><span class="comment">// enc.Encode(KeyValue&#123;key, reduceF(...)&#125;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// file.Close()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code here (Part I).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历属于自己的中间文件，将键值对合并到kvs中</span></span><br><span class="line">kvs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nMap; i++ &#123;</span><br><span class="line">fileName := reduceName(jobName, i, reduceTask)</span><br><span class="line"></span><br><span class="line">file, err := os.Open(fileName)  <span class="comment">//打开中间文件mrtmp.test-i-reduceTask</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doReduce打开文件错误"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dec := json.NewDecoder(file)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;  <span class="comment">//每个中间文件可能包含多个键值对</span></span><br><span class="line"><span class="keyword">var</span> kv KeyValue</span><br><span class="line">err = dec.Decode(&amp;kv)  <span class="comment">//解码一个键值对</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, ok := kvs[kv.Key]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;  <span class="comment">//出现新的键则初始化kvs</span></span><br><span class="line">kvs[kv.Key] = []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">kvs[kv.Key] = <span class="built_in">append</span>(kvs[kv.Key], kv.Value)  <span class="comment">//加入与键对应的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将键集合到一起并排序</span></span><br><span class="line"><span class="keyword">var</span> keys []<span class="keyword">string</span>  </span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(keys)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建输出文件</span></span><br><span class="line">out := mergeName(jobName, reduceTask)  </span><br><span class="line">file, err := os.Create(out)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doReduce创建输出文件错误"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">enc := json.NewEncoder(file)</span><br><span class="line"></span><br><span class="line"><span class="comment">//reduce操作</span></span><br><span class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">res := reduceF(k, kvs[k])  <span class="comment">//调用客户端的reduceF，进行reduce</span></span><br><span class="line">enc.Encode(KeyValue&#123;k, res&#125;)  <span class="comment">//reduce后的键值对写入到输出文件</span></span><br><span class="line">&#125;</span><br><span class="line">file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>go test -run Sequential</code>，结果如下： <img src="https://upload-images.jianshu.io/upload_images/1863961-b5960850942d11a2.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><h3><span id="part-ii-single-worker-dan-ci-tong-ji">Part II: Single-worker单词统计</span><a href="#part-ii-single-worker-dan-ci-tong-ji" class="header-anchor">#</a></h3><p>在该部分，您将要实现一个简单的Map/Reduce示例——单词统计。 具体是需要实现<code>main/wc.go</code>中的<code>mapF()</code>和<code>reduceF()</code>函数。 您的工作是插入代码，以便<code>wc.go</code>返回输入文件中每个单词出现的次数。 一个单词是任意连续的字母序列，其中字母可用Golang的<a href="https://golang.org/pkg/unicode/#IsLetter" target="_blank" rel="noopener">unicode.IsLetter</a>函数来判断。</p><p>在<code>~/6.824/src/main</code>目录中提供了一些路径名为<code>pg-*.txt</code>形式的输入文件， 可用如下命令给<code>wc.go</code>使用输入文件运行：<code>go run wc.go master sequential pg-*.txt</code></p><p>查看MapReduce论文的第2部分。<code>mapF()</code>和<code>reduceF()</code>函数与论文第2.1节中的函数略有不同。<code>mapF()</code>将接收一个文件名和该文件的内容，并将内容分成单词最终输出一个<code>mapreduce.KeyValue</code>型切片。 对于单词统计可将单词作为键。对输出中的每个键都将调用一次<code>reduceF()</code>，其中包含<code>mapF()</code>为该键生成的所有值的切片。 <code>reduceF()</code>返回一个包含键出现总数的字符串。</p><blockquote><p>提示1：关于Go的字符串处理，可以参读 <a href="http://blog.golang.org/strings" target="_blank" rel="noopener">Go Blog on strings</a>提示2：可以使用<a href="https://golang.org/pkg/strings/#FieldsFunc" target="_blank" rel="noopener">strings.FieldsFunc</a>函数将字符串拆分成单词提示3： 利用Go的<a href="https://golang.org/pkg/strconv/" target="_blank" rel="noopener">strconv</a>包可以很方便地将字符串转换成整型</p></blockquote><p>使用如下命令来验证答案：<code>go run wc.go master sequential pg-*.txt</code></p><p><strong>答案：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"mapreduce"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"unicode"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The map function is called once for each file of input. The first</span></span><br><span class="line"><span class="comment">// argument is the name of the input file, and the second is the</span></span><br><span class="line"><span class="comment">// file's complete contents. You should ignore the input file name,</span></span><br><span class="line"><span class="comment">// and look only at the contents argument. The return value is a slice</span></span><br><span class="line"><span class="comment">// of key/value pairs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span>(<span class="params">filename <span class="keyword">string</span>, contents <span class="keyword">string</span></span>) []<span class="title">mapreduce</span>.<span class="title">KeyValue</span></span> &#123;</span><br><span class="line"><span class="comment">// Your code here (Part II).</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> res []mapreduce.KeyValue</span><br><span class="line"></span><br><span class="line">f := <span class="function"><span class="keyword">func</span>(<span class="params">c <span class="keyword">rune</span></span>) <span class="title">bool</span></span> &#123; <span class="comment">//不是字母</span></span><br><span class="line"><span class="keyword">return</span> !unicode.IsLetter(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">words := strings.FieldsFunc(contents, f) <span class="comment">//在不是字母地方拆分字符串contents</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> words &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, mapreduce.KeyValue&#123;key, <span class="string">"1"</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The reduce function is called once for each key generated by the</span></span><br><span class="line"><span class="comment">// map tasks, with a list of all the values created for that key by</span></span><br><span class="line"><span class="comment">// any map task.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span>(<span class="params">key <span class="keyword">string</span>, values []<span class="keyword">string</span></span>) <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="comment">// Your code here (Part II).</span></span><br><span class="line"></span><br><span class="line">count := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line">num, _ := strconv.ParseInt(value, <span class="number">10</span>, <span class="number">64</span>) <span class="comment">// 将字符串value（例如："157"）按照十进制转换成整型</span></span><br><span class="line">count = count + <span class="keyword">int</span>(num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> strconv.Itoa(count) <span class="comment">//整型转换成字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Can be run in 3 ways:</span></span><br><span class="line"><span class="comment">// 1) Sequential (e.g., go run wc.go master sequential x1.txt .. xN.txt)</span></span><br><span class="line"><span class="comment">// 2) Master (e.g., go run wc.go master localhost:7777 x1.txt .. xN.txt)</span></span><br><span class="line"><span class="comment">// 3) Worker (e.g., go run wc.go worker localhost:7777 localhost:7778 &amp;)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &lt; <span class="number">4</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s: see usage comments in file\n"</span>, os.Args[<span class="number">0</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> os.Args[<span class="number">1</span>] == <span class="string">"master"</span> &#123;</span><br><span class="line"><span class="keyword">var</span> mr *mapreduce.Master</span><br><span class="line"><span class="keyword">if</span> os.Args[<span class="number">2</span>] == <span class="string">"sequential"</span> &#123;</span><br><span class="line">mr = mapreduce.Sequential(<span class="string">"wcseq"</span>, os.Args[<span class="number">3</span>:], <span class="number">3</span>, mapF, reduceF)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mr = mapreduce.Distributed(<span class="string">"wcseq"</span>, os.Args[<span class="number">3</span>:], <span class="number">3</span>, os.Args[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line">mr.Wait()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">mapreduce.RunWorker(os.Args[<span class="number">2</span>], os.Args[<span class="number">3</span>], mapF, reduceF, <span class="number">100</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>go run wc.go master sequential pg-sherlock_holmes.txt</code>和<code>sort -n -k2 mrtmp.wcseq | tail -10</code>的结果： <img src="https://upload-images.jianshu.io/upload_images/1863961-2d925a0b957652b7.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><h3><span id="part-iii-fen-bu-shi-mapreduce-ren-wu">Part III: 分布式 MapReduce 任务</span><a href="#part-iii-fen-bu-shi-mapreduce-ren-wu" class="header-anchor">#</a></h3><p>在当前的实现中，是通过串行的方式来执行Map任务和Reduce任务。 Map/Reduce最大的卖点之一是它可以自动地并行执行原始的串行代码而无需开发人员的任何额外工作。 在这一部分中，您将完成一个分布式MapReduce版本，即将工作拆分为在多核上运行的一组worker线程。 尽管不像真实的Map/Reduce部署被分布在多台机器上那样，但你本部分的实现中将使用RPC来模拟分布式计算。</p><p><code>mapreduce/master.go</code>中的代码完成了管理MapReduce的大部分工作。 我们还为您提供了<code>mapreduce/worker.go</code>中worker线程的完整代码以及在<code>mapreduce/common_rpc.go</code>中处理RPC的一些代码。</p><p><strong>你的任务是实现<code>mapreduce/schedule.go</code>中的<code>schedule()</code>函数</strong>。 master在MapReduce期间将两次调用<code>schedule()</code>，一次用于Map阶段，一次用于Reduce阶段。 <code>schedule()</code>的功能是将任务分发给可用的worker。 任务的数量通常比worker线程多，因此<code>schedule()</code>必须为每个worker分配一系列任务，一次一个。 <code>schedule()</code>应该等到所有任务都完成后再返回。</p><p><code>schedule()</code>通过读取<code>registerChan</code>参数来了解一组worker。 该channel为每个worker生成一个包含worker的RPC地址的字符串。所有的worker都会出现在registerChan，其中一些worker可能在调用<code>schedule()</code>之前就存在，而另一些worker可能在<code>schedule()</code>运行时才启动。<code>schedule()</code>应该充分利用所有的worker，包括启动后出现的worker。</p><p><code>schedule()</code>通过向worker发送<code>Worker.DoTask</code>RPC来通知worker执行任务。 此RPC的参数由<code>mapreduce/common_rpc.go</code>中的<code>DoTaskArgs</code>定义。<code>File</code>元素仅由Map任务使用，代表要读取的文件的名称；<code>schedule()</code>可以在<code>mapFiles</code>中找到这些文件名。</p><p>使用<code>mapreduce/common_rpc.go</code>中的<code>call()</code>函数将RPC发送给worker。 第一个参数是worker的地址，从<code>registerChan</code>读取，第二个参数是<code>Worker.DoTask</code>， 第三个参数是<code>DoTaskArgs</code>结构，最后一个参数是<code>nil</code>。</p><p>您对在第III部分的解答仅涉及对<code>schedule.go</code>的修改；如果您在调试过程中修改了其他文件，请恢复其原始内容。请先测试再提交。</p><p>使用<code>go test -run TestParallel</code>来测试您的答案。 该命令将执行两个测试，<code>TestParallelBasic</code>和<code>TestParallelCheck</code>，后者验证您的<code>schedule()</code>是否使worker并行执行任务。</p><blockquote><p>提示1：<code>schedule()</code>应该并行地向worker发送RPC，以便worker可以并发执行任务。 你会发现go语句对此很有用，参见<a href="http://golang.org/doc/effective_go.html#concurrency" target="_blank" rel="noopener">Concurrency in Go</a>。提示2：<code>schedule()</code>必须等待worker完成一个任务后才能给它另下一个任务，Go的channel对此很有用。提示3： <a href="https://golang.org/pkg/sync/#WaitGroup" target="_blank" rel="noopener">sync.WaitGroup</a>提示4：追踪错误的最简单的方法是插入print语句（在common.go中可能是调用<code>debug()</code>），使用<code>go test -run TestParallel &gt; out</code>将输出收集到一个文件中，然后分析输出是否与你对代码的预期相符。 最后一步是最重要的。提示5：检查您的代码是否有竞争的情况可在测试中运行<a href="https://golang.org/doc/articles/race_detector.html" target="_blank" rel="noopener">race detector</a>。</p></blockquote><blockquote><p>注意：我们提供的代码是在单个UNIX进程中将worker作为线程运行，并且可以在单台机器上使用多核。 要想在使用网络进行通信的多台机器上运行worker必须进行一些修改：RPC必须使用TCP而不是UNIX-domain套接字；需要有一种方法来启动所有机器上的worker进程；所有的机器都必须通过某种网络文件系统共享存储。</p></blockquote><p><strong>答案</strong>见Part IV。</p><h3><span id="part-iv-worker-cuo-wu-chu-li">Part IV: worker错误处理</span><a href="#part-iv-worker-cuo-wu-chu-li" class="header-anchor">#</a></h3><p>在这部分中，您将实现master处理失败的worker的功能。由于worker的状态不是持久的，该功能在MapReduce中相对容易实现。 如果worker在处理来自master的RPC时发生错误，master的<code>call()</code>最终会因超时而返回<code>false</code>。在这种情况下，master会将该任务重新分配给另一个worker。</p><p>RPC故障并不一定意味着worker没有执行任务；worker可能已执行任务但是返回结果丢失，或者worker可能仍在执行但master的RPC超时。因此，可能会发生两个worker接收相同任务、计算并产生输出的情况。 需要对map或reduce函数进行两次调用才能为给定输入生成相同的输出，因此如果后续处理读取一个输出或者读取另一个输出，则不会出现不一致。 此外，MapReduce框架确保map和reduce函数输出以原子方式出现：输出文件要么不存在，要么包含单个map或单个reduce函数执行的整个输出（提供的代码不涉及这部分）。</p><p>您的实现必须通过<code>test_test.go</code>中剩下的两个测试用例。 第一个用例测试一个worker的失败，而第二个测试用例测试对多个worker的失败的处理。 测试用例会定期启动新的worker，master可以使用这些worker来推进程序过程，但这些worker在处理完一些任务后会失败。 使用下面的命令来运行测试：<code>go test -run Failure</code></p><p>在第IV部分，只涉及对<code>schedule.go</code>的修改。 如果您在调试过程中修改了其他文件，请恢复其原始内容，然后再进行测试、提交。</p><p>Part III、Part IV<strong>答案：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mapreduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// schedule() starts and waits for all tasks in the given phase (mapPhase</span></span><br><span class="line"><span class="comment">// or reducePhase). the mapFiles argument holds the names of the files that</span></span><br><span class="line"><span class="comment">// are the inputs to the map phase, one per map task. nReduce is the</span></span><br><span class="line"><span class="comment">// number of reduce tasks. the registerChan argument yields a stream</span></span><br><span class="line"><span class="comment">// of registered workers; each item is the worker's RPC address,</span></span><br><span class="line"><span class="comment">// suitable for passing to call(). registerChan will yield all</span></span><br><span class="line"><span class="comment">// existing registered workers (if any) and new ones as they register.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span>(<span class="params">jobName <span class="keyword">string</span>, mapFiles []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>, phase jobPhase, registerChan <span class="keyword">chan</span> <span class="keyword">string</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">var</span> ntasks <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> n_other <span class="keyword">int</span> <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line"><span class="keyword">switch</span> phase &#123;</span><br><span class="line"><span class="keyword">case</span> mapPhase:</span><br><span class="line">ntasks = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">n_other = nReduce</span><br><span class="line"><span class="keyword">case</span> reducePhase:</span><br><span class="line">ntasks = nReduce</span><br><span class="line">n_other = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Schedule: %v %v tasks (%d I/Os)\n"</span>, ntasks, phase, n_other)</span><br><span class="line"></span><br><span class="line"><span class="comment">// All ntasks tasks have to be scheduled on workers. Once all tasks</span></span><br><span class="line"><span class="comment">// have completed successfully, schedule() should return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code here (Part III, Part IV).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ntasks; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params">num <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">args := DoTaskArgs&#123;jobName, mapFiles[num], phase, num, n_other&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> worker <span class="keyword">string</span></span><br><span class="line">reply := <span class="built_in">new</span>(<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">ok := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> ok != <span class="literal">true</span> &#123;</span><br><span class="line">worker = &lt;-registerChan</span><br><span class="line">ok = call(worker, <span class="string">"Worker.DoTask"</span>, args, reply)</span><br><span class="line">&#125;</span><br><span class="line">done &lt;- <span class="literal">true</span>           <span class="comment">//任务完成</span></span><br><span class="line">registerChan &lt;- worker <span class="comment">//该worker工作完毕，处于空闲，加入channel中以分配给其它任务</span></span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ntasks; i++ &#123; <span class="comment">//等待所有任务完成</span></span><br><span class="line">&lt;-done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Schedule: %v done\n"</span>, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>go test -run TestParallel</code>的结果： <img src="https://upload-images.jianshu.io/upload_images/1863961-da345dba91fc382f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://hejtao.netlify.com/tags/Golang/"/>
    
      <category term="MapReduce" scheme="https://hejtao.netlify.com/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>远程过程调用和线程(RPC and Thread)</title>
    <link href="https://hejtao.netlify.com/2019/03/25/2019-3-25/"/>
    <id>https://hejtao.netlify.com/2019/03/25/2019-3-25/</id>
    <published>2019-03-24T16:00:00.000Z</published>
    <updated>2019-11-11T19:59:33.204Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><p><a href="http://nil.csail.mit.edu/6.824/2018/schedule.html" target="_blank" rel="noopener">MIT Distributed System Course: Lecture 2</a>Remote Procedure Call (RPC)</p><p><strong>目标</strong>：建立编程友好的客户端/服务器通信</p><p><strong>RPC消息图</strong>：客户端      服务器请求---&gt;                &lt;---响应</p><p><strong>软件结构</strong>：client app             handlers   stubs                   dispatcher   RPC lib               RPC lib       net  ------------ net</p><p><strong>Go rpc包</strong>：<a href="https://golang.org/pkg/net/rpc/" target="_blank" rel="noopener">官方文档</a><code>import &quot;net/rpc</code>rpc包提供对通过网络或其他I / O连接的对象的导出方法的访问。 服务器注册一个对象，并作为一种服务可见。 注册的对象其导出方法可以被远程访问。 服务器可以注册不同类型的多个对象（服务），但是注册相同类型的多个对象是错误的。</p><p>只有满足下列标准的方法（method）才能被远程访问：</p><ul><li>the method's type is exported.</li><li>the method is exported.</li><li>the method has two arguments, both exported (or builtin) types.</li><li>the method's second argument is a pointer.</li><li>the method has return type error.</li></ul><p>实际上，该方法必须看起来像</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">t *T</span>) <span class="title">MethodName</span>(<span class="params">argType T1, replyType *T2</span>) <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>其中<code>T1</code>和<code>T2</code>可以通过 encoding/gob包来编码。即便使用不同的编解码器，上述标准仍然适用。</p><p>第一个参数<code>T1</code>表示调用者提供的参数;第二个参数<code>T2</code>表示要返回给调用者的结果参数。服务器可以通过调用ServeConn来处理单个连接上的请求。更典型的例子有创建网络侦听器并调用Accept，创建HTTP侦听器并调用HandleHTTP和http.Serve。</p><p>希望使用该服务的客户端首先和服务器建立连接，然后在连接的基础上调用NewClient。可以使用Dial函数（DialHTTP）方便地执行原始网络连接（HTTP连接）的两个步骤。新建的客户端对象具备Call方法和Go方法。</p><p>Call方法等待远程调用完成，而Go方法使用Call结构的Done通道启动异步调用和发出完成信号。</p><p>除非设置了显式编解码器，否则一般使用encoding/gob包来传输数据。</p><p>一个服务器导出Arith类型的对象的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> server</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"errors"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">A, B <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Quotient <span class="keyword">struct</span> &#123;</span><br><span class="line">Quo, Rem <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Arith <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">t *Arith</span>) <span class="title">Multiply</span>(<span class="params">args *Args, reply *<span class="keyword">int</span></span>) <span class="title">error</span></span> &#123;</span><br><span class="line">*reply = args.A * args.B</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">t *Arith</span>) <span class="title">Divide</span>(<span class="params">args *Args, quo *Quotient</span>) <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> args.B == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"divide by zero"</span>)</span><br><span class="line">&#125;</span><br><span class="line">quo.Quo = args.A / args.B</span><br><span class="line">quo.Rem = args.A % args.B</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端调用 HTTP service：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">arith := <span class="built_in">new</span>(Arith)</span><br><span class="line">rpc.Register(arith)</span><br><span class="line">rpc.HandleHTTP()</span><br><span class="line">l, e := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1234"</span>)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"listen error:"</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> http.Serve(l, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>现在，客户端拥有了一项服务Arith，该服务提供了Arith.Multiply和Arith.Divide方法。要调用这些方法，客户端得先拨通服务器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client, err := rpc.DialHTTP(<span class="string">"tcp"</span>, serverAddress + <span class="string">":1234"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"dialing:"</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进行远程调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Synchronous call</span></span><br><span class="line">args := &amp;server.Args&#123;<span class="number">7</span>,<span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">var</span> reply <span class="keyword">int</span></span><br><span class="line">err = client.Call(<span class="string">"Arith.Multiply"</span>, args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"arith error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Arith: %d*%d=%d"</span>, args.A, args.B, reply)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Asynchronous call</span></span><br><span class="line">quotient := <span class="built_in">new</span>(Quotient)</span><br><span class="line">divCall := client.Go(<span class="string">"Arith.Divide"</span>, args, quotient, <span class="literal">nil</span>)</span><br><span class="line">replyCall := &lt;-divCall.Done<span class="comment">// will be equal to divCall</span></span><br><span class="line"><span class="comment">// check errors, print, etc.</span></span><br></pre></td></tr></table></figure><p>服务器通常会为客户端提供一个简单的、类型安全的封装。net/rpc包已冻结，不会增加新的功能属性。</p><p><strong>Go举例</strong>：一个简单的key/value存储服务器——Put(key,value), Get(key)-&gt;value</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"net/rpc"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// RPC request/reply definitions</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">OK       = <span class="string">"OK"</span></span><br><span class="line">ErrNoKey = <span class="string">"ErrNoKey"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Err <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PutArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Key   <span class="keyword">string</span></span><br><span class="line">Value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PutReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Err Err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">Key <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> GetReply <span class="keyword">struct</span> &#123;</span><br><span class="line">Err   Err</span><br><span class="line">Value <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Client</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span>(<span class="params"></span>) *<span class="title">rpc</span>.<span class="title">Client</span></span> &#123;</span><br><span class="line">client, err := rpc.Dial(<span class="string">"tcp"</span>, <span class="string">":1234"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"dialing:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span>(<span class="params">key <span class="keyword">string</span></span>) <span class="title">string</span></span> &#123;</span><br><span class="line">client := connect()</span><br><span class="line">args := GetArgs&#123;Key: key&#125;</span><br><span class="line">reply := GetReply&#123;&#125;</span><br><span class="line">err := client.Call(<span class="string">"KV.Get"</span>, &amp;args, &amp;reply) <span class="comment">//远程调用KV.Get，等待它完成，并返回其错误状态。</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">client.Close()</span><br><span class="line"></span><br><span class="line">log.Println(reply.Err)</span><br><span class="line"><span class="keyword">return</span> reply.Value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">put</span>(<span class="params">key <span class="keyword">string</span>, val <span class="keyword">string</span></span>)</span> &#123;</span><br><span class="line">client := connect()</span><br><span class="line">args := PutArgs&#123;Key: key, Value: val&#125;</span><br><span class="line">reply := PutReply&#123;&#125;</span><br><span class="line">err := client.Call(<span class="string">"KV.Put"</span>, &amp;args, &amp;reply) <span class="comment">//远程调用KV.Put</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"error:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">client.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Server</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> KV <span class="keyword">struct</span> &#123;</span><br><span class="line">mu   sync.Mutex</span><br><span class="line">data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">kv := <span class="built_in">new</span>(KV)</span><br><span class="line">kv.data = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">rpcs := rpc.NewServer()</span><br><span class="line">rpcs.Register(kv)</span><br><span class="line"></span><br><span class="line">l, e := net.Listen(<span class="string">"tcp"</span>, <span class="string">":1234"</span>)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"listen error:"</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := l.Accept()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">go</span> rpcs.ServeConn(conn)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">l.Close()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">kv *KV</span>) <span class="title">Get</span>(<span class="params">args *GetArgs, reply *GetReply</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">kv.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">val, ok := kv.data[args.Key]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">reply.Err = OK</span><br><span class="line">reply.Value = val</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reply.Err = ErrNoKey</span><br><span class="line">reply.Value = <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">kv *KV</span>) <span class="title">Put</span>(<span class="params">args *PutArgs, reply *PutReply</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">kv.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> kv.mu.Unlock()</span><br><span class="line"></span><br><span class="line">kv.data[args.Key] = args.Value</span><br><span class="line">reply.Err = OK</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">server()</span><br><span class="line"></span><br><span class="line">put(<span class="string">"passwd"</span>, <span class="string">"2w6C*kcXWWmzK$Jg"</span>) <span class="comment">//客户端存储密码</span></span><br><span class="line">fmt.Println(get(<span class="string">"passwd"</span>))        <span class="comment">//客户端获取密码</span></span><br><span class="line">&#125;</span><br><span class="line">command-line-arguments</span><br><span class="line"><span class="number">2019</span>/<span class="number">04</span>/<span class="number">02</span> <span class="number">18</span>:<span class="number">34</span>:<span class="number">11</span> OK</span><br><span class="line"><span class="number">2</span>w6C*kcXWWmzK$Jg</span><br></pre></td></tr></table></figure><ul><li><p>共同：必须为每种RPC类型声明Args和Reply结构</p></li><li><p>Client:connect()的Dial()创建与服务器的TCP连接Call()要求RPC库执行远程调用指定server function name, args,replylibrary marshalls args, sends request, waits, unmarshally replyCall()的返回值表示是否收到回复usually you'll also have a reply.Err indicating service-level failure</p></li><li><p>server：Go要求您声明一个带有方法的对象作为RPC处理程序(RPC handler)然后，您使用RPC库注册该对象您接受TCP连接，并给它们提供RPC库</p><ul><li>RPC库读取每个请求为此请求创建一个新的goroutineunmarshalls request调用命名方法（调度）marshalls reply在TCP连接上写回复</li><li>服务器的Get()和Put()处理程序必须锁定，因为RPC库给每个请求创建goroutines解读args; 修改reply</li></ul></li></ul><hr><p><strong>线程</strong>:线程是一种有用的结构化工具Go称他们为goroutines;其他人称他们为线程他们可能很棘手</p><p><strong>Why threads?</strong>用它们实现并发，在分布式系统中自然地出现</p><ul><li>I / O并发：在等待来自其他服务器的响应时，处理下一个请求</li><li>多核：线程在多个核心上并行运行</li></ul><p><strong>Thread =“执行线程”</strong>线程允许一个程序（逻辑上）一次执行许多事情线程共享内存each thread includes some per-thread state，包括：程序计数器，寄存器，堆栈</p><p><strong>程序中有多少个线程？</strong></p><ul><li>由结构驱动例如每个客户端一个线程，一个用于后台任务</li><li>多核并行one active thread per core。Go的 runtime 自动地在可用内核上调度可运行的goroutine</li><li>I / O并发数量由延迟和容量决定继续增加直到吞吐量停止增长</li><li>Go threads are pretty cheap100或1000是好的，但可能达不到数百万的量级创建线程比方法调用更昂贵</li></ul><p><strong>Threading challenges：</strong></p><ul><li>共享数据一个线程读取另一个线程正在改变的数据？例如当两个线程执行count = count + 1时，this is a &quot;race&quot; -- and is usually a bug——使用互斥锁（或其他同步）——或避免共享</li><li>线程之间的协调如何等待所有Map线程完成？——使用Go channel或WaitGroup</li><li>并发的粒度粗粒度(coarse-grained)  —— 简单，但并发/并行很少细粒度  —— 更多的并发、竞争(race)和死锁</li></ul><p><strong>什么是爬虫？</strong>目标是获取所有网页，例如提供给索引器(indexer)网页形成一个图(graph)每个页面的多个链接graph has cycles</p><p><strong>Crawler challenges</strong></p><ul><li>安排I / O并发同时获取多个URL增加每秒获取的URL由于网络延迟远远超过网络容量</li><li>Fetch each URL only once避免浪费网络带宽对远程服务器很好需要记住访问过的URL</li><li>知道什么时候完成</li></ul><p><strong>Crawler solutions：</strong></p><ul><li>串行爬虫：fetched map 避免重复、进入死循环它是一个单一的映射，通过递归调用传递一次只能爬取一页</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span> &#123;</span><br><span class="line">Fetch(url <span class="keyword">string</span>) (urls []<span class="keyword">string</span>, err error) <span class="comment">//由一个URL返回多个URL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeResult <span class="keyword">struct</span> &#123;</span><br><span class="line">body <span class="keyword">string</span></span><br><span class="line">urls []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeFetcher <span class="keyword">map</span>[<span class="keyword">string</span>]*fakeResult</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">f fakeFetcher</span>) <span class="title">Fetch</span>(<span class="params">url <span class="keyword">string</span></span>) (<span class="params">[]<span class="keyword">string</span>, error</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> res, ok := f[url]; ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"found:   %s\n"</span>, url)</span><br><span class="line"><span class="keyword">return</span> res.urls, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"missing: %s\n"</span>, url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"not found: %s"</span>, url) <span class="comment">//打印字符串错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fetcher = fakeFetcher&#123; </span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"The Go Programming Language"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/cmd/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Packages"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/cmd/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/fmt/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/os/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/pkg/fmt/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Package fmt"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/pkg/os/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Package os"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 串行爬虫</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Serial</span>(<span class="params">url <span class="keyword">string</span>, fetcher Fetcher, fetched <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> fetched[url] &#123; <span class="comment">// 已经爬取</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetched[url] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">urls, err := fetcher.Fetch(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">Serial(u, fetcher, fetched)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">Serial(<span class="string">"http://golang.org/"</span>, fetcher, <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ConcurrentMutex爬虫：<ul><li>为每个页面的爬取创建一个线程，因此可以并发爬取，爬取率更高</li><li>线程共享 fetched map</li><li>Why the Mutex (== lock)?<ol><li>没有锁：两个网页包含指向同一URL的链接，导致两个线程同时获取这这个页面T1、T2检查获取[url]，当两者都看到url尚未获取，两者都取，导致错误</li><li>同时读写（或写入+写入）是竞争</li><li>如果我注释掉Lock()/Unlock()调用会发生什么？go run crawler.gogo run -race crawler.goThe lock causes the check and update to be atomic</li></ol></li><li>How does it decide it is done?sync.WaitGroupimplicitly waits for children to finish recursive fetches</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span> &#123;</span><br><span class="line">Fetch(url <span class="keyword">string</span>) (urls []<span class="keyword">string</span>, err error) <span class="comment">//由一个URL返回多个URL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeResult <span class="keyword">struct</span> &#123;</span><br><span class="line">body <span class="keyword">string</span></span><br><span class="line">urls []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeFetcher <span class="keyword">map</span>[<span class="keyword">string</span>]*fakeResult</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">f fakeFetcher</span>) <span class="title">Fetch</span>(<span class="params">url <span class="keyword">string</span></span>) (<span class="params">[]<span class="keyword">string</span>, error</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> res, ok := f[url]; ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"found:   %s\n"</span>, url)</span><br><span class="line"><span class="keyword">return</span> res.urls, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"missing: %s\n"</span>, url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"not found: %s"</span>, url) <span class="comment">//打印字符串错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fetcher = fakeFetcher&#123;</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"The Go Programming Language"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/cmd/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Packages"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/cmd/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/fmt/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/os/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/pkg/fmt/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Package fmt"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/pkg/os/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Package os"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concurrent crawler with shared state and Mutex</span></span><br><span class="line"><span class="keyword">type</span> fetchState <span class="keyword">struct</span> &#123;</span><br><span class="line">mu      sync.Mutex</span><br><span class="line">fetched <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeState</span>(<span class="params"></span>) *<span class="title">fetchState</span></span> &#123;</span><br><span class="line">f := &amp;fetchState&#123;&#125;</span><br><span class="line">f.fetched = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"><span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentMutex</span>(<span class="params">url <span class="keyword">string</span>, fetcher Fetcher, f *fetchState</span>)</span> &#123;</span><br><span class="line">f.mu.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> f.fetched[url] &#123; <span class="comment">// 已经爬取</span></span><br><span class="line">f.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.fetched[url] = <span class="literal">true</span></span><br><span class="line">f.mu.Unlock()</span><br><span class="line"></span><br><span class="line">urls, err := fetcher.Fetch(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> done sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line">done.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params">u <span class="keyword">string</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> done.Done() <span class="comment">//等价于defer done.Add(-1)</span></span><br><span class="line">ConcurrentMutex(u, fetcher, f)</span><br><span class="line">&#125;(u)</span><br><span class="line">&#125;</span><br><span class="line">done.Wait() <span class="comment">//等待所有的goroutine完成</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">ConcurrentMutex(<span class="string">"http://golang.org/"</span>, fetcher, makeState())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ConcurrentChannel爬虫<ul><li>Go channel：channel是一个对象,可能有很多个, ch：= make（chan int）channel允许一个线程将对象发送到另一个线程：<code>ch &lt; - x</code>，sender等待goroutine接收<code>y：= &lt; - ch; for y := range ch</code>，receiver等待goroutine发送可以用channel来进行通信和同步多个线程可以在一个channel上发送和接收在发送时握住锁可能很危险...</li><li>ConcurrentChannel master（）master()创建一个worker goroutine来获取每个页面worker()在channel上发送URL多个worker在一个channel上发送master()从channel中读取URL[图：主人，通道，工人]</li><li>无需锁定 fetched map，因为它不是共享的！</li><li>有共享数据吗？channel通道上发送的切片和字符串master()传递给worker()的参数</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span> &#123;</span><br><span class="line">Fetch(url <span class="keyword">string</span>) (urls []<span class="keyword">string</span>, err error) <span class="comment">//由一个URL返回多个URL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeResult <span class="keyword">struct</span> &#123;</span><br><span class="line">body <span class="keyword">string</span></span><br><span class="line">urls []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeFetcher <span class="keyword">map</span>[<span class="keyword">string</span>]*fakeResult</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">f fakeFetcher</span>) <span class="title">Fetch</span>(<span class="params">url <span class="keyword">string</span></span>) (<span class="params">[]<span class="keyword">string</span>, error</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> res, ok := f[url]; ok &#123;</span><br><span class="line">fmt.Printf(<span class="string">"found:   %s\n"</span>, url)</span><br><span class="line"><span class="keyword">return</span> res.urls, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"missing: %s\n"</span>, url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"not found: %s"</span>, url) <span class="comment">//打印字符串错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fetcher = fakeFetcher&#123;</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"The Go Programming Language"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/cmd/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Packages"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/cmd/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/fmt/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/os/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/pkg/fmt/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Package fmt"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="string">"http://golang.org/pkg/os/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Package os"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"http://golang.org/"</span>,</span><br><span class="line"><span class="string">"http://golang.org/pkg/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Concurrent crawler with channels</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span>(<span class="params">url <span class="keyword">string</span>, ch <span class="keyword">chan</span> []<span class="keyword">string</span>, fetcher Fetcher</span>)</span> &#123;</span><br><span class="line">urls, err := fetcher.Fetch(url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ch &lt;- []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ch &lt;- urls</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">master</span>(<span class="params">ch <span class="keyword">chan</span> []<span class="keyword">string</span>, fetcher Fetcher</span>)</span> &#123;</span><br><span class="line">n := <span class="number">1</span></span><br><span class="line">fetched := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> urls := <span class="keyword">range</span> ch &#123;</span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> urls &#123;</span><br><span class="line"><span class="keyword">if</span> fetched[u] == <span class="literal">false</span> &#123;</span><br><span class="line">fetched[u] = <span class="literal">true</span></span><br><span class="line">n += <span class="number">1</span></span><br><span class="line"><span class="keyword">go</span> worker(u, ch, fetcher)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentChannel</span>(<span class="params">url <span class="keyword">string</span>, fetcher Fetcher</span>)</span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> []<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">ch &lt;- []<span class="keyword">string</span>&#123;url&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">master(ch, fetcher)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">ConcurrentChannel(<span class="string">"http://golang.org/"</span>, fetcher)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>**什么时候使用sharing和locks，而不是channels？** - 大多数问题都可以用任何一种方式解决 - 最有意义的取决于程序员的想法    state(状态) -- sharing and locks    communication -- channels    waiting for events -- channels - 使用Go的竞争检测器：    [Data Race Detector](https://golang.org/doc/articles/race_detector.html)    go test -race]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://hejtao.netlify.com/tags/Golang/"/>
    
      <category term="RPC" scheme="https://hejtao.netlify.com/tags/RPC/"/>
    
      <category term="并发" scheme="https://hejtao.netlify.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Go并发模式 (Cocurrency Pattern)</title>
    <link href="https://hejtao.netlify.com/2019/02/10/2019-2-10/"/>
    <id>https://hejtao.netlify.com/2019/02/10/2019-2-10/</id>
    <published>2019-02-09T16:00:00.000Z</published>
    <updated>2019-11-11T19:59:33.203Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><p>这篇博客的原创来自Go的<a href="https://blog.golang.org/advanced-go-concurrency-patterns" target="_blank" rel="noopener">官方博客</a>，其中提供了丰富的关于Go的并发的相关资料。本文仅仅是对 Rob Pike 的演讲 Go Concurrency Patterns 和 Sameer Ajmani 的续集  Advanced Go Concurrency Patterns 的学习，相关内容的视频和ppt在网上都可以找到。</p><h4><span id="1-han-shu-fan-hui-channel">1. 函数返回 channel</span><a href="#1-han-shu-fan-hui-channel" class="header-anchor">#</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boring</span>(<span class="params">msg <span class="keyword">string</span></span>) &lt;-<span class="title">chan</span> <span class="title">string</span></span> &#123; <span class="comment">// 返回字符串通道，仅接收</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">c &lt;- fmt.Sprintf(<span class="string">"%s %d"</span>, msg, i)</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">3e3</span>)) * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">c := boring(<span class="string">"boring!"</span>) <span class="comment">// 通道作为返回的函数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"You say: %q\n"</span>, &lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"You're boring; I'm leaving."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">You say: <span class="string">"boring! 0"</span></span><br><span class="line">You say: <span class="string">"boring! 1"</span></span><br><span class="line">You say: <span class="string">"boring! 2"</span></span><br><span class="line">You say: <span class="string">"boring! 3"</span></span><br><span class="line">You say: <span class="string">"boring! 4"</span></span><br><span class="line">You<span class="string">'re boring; I'</span>m leaving.</span><br></pre></td></tr></table></figure><h4><span id="2-tong-dao-zuo-wei-fu-wu">2. 通道作为服务</span><a href="#2-tong-dao-zuo-wei-fu-wu" class="header-anchor">#</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">joe := boring(<span class="string">"Joe"</span>)</span><br><span class="line">ann := boring(<span class="string">"Ann"</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">fmt.Println(&lt;-joe)</span><br><span class="line">fmt.Println(&lt;-ann)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"You're both boring; I'm leaving."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Joe <span class="number">0</span></span><br><span class="line">Ann <span class="number">0</span></span><br><span class="line">Joe <span class="number">1</span></span><br><span class="line">Ann <span class="number">1</span></span><br><span class="line">Joe <span class="number">2</span></span><br><span class="line">Ann <span class="number">2</span></span><br><span class="line">Joe <span class="number">3</span></span><br><span class="line">Ann <span class="number">3</span></span><br><span class="line">Joe <span class="number">4</span></span><br><span class="line">Ann <span class="number">4</span></span><br><span class="line">You<span class="string">'re both boring; I'</span>m leaving.</span><br></pre></td></tr></table></figure><h4><span id="3-duo-chong-tong-dao-shan-ru-han-shu-fan-in-function">3.多重通道(扇入函数，fan-in function)</span><a href="#3-duo-chong-tong-dao-shan-ru-han-shu-fan-in-function" class="header-anchor">#</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boring</span>(<span class="params">msg <span class="keyword">string</span></span>) &lt;-<span class="title">chan</span> <span class="title">string</span></span> &#123; <span class="comment">// 返回字符串通道，仅接收</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">c &lt;- fmt.Sprintf(<span class="string">"%s %d"</span>, msg, i)</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">1e3</span>)) * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span>(<span class="params">input1, input2 &lt;-<span class="keyword">chan</span> <span class="keyword">string</span></span>) &lt;-<span class="title">chan</span> <span class="title">string</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">c &lt;- &lt;-input1</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">c &lt;- &lt;-input2</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">c := fanIn(boring(<span class="string">"Joe"</span>), boring(<span class="string">"Ann"</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"You're both boring; I'm leaving."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1863961-e259e9b8d2d6bbe2.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><h4><span id="4-tong-dao-fa-song-tong-dao-shi-goroutine-you-xu">4. 通道发送通道，使 goroutine 有序</span><a href="#4-tong-dao-fa-song-tong-dao-shi-goroutine-you-xu" class="header-anchor">#</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Message <span class="keyword">struct</span> &#123;</span><br><span class="line">str  <span class="keyword">string</span></span><br><span class="line">wait <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boring</span>(<span class="params">msg <span class="keyword">string</span></span>) <span class="title">chan</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> Message)</span><br><span class="line">waitForIt := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>) <span class="comment">// 被所有 Message 共享</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">c &lt;- Message&#123;fmt.Sprintf(<span class="string">"%s: %d"</span>, msg, i), waitForIt&#125;</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">1e3</span>)) * time.Millisecond)</span><br><span class="line">&lt;-waitForIt  <span class="comment">// 进入等待</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span>(<span class="params">input1, input2 <span class="keyword">chan</span> Message</span>) <span class="title">chan</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> Message)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">c &lt;- &lt;-input1</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">c &lt;- &lt;-input2</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">c := fanIn(boring(<span class="string">"Joe"</span>), boring(<span class="string">"Ann"</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">msg1 := &lt;-c</span><br><span class="line">fmt.Println(msg1.str)</span><br><span class="line">msg2 := &lt;-c</span><br><span class="line">fmt.Println(msg2.str)  <span class="comment">// 当 Joe 和 Ann 的信息都收到后，才开放下一次消息接收</span></span><br><span class="line">msg1.wait &lt;- <span class="literal">true</span></span><br><span class="line">msg2.wait &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="5-select-yu-ju">5. select 语句</span><a href="#5-select-yu-ju" class="header-anchor">#</a></h4><p>使用 select 来写扇入函数，减少 goroutine 数量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span>(<span class="params">input1, input2 &lt;-<span class="keyword">chan</span> <span class="keyword">string</span></span>) &lt;-<span class="title">chan</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> s := &lt;-input1:  c &lt;- s</span><br><span class="line">            <span class="keyword">case</span> s := &lt;-input2:  c &lt;- s</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select设置超时</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boring</span>(<span class="params">msg <span class="keyword">string</span></span>) &lt;-<span class="title">chan</span> <span class="title">string</span></span> &#123; <span class="comment">// 返回字符串通道，仅接收</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; ; i++ &#123;</span><br><span class="line">c &lt;- fmt.Sprintf(<span class="string">"%s %d"</span>, msg, i)</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">1500</span>)) * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">c := boring(<span class="string">"Joe"</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s := &lt;-c:</span><br><span class="line">fmt.Println(s)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">fmt.Println(<span class="string">"You're too slow."</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">Joe <span class="number">0</span></span><br><span class="line">Joe <span class="number">1</span></span><br><span class="line">Joe <span class="number">2</span></span><br><span class="line">Joe <span class="number">3</span></span><br><span class="line">Joe <span class="number">4</span></span><br><span class="line">You<span class="string">'re too slow.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://hejtao.netlify.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>MySQL驱动</title>
    <link href="https://hejtao.netlify.com/2018/12/31/2018-12-31/"/>
    <id>https://hejtao.netlify.com/2018/12/31/2018-12-31/</id>
    <published>2018-12-30T16:00:00.000Z</published>
    <updated>2019-12-13T03:54:47.577Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><div class="toc"><!-- toc --><ul><li><a href="#qi-dong-yi-mi-ma-deng-ru-he-chuang-jian-shu-ju-ku">启动、以密码登入和创建数据库</a><ul><li><a href="#windows">windows:</a></li><li><a href="#ubuntu">ubuntu:</a></li></ul></li><li><a href="#bian-xie-go-wen-jian">编写Go文件</a></li></ul><!-- tocstop --></div><p>MySQL基础见<a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>;本文参考了<a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/05.2.md" target="_blank" rel="noopener">astaxie/build-web-application-with-golang</a>.</p><h3><span id="qi-dong-yi-mi-ma-deng-ru-he-chuang-jian-shu-ju-ku">启动、以密码登入和创建数据库</span><a href="#qi-dong-yi-mi-ma-deng-ru-he-chuang-jian-shu-ju-ku" class="header-anchor">#</a></h3><h4><span id="windows">windows:</span><a href="#windows" class="header-anchor">#</a></h4><p>在bin目录下，运行(git-bash以管理员运行，加winpty)</p><p><code>mysqld --remove</code> 删除之前的mysql服务</p><p><code>mysqld -install mysql</code> 安装windows服务，服务名称为mysql(任意取)</p><p><code>mysqld --initialize-insecure</code> 可无密码登陆root</p><p><code>net start mysql</code> 启动服务(关闭的命令是 <code>net stop mysql</code>)</p><h4><span id="ubuntu">ubuntu:</span><a href="#ubuntu" class="header-anchor">#</a></h4><p><code>service mysql start</code>　启动服务</p><p><code>service mysql stop</code>　关闭服务</p><p><code>service restart stop</code>　重启服务</p><p><code>ps -ef | grep mysqld</code>   查看mysql进程列表</p><p>执行如下SQL语句以密码登入</p><p><code>ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';</code></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-b53852355153eddc.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/740" alt=""></p><p>或者编写 test.sql 创建</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-279c6b518995b5ab.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/740" alt=""></p><p>source test.sql 文件</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-89f3de8a8ea85d68.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/740" alt=""></p><h3><span id="bian-xie-go-wen-jian">编写Go文件</span><a href="#bian-xie-go-wen-jian" class="header-anchor">#</a></h3><p>test.go 内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">"github.com/go-sql-driver/mysql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"root:123456@/test"</span>) <span class="comment">//Linux用户名:MySQL密码@/数据库名test</span></span><br><span class="line">checkErr(err)</span><br><span class="line">stm, err := db.Prepare(<span class="string">"DROP TABLE IF EXISTS userinfo;"</span>) <span class="comment">//准备SQL语句，删除数据表</span></span><br><span class="line">checkErr(err)</span><br><span class="line">_, err = stm.Exec() <span class="comment">//Excute, 执行语句</span></span><br><span class="line">checkErr(err)</span><br><span class="line">stm, err = db.Prepare(<span class="string">`CREATE TABLE userinfo (</span></span><br><span class="line"><span class="string">                                uid INT(10) NOT NULL AUTO_INCREMENT,</span></span><br><span class="line"><span class="string">                                name VARCHAR(64) NOT NULL DEFAULT '匿名',</span></span><br><span class="line"><span class="string">                                city VARCHAR(64) NULL DEFAULT '不详',</span></span><br><span class="line"><span class="string">                                moment DATE NOT NULL DEFAULT '1949-10-10',</span></span><br><span class="line"><span class="string">                                PRIMARY KEY (uid)</span></span><br><span class="line"><span class="string">                            ) DEFAULT CHARSET=utf8;`</span>) <span class="comment">//创建数据表，设置utf8以支持中文字符</span></span><br><span class="line">checkErr(err)</span><br><span class="line">_, err = stm.Exec()</span><br><span class="line">checkErr(err)</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加数据</span></span><br><span class="line">stm, err = db.Prepare(<span class="string">"INSERT userinfo SET name=?, city=?, moment=?"</span>) <span class="comment">//准备SQL语句</span></span><br><span class="line">checkErr(err)</span><br><span class="line">_, err = stm.Exec(<span class="string">"诸葛亮"</span>, <span class="string">"山东临沂"</span>, <span class="string">"234-10-8"</span>) <span class="comment">//Excute, 传入参数并执行</span></span><br><span class="line">checkErr(err)</span><br><span class="line">_, err = stm.Exec(<span class="string">"关羽"</span>, <span class="string">"山西运城"</span>, <span class="string">"220-1-1"</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">_, err = stm.Exec(<span class="string">"荀彧"</span>, <span class="string">"河南许昌"</span>, <span class="string">"212-1-1"</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line"></span><br><span class="line">stm, err = db.Prepare(<span class="string">"INSERT userinfo SET city=?"</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">res, err := stm.Exec(<span class="string">"河南禹州"</span>)</span><br><span class="line">id, err := res.LastInsertId()</span><br><span class="line">checkErr(err)</span><br><span class="line">fmt.Println(<span class="string">"最后插入的用户序号为:"</span>, id)</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询数据</span></span><br><span class="line">rows, err := db.Query(<span class="string">"SELECT * FROM userinfo"</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">fmt.Println(<span class="string">"打印数据表的每行信息:"</span>)</span><br><span class="line">fmt.Println(<span class="string">"---------------------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="keyword">var</span> uid <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> city <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> moment <span class="keyword">string</span></span><br><span class="line">err = rows.Scan(&amp;uid, &amp;name, &amp;city, &amp;moment)</span><br><span class="line">checkErr(err)</span><br><span class="line"></span><br><span class="line">fmt.Print(uid, <span class="string">" "</span>)</span><br><span class="line">fmt.Print(name, <span class="string">" "</span>)</span><br><span class="line">fmt.Print(city, <span class="string">" "</span>)</span><br><span class="line">fmt.Println(moment)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除数据</span></span><br><span class="line">stm, err = db.Prepare(<span class="string">"DELETE FROM userinfo WHERE uid=?"</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">res, err = stm.Exec(<span class="number">2</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">fmt.Println(<span class="string">"删除了第2行"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//更改数据</span></span><br><span class="line">stm, err = db.Prepare(<span class="string">"UPDATE userinfo SET name=? WHERE uid=? OR uid=?"</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">res, err = stm.Exec(<span class="string">"郭嘉"</span>, id<span class="number">-1</span>, id)</span><br><span class="line">checkErr(err)</span><br><span class="line">affect, err := res.RowsAffected()</span><br><span class="line">checkErr(err)</span><br><span class="line">fmt.Println(<span class="string">"总共有"</span>, affect, <span class="string">"行的信息发生了更改"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询数据</span></span><br><span class="line">rows, err = db.Query(<span class="string">"SELECT * FROM userinfo"</span>)</span><br><span class="line">checkErr(err)</span><br><span class="line">fmt.Println(<span class="string">"打印数据表的每行信息:"</span>)</span><br><span class="line">fmt.Println(<span class="string">"---------------------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line"><span class="keyword">var</span> uid <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> city <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> moment <span class="keyword">string</span></span><br><span class="line">err = rows.Scan(&amp;uid, &amp;name, &amp;city, &amp;moment)</span><br><span class="line">checkErr(err)</span><br><span class="line"></span><br><span class="line">fmt.Print(uid, <span class="string">" "</span>)</span><br><span class="line">fmt.Print(name, <span class="string">" "</span>)</span><br><span class="line">fmt.Print(city, <span class="string">" "</span>)</span><br><span class="line">fmt.Println(moment)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkErr</span>(<span class="params">err error</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-ab78626ef24500f9.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/740" alt=""></p><p>进入MySQL查看数据表：</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-135e838917e196c5.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/740" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://hejtao.netlify.com/tags/Golang/"/>
    
      <category term="MySQL" scheme="https://hejtao.netlify.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>大话数据结构</title>
    <link href="https://hejtao.netlify.com/2018/12/20/2018-12-20/"/>
    <id>https://hejtao.netlify.com/2018/12/20/2018-12-20/</id>
    <published>2018-12-20T15:04:00.000Z</published>
    <updated>2019-11-11T19:59:33.200Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><div class="toc"><!-- toc --><ul><li><a href="#3-4-shun-xu-cun-chu-jie-gou">3.4 顺序存储结构</a></li><li><a href="#3-6-lian-shi-cun-chu-jie-gou">3.6 链式存储结构</a></li><li><a href="#3-11-dan-lian-biao-jie-gou-yu-shun-xu-cun-chu-jie-gou">3.11 单链表结构与顺序存储结构</a></li><li><a href="#3-12-jing-tai-lian-biao">3.12 静态链表</a></li><li><a href="#3-13-xun-huan-lian-biao">3.13 循环链表</a></li><li><a href="#3-14-shuang-xiang-lian-biao">3.14 双向链表</a></li><li><a href="#4-2-zhan">4.2 栈</a></li><li><a href="#4-10-dui-lie">4.10 队列</a></li><li><a href="#4-12-xun-huan-dui-lie">4.12 循环队列</a></li><li><a href="#6-4-shu-de-cun-chu-jie-gou">6.4 树的存储结构</a><ul><li><a href="#6-5-2-te-shu-er-cha-shu">6.5.2 特殊二叉树</a></li></ul></li><li><a href="#6-6-er-cha-shu-xing-zhi">6.6 二叉树性质</a></li><li><a href="#6-8-bian-li-er-cha-shu">6.8 遍历二叉树</a></li><li><a href="#6-8-6-tui-dao-bian-li-jie-guo">6.8.6 推导遍历结果</a></li><li><a href="#6-10-xian-suo-er-cha-shu">6.10 线索二叉树</a><ul><li><a href="#6-11-1-shu-zhuan-huan-wei-er-cha-shu">6.11.1 树转换为二叉树</a></li></ul></li><li><a href="#6-12-he-fu-man-shu">6.12 <strong>赫夫曼树</strong></a><ul><li><a href="#7-4-1-lin-jie-ju-zhen-adjacency-matrix">7.4.1 <strong>邻接矩阵</strong>(adjacency matrix)</a></li><li><a href="#7-4-2-lin-jie-biao">7.4.2 <strong>邻接表</strong></a></li><li><a href="#7-5-1-shen-du-you-xian-bian-li-depth-first-search">7.5.1 <strong>深度优先遍历</strong>(Depth First Search)</a></li><li><a href="#7-5-2-guang-du-you-xian-bian-li-breadth-first-search">7.5.2 <strong>广度优先遍历</strong>(Breadth First Search)</a></li><li><a href="#8-4-1-er-fen-cha-zhao">8.4.1 二分查找</a></li></ul></li><li><a href="#8-6-er-cha-cha-zhao-shu-binary-sort-tree">8.6 二叉查找树(Binary Sort Tree)</a><ul><li><a href="#8-6-2-er-cha-cha-zhao-shu-cha-ru">8.6.2 二叉查找树插入</a></li><li><a href="#8-6-3-er-cha-cha-zhao-shu-shan-chu">8.6.3 二叉查找树删除</a></li></ul></li><li><a href="#8-7-ping-heng-er-cha-shu-avl-shu">8.7 平衡二叉树(AVL树)</a><ul><li><a href="#9-2-1-pai-xu-de-wen-ding-xing">9.2.1 排序的稳定性</a></li><li><a href="#9-2-2-nei-pai-xu-he-wai-pai-xu">9.2.2 内排序和外排序</a></li><li><a href="#9-3-2-mou-pao-pai-xu-suan-fa-bubble-sort">9.3.2 冒泡排序算法(Bubble Sort)</a></li><li><a href="#9-3-3-mou-pao-pai-xu-you-hua">9.3.3 冒泡排序优化</a></li></ul></li></ul><ul><li><a href="#9-4-1-jian-dan-xuan-ze-pai-xu-simple-selection-sort">9.4.1 简单选择排序(Simple Selection Sort)</a><ul><li><a href="#9-5-1-zhi-jie-cha-ru-pai-xu-straight-insertion-sort">9.5.1 直接插入排序(Straight Insertion Sort)</a></li></ul><ul><li><a href="#9-6-xi-er-pai-xu-shell-sort">9.6 希尔排序(Shell Sort)</a></li><li><a href="#9-7-dui-pai-xu">9.7 堆排序</a></li><li><a href="#9-8-gui-bing-pai-xu">9.8 归并排序</a></li><li><a href="#9-9-kuai-su-pai-xu">9.9 快速排序</a></li></ul></li></ul><!-- tocstop --></div><h4><span id="3-4-shun-xu-cun-chu-jie-gou">3.4 顺序存储结构</span><a href="#3-4-shun-xu-cun-chu-jie-gou" class="header-anchor">#</a></h4><p>数值data(起始位置)；数组长度MaxSize；线性表长度lengthLOC($a_{i}$)=LOC($a_{1}$)+(i-1)c</p><h4><span id="3-6-lian-shi-cun-chu-jie-gou">3.6 链式存储结构</span><a href="#3-6-lian-shi-cun-chu-jie-gou" class="header-anchor">#</a></h4><p><strong>单链表</strong>，每个节点只包含一个指针域头指针，头节点，第一个节点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">data <span class="keyword">string</span></span><br><span class="line">next *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LinkList <span class="keyword">struct</span> &#123;</span><br><span class="line">length <span class="keyword">int</span></span><br><span class="line">head   *Node</span><br><span class="line">rear   *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLinkList</span>(<span class="params">head *Node</span>) *<span class="title">LinkList</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;LinkList&#123;<span class="number">0</span>, head, head&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *LinkList</span>) <span class="title">Append</span>(<span class="params">data <span class="keyword">string</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> this.rear == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">node := &amp;Node&#123;data: data&#125;</span><br><span class="line"></span><br><span class="line">this.rear.next = node</span><br><span class="line">this.rear = node</span><br><span class="line">this.length++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *LinkList</span>) <span class="title">Reverse</span>(<span class="params"></span>) *<span class="title">LinkList</span></span> &#123;</span><br><span class="line">head := this.head</span><br><span class="line"><span class="keyword">if</span> head == <span class="literal">nil</span> || head.next == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pre *Node = <span class="literal">nil</span></span><br><span class="line">cur := head.next <span class="comment">//head不为空时，当前为第1节点</span></span><br><span class="line">this.rear = head.next  <span class="comment">//第1节点不为空时，作为最后节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">cur.next, pre, cur = pre, cur, cur.next</span><br><span class="line"></span><br><span class="line"><span class="comment">//buf := cur.next</span></span><br><span class="line"><span class="comment">//cur.next = pre</span></span><br><span class="line"><span class="comment">//pre = cur</span></span><br><span class="line"><span class="comment">//cur = buf</span></span><br><span class="line">&#125;</span><br><span class="line">head.next = pre <span class="comment">//指向第最后一个节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">head := &amp;Node&#123;&#125;</span><br><span class="line">bl := NewLinkList(head)</span><br><span class="line"></span><br><span class="line">bl.Append(<span class="string">"1"</span>)</span><br><span class="line">bl.Append(<span class="string">"2"</span>)</span><br><span class="line">bl.Append(<span class="string">"3"</span>)</span><br><span class="line">bl.Append(<span class="string">"4"</span>)</span><br><span class="line">bl.Reverse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> node := bl.head; node != <span class="literal">nil</span>; node = node.next &#123;</span><br><span class="line">fmt.Print(node.data, <span class="string">"  "</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">  <span class="number">4</span>  <span class="number">3</span>  <span class="number">2</span>  <span class="number">1</span></span><br></pre></td></tr></table></figure><h4><span id="3-11-dan-lian-biao-jie-gou-yu-shun-xu-cun-chu-jie-gou">3.11 单链表结构与顺序存储结构</span><a href="#3-11-dan-lian-biao-jie-gou-yu-shun-xu-cun-chu-jie-gou" class="header-anchor">#</a></h4><p>内存分配；时间复杂度(查找，插入和删除)；空间复杂度</p><h4><span id="3-12-jing-tai-lian-biao">3.12 静态链表</span><a href="#3-12-jing-tai-lian-biao" class="header-anchor">#</a></h4><h4><span id="3-13-xun-huan-lian-biao">3.13 循环链表</span><a href="#3-13-xun-huan-lian-biao" class="header-anchor">#</a></h4><p>尾指针rear头节点rear-&gt;next第一个节点rear-&gt;next-&gt;next合并：p=rearA-&gt;nextq=rearB-&gt;nextrearA-&gt;next=rearB-&gt;next-&gt;nextrearB-&gt;next=pfree(q)</p><h4><span id="3-14-shuang-xiang-lian-biao">3.14 双向链表</span><a href="#3-14-shuang-xiang-lian-biao" class="header-anchor">#</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">data <span class="keyword">string</span></span><br><span class="line">pre  *Node</span><br><span class="line">next *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BiLinkList <span class="keyword">struct</span> &#123;</span><br><span class="line">length <span class="keyword">int</span></span><br><span class="line">head   *Node</span><br><span class="line">rear   *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBiLinkList</span>(<span class="params">head *Node</span>) *<span class="title">BiLinkList</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;BiLinkList&#123;<span class="number">0</span>, head, head&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *BiLinkList</span>) <span class="title">Append</span>(<span class="params">data <span class="keyword">string</span></span>)</span> &#123;</span><br><span class="line">node := &amp;Node&#123;data: data&#125;</span><br><span class="line"></span><br><span class="line">this.rear.next = node</span><br><span class="line">node.pre = this.rear</span><br><span class="line">this.rear = node</span><br><span class="line">this.length++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *BiLinkList</span>) <span class="title">InsertNext</span>(<span class="params">p *Node, e <span class="keyword">string</span></span>)</span> &#123;</span><br><span class="line"><span class="comment">//省略判断 nd 不为空且属于链表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.next == <span class="literal">nil</span> &#123;</span><br><span class="line">this.Append(e)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s := &amp;Node&#123;data: e&#125;</span><br><span class="line">s.pre = p</span><br><span class="line">s.next = p.next</span><br><span class="line">p.next.pre = s</span><br><span class="line">p.next = s</span><br><span class="line">&#125;</span><br><span class="line">this.length++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">head := &amp;Node&#123;&#125;</span><br><span class="line">bl := NewBiLinkList(head)</span><br><span class="line"></span><br><span class="line">bl.Append(<span class="string">"1"</span>)</span><br><span class="line">bl.Append(<span class="string">"2"</span>)</span><br><span class="line">bl.Append(<span class="string">"3"</span>)</span><br><span class="line"></span><br><span class="line">bl.InsertNext(head.next.next, <span class="string">"2.5"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//for i := 0; i &lt; bl.length; i++ &#123;</span></span><br><span class="line"><span class="comment">//fmt.Print(head.next.data, "  ")</span></span><br><span class="line"><span class="comment">//head = head.next</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> node := bl.head; node.next != <span class="literal">nil</span>; node = node.next &#123;</span><br><span class="line">fmt.Print(node.data, <span class="string">"  "</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(bl.rear.data)  <span class="comment">//打印末节点</span></span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">  <span class="number">1</span>  <span class="number">2</span>  <span class="number">2.5</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure><p>使用标准库</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"container/list"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">bl := list.New()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">bl.PushBack(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">head := bl.Front()</span><br><span class="line">rear := bl.Back()</span><br><span class="line"><span class="keyword">for</span> p := head; p != rear; p = p.Next() &#123;</span><br><span class="line">fmt.Print(p.Value, <span class="string">"  "</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(rear.Value)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure><h4><span id="4-2-zhan">4.2 栈</span><a href="#4-2-zhan" class="header-anchor">#</a></h4><p>123依次进栈，出栈次序不可能有312(12同时在栈中,2一定先出)s-&gt;top 栈顶指针栈顶指针为-1表示控栈s-&gt;data[s-&gt;top]栈顶元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123; <span class="comment">//用于存放 int 的栈</span></span><br><span class="line">nums []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Stack</span>) <span class="title">Push</span>(<span class="params">n <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">this.nums = <span class="built_in">append</span>(this.nums, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Stack</span>) <span class="title">Pop</span>(<span class="params"></span>) <span class="title">int</span></span> &#123;</span><br><span class="line">res := this.nums[<span class="built_in">len</span>(this.nums)<span class="number">-1</span>]</span><br><span class="line">this.nums = this.nums[:<span class="built_in">len</span>(this.nums)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="4-10-dui-lie">4.10 队列</span><a href="#4-10-dui-lie" class="header-anchor">#</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123; <span class="comment">//Queue 是用于存放 int 的队列</span></span><br><span class="line">nums []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Queue</span>) <span class="title">Push</span>(<span class="params">n <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">this.nums = <span class="built_in">append</span>(this.nums, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Queue</span>) <span class="title">Pop</span>(<span class="params"></span>) <span class="title">int</span></span> &#123;</span><br><span class="line">res := this.nums[<span class="number">0</span>]</span><br><span class="line">this.nums = this.nums[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="4-12-xun-huan-dui-lie">4.12 循环队列</span><a href="#4-12-xun-huan-dui-lie" class="header-anchor">#</a></h4><p>队列满的条件: <strong>(rear+1)%QueueSize == front</strong>队列长度:<strong>(rear-front+QueueSize)%QueueSize</strong></p><h4><span id="6-4-shu-de-cun-chu-jie-gou">6.4 树的存储结构</span><a href="#6-4-shu-de-cun-chu-jie-gou" class="header-anchor">#</a></h4><p>双亲表示(数组)，孩子兄弟表示(数组)，孩子表示(数组+链表)</p><h5><span id="6-5-2-te-shu-er-cha-shu">6.5.2 特殊二叉树</span><a href="#6-5-2-te-shu-er-cha-shu" class="header-anchor">#</a></h5><p>斜树，满二叉树，完全二叉树</p><h4><span id="6-6-er-cha-shu-xing-zhi">6.6 二叉树性质</span><a href="#6-6-er-cha-shu-xing-zhi" class="header-anchor">#</a></h4><p>总结点数：$n=n_{0}+n_{1}+n_{2}$分支线总数： $n-1=n_{1}+2n_{2}$完全二叉树深度：$[log_{2}n]+1$完全二叉树按层序排号：节点$i$的左节点为$2i$</p><h4><span id="6-8-bian-li-er-cha-shu">6.8 遍历二叉树</span><a href="#6-8-bian-li-er-cha-shu" class="header-anchor">#</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BinaryTree <span class="keyword">struct</span> &#123;</span><br><span class="line">data  <span class="keyword">string</span></span><br><span class="line">left  *BinaryTree</span><br><span class="line">right *BinaryTree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreOrderRec</span>(<span class="params">bt *BinaryTree</span>)</span> &#123; <span class="comment">//前序</span></span><br><span class="line"><span class="keyword">if</span> bt == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Print(bt.data, <span class="string">" "</span>)</span><br><span class="line">PreOrderRec(bt.left)</span><br><span class="line">PreOrderRec(bt.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MidOrderRec</span>(<span class="params">bt *BinaryTree</span>)</span> &#123; <span class="comment">//中序</span></span><br><span class="line"><span class="keyword">if</span> bt == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MidOrderRec(bt.left)</span><br><span class="line">fmt.Print(bt.data, <span class="string">" "</span>)</span><br><span class="line">MidOrderRec(bt.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PostOrderRec</span>(<span class="params">bt *BinaryTree</span>)</span> &#123; <span class="comment">//后序</span></span><br><span class="line"><span class="keyword">if</span> bt == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PostOrderRec(bt.left)</span><br><span class="line">PostOrderRec(bt.right)</span><br><span class="line">fmt.Print(bt.data, <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">node9 := &amp;BinaryTree&#123;data: <span class="string">"I"</span>&#125;</span><br><span class="line">node8 := &amp;BinaryTree&#123;data: <span class="string">"H"</span>&#125;</span><br><span class="line">node7 := &amp;BinaryTree&#123;data: <span class="string">"G"</span>&#125;</span><br><span class="line">node6 := &amp;BinaryTree&#123;data: <span class="string">"F"</span>&#125;</span><br><span class="line">node5 := &amp;BinaryTree&#123;data: <span class="string">"E"</span>, right: node9&#125;</span><br><span class="line">node4 := &amp;BinaryTree&#123;<span class="string">"D"</span>, node7, node8&#125;</span><br><span class="line">node3 := &amp;BinaryTree&#123;<span class="string">"C"</span>, node5, node6&#125;</span><br><span class="line">node2 := &amp;BinaryTree&#123;data: <span class="string">"B"</span>, left: node4&#125;</span><br><span class="line">root := &amp;BinaryTree&#123;<span class="string">"A"</span>, node2, node3&#125;</span><br><span class="line"></span><br><span class="line">PreOrderRec(root)</span><br><span class="line">fmt.Println()</span><br><span class="line">MidOrderRec(root)</span><br><span class="line">fmt.Println()</span><br><span class="line">PostOrderRec(root)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">A B D G H C E I F </span><br><span class="line">G D H B A E I C F </span><br><span class="line">G H D B I E F C A</span><br></pre></td></tr></table></figure><h4><span id="6-8-6-tui-dao-bian-li-jie-guo">6.8.6 推导遍历结果</span><a href="#6-8-6-tui-dao-bian-li-jie-guo" class="header-anchor">#</a></h4><p>前序遍历序列+中序遍历序列-&gt;二叉树后序遍历序列+中序遍历序列-&gt;二叉树前中后：BAC ABC ACB</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BinaryTree <span class="keyword">struct</span> &#123;</span><br><span class="line">data  <span class="keyword">string</span></span><br><span class="line">left  *BinaryTree</span><br><span class="line">right *BinaryTree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreOrderRec</span>(<span class="params">bt *BinaryTree</span>)</span> &#123; <span class="comment">//前序</span></span><br><span class="line"><span class="keyword">if</span> bt == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Print(bt.data, <span class="string">" "</span>)</span><br><span class="line">PreOrderRec(bt.left)</span><br><span class="line">PreOrderRec(bt.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MidOrderRec</span>(<span class="params">bt *BinaryTree</span>)</span> &#123; <span class="comment">//中序</span></span><br><span class="line"><span class="keyword">if</span> bt == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MidOrderRec(bt.left)</span><br><span class="line">fmt.Print(bt.data, <span class="string">" "</span>)</span><br><span class="line">MidOrderRec(bt.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PostOrderRec</span>(<span class="params">bt *BinaryTree</span>)</span> &#123; <span class="comment">//后序</span></span><br><span class="line"><span class="keyword">if</span> bt == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PostOrderRec(bt.left)</span><br><span class="line">PostOrderRec(bt.right)</span><br><span class="line">fmt.Print(bt.data, <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreMid2Tree</span>(<span class="params">pre, mid []<span class="keyword">string</span></span>) *<span class="title">BinaryTree</span></span> &#123; <span class="comment">//前序+中序推导二叉树</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(pre) != <span class="built_in">len</span>(mid) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"两个切片的长度不相等"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(mid) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root := &amp;BinaryTree&#123; <span class="comment">//前序第一个元素为root</span></span><br><span class="line">data: pre[<span class="number">0</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(mid) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">position := IndexOf(root.data, mid) <span class="comment">//找出root在中序的位置</span></span><br><span class="line"></span><br><span class="line">root.left = PreMid2Tree(pre[<span class="number">1</span>:position+<span class="number">1</span>], mid[:position]) <span class="comment">//递归</span></span><br><span class="line">root.right = PreMid2Tree(pre[position+<span class="number">1</span>:], mid[position+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexOf</span>(<span class="params">ele <span class="keyword">string</span>, seq []<span class="keyword">string</span></span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> seq &#123;</span><br><span class="line"><span class="keyword">if</span> v == ele &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"IndexOf错误，元素不存在"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">bt := PreMid2Tree([]<span class="keyword">string</span>&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"D"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"C"</span>, <span class="string">"E"</span>, <span class="string">"I"</span>, <span class="string">"F"</span>&#125;,</span><br><span class="line">[]<span class="keyword">string</span>&#123;<span class="string">"G"</span>, <span class="string">"D"</span>, <span class="string">"H"</span>, <span class="string">"B"</span>, <span class="string">"A"</span>, <span class="string">"E"</span>, <span class="string">"I"</span>, <span class="string">"C"</span>, <span class="string">"F"</span>&#125;)</span><br><span class="line"></span><br><span class="line">PostOrderRec(bt)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">G H D B I E F C A</span><br></pre></td></tr></table></figure><h4><span id="6-10-xian-suo-er-cha-shu">6.10 线索二叉树</span><a href="#6-10-xian-suo-er-cha-shu" class="header-anchor">#</a></h4><p>将节点的空指针改为指向在遍历序列中的前驱或后继的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ThreadBiTree <span class="keyword">struct</span> &#123;</span><br><span class="line">    data  <span class="keyword">string</span></span><br><span class="line">    left  *ThreadBiTree</span><br><span class="line">    right *ThreadBiTree</span><br><span class="line">    lTag  *ThreadBiTree <span class="comment">//一个bit位，区分是指向孩子还是线索</span></span><br><span class="line">    rTag  *ThreadBiTree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pre *ThreadBiTree <span class="comment">//保存前驱</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MidThreading</span>(<span class="params">bt *ThreadBiTree</span>)</span> &#123; <span class="comment">//中序遍历线索化</span></span><br><span class="line">    <span class="keyword">if</span> bt == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MidThreading(bt.left)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> bt.left == <span class="literal">nil</span> &#123; <span class="comment">//若bt有左空指针，则把pre设为bt的前驱，并设置标志位</span></span><br><span class="line">        bt.left = pre</span><br><span class="line">        bt.lTag = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> bt.right == <span class="literal">nil</span> &#123; <span class="comment">//若bt有右空指针，则把bt设为pre的后继，并设置标志位</span></span><br><span class="line">        pre.right = bt</span><br><span class="line">        pre.rTag = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pre = bt</span><br><span class="line"></span><br><span class="line">    MidThreading(bt.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="6-11-1-shu-zhuan-huan-wei-er-cha-shu">6.11.1 树转换为二叉树</span><a href="#6-11-1-shu-zhuan-huan-wei-er-cha-shu" class="header-anchor">#</a></h5><p>兄弟连线；只保留第一个孩子的连线</p><h4><span id="6-12-he-fu-man-shu">6.12 <strong>赫夫曼树</strong></span><a href="#6-12-he-fu-man-shu" class="header-anchor">#</a></h4><p>带权路径长度(WPL)最小的二叉树<img src="https://upload-images.jianshu.io/upload_images/1863961-81d44580cf5163ee.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="Huffman Tree"></p><p>WPL(a)= 5<em>1+15</em>2+40<em>3+30</em>4+10<em>4WPL(b)= 5</em>3+15<em>3+40</em>2+30<em>2+10</em>2</p><p>构造<img src="https://upload-images.jianshu.io/upload_images/1863961-1acee79132eab45b.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><p>排序：A5, E10, B15, D30, C40</p><h5><span id="7-4-1-lin-jie-ju-zhen-adjacency-matrix">7.4.1 <strong>邻接矩阵</strong>(adjacency matrix)</span><a href="#7-4-1-lin-jie-ju-zhen-adjacency-matrix" class="header-anchor">#</a></h5><p>无向图：<img src="https://upload-images.jianshu.io/upload_images/1863961-d9ce3ee2d67e574e.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><p>有向图：<img src="https://upload-images.jianshu.io/upload_images/1863961-d915f439c8959688.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><p>有向网：<img src="https://upload-images.jianshu.io/upload_images/1863961-f214b0dd61c11ca3.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><p>无向网的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">INFINITY <span class="keyword">int32</span> = <span class="number">65536</span> <span class="comment">// 无穷</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Edge <span class="keyword">struct</span> &#123; <span class="comment">//边的顶点和权值</span></span><br><span class="line">v0     <span class="keyword">string</span></span><br><span class="line">v1     <span class="keyword">string</span></span><br><span class="line">weight <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Graph <span class="keyword">struct</span> &#123; <span class="comment">//无向网</span></span><br><span class="line">v []<span class="keyword">string</span> <span class="comment">//顶点数组</span></span><br><span class="line">e []Edge   <span class="comment">//边的权值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexOfVertex</span>(<span class="params">vs []<span class="keyword">string</span>, v <span class="keyword">string</span></span>) <span class="title">int</span></span> &#123; <span class="comment">//顶点在顶点数组的位置</span></span><br><span class="line"><span class="keyword">for</span> i, value := <span class="keyword">range</span> vs &#123;</span><br><span class="line"><span class="keyword">if</span> value == v &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"边的顶点不在顶点数组中！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Graph</span>) <span class="title">AdjMatrix</span>(<span class="params"></span>) [][]<span class="title">int32</span></span> &#123;</span><br><span class="line">vertexNum := <span class="built_in">len</span>(this.v)</span><br><span class="line"></span><br><span class="line">adjM := <span class="built_in">make</span>([][]<span class="keyword">int32</span>, vertexNum) <span class="comment">//生成矩阵用两次make()</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; vertexNum; i++ &#123;   <span class="comment">//初始化</span></span><br><span class="line">adjM[i] = <span class="built_in">make</span>([]<span class="keyword">int32</span>, vertexNum)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; vertexNum; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> j == i &#123;</span><br><span class="line">adjM[i][j] = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">adjM[i][j] = INFINITY</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e := this.e</span><br><span class="line">v := this.v</span><br><span class="line"><span class="keyword">for</span> _, edge := <span class="keyword">range</span> e &#123;</span><br><span class="line">adjM[IndexOfVertex(v, edge.v0)][IndexOfVertex(v, edge.v1)] = edge.weight</span><br><span class="line">adjM[IndexOfVertex(v, edge.v1)][IndexOfVertex(v, edge.v0)] = edge.weight <span class="comment">//因为是无向图所以是对称矩阵</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> adjM</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">v := []<span class="keyword">string</span>&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>&#125;</span><br><span class="line">e := []Edge&#123;</span><br><span class="line">Edge&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="number">5</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"A"</span>, <span class="string">"C"</span>, <span class="number">3</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"A"</span>, <span class="string">"D"</span>, <span class="number">6</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"B"</span>, <span class="string">"C"</span>, <span class="number">7</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"C"</span>, <span class="string">"D"</span>, <span class="number">9</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">graph := &amp;Graph&#123;v, e&#125; <span class="comment">//生成无向网</span></span><br><span class="line"></span><br><span class="line">fmt.Println(graph.AdjMatrix())</span><br><span class="line"><span class="comment">//     A    B     C    D</span></span><br><span class="line"><span class="comment">//A [  0    5      3    6   ]</span></span><br><span class="line"><span class="comment">//B [  5    0      7  65536 ]</span></span><br><span class="line"><span class="comment">//C [  3    7      0    9   ]</span></span><br><span class="line"><span class="comment">//D [  6  65536    9    0   ]</span></span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">[[<span class="number">0</span> <span class="number">5</span> <span class="number">3</span> <span class="number">6</span>] [<span class="number">5</span> <span class="number">0</span> <span class="number">7</span> <span class="number">65536</span>] [<span class="number">3</span> <span class="number">7</span> <span class="number">0</span> <span class="number">9</span>] [<span class="number">6</span> <span class="number">65536</span> <span class="number">9</span> <span class="number">0</span>]]</span><br></pre></td></tr></table></figure><h5><span id="7-4-2-lin-jie-biao">7.4.2 <strong>邻接表</strong></span><a href="#7-4-2-lin-jie-biao" class="header-anchor">#</a></h5><p>无向图：<img src="https://upload-images.jianshu.io/upload_images/1863961-a0854989cc6149ef.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Edge <span class="keyword">struct</span> &#123; <span class="comment">//给定顶点定义边</span></span><br><span class="line">v0 <span class="keyword">string</span></span><br><span class="line">v1 <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Graph <span class="keyword">struct</span> &#123; <span class="comment">//无向图</span></span><br><span class="line">v []<span class="keyword">string</span> <span class="comment">//顶点数组</span></span><br><span class="line">e []Edge   <span class="comment">//边数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123; <span class="comment">//邻接表的边表节点</span></span><br><span class="line">adjvex <span class="keyword">int</span></span><br><span class="line">next   *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123; <span class="comment">//邻接表的顶点</span></span><br><span class="line">data      <span class="keyword">string</span></span><br><span class="line">firstedge *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LinkList <span class="keyword">struct</span> &#123; <span class="comment">//邻接表的链表</span></span><br><span class="line">head *Vertex</span><br><span class="line">rear *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *LinkList</span>) <span class="title">Append</span>(<span class="params">adjvex <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">newNode := &amp;Node&#123;adjvex: adjvex&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> this.rear == <span class="literal">nil</span> &#123;</span><br><span class="line">this.head.firstedge = newNode</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">this.rear.next = newNode</span><br><span class="line">this.rear = newNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.rear = newNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexOfVertex</span>(<span class="params">vs []<span class="keyword">string</span>, v <span class="keyword">string</span></span>) <span class="title">int</span></span> &#123; <span class="comment">//顶点在顶点数组的位置</span></span><br><span class="line"><span class="keyword">for</span> i, value := <span class="keyword">range</span> vs &#123;</span><br><span class="line"><span class="keyword">if</span> value == v &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"边的顶点不在顶点数组中！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Graph</span>) <span class="title">AdjList</span>(<span class="params"></span>) []<span class="title">LinkList</span></span> &#123;</span><br><span class="line">vertexNum := <span class="built_in">len</span>(this.v)</span><br><span class="line">v := this.v</span><br><span class="line">e := this.e</span><br><span class="line"></span><br><span class="line">adjL := <span class="built_in">make</span>([]LinkList, vertexNum) <span class="comment">//用一个单向链表的数组来表示邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for i := 0; i &lt; vertexNum; i++ &#123; //初始</span></span><br><span class="line"><span class="comment">//  adjL[i].head.data = v[i]                因为此时head为nil，没有data字段</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; vertexNum; i++ &#123; <span class="comment">//初始</span></span><br><span class="line">adjL[i].head = &amp;Vertex&#123;data: v[i]&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, edge := <span class="keyword">range</span> e &#123;</span><br><span class="line">i := IndexOfVertex(v, edge.v0)</span><br><span class="line">j := IndexOfVertex(v, edge.v1)</span><br><span class="line">adjL[i].Append(j)</span><br><span class="line">adjL[j].Append(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> adjL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">v := []<span class="keyword">string</span>&#123;<span class="string">"v0"</span>, <span class="string">"v1"</span>, <span class="string">"v2"</span>, <span class="string">"v3"</span>&#125;</span><br><span class="line">e := []Edge&#123;</span><br><span class="line">Edge&#123;<span class="string">"v0"</span>, <span class="string">"v1"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"v0"</span>, <span class="string">"v2"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"v0"</span>, <span class="string">"v3"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"v1"</span>, <span class="string">"v2"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"v2"</span>, <span class="string">"v3"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">graph := &amp;Graph&#123;v, e&#125; <span class="comment">//生成无向图</span></span><br><span class="line"></span><br><span class="line">adjL := graph.AdjList()</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> adjL &#123;</span><br><span class="line">fmt.Print(v.head.data, <span class="string">" "</span>)</span><br><span class="line"><span class="keyword">for</span> node := v.head.firstedge; node != <span class="literal">nil</span>; node = node.next &#123;</span><br><span class="line">fmt.Print(node.adjvex, <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">v0 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line">v1 <span class="number">0</span> <span class="number">2</span> </span><br><span class="line">v2 <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> </span><br><span class="line">v3 <span class="number">0</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>有向网：<img src="https://upload-images.jianshu.io/upload_images/1863961-95004e37703686d9.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><h5><span id="7-5-1-shen-du-you-xian-bian-li-depth-first-search">7.5.1 <strong>深度优先遍历</strong>(Depth First Search)</span><a href="#7-5-1-shen-du-you-xian-bian-li-depth-first-search" class="header-anchor">#</a></h5><p><img src="https://upload-images.jianshu.io/upload_images/1863961-4139cb15eb112b82.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flag []<span class="keyword">bool</span> <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Edge <span class="keyword">struct</span> &#123; <span class="comment">//给定顶点定义边</span></span><br><span class="line">v0 <span class="keyword">string</span></span><br><span class="line">v1 <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Graph <span class="keyword">struct</span> &#123; <span class="comment">//无向图</span></span><br><span class="line">v []<span class="keyword">string</span> <span class="comment">//顶点数组</span></span><br><span class="line">e []Edge   <span class="comment">//边数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Graph</span>) <span class="title">AdjMatrix</span>(<span class="params"></span>) [][]<span class="title">int</span></span> &#123;</span><br><span class="line">vertexNum := <span class="built_in">len</span>(this.v)</span><br><span class="line"></span><br><span class="line">adjM := <span class="built_in">make</span>([][]<span class="keyword">int</span>, vertexNum) <span class="comment">//生成矩阵用两次make()</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; vertexNum; i++ &#123; <span class="comment">//初始化</span></span><br><span class="line">adjM[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, vertexNum)</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; vertexNum; j++ &#123;</span><br><span class="line">adjM[i][j] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e := this.e</span><br><span class="line">v := this.v</span><br><span class="line"><span class="keyword">for</span> _, edge := <span class="keyword">range</span> e &#123;</span><br><span class="line">adjM[IndexOfVertex(v, edge.v0)][IndexOfVertex(v, edge.v1)] = <span class="number">1</span></span><br><span class="line">adjM[IndexOfVertex(v, edge.v1)][IndexOfVertex(v, edge.v0)] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> adjM</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexOfVertex</span>(<span class="params">vs []<span class="keyword">string</span>, v <span class="keyword">string</span></span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, value := <span class="keyword">range</span> vs &#123;</span><br><span class="line"><span class="keyword">if</span> value == v &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"边的顶点不在顶点数组中！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DFSTraverse</span>(<span class="params">adjM [][]<span class="keyword">int</span></span>)</span> &#123; <span class="comment">//输入无向图的邻接矩阵</span></span><br><span class="line">vertexNum := <span class="built_in">len</span>(adjM)</span><br><span class="line"></span><br><span class="line">flag = <span class="built_in">make</span>([]<span class="keyword">bool</span>, vertexNum) <span class="comment">//初始化flag，注意这里不能用 :=</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; vertexNum; i++ &#123;</span><br><span class="line">flag[i] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; vertexNum; i++ &#123; <span class="comment">//对未访问的节点执行深度搜索</span></span><br><span class="line"><span class="keyword">if</span> !flag[i] &#123;</span><br><span class="line">DFS(vertexNum, i, adjM)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DFS</span>(<span class="params">vertexNum <span class="keyword">int</span>, i <span class="keyword">int</span>, adjM [][]<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">flag[i] = <span class="literal">true</span></span><br><span class="line">fmt.Print(i, <span class="string">"  "</span>)               <span class="comment">//打印被访问的节点序号</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; vertexNum; j++ &#123; <span class="comment">//对未被访问的邻节点递归</span></span><br><span class="line"><span class="keyword">if</span> adjM[i][j] == <span class="number">1</span> &amp;&amp; !flag[j] &#123;</span><br><span class="line">DFS(vertexNum, j, adjM)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">v := []<span class="keyword">string</span>&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>&#125;</span><br><span class="line">e := []Edge&#123;</span><br><span class="line">Edge&#123;<span class="string">"A"</span>, <span class="string">"B"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"A"</span>, <span class="string">"F"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"B"</span>, <span class="string">"C"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"B"</span>, <span class="string">"G"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"B"</span>, <span class="string">"I"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"F"</span>, <span class="string">"G"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"F"</span>, <span class="string">"E"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"C"</span>, <span class="string">"D"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"C"</span>, <span class="string">"I"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"G"</span>, <span class="string">"D"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"G"</span>, <span class="string">"H"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"E"</span>, <span class="string">"D"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"E"</span>, <span class="string">"H"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">graph := &amp;Graph&#123;v, e&#125; <span class="comment">//生成无向图</span></span><br><span class="line">adjM := graph.AdjMatrix()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(adjM); i++ &#123;</span><br><span class="line">fmt.Println(adjM[i])</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"-------------------"</span>)</span><br><span class="line">DFSTraverse(adjM)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">-------------------</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br></pre></td></tr></table></figure><h5><span id="7-5-2-guang-du-you-xian-bian-li-breadth-first-search">7.5.2 <strong>广度优先遍历</strong>(Breadth First Search)</span><a href="#7-5-2-guang-du-you-xian-bian-li-breadth-first-search" class="header-anchor">#</a></h5><p><img src="https://upload-images.jianshu.io/upload_images/1863961-1aab42f56392a97a.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Edge <span class="keyword">struct</span> &#123; <span class="comment">//给定顶点定义边</span></span><br><span class="line">v0 <span class="keyword">string</span></span><br><span class="line">v1 <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Graph <span class="keyword">struct</span> &#123; <span class="comment">//无向图</span></span><br><span class="line">v []<span class="keyword">string</span> <span class="comment">//顶点数组</span></span><br><span class="line">e []Edge   <span class="comment">//边数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123; <span class="comment">//邻接表的边表节点</span></span><br><span class="line">adjvex <span class="keyword">int</span></span><br><span class="line">next   *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123; <span class="comment">//邻接表的顶点</span></span><br><span class="line">data      <span class="keyword">string</span></span><br><span class="line">firstedge *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LinkList <span class="keyword">struct</span> &#123; <span class="comment">//邻接表的链表</span></span><br><span class="line">head *Vertex</span><br><span class="line">rear *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Queue <span class="keyword">struct</span> &#123;</span><br><span class="line">nums []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Queue</span>) <span class="title">Push</span>(<span class="params">n <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">this.nums = <span class="built_in">append</span>(this.nums, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Queue</span>) <span class="title">Pop</span>(<span class="params"></span>) <span class="title">int</span></span> &#123;</span><br><span class="line">res := this.nums[<span class="number">0</span>]</span><br><span class="line">this.nums = this.nums[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *LinkList</span>) <span class="title">Append</span>(<span class="params">adjvex <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">newNode := &amp;Node&#123;adjvex: adjvex&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> this.rear == <span class="literal">nil</span> &#123;</span><br><span class="line">this.head.firstedge = newNode</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">this.rear.next = newNode</span><br><span class="line">this.rear = newNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.rear = newNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexOfVertex</span>(<span class="params">vs []<span class="keyword">string</span>, v <span class="keyword">string</span></span>) <span class="title">int</span></span> &#123; <span class="comment">//顶点在顶点数组的位置</span></span><br><span class="line"><span class="keyword">for</span> i, value := <span class="keyword">range</span> vs &#123;</span><br><span class="line"><span class="keyword">if</span> value == v &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"边的顶点不在顶点数组中！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">this *Graph</span>) <span class="title">AdjList</span>(<span class="params"></span>) []<span class="title">LinkList</span></span> &#123;</span><br><span class="line">vertexNum := <span class="built_in">len</span>(this.v)</span><br><span class="line">v := this.v</span><br><span class="line">e := this.e</span><br><span class="line"></span><br><span class="line">adjL := <span class="built_in">make</span>([]LinkList, vertexNum) <span class="comment">//用一个单向链表的数组来表示邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//for i := 0; i &lt; vertexNum; i++ &#123; //初始</span></span><br><span class="line"><span class="comment">//adjL[i].head.data = v[i]                因为此时head为nil，没有data字段</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; vertexNum; i++ &#123; <span class="comment">//初始</span></span><br><span class="line">adjL[i].head = &amp;Vertex&#123;data: v[i]&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, edge := <span class="keyword">range</span> e &#123;</span><br><span class="line">i := IndexOfVertex(v, edge.v0)</span><br><span class="line">j := IndexOfVertex(v, edge.v1)</span><br><span class="line">adjL[i].Append(j)</span><br><span class="line">adjL[j].Append(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> adjL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFSTraverse</span>(<span class="params">adjL []LinkList</span>)</span> &#123; <span class="comment">//输入邻接表</span></span><br><span class="line">vertexNum := <span class="built_in">len</span>(adjL)</span><br><span class="line"></span><br><span class="line">flag := <span class="built_in">make</span>([]<span class="keyword">bool</span>, vertexNum) <span class="comment">//标记被访问的节点</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; vertexNum; i++ &#123;</span><br><span class="line">flag[i] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Q := <span class="built_in">new</span>(Queue) <span class="comment">//队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; vertexNum; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> !flag[i] &#123; <span class="comment">//如果顶点未被访问</span></span><br><span class="line">flag[i] = <span class="literal">true</span></span><br><span class="line">Q.Push(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(Q.nums) &gt; <span class="number">0</span> &#123; <span class="comment">//队列不为空</span></span><br><span class="line">j := Q.Pop()</span><br><span class="line">fmt.Print(adjL[j].head.data, <span class="string">" "</span>) <span class="comment">//打印节点</span></span><br><span class="line"><span class="keyword">for</span> node := adjL[j].head.firstedge; node != <span class="literal">nil</span>; node = node.next &#123;</span><br><span class="line"><span class="keyword">if</span> flag[node.adjvex] == <span class="literal">false</span> &#123;</span><br><span class="line">flag[node.adjvex] = <span class="literal">true</span></span><br><span class="line">Q.Push(node.adjvex)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">v := []<span class="keyword">string</span>&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>&#125;</span><br><span class="line">e := []Edge&#123;</span><br><span class="line">Edge&#123;<span class="string">"A"</span>, <span class="string">"B"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"A"</span>, <span class="string">"F"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"B"</span>, <span class="string">"C"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"B"</span>, <span class="string">"G"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"B"</span>, <span class="string">"I"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"F"</span>, <span class="string">"G"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"F"</span>, <span class="string">"E"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"C"</span>, <span class="string">"D"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"C"</span>, <span class="string">"I"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"G"</span>, <span class="string">"D"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"G"</span>, <span class="string">"H"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"E"</span>, <span class="string">"D"</span>&#125;,</span><br><span class="line">Edge&#123;<span class="string">"E"</span>, <span class="string">"H"</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">graph := &amp;Graph&#123;v, e&#125; <span class="comment">//生成无向图</span></span><br><span class="line"></span><br><span class="line">adjL := graph.AdjList()</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> adjL &#123;</span><br><span class="line">fmt.Print(v.head.data, <span class="string">" "</span>)</span><br><span class="line"><span class="keyword">for</span> node := v.head.firstedge; node != <span class="literal">nil</span>; node = node.next &#123;</span><br><span class="line">fmt.Print(adjL[node.adjvex].head.data, <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"-----------------"</span>)</span><br><span class="line">BFSTraverse(adjL)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">A B F </span><br><span class="line">B A C G I </span><br><span class="line">C B D I </span><br><span class="line">D C G E </span><br><span class="line">E F D H </span><br><span class="line">F A G E </span><br><span class="line">G B F D H </span><br><span class="line">H G E </span><br><span class="line">I B C </span><br><span class="line">-----------------</span><br><span class="line">A B F C G I E D H</span><br></pre></td></tr></table></figure><h5><span id="8-4-1-er-fen-cha-zhao">8.4.1 二分查找</span><a href="#8-4-1-er-fen-cha-zhao" class="header-anchor">#</a></h5><p><img src="https://upload-images.jianshu.io/upload_images/1863961-e7c869cf58b3751b.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BiSearch</span>(<span class="params">a []<span class="keyword">int</span>, n, key <span class="keyword">int</span></span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> low, high, mid <span class="keyword">int</span></span><br><span class="line">low = <span class="number">1</span></span><br><span class="line">high = n</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">mid = (low + high) / <span class="number">2</span></span><br><span class="line"><span class="comment">//mid = low + (high-low)(key-1)/(99-1)  插值</span></span><br><span class="line"><span class="keyword">if</span> key == a[mid] &#123;</span><br><span class="line"><span class="keyword">return</span> mid</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> key &lt; a[mid] &#123;</span><br><span class="line">high = mid - <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">low = mid + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">35</span>, <span class="number">47</span>, <span class="number">59</span>, <span class="number">62</span>, <span class="number">73</span>, <span class="number">88</span>, <span class="number">99</span>&#125;</span><br><span class="line">fmt.Println(BiSearch(a, <span class="number">10</span>, <span class="number">62</span>))</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><h4><span id="8-6-er-cha-cha-zhao-shu-binary-sort-tree">8.6 二叉查找树(Binary Sort Tree)</span><a href="#8-6-er-cha-cha-zhao-shu-binary-sort-tree" class="header-anchor">#</a></h4><p>左小右大<img src="https://upload-images.jianshu.io/upload_images/1863961-ac2cd3676f5e970c.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BinaryTree <span class="keyword">struct</span> &#123;</span><br><span class="line">data  <span class="keyword">int</span></span><br><span class="line">left  *BinaryTree</span><br><span class="line">right *BinaryTree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SearchBST</span>(<span class="params">root *BinaryTree, key <span class="keyword">int</span></span>) <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> key &lt; root.data:</span><br><span class="line"><span class="keyword">return</span> SearchBST(root.left, key)</span><br><span class="line"><span class="keyword">case</span> key &gt; root.data:</span><br><span class="line"><span class="keyword">return</span> SearchBST(root.right, key)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">node10 := &amp;BinaryTree&#123;data: <span class="number">37</span>&#125;</span><br><span class="line">node9 := &amp;BinaryTree&#123;data: <span class="number">93</span>&#125;</span><br><span class="line">node8 := &amp;BinaryTree&#123;data: <span class="number">51</span>&#125;</span><br><span class="line">node7 := &amp;BinaryTree&#123;data: <span class="number">35</span>, right: node10&#125;</span><br><span class="line">node6 := &amp;BinaryTree&#123;data: <span class="number">99</span>, left: node9&#125;</span><br><span class="line">node5 := &amp;BinaryTree&#123;data: <span class="number">73</span>&#125;</span><br><span class="line">node4 := &amp;BinaryTree&#123;data: <span class="number">47</span>, left: node7, right: node8&#125;</span><br><span class="line">node3 := &amp;BinaryTree&#123;<span class="number">88</span>, node5, node6&#125;</span><br><span class="line">node2 := &amp;BinaryTree&#123;data: <span class="number">58</span>, left: node4&#125;</span><br><span class="line">root := &amp;BinaryTree&#123;<span class="number">62</span>, node2, node3&#125;</span><br><span class="line"></span><br><span class="line">fmt.Print(SearchBST(root, <span class="number">73</span>), <span class="string">" "</span>)</span><br><span class="line">fmt.Print(SearchBST(root, <span class="number">99</span>), <span class="string">" "</span>)</span><br><span class="line">fmt.Print(SearchBST(root, <span class="number">37</span>), <span class="string">" "</span>)</span><br><span class="line">fmt.Print(SearchBST(root, <span class="number">48</span>), <span class="string">" "</span>)</span><br><span class="line">fmt.Print(SearchBST(root, <span class="number">100</span>))</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line"><span class="literal">true</span> <span class="literal">true</span> <span class="literal">true</span> <span class="literal">false</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h5><span id="8-6-2-er-cha-cha-zhao-shu-cha-ru">8.6.2 二叉查找树插入</span><a href="#8-6-2-er-cha-cha-zhao-shu-cha-ru" class="header-anchor">#</a></h5><p><img src="https://upload-images.jianshu.io/upload_images/1863961-a95e74e49282a74c.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BinaryTree <span class="keyword">struct</span> &#123;</span><br><span class="line">data  <span class="keyword">int</span></span><br><span class="line">left  *BinaryTree</span><br><span class="line">right *BinaryTree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertBST</span>(<span class="params">root *BinaryTree, key <span class="keyword">int</span></span>) (<span class="params"><span class="keyword">bool</span>, *BinaryTree</span>)</span> &#123;</span><br><span class="line"><span class="comment">//if SearchBST(root, key) &#123;  //假设不存在</span></span><br><span class="line"><span class="comment">//return false, root</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, Insert(root, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insert</span>(<span class="params">root *BinaryTree, key <span class="keyword">int</span></span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;BinaryTree&#123;data: key&#125; <span class="comment">//插入的本质要生成新的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> key &lt; root.data &#123;</span><br><span class="line">root.left = Insert(root.left, key)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有key = root.data 的情况</span></span><br><span class="line">root.right = Insert(root.right, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">node10 := &amp;BinaryTree&#123;data: <span class="number">37</span>&#125;</span><br><span class="line">node9 := &amp;BinaryTree&#123;data: <span class="number">93</span>&#125;</span><br><span class="line">node8 := &amp;BinaryTree&#123;data: <span class="number">51</span>&#125;</span><br><span class="line">node7 := &amp;BinaryTree&#123;data: <span class="number">35</span>, right: node10&#125;</span><br><span class="line">node6 := &amp;BinaryTree&#123;data: <span class="number">99</span>, left: node9&#125;</span><br><span class="line">node5 := &amp;BinaryTree&#123;data: <span class="number">73</span>&#125;</span><br><span class="line">node4 := &amp;BinaryTree&#123;data: <span class="number">47</span>, left: node7, right: node8&#125;</span><br><span class="line">node3 := &amp;BinaryTree&#123;<span class="number">88</span>, node5, node6&#125;</span><br><span class="line">node2 := &amp;BinaryTree&#123;data: <span class="number">58</span>, left: node4&#125;</span><br><span class="line">root := &amp;BinaryTree&#123;<span class="number">62</span>, node2, node3&#125;</span><br><span class="line"></span><br><span class="line">fmt.Print(root.right.right.left.data, root.right.right.left.right, <span class="string">" "</span>)</span><br><span class="line">_, root = InsertBST(root, <span class="number">95</span>)</span><br><span class="line">fmt.Print(root.right.right.left.right.data)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line"><span class="number">93</span> &lt;<span class="literal">nil</span>&gt; <span class="number">95</span></span><br></pre></td></tr></table></figure><h5><span id="8-6-3-er-cha-cha-zhao-shu-shan-chu">8.6.3 二叉查找树删除</span><a href="#8-6-3-er-cha-cha-zhao-shu-shan-chu" class="header-anchor">#</a></h5><p><img src="https://upload-images.jianshu.io/upload_images/1863961-73f49cf999259ca8.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-f901a4ee0de2558c.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BinaryTree <span class="keyword">struct</span> &#123;</span><br><span class="line">data  <span class="keyword">int</span></span><br><span class="line">left  *BinaryTree</span><br><span class="line">right *BinaryTree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除data为key的节点，并返回该二叉树的根节点。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteBST</span>(<span class="params">root *BinaryTree, key <span class="keyword">int</span></span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> key &gt; root.data: <span class="comment">//在右子树中</span></span><br><span class="line">root.right = DeleteBST(root.right, key)</span><br><span class="line"><span class="keyword">case</span> key &lt; root.data: <span class="comment">//在左子树中</span></span><br><span class="line">root.left = DeleteBST(root.left, key)</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//key == root.data</span></span><br><span class="line"><span class="keyword">if</span> root.left == <span class="literal">nil</span> &amp;&amp; root.right == <span class="literal">nil</span> &#123; <span class="comment">//该节点为叶节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> root.left == <span class="literal">nil</span> &amp;&amp; root.right != <span class="literal">nil</span> &#123; <span class="comment">//该节点仅有右子树</span></span><br><span class="line"><span class="keyword">return</span> root.right</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> root.left != <span class="literal">nil</span> &amp;&amp; root.right == <span class="literal">nil</span> &#123; <span class="comment">//该节点仅有左子树</span></span><br><span class="line"><span class="keyword">return</span> root.left</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//该节点有左、右子树</span></span><br><span class="line">success := FindMin(root.right) <span class="comment">//找到key的后继节点,即48</span></span><br><span class="line">root.right = DeleteBST(root.right, success)</span><br><span class="line">root.data = success</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到BST中data最小的节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindMin</span>(<span class="params">root *BinaryTree</span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root.left == <span class="literal">nil</span> &#123; <span class="comment">//最小值在根节点</span></span><br><span class="line"><span class="keyword">return</span> root.data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> FindMin(root.left) <span class="comment">//最小值在左子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">node16 := &amp;BinaryTree&#123;data: <span class="number">50</span>&#125;</span><br><span class="line">node15 := &amp;BinaryTree&#123;data: <span class="number">48</span>&#125;</span><br><span class="line">node14 := &amp;BinaryTree&#123;data: <span class="number">36</span>&#125;</span><br><span class="line">node13 := &amp;BinaryTree&#123;data: <span class="number">56</span>&#125;</span><br><span class="line">node12 := &amp;BinaryTree&#123;<span class="number">49</span>, node15, node16&#125;</span><br><span class="line">node11 := &amp;BinaryTree&#123;data: <span class="number">37</span>, left: node14&#125;</span><br><span class="line">node10 := &amp;BinaryTree&#123;data: <span class="number">29</span>&#125;</span><br><span class="line">node9 := &amp;BinaryTree&#123;data: <span class="number">93</span>&#125;</span><br><span class="line">node8 := &amp;BinaryTree&#123;<span class="number">51</span>, node12, node13&#125;</span><br><span class="line">node7 := &amp;BinaryTree&#123;<span class="number">35</span>, node10, node11&#125;</span><br><span class="line">node6 := &amp;BinaryTree&#123;data: <span class="number">99</span>, left: node9&#125;</span><br><span class="line">node5 := &amp;BinaryTree&#123;data: <span class="number">73</span>&#125;</span><br><span class="line">node4 := &amp;BinaryTree&#123;data: <span class="number">47</span>, left: node7, right: node8&#125;</span><br><span class="line">node3 := &amp;BinaryTree&#123;<span class="number">88</span>, node5, node6&#125;</span><br><span class="line">node2 := &amp;BinaryTree&#123;data: <span class="number">58</span>, left: node4&#125;</span><br><span class="line">root := &amp;BinaryTree&#123;<span class="number">62</span>, node2, node3&#125;</span><br><span class="line"></span><br><span class="line">root = DeleteBST(root, <span class="number">47</span>)</span><br><span class="line">NewNode := root.left.left</span><br><span class="line">fmt.Print(NewNode.data, <span class="string">" "</span>) <span class="comment">//打印代替删除位置的新节点</span></span><br><span class="line">fmt.Print(NewNode.left.data, NewNode.right.data)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line"><span class="number">48</span> <span class="number">35</span> <span class="number">51</span></span><br></pre></td></tr></table></figure><h4><span id="8-7-ping-heng-er-cha-shu-avl-shu">8.7 平衡二叉树(AVL树)</span><a href="#8-7-ping-heng-er-cha-shu-avl-shu" class="header-anchor">#</a></h4><p><strong>平衡因子</strong>(BF)=左子树的深度-右子树的深度<strong>旋转：</strong><img src="https://upload-images.jianshu.io/upload_images/1863961-b493bc28e8068b46.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""><img src="https://upload-images.jianshu.io/upload_images/1863961-b6715f1391c81757.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RRotate</span>(<span class="params">k2 *BinaryTree</span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line">k1 := k2.left</span><br><span class="line">y := k1.right</span><br><span class="line">k1.right = k2</span><br><span class="line">k2.left = y</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> k1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双旋转：</strong><img src="https://upload-images.jianshu.io/upload_images/1863961-132deac059f8995f.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LRRotate</span>(<span class="params">k3 *BinaryTree</span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line">k3.left = LRotate(k3.left)</span><br><span class="line"><span class="keyword">return</span> RRotate(k3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1863961-fe05b14c2bdb3e2c.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""></p><p>将任意二叉树一次性调整AVL</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BinaryTree <span class="keyword">struct</span> &#123;</span><br><span class="line">data  <span class="keyword">int</span></span><br><span class="line">bf    <span class="keyword">int</span> <span class="comment">//Balance Factor</span></span><br><span class="line">left  *BinaryTree</span><br><span class="line">right *BinaryTree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">R_Rotate</span>(<span class="params">root *BinaryTree</span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line">a := root.left</span><br><span class="line">b := a.right</span><br><span class="line">a.right = root</span><br><span class="line">root.left = b</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左旋</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">L_Rotate</span>(<span class="params">root *BinaryTree</span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line">a := root.right</span><br><span class="line">b := a.left</span><br><span class="line">a.left = root</span><br><span class="line">root.right = b</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//左右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LR_Rotate</span>(<span class="params">root *BinaryTree</span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line">root.left = L_Rotate(root.left)</span><br><span class="line"><span class="keyword">return</span> R_Rotate(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右左旋转</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RL_Rotate</span>(<span class="params">root *BinaryTree</span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line">root.right = R_Rotate(root.right)</span><br><span class="line"><span class="keyword">return</span> L_Rotate(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将任意二叉树转化成AVL</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span>(<span class="params">root *BinaryTree</span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line">a := &amp;BinaryTree&#123;left: root&#125; <span class="comment">//给二叉树生成一个父母节点</span></span><br><span class="line">_, isAVL := Bal(root)        <span class="comment">//调整二叉树的子树并判断二叉树是否平衡</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> !isAVL &#123;</span><br><span class="line">Bal(a)                 <span class="comment">//处理a的左子树，即二叉树</span></span><br><span class="line">_, isAVL = Bal(a.left) <span class="comment">//判断二叉树是否平衡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a.left <span class="comment">//返回二叉树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整子树</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bal</span>(<span class="params">root *BinaryTree</span>) (<span class="params"><span class="keyword">int</span>, <span class="keyword">bool</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">leftHeight, leftIsBalanced := Bal(root.left)</span><br><span class="line">rightHeight, rightIsBalanced := Bal(root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !leftIsBalanced &#123;</span><br><span class="line">root.left = Rotate(root.left)    <span class="comment">//调整左子树</span></span><br><span class="line">leftHeight = UpdateBF(root.left) <span class="comment">//刷新左子树的BF和高度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !rightIsBalanced &#123;</span><br><span class="line">root.right = Rotate(root.right)</span><br><span class="line">rightHeight = UpdateBF(root.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">root.bf = leftHeight - rightHeight <span class="comment">//计算本身的BF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Abs(root.bf) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Max(leftHeight, rightHeight) + <span class="number">1</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Max(leftHeight, rightHeight) + <span class="number">1</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对不平衡树进行旋转调整</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Rotate</span>(<span class="params">root *BinaryTree</span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root.bf &gt; <span class="number">0</span> &#123; <span class="comment">//左边太重，需要右旋</span></span><br><span class="line"><span class="keyword">if</span> root.left.bf &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> LR_Rotate(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> R_Rotate(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> root.right.bf &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> RL_Rotate(root)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> L_Rotate(root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateBF</span>(<span class="params">root *BinaryTree</span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">leftHeight := UpdateBF(root.left)</span><br><span class="line">rightHeight := UpdateBF(root.right)</span><br><span class="line">root.bf = leftHeight - rightHeight</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Max(leftHeight, rightHeight) + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Max</span>(<span class="params">a, b <span class="keyword">int</span></span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Abs</span>(<span class="params">a <span class="keyword">int</span></span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertBST</span>(<span class="params">root *BinaryTree, key <span class="keyword">int</span></span>) (<span class="params"><span class="keyword">bool</span>, *BinaryTree</span>)</span> &#123;</span><br><span class="line"><span class="comment">//if SearchBST(root, key) &#123;  //假设不存在</span></span><br><span class="line"><span class="comment">//  return false, root</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, Insert(root, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Insert</span>(<span class="params">root *BinaryTree, key <span class="keyword">int</span></span>) *<span class="title">BinaryTree</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;BinaryTree&#123;data: key&#125; <span class="comment">//插入的本质要生成新的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> key &lt; root.data &#123;</span><br><span class="line">root.left = Insert(root.left, key)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有key = root.data 的情况</span></span><br><span class="line">root.right = Insert(root.right, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrintBF</span>(<span class="params">root *BinaryTree</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PrintBF(root.left)</span><br><span class="line">fmt.Print(root.bf, <span class="string">" "</span>)</span><br><span class="line">PrintBF(root.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">root := &amp;BinaryTree&#123;data: <span class="number">1</span>&#125;</span><br><span class="line">InsertBST(root, <span class="number">7</span>)</span><br><span class="line">InsertBST(root, <span class="number">2</span>)</span><br><span class="line">InsertBST(root, <span class="number">4</span>)</span><br><span class="line">InsertBST(root, <span class="number">8</span>)</span><br><span class="line">InsertBST(root, <span class="number">3</span>)</span><br><span class="line">InsertBST(root, <span class="number">10</span>)</span><br><span class="line">InsertBST(root, <span class="number">5</span>)</span><br><span class="line">InsertBST(root, <span class="number">9</span>)</span><br><span class="line">InsertBST(root, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">UpdateBF(root)</span><br><span class="line">PrintBF(root) <span class="comment">//二叉树的BF</span></span><br><span class="line">fmt.Println()</span><br><span class="line">PrintBF(Balance(root)) <span class="comment">//平衡调整后的二叉树的BF</span></span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line"><span class="number">-5</span> <span class="number">-3</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">-2</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h5><span id="9-2-1-pai-xu-de-wen-ding-xing">9.2.1 排序的稳定性</span><a href="#9-2-1-pai-xu-de-wen-ding-xing" class="header-anchor">#</a></h5><p><img src="https://upload-images.jianshu.io/upload_images/1863961-da3eb9745c415426.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><h5><span id="9-2-2-nei-pai-xu-he-wai-pai-xu">9.2.2 内排序和外排序</span><a href="#9-2-2-nei-pai-xu-he-wai-pai-xu" class="header-anchor">#</a></h5><p><strong>内排序</strong>是在排序的整个过程中，待排序的所有记录全部在内存中。<strong>外排序</strong>的整个过程则需要在内外存之间交换数据。</p><h5><span id="9-3-2-mou-pao-pai-xu-suan-fa-bubble-sort">9.3.2 冒泡排序算法(Bubble Sort)</span><a href="#9-3-2-mou-pao-pai-xu-suan-fa-bubble-sort" class="header-anchor">#</a></h5><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改 变，所以冒泡排序是一种稳定排序算法。<img src="https://upload-images.jianshu.io/upload_images/1863961-35aca3bf05e9be84.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort</span>(<span class="params">a []<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length<span class="number">-1</span>; i++ &#123; <span class="comment">//需要交换(length-2)次，从后往前排</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; length-i; j++ &#123; <span class="comment">//当i=1时，j可以取到(length-2)</span></span><br><span class="line"><span class="keyword">if</span> a[j] &gt; a[j+<span class="number">1</span>] &#123;</span><br><span class="line">a[j], a[j+<span class="number">1</span>] = a[j+<span class="number">1</span>], a[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>&#125;</span><br><span class="line">BubbleSort(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归实现. for 循环找出最大值排到末尾，去掉末尾把对新的序列递归</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func RecurBubble(a []int) &#123;</span><br><span class="line">length := len(a)</span><br><span class="line">if length &lt; 3 &#123;  //递归跳出条件</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for j := 1; j &lt;= length-2; j++ &#123;</span><br><span class="line">if a[j] &gt; a[j+1] &#123;</span><br><span class="line">a[j], a[j+1] = a[j+1], a[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = a[0 : length-1] //不包括第 length-1 个元素</span><br><span class="line"></span><br><span class="line">RecurBubble(a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a := []int&#123;0, 9, 1, 5, 8, 3, 7, 4, 6, 2&#125;</span><br><span class="line">RecurBubble(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="9-3-3-mou-pao-pai-xu-you-hua">9.3.3 冒泡排序优化</span><a href="#9-3-3-mou-pao-pai-xu-you-hua" class="header-anchor">#</a></h5><p><img src="https://upload-images.jianshu.io/upload_images/1863961-2c7713c7b8115947.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BubbleSort2</span>(<span class="params">a []<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">flag := <span class="literal">true</span> <span class="comment">// 有数据交换</span></span><br><span class="line">length := <span class="built_in">len</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length<span class="number">-1</span> &amp;&amp; flag; i++ &#123; </span><br><span class="line">flag = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; length-i; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> a[j] &gt; a[j+<span class="number">1</span>] &#123;</span><br><span class="line">a[j], a[j+<span class="number">1</span>] = a[j+<span class="number">1</span>], a[j]</span><br><span class="line">flag = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>&#125;</span><br><span class="line">BubbleSort2(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="9-4-1-jian-dan-xuan-ze-pai-xu-simple-selection-sort">9.4.1 简单选择排序(Simple Selection Sort)</span><a href="#9-4-1-jian-dan-xuan-ze-pai-xu-simple-selection-sort" class="header-anchor">#</a></h3><p>复杂度与冒泡排序同为$O(n^{2})$,但性能更优(数据交换次数更少)。选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个 元素不用选择了，因为只剩下它一个最大的元素了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SelectionSort</span>(<span class="params">a []<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">var</span> min <span class="keyword">int</span></span><br><span class="line">length := <span class="built_in">len</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; length<span class="number">-1</span>; i++ &#123; <span class="comment">//插入次数(length-2)，从前往后排；把后面序列中较小的数插</span></span><br><span class="line">min = i</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环找出序列中的最小数的下标</span></span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; length; j++ &#123; <span class="comment">//j取到i后的所有数</span></span><br><span class="line"><span class="keyword">if</span> a[j] &lt; a[min] &#123; <span class="comment">//之后有更小的数</span></span><br><span class="line">min = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i != min &#123; <span class="comment">//下标改变，交换，防止数据丢失</span></span><br><span class="line">a[i], a[min] = a[min], a[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>&#125;</span><br><span class="line">SelectionSort(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反过来排</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func SelectionSort(a []int) &#123;</span><br><span class="line">var max int</span><br><span class="line">length := len(a)</span><br><span class="line"></span><br><span class="line">for i := length - 1; i &gt; 0; i-- &#123; 从大到小排</span><br><span class="line">max = i</span><br><span class="line">for j := 1; j &lt; i; j++ &#123;</span><br><span class="line">if a[j] &gt; a[max] &#123;</span><br><span class="line">max = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if max != i &#123;</span><br><span class="line">a[i], a[max] = a[max], a[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a := []int&#123;0, 9, 1, 5, 8, 3, 7, 4, 6, 2&#125;</span><br><span class="line">SelectionSort(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SelectionSort</span>(<span class="params">a []<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> length &lt; <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max := length - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; length<span class="number">-1</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> a[j] &gt; a[max] &#123;</span><br><span class="line">max = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> max != length<span class="number">-1</span> &#123;</span><br><span class="line">a[length<span class="number">-1</span>], a[max] = a[max], a[length<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SelectionSort(a[:length<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>&#125;</span><br><span class="line">SelectionSort(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="9-5-1-zhi-jie-cha-ru-pai-xu-straight-insertion-sort">9.5.1 直接插入排序(Straight Insertion Sort)</span><a href="#9-5-1-zhi-jie-cha-ru-pai-xu-straight-insertion-sort" class="header-anchor">#</a></h5><p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开 始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳 定的。复杂度同为为$O(n^{2})$，性能：<strong>插入排序&gt;选择排序&gt;冒泡排序</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InsertionSort</span>(<span class="params">a []<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">var</span> j <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">2</span>; i &lt; length; i++ &#123; <span class="comment">//第二个数到最后一个数</span></span><br><span class="line"><span class="keyword">if</span> a[i] &lt; a[i<span class="number">-1</span>] &#123; <span class="comment">//第i个数比前面的数小，需要插入</span></span><br><span class="line">a[<span class="number">0</span>] = a[i] <span class="comment">//哨兵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j = i - <span class="number">1</span>; a[j] &gt; a[<span class="number">0</span>]; j-- &#123; <span class="comment">//j取 i-1 到 1</span></span><br><span class="line">a[j+<span class="number">1</span>] = a[j] <span class="comment">//将大于第i个数的数后移一位，留出空位</span></span><br><span class="line">&#125;</span><br><span class="line">a[j+<span class="number">1</span>] = a[<span class="number">0</span>] <span class="comment">//将第i个数放入空位</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>&#125;</span><br><span class="line">InsertionSort(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="9-6-xi-er-pai-xu-shell-sort">9.6 希尔排序(Shell Sort)</span><a href="#9-6-xi-er-pai-xu-shell-sort" class="header-anchor">#</a></h4><p>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。<img src="https://upload-images.jianshu.io/upload_images/1863961-8713bb4788430478.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShellSort</span>(<span class="params">a []<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">var</span> i, j <span class="keyword">int</span></span><br><span class="line">length := <span class="built_in">len</span>(a) - <span class="number">1</span> <span class="comment">//去掉第0位</span></span><br><span class="line">inc := length <span class="comment">//增量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> inc &gt; <span class="number">1</span> &#123;</span><br><span class="line">inc = inc/<span class="number">3</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> + inc; i &lt;= length; i++ &#123; <span class="comment">//第(1+inc)个数到最后一个数</span></span><br><span class="line"><span class="keyword">if</span> a[i] &lt; a[i-inc] &#123;</span><br><span class="line">a[<span class="number">0</span>] = a[i]</span><br><span class="line"><span class="keyword">for</span> j = i - inc; j &gt; <span class="number">0</span> &amp;&amp; a[j] &gt; a[<span class="number">0</span>]; j -= inc &#123;</span><br><span class="line">a[j+inc] = a[j]</span><br><span class="line">&#125;</span><br><span class="line">a[j+inc] = a[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>&#125;</span><br><span class="line">ShellSort(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="9-7-dui-pai-xu">9.7 堆排序</span><a href="#9-7-dui-pai-xu" class="header-anchor">#</a></h4><p>时间复杂度$O(nlogn)$</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span>(<span class="params">a []<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//循环后a[1]为最大值</span></span><br><span class="line"><span class="keyword">for</span> i := length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i-- &#123; <span class="comment">//(length/2)是最后一个节点的父节点到根节点</span></span><br><span class="line">HeapAdjust(a, i, length)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := length; i &gt; <span class="number">1</span>; i-- &#123; <span class="comment">//从最后节点到第二个节点</span></span><br><span class="line">a[<span class="number">1</span>], a[i] = a[i], a[<span class="number">1</span>] <span class="comment">//排序第i位</span></span><br><span class="line">HeapAdjust(a, <span class="number">1</span>, i<span class="number">-1</span>)   <span class="comment">//将1到i-1中的最大数放到a[1]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapAdjust</span>(<span class="params">a []<span class="keyword">int</span>, s, m <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">var</span> temp, j <span class="keyword">int</span></span><br><span class="line">temp = a[s]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j = <span class="number">2</span> * s; j &lt;= m; j *= <span class="number">2</span> &#123; <span class="comment">//以s为父节点开始</span></span><br><span class="line"><span class="keyword">if</span> j &lt; m &amp;&amp; a[j] &lt; a[j+<span class="number">1</span>] &#123; <span class="comment">//取出较大的孩子节点</span></span><br><span class="line">j = j + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> temp &gt;= a[j] &#123; <span class="comment">//父节点已经最大</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">a[s] = a[j] <span class="comment">//将最大的值替换给父节点</span></span><br><span class="line">s = j       <span class="comment">//将当前节点作为父节点，进行下一轮操作</span></span><br><span class="line">&#125;</span><br><span class="line">a[s] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>&#125;</span><br><span class="line">HeapAdjust(a, <span class="number">1</span>, <span class="number">9</span>)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="9-8-gui-bing-pai-xu">9.8 归并排序</span><a href="#9-8-gui-bing-pai-xu" class="header-anchor">#</a></h4><p>归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的段序列合并成一个有 序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定 性。那么，在短的有序序列合并的过程中，稳定是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。</p><p>递归方法<img src="https://upload-images.jianshu.io/upload_images/1863961-494a82286018f65f.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><p>Merge()归并排序示意图：<img src="https://upload-images.jianshu.io/upload_images/1863961-cfe727471bdad794.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将a排序到b</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergeSort</span>(<span class="params">a []<span class="keyword">int</span></span>) []<span class="title">int</span></span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(a)</span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, length)</span><br><span class="line"></span><br><span class="line">MSort(a, b, <span class="number">1</span>, length<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MSort</span>(<span class="params">a, b []<span class="keyword">int</span>, s, t <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> s == t &#123;</span><br><span class="line">b[s] = a[s] <span class="comment">//将a复制到到b</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m := (s + t) / <span class="number">2</span></span><br><span class="line">MSort(a, b, s, m)</span><br><span class="line">MSort(a, b, m+<span class="number">1</span>, t)</span><br><span class="line">Merge(b, s, m, t) <span class="comment">//将b归并排序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Merge</span>(<span class="params">SR []<span class="keyword">int</span>, i, m, n <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">TR := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(SR)) <span class="comment">//归并的序列暂存到TR</span></span><br><span class="line"></span><br><span class="line">s := i <span class="comment">//保存起始位置</span></span><br><span class="line">j := m + <span class="number">1</span></span><br><span class="line">k := i <span class="comment">//TR序号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &lt;= m &amp;&amp; j &lt;= n &#123;</span><br><span class="line"><span class="keyword">if</span> SR[i] &lt; SR[j] &#123;</span><br><span class="line">TR[k] = SR[i]</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">TR[k] = SR[j]</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &lt;= m &#123;</span><br><span class="line"><span class="keyword">for</span> l := <span class="number">0</span>; l &lt;= m-i; l++ &#123;</span><br><span class="line">TR[k+l] = SR[i+l]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> j &lt;= n &#123;</span><br><span class="line"><span class="keyword">for</span> l := <span class="number">0</span>; l &lt;= n-j; l++ &#123;</span><br><span class="line">TR[k+l] = SR[j+l]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p := s; p &lt;= n; p++ &#123; <span class="comment">//将排好序的TR写回到SR</span></span><br><span class="line"><span class="keyword">if</span> SR[p] != TR[p] &#123;</span><br><span class="line">SR[p] = TR[p]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">16</span>&#125;</span><br><span class="line">fmt.Println(MergeSort(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergeSort2</span>(<span class="params">a []<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(a) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k := <span class="number">1</span>; k &lt; length; &#123;</span><br><span class="line">MergePass(a, k, length)</span><br><span class="line">k = k * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MergePass</span>(<span class="params">a []<span class="keyword">int</span>, s, n <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= n<span class="number">-2</span>*s+<span class="number">1</span> &#123;</span><br><span class="line">Merge2(a, i, i+s<span class="number">-1</span>, i+<span class="number">2</span>*s<span class="number">-1</span>) <span class="comment">//i+2*s-1&lt;=n</span></span><br><span class="line">i = i + <span class="number">2</span>*s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &lt; n-s+<span class="number">1</span> &#123; <span class="comment">//n&gt;i+s-1,归并最后两个子块</span></span><br><span class="line">Merge2(a, i, i+s<span class="number">-1</span>, n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Merge2</span>(<span class="params">SR []<span class="keyword">int</span>, i, m, n <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">TR := <span class="built_in">make</span>([]<span class="keyword">int</span>, n-i+<span class="number">1</span>) <span class="comment">//与Merge相比栈空间更小</span></span><br><span class="line"></span><br><span class="line">s := i <span class="comment">//保存起始位置</span></span><br><span class="line">j := m + <span class="number">1</span></span><br><span class="line">k := <span class="number">0</span> <span class="comment">//TR序号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &lt;= m &amp;&amp; j &lt;= n &#123;</span><br><span class="line"><span class="keyword">if</span> SR[i] &lt; SR[j] &#123;</span><br><span class="line">TR[k] = SR[i]</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">TR[k] = SR[j]</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">k++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &lt;= m &#123;</span><br><span class="line"><span class="keyword">for</span> l := <span class="number">0</span>; l &lt;= m-i; l++ &#123;</span><br><span class="line">TR[k+l] = SR[i+l]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> j &lt;= n &#123;</span><br><span class="line"><span class="keyword">for</span> l := <span class="number">0</span>; l &lt;= n-j; l++ &#123;</span><br><span class="line">TR[k+l] = SR[j+l]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p := s; p &lt;= n; p++ &#123; <span class="comment">//将排好序的TR写回到SR</span></span><br><span class="line"><span class="keyword">if</span> SR[p] != TR[p-s] &#123;</span><br><span class="line">SR[p] = TR[p-s]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">3</span>, <span class="number">41</span>, <span class="number">7</span>, <span class="number">55</span>, <span class="number">21</span>&#125;</span><br><span class="line">MergeSort2(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="9-9-kuai-su-pai-xu">9.9 快速排序</span><a href="#9-9-kuai-su-pai-xu" class="header-anchor">#</a></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span>(<span class="params">a []<span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">Qsort(a, <span class="number">1</span>, <span class="built_in">len</span>(a)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Qsort</span>(<span class="params">a []<span class="keyword">int</span>, low, high <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> low &lt; high &#123;</span><br><span class="line">pivot := Partition(a, low, high)</span><br><span class="line"></span><br><span class="line">Qsort(a, low, pivot<span class="number">-1</span>)</span><br><span class="line">Qsort(a, pivot+<span class="number">1</span>, high)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Partition</span>(<span class="params">a []<span class="keyword">int</span>, low, high <span class="keyword">int</span></span>) <span class="title">int</span></span> &#123;</span><br><span class="line">pivotValue := a[low]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line"><span class="keyword">for</span> pivotValue &lt;= a[high] &#123; <span class="comment">//找出a[high]&lt;pivotValue</span></span><br><span class="line">high--</span><br><span class="line">&#125;</span><br><span class="line">a[low], a[high] = a[high], a[low] <span class="comment">//将a[hign]放到pivoValue左边</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> low &lt; high &amp;&amp; pivotValue &gt;= a[low] &#123; <span class="comment">//找出a[low]&gt;pivotValue</span></span><br><span class="line">low++</span><br><span class="line">&#125;</span><br><span class="line">a[low], a[high] = a[high], a[low] <span class="comment">//将a[low]放到pivoValue右边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> low</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Partition2</span>(<span class="params">a []<span class="keyword">int</span>, low, high <span class="keyword">int</span></span>) <span class="title">int</span></span> &#123;</span><br><span class="line">pivotValue := a[low]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line"><span class="keyword">for</span> pivotValue &lt;= a[high] &#123; <span class="comment">//找出a[high]&lt;pivotValue</span></span><br><span class="line">high--</span><br><span class="line">&#125;</span><br><span class="line">a[low] = a[high] <span class="comment">//将a[hign]放到较低的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> low &lt; high &amp;&amp; pivotValue &gt;= a[low] &#123; <span class="comment">//找出a[low]&gt;pivotValue</span></span><br><span class="line">low++</span><br><span class="line">&#125;</span><br><span class="line">a[high] = a[low] <span class="comment">//将a[low]放到较高的位置</span></span><br><span class="line">&#125;</span><br><span class="line">a[low] = pivotValue</span><br><span class="line"><span class="keyword">return</span> low</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">90</span>, <span class="number">30</span>, <span class="number">70</span>, <span class="number">40</span>, <span class="number">80</span>, <span class="number">60</span>, <span class="number">20</span>&#125;</span><br><span class="line">QuickSort(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1863961-25127e3a301cf527.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://hejtao.netlify.com/tags/Golang/"/>
    
      <category term="长文" scheme="https://hejtao.netlify.com/tags/%E9%95%BF%E6%96%87/"/>
    
      <category term="数据结构" scheme="https://hejtao.netlify.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Go内存模型</title>
    <link href="https://hejtao.netlify.com/2018/11/14/2018-11-14/"/>
    <id>https://hejtao.netlify.com/2018/11/14/2018-11-14/</id>
    <published>2018-11-13T16:00:00.000Z</published>
    <updated>2019-11-11T19:59:33.199Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><div class="toc"><!-- toc --><ul><li><a href="#1-shi-me-shi-go-nei-cun-mo-xing">1. 什么是 Go内存模型？</a></li><li><a href="#2-happens-before">2. Happens Before</a></li><li><a href="#3-synchronization">3. Synchronization</a><ul><li><a href="#3-1-initialization">3.1 Initialization</a></li><li><a href="#3-2-goroutine-creation">3.2 Goroutine creation</a></li><li><a href="#3-3-goroutine-destruction">3.3 Goroutine destruction</a></li><li><a href="#3-4-channel-communication">3.4 Channel communication</a></li><li><a href="#3-5-locks">3.5 Locks</a></li><li><a href="#3-6-once">3.6 Once</a></li></ul></li><li><a href="#4-incorrect-synchronization">4. Incorrect synchronization</a></li></ul><!-- tocstop --></div><p>本文主要翻译自官方文档 <a href="https://golang.org/ref/mem" target="_blank" rel="noopener">The Go Memory Model</a></p><h3><span id="1-shi-me-shi-go-nei-cun-mo-xing">1. 什么是 Go内存模型？</span><a href="#1-shi-me-shi-go-nei-cun-mo-xing" class="header-anchor">#</a></h3><p>我们知道不同的 goroutine 可以对同一个变量进行读写操作。Go内存模型指定了在什么样的条件下可以保证一个 goroutine 写入到变量的值可以被另外一个 goroutine 正确的读取。</p><h3><span id="2-happens-before">2. Happens Before</span><a href="#2-happens-before" class="header-anchor">#</a></h3><p>在单个 goroutine 中，读、写操作按照程序设计的顺序进行。需要注意的是，在不改变 goroutine 程序行为的前提下，这些读、写顺序在编译的过程中可能会被<strong>重排</strong>。因此导致对相同变量的读、写操作在不同的 goroutine 看来执行顺序可能不同。例如，如果在某个 goroutine 中执行 a = 1; b = 2;，另一个 goroutine 可能观察到变量 b 比 a 先被赋值。</p><p>Happens Before 是针对Go语言编程中内存操作的一种局部排序。 如果 $e_{1}$ happens before  $e_{2}$，那么也可以说 $e_{2}$ happens after  $e_{1}$。进一步，如果 $e_{1}$  既不 happens before  $e_{2}$，也不 happens after  $e_{2}$，那么我们称 $e_{1}$ 和 $e_{2}$  happen concurrently (<strong>并发</strong>)。</p><blockquote><p>在单个 goroutine 中，Happens Before顺序就是程序设计的顺序</p></blockquote><p>$v$：某个变量$w$: 对$v$的写$w'$: 对$v$的写，不同于$w$$r$: 对$v$的读</p><p><strong>$w$可以被$r$获取的条件</strong>：</p><ul><li>$r$ 不 happen before $w$. (包括 happen after 和 happen concurrently)</li><li>不存在另一个 $w'$  happens after $w$ but before $r$.</li></ul><p><strong>$w$保证能被$r$获取的条件</strong>(该条件不允许$w'$与$w$或者$r$并发，因此比上面的条件更强):</p><ul><li>$w$ happens before $r$.</li><li>任何其它的 $w'$ 要么 happens before $w$，要么 happens after $r$.</li></ul><p>当有多个 goroutine 可以访问$v$时，必须利用同步事件(synchronization events)来建立 happens before 以保证 $r$能够获取想要的$w$。在初始化过程中，赋给$v$以其类型的零值的操作可以看作是内存模型中的一种$w$</p><h3><span id="3-synchronization">3. Synchronization</span><a href="#3-synchronization" class="header-anchor">#</a></h3><h4><span id="3-1-initialization">3.1 Initialization</span><a href="#3-1-initialization" class="header-anchor">#</a></h4><p>程序的初始化在一个 goroutine 中进行，并且在该 goroutine 中还可以创建其它的 goroutine</p><blockquote><p>如果包 $p$导入了包$q$，那么包$q$在被导入之前就完成了初始化，函数main.main在所有的init函数完成后开始执行，见astaxie的<a href="https://github.com/jiangtaohe/build-web-application-with-golang/blob/master/zh/02.3.md" target="_blank" rel="noopener">main函数和init函数一文</a></p></blockquote><h4><span id="3-2-goroutine-creation">3.2 Goroutine creation</span><a href="#3-2-goroutine-creation" class="header-anchor">#</a></h4><blockquote><p>启动一个新的 goroutine 的 <strong>Go</strong>声明发生在该 goroutine开始执行之前</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用hello()将会在未来某个时间点( 可能在hello()返回之后 )打印hello, world</p><h4><span id="3-3-goroutine-destruction">3.3 Goroutine destruction</span><a href="#3-3-goroutine-destruction" class="header-anchor">#</a></h4><p>无法保证 goroutine 在其创建程序中的某个位置退出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123; a = <span class="string">"hello"</span> &#125;()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 a 的写(赋值)没有进行任何同步操作，无法被其它 goroutine 获取，在激进的编译器中甚至可能会删除整个 go 声明。</p><h4><span id="3-4-channel-communication">3.4 Channel communication</span><a href="#3-4-channel-communication" class="header-anchor">#</a></h4><p>通道通信(channel communication)是同步两个 goroutine 的主要方法。</p><blockquote><p>send 发生在完成相应的 receive 之前</p></blockquote><p>程序：</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line">c &lt;- <span class="number">0</span> <span class="comment">// send</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">&lt;-c <span class="comment">// receive</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure><p>会保证打印 hello, world，因为：对 a 的写 <strong>happens before</strong> 通道 c 的 send通道 c 的 send <strong>happens before</strong> 通道 c 的 receive通道 c 的 receive <strong>happens before</strong> print(a)，因此 ,对 a 的写 <strong>happens before</strong> print(a), 即保证 main() 获取了 goroutine 对 a的写</p><blockquote><p>channel 的关闭发生在完成 receive(此时得到的是通道类型的零值)之前</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line"><span class="built_in">close</span>(c) <span class="comment">// 关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line"><span class="built_in">print</span>(a, <span class="string">"\n"</span>, &lt;-c) <span class="comment">// receive</span></span><br><span class="line">&#125;</span><br><span class="line">&gt;Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">hello, world</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>无缓存通道的 receive 发生在完成 send 之前</p></blockquote><p>调换 <code>c &lt;- 0 // send</code> 和 <code>&lt;-c // receive</code>的位置，得到程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line">&lt;-c <span class="comment">//receive</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">c &lt;- <span class="number">0</span> <span class="comment">// send</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure><p>仍然保证打印 hello, world但如果channel具有缓存，例如当<code>c = make(chan int, 1)</code>，那么程序无法保证打印 hello, world</p><blockquote><p>当通道的容量为$c$时，第 $k$ 次 receive 发生在完成第 $k+c$ 次 send 之前</p></blockquote><p>下面的程序给 work 的每个条目(函数类型)启动一个 goroutine，由于通道limit的容量为3，因此最多允许3个 goroutine 调用调用了函数w()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> limit = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, w := <span class="keyword">range</span> work &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params">w <span class="keyword">func</span>(</span>))</span> &#123;</span><br><span class="line">limit &lt;- <span class="number">1</span></span><br><span class="line">w()</span><br><span class="line">&lt;-limit</span><br><span class="line">&#125;(w)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="3-5-locks">3.5 Locks</span><a href="#3-5-locks" class="header-anchor">#</a></h4><p><code>sync</code> 包实现了两种 <code>lock</code> 数据类型, <code>sync.Mutex</code>和 <code>sync.RWMutex</code>.</p><blockquote><p>对任意的 <code>sync.Mutex</code> 或者 <code>sync.RWMutex</code>变量 <code>l</code>且$n&lt;m$，第$n$次调用  <code>l.Unlock()</code> 发生在 第 $m$次调用 <code>l.Lock()</code>返回之前</p></blockquote><p>程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> l sync.Mutex</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line">l.Unlock() <span class="comment">//第一次 l.Unlock()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">l.Lock()</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">l.Lock() <span class="comment">//第二次 l.Lock()</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure><p>保证打印hello, world，因为，第一次 <code>l.Unlock()</code>  <strong>happens before</strong>  第二次 <code>l.Lock()</code> 返回第二次 <code>l.Lock()</code> 返回 <strong>happens before</strong>  print(a)</p><blockquote><p>对于任意的<code>l.RLock</code>，存在$k$满足：第 $k$ 次调用 <code>l.Unlock</code> <strong>happens  before</strong> <code>l.RLock</code>；<br>与<code>l.RLock</code>对应的<code>l.RUnlock</code> <strong>happens before</strong> 第 $k+1$次调用 <code>l.Lock</code></p></blockquote><h4><span id="3-6-once">3.6 Once</span><a href="#3-6-once" class="header-anchor">#</a></h4><p>对某个函数<code>f()</code>，可以有多个线程通过<code>once.Do(f)</code>来对其调用，但仅有线程能够调用执行函数<code>f()</code>，其它的调用会被阻塞知道<code>f()</code>返回。</p><p>程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SETUP</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="string">"HELLO, WORLD"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doprint</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">once.Do(setup) <span class="comment">//注意不要括号</span></span><br><span class="line">once.Do(SETUP)</span><br><span class="line"><span class="built_in">print</span>(a, <span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> doprint()</span><br><span class="line"><span class="keyword">go</span> doprint()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output:</span><br><span class="line">command-line-arguments</span><br><span class="line">hello, world</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure><p>会打印两次 hello, world，但是仅在第一次调用 doprint 时执行了 setup</p><h3><span id="4-incorrect-synchronization">4. Incorrect synchronization</span><a href="#4-incorrect-synchronization" class="header-anchor">#</a></h3><p>程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="built_in">print</span>(b, <span class="string">"\n"</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> f()</span><br><span class="line">g()</span><br><span class="line">&#125;</span><br><span class="line">&gt; Output: <span class="comment">//大多数输出结果</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt; Output: <span class="comment">//少数输出结果</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>也可能先打印2，然后打印0</p><p>程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="string">"hello, world \n"</span></span><br><span class="line">done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doprint</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !done &#123;</span><br><span class="line">setup()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoprint</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> doprint()</span><br><span class="line"><span class="keyword">go</span> doprint()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">twoprint()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有3种输出的可能</span></span><br><span class="line">&gt; Output:</span><br><span class="line">hello, world </span><br><span class="line">hello, world </span><br><span class="line">&gt; Output:</span><br><span class="line">hello, world </span><br><span class="line">&gt; Output:</span><br></pre></td></tr></table></figure><p>下面的程序，由于不能保证main()先获取对done的写，因此print()可能打印空字符串。甚至main()完全没有获取对done的写，此时main()进入死循环</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">a = <span class="string">"hello, world"</span></span><br><span class="line">done = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> setup()</span><br><span class="line"><span class="keyword">for</span> !done &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; Output:</span><br><span class="line">hello, world</span><br><span class="line">&gt; Elapsed: <span class="number">3.703</span>s  <span class="comment">//等待了较长的时间</span></span><br><span class="line">&gt; Result: Success</span><br><span class="line">&gt; Output:</span><br><span class="line">hello, world</span><br><span class="line">&gt; Elapsed: <span class="number">0.704</span>s </span><br><span class="line">&gt; Result: Success</span><br></pre></td></tr></table></figure><p>类似的程序如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">msg <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g *T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">t := <span class="built_in">new</span>(T)</span><br><span class="line">t.msg = <span class="string">"hello, world"</span></span><br><span class="line">g = t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">go</span> setup()</span><br><span class="line"><span class="keyword">for</span> g == <span class="literal">nil</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(g.msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://hejtao.netlify.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>搭建IPFS 私有网络</title>
    <link href="https://hejtao.netlify.com/2018/11/05/2018-11-5/"/>
    <id>https://hejtao.netlify.com/2018/11/05/2018-11-5/</id>
    <published>2018-11-04T16:00:00.000Z</published>
    <updated>2019-11-11T19:59:33.200Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><div class="toc"><!-- toc --><ul><li><a href="#zai-servers-shang-an-zhuang-go-huan-jing">在servers上安装 Go 环境</a></li><li><a href="#sheng-cheng-ifps-jie-dian">生成 ifps 节点</a></li><li><a href="#chuang-jian-gong-xiang-mi-yao">创建共享密钥</a></li><li><a href="#tian-jia-qi-dong-jie-dian">添加启动节点</a></li><li><a href="#qi-dong-si-you-wang-luo">启动私有网络</a></li></ul><!-- tocstop --></div><p>本例为建立包含三个节点的IPFS私有网络，节点分别为：server a: root@45.32.28.71server b: root@207.148.109.110本地 mac</p><h3><span id="zai-servers-shang-an-zhuang-go-huan-jing">在servers上安装 Go 环境</span><a href="#zai-servers-shang-an-zhuang-go-huan-jing" class="header-anchor">#</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd ~ </span><br><span class="line">$wget https://dl.google.com/go/go1.11.2.linux-amd64.tar.gz</span><br><span class="line">$tar -C /usr/local -xzf go1.11.2.linux-amd64.tar.gz    //解压到得到的 go 目录，放到 /usr/local 目录下</span><br><span class="line">$vim .bashrc</span><br><span class="line">export GOPATH=~/hejtao/go_projects</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOBIN=$GOROOT/bin</span><br><span class="line">export PATH=$PATH:$GOBIN</span><br><span class="line">$source .bashrc</span><br><span class="line">$go version </span><br><span class="line">go version go1.11.2 linux/amd64  //安装成功</span><br></pre></td></tr></table></figure><p>mac 上的安装类似。</p><h3><span id="sheng-cheng-ifps-jie-dian">生成 ifps 节点</span><a href="#sheng-cheng-ifps-jie-dian" class="header-anchor">#</a></h3><p>在三台机器上执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$go get -u -d github.com/ipfs/go-ipfs         </span><br><span class="line">$cd $GOPATH/src/github.com/ipfs/go-ipfs</span><br><span class="line">$make install</span><br><span class="line">Command &apos;make&apos; not found, but can be installed with:</span><br><span class="line"></span><br><span class="line">sudo apt install make</span><br><span class="line">sudo apt install make-guile</span><br><span class="line">$apt update        \\ 需要安装 make ， 先检查安装包</span><br><span class="line">...</span><br><span class="line">$apt upgrade        \\ 更新安装包</span><br><span class="line">...</span><br><span class="line">$apt install make      \\ 安装 make</span><br><span class="line">...</span><br><span class="line">$make install</span><br><span class="line">/usr/local/go/pkg/tool/linux_amd64/link: running gcc failed: exec: &quot;gcc&quot;: executable file not found in $PATH</span><br><span class="line"></span><br><span class="line">cmd/ipfs/Rules.mk:37: recipe for target &apos;cmd/ipfs-install&apos; failed</span><br><span class="line">make: *** [cmd/ipfs-install] Error 2</span><br><span class="line"></span><br><span class="line">$apt install gcc</span><br><span class="line">...</span><br><span class="line">$gcc -v</span><br><span class="line">...</span><br><span class="line">gcc version 7.3.0 (Ubuntu 7.3.0-27ubuntu1~18.04)</span><br><span class="line">$make install</span><br><span class="line">...</span><br><span class="line">$ipfs init</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>记下每个节点的ID，比如本例server a 的ID: <strong>QmQ9RjTGVDjhZ2kRVx9tjL4CciiKdNrQzknSyUnCMmB3m2</strong>server b 的ID: <strong>QmRyxoe9JpkDZuMK4G7PkXUy7nGv8VdM98d6Vr2wxFSa3V</strong>mac 的ID: <strong>QmWKKVUy9XqWEGhrikJW8ugHuFzKJJGP5DCGFyvzUJFjzL</strong></p><h3><span id="chuang-jian-gong-xiang-mi-yao">创建共享密钥</span><a href="#chuang-jian-gong-xiang-mi-yao" class="header-anchor">#</a></h3><p>先在任意一台机器上创建密钥，然后拷贝到剩余节点。本例在mac上创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$go get -u github.com/Kubuxu/go-ipfs-swarm-key-gen/ipfs-swarm-key-gen</span><br><span class="line">$ipfs-swarm-key-gen &gt; ~/.ipfs/swarm.key</span><br></pre></td></tr></table></figure><ul><li>手动拷贝</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$vim ~/.ipfs/swarm.key        \\ 打开swarm.key, 拷贝内容</span><br></pre></td></tr></table></figure><p>在servers上新建swarm.key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$vim ~/.ipfs/swarm.key        \\ 将拷贝的内容粘贴</span><br></pre></td></tr></table></figure><ul><li>使用 <code>scp</code> 命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$scp ~/.ipfs/swarm.key root@45.32.28.71:~/.ipfs/</span><br><span class="line">$scp ~/.ipfs/swarm.key root@207.148.109.110:~/.ipfs/</span><br></pre></td></tr></table></figure><h3><span id="tian-jia-qi-dong-jie-dian">添加启动节点</span><a href="#tian-jia-qi-dong-jie-dian" class="header-anchor">#</a></h3><p><code>pfs init</code>后的默认启动节点是连接ipfs公网的节点。建立私有网络需要在<strong>每一个节点上</strong>删掉默认启动节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ipfs bootstrap rm --all</span><br></pre></td></tr></table></figure><p>将网络中任意其他节点作为启动节点。例如将 server a 作为mac的启动节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ipfs bootstrap add/ip4/45.32.28.71/tcp/4001/ipfs/QmQ9RjTGVDjhZ2kRVx9tjL4CciiKdNrQzknSyUnCMmB3m2</span><br></pre></td></tr></table></figure><h3><span id="qi-dong-si-you-wang-luo">启动私有网络</span><a href="#qi-dong-si-you-wang-luo" class="header-anchor">#</a></h3><p>给三个节点添加了启动节点后，启动所有节点，便建立起了含有三个节点的IPFS私有网络。分别执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ipfs daemon</span><br></pre></td></tr></table></figure><p>可以使用 <figure class="highlight plain"><figcaption><span>bootstrap list```查看节点所包含的启动节点，使用```ipfs swarm peers```查看节点连接了哪些其他节点。使用```ipfs add file```上传文件到节点，比如给mac节点上传pdf文件，并得到该文件的ID</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">$ipfs add ~/files/GO语言编程.pdf</span><br></pre></td></tr></table></figure></p><p>该文件的ID：<strong>QmRDqZoSMCLMP2GH66MKKnduqgTqKBfqNeysPugp9xadUi</strong>。现在与mac建立了连接的server就可以下载该文件了，在server上执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ipfs get QmRDqZoSMCLMP2GH66MKKnduqgTqKBfqNeysPugp9xadUi        \\在当前目录会多出一个新的文件便是get到的文件</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="IPFS" scheme="https://hejtao.netlify.com/tags/IPFS/"/>
    
  </entry>
  
  <entry>
    <title>A Study for the Reed-Solomon Code</title>
    <link href="https://hejtao.netlify.com/2018/10/18/2018-10-18/"/>
    <id>https://hejtao.netlify.com/2018/10/18/2018-10-18/</id>
    <published>2018-10-18T04:11:11.000Z</published>
    <updated>2019-11-11T19:59:33.199Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><div class="toc"><!-- toc --><ul><li><a href="#introduction">Introduction</a></li><li><a href="#galois-field">Galois Field</a></li><li><a href="#galois-field-arithmetic">Galois Field Arithmetic</a><ul><li><a href="#addition-and-subtraction">Addition and Subtraction</a></li><li><a href="#multiplication-and-division">Multiplication and Division</a></li></ul></li><li><a href="#rs-code">RS Code</a><ul><li><a href="#coding-matrix-method">Coding Matrix Method</a></li><li><a href="#generator-polynomial-method">Generator Polynomial Method</a></li></ul></li><li><a href="#rs-code-in-distributed-storage-systems">RS Code in Distributed Storage Systems</a><ul><li><a href="#5-1-rotated-reed-solomon-code">5.1 Rotated Reed-Solomon code</a></li></ul><ul><li><a href="#local-reconstruction-code-lrc">Local Reconstruction Code (LRC)</a></li></ul></li><li><a href="#references">References</a></li></ul><!-- tocstop --></div><h3><span id="introduction">Introduction</span><a href="#introduction" class="header-anchor">#</a></h3><p>Reed-Solomon (RS) code is an error-correcting code first proposed by Reed and Solomon in 1960, which is the most frequently applied digital error correction code around the word. The applications include data storage(hard drives, CD/DVD/Blue Ray), data transmission and common commercial activities(bar codes, QR codes) .RS code has the advantage of high capability of correcting  random or burst errors since it encodes  groups of bits instead of one bit at a time. Redundant datas are generated  so that the original data can be reconstructed with part of the stored or received data loss.  People often back up important files which can be regarded as kind of  data loss protection with redundant data. However, backup is just a copy of the original datas while the redundant data generated in the RS code is a  fusion of the all the original data parts, which is more efficient for storage and error correction.In this article, I have run through the procedure of the RS code and hope it is usefull for you to understand what is going on with this erasure code. Its application in the distributed strorage system are briefly introduced at the end. Part of implementations in pure Go are also provided whose source files can be found on the <a href="https://github.com/klauspost/reedsolomon" target="_blank" rel="noopener">Githup website</a> .</p><h3><span id="galois-field">Galois Field</span><a href="#galois-field" class="header-anchor">#</a></h3><p>The finite field is also called Galois field which has finite elements  and the property that arithmetic operations on field elements always have a result in the field. In the sequel, we illustrate two kind of representations of the finite elements and its arithmetic operations.</p><blockquote><p><strong>Proposition 1.</strong> For any prime $ p $ and any natual number$ r $ there exists a finite field with $ p^{r} $ elements and vice versa.</p></blockquote><p>With the proposition 1, the Galois Field is denoted as $ GF(p^{r}) $. In fact, the nature of RS encoding is mapping $ k $ elments of $ GF(2^{r}) $ into another $ n $ elements of $ GF(2^{r}) $ and $k+2\leq n\leq 2^{r} $. This Galois fields can be represented with the help of $ \mathbf{Z}<em>{2}[x] $, the set of polynomials with coefficients in the field of two elements $ \mathbf{Z}</em>{2} $, namely the polynomial representation as$$0,1,x,x+1,x<sup>{2},..,x</sup>{r-1}+x^{r-2}+...+1 \tag{1}$$This representation  can also be seen as a $r$-bit digit or binary vector.</p><blockquote><p><strong>Proposition 2.</strong> $ GF(q) $ has cyclic the multiplicative group $ {\alpha, \alpha<sup>{2},...,\alpha</sup>{q-1}=1}$, where $ \alpha $ is the primitive element.</p></blockquote><p>Thus, $ GF(2^{r}) $ has the exponential representation as$$0, 1(=\alpha^{255}), \alpha, \alpha^{2},..., \alpha<sup>{2</sup>{r}-2} \tag{2}$$which is a better choice for the '$ \times $' and '$ / $'  operation. Even a binary matrix can be used to  represente the elements. For example, we can establish a bijection between the vector representation and matrix representation over $ GF(2^{4}) $ as follows</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-ea01dad7bef4b4f4.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Matrix representation"></p><p>where the first column is the vector representation and the columns satisfy $column(i)=2\times column(i-1)$. This matrix representation transforms arithmetic over $ GF(2^{4}) $ into arithmetic over $ GF(2) $ which only has XOR, AND operations.</p><h3><span id="galois-field-arithmetic">Galois Field Arithmetic</span><a href="#galois-field-arithmetic" class="header-anchor">#</a></h3><p>In this section, we discuss  arithmetic in $ GF(2^{8}) $, whose element corresponds a byte data.</p><h4><span id="addition-and-subtraction">Addition and Subtraction</span><a href="#addition-and-subtraction" class="header-anchor">#</a></h4><p>Addition and subtraction are operated under the polynomial representation (also a byte in $ GF(2^{8}) $) and both are equivalent to XOR operation</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">galAdd</span>(<span class="params">a, b <span class="keyword">byte</span></span>) <span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a ^ b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">galSub</span>(<span class="params">a, b <span class="keyword">byte</span></span>) <span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a ^ b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="multiplication-and-division">Multiplication and Division</span><a href="#multiplication-and-division" class="header-anchor">#</a></h4><p>The multiplication is operated with the exponential representation $(2)$, before that we should establish a bijection (injection and surjection) between the two representations. Suppose$$\alpha^{i}   -&gt;  2^{i}$$where $0\leq i \leq 2^{8}-2=254$. According to proposition 2, $\forall j\geq 255,\alpha<sup>{j}=\alpha</sup>{j-255}$.</p><blockquote><p><strong>Proposition 3.</strong>$ GF(2^{8}) $ has the irreducible polynomial $ f(x)=x<sup>{8}+x</sup>{4}+x<sup>{3}+x</sup>{2}+1 $ which has no factors of smaller polynomials.</p></blockquote><p>The irreducible polynomial is necessary to establish the bijection since some $2^{i}$ term are no longer in  $GF(2^{8})$. Let $ f(\alpha) =0$, we have $$\alpha<sup>{8}=\alpha</sup>{4}+\alpha<sup>{3}+\alpha</sup>{2}+1=2<sup>{4}+2</sup>{3}+2^{2}+1=00011101$$or <strong>0x1d</strong> . For convenience, we record the bijection with a table, namely called exponent table, whose indexs is the exponents of elements in exponential representation and value is elements in byte representation.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expTable = [<span class="number">255</span>]<span class="keyword">byte</span>&#123;<span class="number">0x1</span>, <span class="number">0x2</span>, <span class="number">0x4</span>, <span class="number">0x8</span>, <span class="number">0x10</span>, <span class="number">0x20</span>, <span class="number">0x40</span>, <span class="number">0x80</span>, <span class="number">0x1d</span>, <span class="number">0x3a</span>, ..., <span class="number">0x8e</span>&#125;</span><br></pre></td></tr></table></figure><p>Use logTable[expTable[$i$]]=$i$, the logarithmic table is generated,</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> logTable = []<span class="keyword">byte</span>&#123;</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">25</span>, <span class="number">2</span>, <span class="number">50</span>, <span class="number">26</span>, <span class="number">198</span>,</span><br><span class="line">...</span><br><span class="line"><span class="number">116</span>, <span class="number">214</span>, <span class="number">244</span>, <span class="number">234</span>, <span class="number">168</span>, <span class="number">80</span>, <span class="number">88</span>, <span class="number">175</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>With these tables, the $\times$ and $/$ functions in $GF(2^8)$ are easily defined,</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">galMultiply</span>(<span class="params">a, b <span class="keyword">byte</span></span>) <span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a == <span class="number">0</span> || b == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logA := <span class="keyword">int</span>(logTable[a])</span><br><span class="line">logB := <span class="keyword">int</span>(logTable[b])</span><br><span class="line"></span><br><span class="line">sum := logA+logB</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sum&gt;<span class="number">254</span> &#123;</span><br><span class="line">        sum -= <span class="number">255</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> expTable[sum]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">galDivide</span>(<span class="params">a, b <span class="keyword">byte</span></span>) <span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"Argument 'divisor' is 0"</span>)</span><br><span class="line">&#125;</span><br><span class="line">logA := <span class="keyword">int</span>(logTable[a])</span><br><span class="line">logB := <span class="keyword">int</span>(logTable[b])</span><br><span class="line">logResult := logA - logB</span><br><span class="line"><span class="keyword">if</span> logResult &lt; <span class="number">0</span> &#123;</span><br><span class="line">logResult += <span class="number">255</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> expTable[logResult]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Based on the result above, the power and inverse functions can be further obtained. In fact, the method to establish the bijection is not unique. The original paper of Reed and Solomon in 1960 provides another method  with finite difference equation which has better computability.</p><h3><span id="rs-code">RS Code</span><a href="#rs-code" class="header-anchor">#</a></h3><h4><span id="coding-matrix-method">Coding Matrix Method</span><a href="#coding-matrix-method" class="header-anchor">#</a></h4><p><strong>1.</strong> Orignal approach:For arbitrary $ k $  8-bit symbols,$ m_{0}$,  $m_{1}$,  $...$,  $m_{k-1} $, we have the message polynomial$$m(x)=m_{0}+m_{1}x+...+m_{k-1}x^{k-1},$$with this $ m(x) $, $ 2^{8} $ codewords, i.e. $ m(0)$,$m(1)$,$...$,  $m(\alpha^{r-2}) $ are obtained and the  the encoded messages, which will be transmitted or stored, are $ n $ of the codewords (professionally called stripe).  Using linear algebra, the stripe are denoted collectively as follows$$\begin{bmatrix}m(\alpha_{1})\m(\alpha_{2})\...\m(\alpha_{n})\end{bmatrix} =\begin{bmatrix}1 &amp; \alpha_{1} &amp; ... &amp; \alpha_{1}^{k-1} \1 &amp; \alpha_{2} &amp; ...&amp;\alpha_{2}^{k-1} \... &amp; ... &amp; ...&amp;... \1 &amp; \alpha_{n} &amp; ...&amp;\alpha_{n}^{k-1}\end{bmatrix} \begin{bmatrix}m_{0}\m_{1}\...\m_{k-1}\end{bmatrix}\tag{3}$$Note that  we only discuss one byte a shard (the messages are splited into multiple shards for encoding) here, in practice  one input shard contains thousands of bytes, in this case the output shard contains same size of byte as input shard and the vectors in $(3)$ becomes matrice.</p><blockquote><p><strong>Coding procedure :</strong> <br>1.Split the whole message into same size data shards;  <br>2. Build the  Vandermonde matrix (coding matrix); <br>3. Multiplies the coding matrix by data shards to produce code shards.</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">r reedSolomon</span>) <span class="title">Split</span>(<span class="params">data []<span class="keyword">byte</span></span>) (<span class="params">[][]<span class="keyword">byte</span>, error</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrShortData</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Calculate number of bytes per data shard.</span></span><br><span class="line">perShard := (<span class="built_in">len</span>(data) + r.DataShards - <span class="number">1</span>) / r.DataShards</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span>(data) &gt; <span class="built_in">len</span>(data) &#123;</span><br><span class="line">data = data[:<span class="built_in">cap</span>(data)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only allocate memory if necessary</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(data) &lt; (r.Shards * perShard) &#123;</span><br><span class="line"><span class="comment">// Pad data to r.Shards*perShard.</span></span><br><span class="line">padding := <span class="built_in">make</span>([]<span class="keyword">byte</span>, (r.Shards*perShard)-<span class="built_in">len</span>(data))</span><br><span class="line">data = <span class="built_in">append</span>(data, padding...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Split into equal-length shards.</span></span><br><span class="line">dst := <span class="built_in">make</span>([][]<span class="keyword">byte</span>, r.Shards)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> dst &#123;</span><br><span class="line">dst[i] = data[:perShard]</span><br><span class="line">data = data[perShard:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dst, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">vandermonde</span>(<span class="params">rows, cols <span class="keyword">int</span></span>) (<span class="params">matrix, error</span>)</span> &#123;</span><br><span class="line">result, err := newMatrix(rows, cols)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> r, row := <span class="keyword">range</span> result &#123;</span><br><span class="line"><span class="keyword">for</span> c := <span class="keyword">range</span> row &#123;</span><br><span class="line">result[r][c] = galExp(<span class="keyword">byte</span>(r), c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiplies a subset of rows from a coding matrix by a full set of</span></span><br><span class="line"><span class="comment">// input shards to produce some output shards.</span></span><br><span class="line"><span class="comment">// 'matrixRows' is The rows from the matrix to use.</span></span><br><span class="line"><span class="comment">// 'inputs' An array of byte arrays, each of which is one input shard.</span></span><br><span class="line"><span class="comment">// The number of inputs used is determined by the length of each matrix row.</span></span><br><span class="line"><span class="comment">// outputs Byte arrays where the computed shards are stored.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">r reedSolomon</span>) <span class="title">codeSomeShards</span>(<span class="params">matrixRows, inputs, outputs [][]<span class="keyword">byte</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> c := <span class="number">0</span>; c &lt; r.DataShards; c++ &#123;</span><br><span class="line">in := inputs[c]</span><br><span class="line"><span class="keyword">for</span> iRow := <span class="number">0</span>; iRow &lt; outputCount; iRow++ &#123;</span><br><span class="line"><span class="keyword">if</span> c == <span class="number">0</span> &#123;</span><br><span class="line">galMulSlice(matrixRows[iRow][c], in, outputs[iRow], r.o.useSSSE3, r.o.useAVX2)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">galMulSliceXor(matrixRows[iRow][c], in, outputs[iRow], r.o.useSSSE3, r.o.useAVX2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Since any $ k $ rows of Vandermonde matrix are linearly independent, with arbitrary $ k $ correct code shards, the original $ k $  data shards can be reconstructed by multiplying the corresponding inverse matrix. However, in practice, we usually do not know which one is correct or corrupted for the $ n $ received codewords. In this case, the plurality of votes method is necessary and$$\left(\begin{array}{c}n-s\k\end{array} \right)&gt;\left(\begin{array}{c}s+k-1\k\end{array} \right)$$or$$s&lt;\frac{n-k+1}{2}$$where $s$ is number of unkown errors, therefore $ n=k+2s $ always satisfies the in-equation. Another approach is to use the Berlekamp-Welsh Algorithm  which avoids the heavy computation of votes:</p><blockquote><p><strong>Berlekamp-Welsh decoder:</strong><br> 1. Send $m(0),m(1),...,m(n)$,  receive $m'(0),m'(1),...,m'(n)$, and most $s$ of  them such that $m(i)\neq m'(i)$；<br> 2.  $E(x)=x<sup>{s}+b_{s-1}x</sup>{s-1}+...+b_{0}$, $Q(x)=a_{k+s-1}x<sup>{k+s-1}+a_{k+s-2}x</sup>{k+s-2}+...+a_{0}$ <br> 3. Solve the coefficients of co$E(x)$,$Q(x)$ with $  Q(i)=m'(i)E(i)$ <br>4. Derive $m(x)=Q(x)/E(x)$.</p></blockquote><p>And $\forall m(i)\neq m'(i)$,$E(i)=0$.<strong>The implicite principle:</strong> $Q'(x)/E'(x)$ and $Q(x)/E(x)$  agree on at least $k+s$ points. $E'(x)$  and  $E(x)$ both have at most $s$ zero points. Elimilate $E'(x)$  and  $E(x)$,$Q'(x)/E'(x)$ and $Q(x)/E(x)$ are degree at least $k-1$ and agree on at least $k$ points, thus $Q'(x)/E'(x)=Q(x)/E(x)=m(x)$.<br><strong>2.</strong> Systematic coding matrix:</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-aceb4a25d416d295.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""><br></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-8b2f627ce05e386f.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""><br></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-7404acc2dbc829e4.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""><br></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-df23756e41d208b3.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""><br></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-8c7bbe0310c9efea.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""><br></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-d69a32352af4c86a.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""><br></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-c0a5889de5a6bd1d.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""><br></p><p>In the original approach, all the code shards have been encoded. While in the systematic encoding, the original data shards become part of the code shards and only the parity shards should be encoded. In other words, the stripe contains the original datas and parity codewords together no longer codewords only. The coding matrix is composed of  the top square identity matrix and the parity matrix. There are three methods of building the coding matrix in this systematic way are provided:</p><ul><li>Elementary transform on the Vandermonde matrix as the procedure 1.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildMatrix</span>(<span class="params">dataShards, totalShards <span class="keyword">int</span></span>) (<span class="params">matrix, error</span>)</span> &#123;</span><br><span class="line">vm, err := vandermonde(totalShards, dataShards)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">top, err := vm.SubMatrix(<span class="number">0</span>, <span class="number">0</span>, dataShards, dataShards)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">topInv, err := top.Invert()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> vm.Multiply(topInv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Parity matrix is Vandermonde matrix.</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildMatrixPAR1</span>(<span class="params">dataShards, totalShards <span class="keyword">int</span></span>) (<span class="params">matrix, error</span>)</span> &#123;</span><br><span class="line">result, err := newMatrix(totalShards, dataShards)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> r, row := <span class="keyword">range</span> result &#123;</span><br><span class="line"><span class="comment">// The top portion of the matrix is the identity</span></span><br><span class="line"><span class="comment">// matrix, and the bottom is a transposed Vandermonde</span></span><br><span class="line"><span class="comment">// matrix starting at 1 instead of 0.</span></span><br><span class="line"><span class="keyword">if</span> r &lt; dataShards &#123;</span><br><span class="line">result[r][r] = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> c := <span class="keyword">range</span> row &#123;</span><br><span class="line">result[r][c] = galExp(<span class="keyword">byte</span>(c+<span class="number">1</span>), r-dataShards)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Parity matrix is Cauchy matrix. Cauchy matrices are easier to invert than general matrices [8].</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildMatrixCauchy</span>(<span class="params">dataShards, totalShards <span class="keyword">int</span></span>) (<span class="params">matrix, error</span>)</span> &#123;</span><br><span class="line">result, err := newMatrix(totalShards, dataShards)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> r, row := <span class="keyword">range</span> result &#123;</span><br><span class="line"><span class="comment">// The top portion of the matrix is the identity</span></span><br><span class="line"><span class="comment">// matrix, and the bottom is a transposed Cauchy matrix.</span></span><br><span class="line"><span class="keyword">if</span> r &lt; dataShards &#123;</span><br><span class="line">result[r][r] = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> c := <span class="keyword">range</span> row &#123;</span><br><span class="line">result[r][c] = invTable[(<span class="keyword">byte</span>(r ^ c))]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="generator-polynomial-method">Generator Polynomial Method</span><a href="#generator-polynomial-method" class="header-anchor">#</a></h4><p>Define the generator polynomial:</p><p>$$g(x)=(x-\alpha)(x-\alpha<sup>{2})\dots(x-\alpha</sup>{2s})$$and the codeword polynomial can be directly computed as$$c(x)=m(x)g(x)$$For the systematic form, which is more often used in practice, we define$$b(x)=x^{2s}m(x) \quad mod\quad g(x)$$then the codeword polynomial becomes$$c(x)=x^{2s}m(x)-b(x)$$</p><p>where $-b(x)$ is the parity  codeword polynomial. All the polynomial operation above is processed over $GF(2^8)$. It is also observed that the correction of received message can be checked  by testing its divisibility by g(x), and there is no need to decode for the systematic encoding if the answer is affirmative. Otherwise, we denote $r(x)=c(x)+e(x)$ and suppose there are $ v(\leq s) $ errors</p><blockquote><p><strong>Syndrome based decoder:</strong>1.Calculate the $2s$ Syndromes: $S_{j}=r(\alpha<sup>{j})=e(\alpha</sup>{j})$ <br> 2. Solve$$ \begin{bmatrix}S_{1} &amp; S_{2}&amp; ... &amp; S_{v} \S_{2} &amp; S_{3} &amp; ...&amp;S_{v+1} \... &amp; ... &amp; ...&amp;... \S_{v} &amp; S_{v+1} &amp; ...&amp;S_{2v-1}\end{bmatrix} \begin{bmatrix}\Lambda_{v}\\Lambda_{v-1}\...\\Lambda_{1}\end{bmatrix}=\begin{bmatrix}-S_{v} \-S_{v+1}\...\-S_{2v}\tag{4}\end{bmatrix} $$ and use <a href="https://en.wikipedia.org/wiki/Chien_search" target="_blank" rel="noopener">Chien search</a> solve $\Lambda(x)=\Lambda_{v}x^{v} +\Lambda_{v-1}x^{v-1}+...+1=0$ to derive the $v$ roots, denoted as,$x_{1},..,x_{v}$. <br> 3. Use <a href="https://en.wikipedia.org/wiki/Forney_algorithm" target="_blank" rel="noopener">Forney algorithm</a> to solve$$ \begin{bmatrix}x_{1}^{-1} &amp; x_{2}^{-1}&amp; ... &amp; x_{v}^{-1} \x_{1}^{-2} &amp; x_{2}^{-2} &amp; ...&amp;x_{v}^{-2} \... &amp; ... &amp; ...&amp;... \x_{1}^{-2s} &amp; x_{2}^{-2s} &amp; ...&amp;x_{v}^{-2s}\end{bmatrix} \begin{bmatrix}e_{i_{1}}\e_{i_{2}}\...\e_{i_{v}}\end{bmatrix}=\begin{bmatrix}S_{1} \S_{2}\...\S_{2s}\tag{5}\end{bmatrix} $$  <br>4. The index $i_{j}$ of $e_{i_{j}}$ are determined by looking up the  logarithmic table as earlier mentioned <br> 5. Compute $e(x)=\sum_{j=1}<sup>{v}e_{i_{j}}x</sup>{i_{j}}$ and $c(x) = r(x)-e(x)$.</p></blockquote><p>It is worth mentioning that all the syndromes are zeros if $r(x)=c(x)$,  this can be used to check if the received message is corrupted or if the message was completely constructed.  RS encoding is relatively straightforward for the generator approach, but decoding needs complicated algebraic computation, especially for the step 2. Because the real value of $v$ is unknown and the normal way has to use the trial value  untill the matrix in $(4)$ is nonsingular.  Other algebraic methods for the evaluation of this error location polynomial $\Lambda(x)$ include  <a href="https://en.wikipedia.org/wiki/Berlekamp%E2%80%93Massey_algorithm" target="_blank" rel="noopener">Berlekamp–Massey algorithm</a> and <a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm" target="_blank" rel="noopener">Extended Euclidean algorithm</a>.This syndrome based decoder  can be implemented with different hardware unit such as matrix vector multiplication unit, remainder unit,  and performs <strong>hard-decision decoding</strong> up to $s$ errors. Hard-decision decoding decides the  bit according to the a threshold, where each bit is  definitely one or zero. While <strong>soft-decision decoding</strong>  requires additional reliability information to improve the decision, which has better coding gain for the white Guassian channel [2].</p><h3><span id="rs-code-in-distributed-storage-systems">RS Code in Distributed Storage Systems</span><a href="#rs-code-in-distributed-storage-systems" class="header-anchor">#</a></h3><p>The RS code are stored in different disks in the distributed storage systems, and the performance arasure code in distributed storage systems involves  disk I/O and repair bandwidth overhead.</p><h5><span id="5-1-rotated-reed-solomon-code">5.1 Rotated Reed-Solomon code</span><a href="#5-1-rotated-reed-solomon-code" class="header-anchor">#</a></h5><p>In the conventional RS code, all the parity blocds are encoded with data blocks in the same strip, while in the rotated reed-solomon code, parity blocks may be generated with different stripes as in the following figure,</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-1a81fb7850f88085.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="RRS code"></p><p>when the disk 5 in the figure fails, this method reduceS 3 operations of reading the data blocks than the conventional RS code [5].</p><h4><span id="local-reconstruction-code-lrc">Local Reconstruction Code (LRC)</span><a href="#local-reconstruction-code-lrc" class="header-anchor">#</a></h4><p>LRC introduces local parity codes which requires slightly more storage space than conventional RS code, but significantly reduce the number of participating data discs for encoding, thus it is beneficial to the reduction of bandwidth and disc I/O overhead.  The figure of pyramid code is shown as follows [6]</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-eb3e80741654047b.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Pyramid"></p><p>However, repair of the global redundancy still needs to access all data discs, another LRC approach in  [7] further introduces parity code ($ S_{3} $ in the figure) for the global parity codes ($P_{1}$,$P_{2}$,$P_{3}$,$P_{4}$)  to avoid this undesirable situation. By choosing the coefficients of $c_{1}^{'}$, $c_{2}^{'}$, $c_{3}^{'}$, $c_{4}^{'}$ and $c_{5}^{'}$, $c_{6}^{'}$ properly, the parity code of  $ S_{3} $ can be calculated by the existing parity codes $ S_{1} $ and $ S_{2} $. Thus parity code $ S_{3} $ does not have to occupy additional storage.</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-26576a62ea3ad8ca.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="HDFS-Xorbas"></p><blockquote><p><strong>Observation:</strong>  Copy is kind of LRC.</p></blockquote><h3><span id="references">References</span><a href="#references" class="header-anchor">#</a></h3><p>[1] I. Reed and G. Solomon, BPolynomial codes over certain finite fields,[ J. Soc. Ind. Appl. Math., vol. 8,<br>no. 2, pp. 300–304, Jun. 1960.[2] Wicker and Bhargava, Reed-Solomon Codes and Their Applications, 1994.[3] James S. Plank and Lihao Xu, Optimizing Cauchy Reed-Solomon Codes for Fault-Tolerant Network Storage Applications.[4] Reed–Solomon codes for coders.[5] Khan O, Burns R C, Plank J S, et al. Rethinking erasure codes for cloud file systems: minimizing I/O for recovery and degraded reads.[6] Huang Cheng, Chen Minghua, Li Jin. Pyramid codes: flexible schemes to trade space for access efficiency in reliable data storage systems.[7] Sathiamoorthy M, Asteris M, Papailiopoulos D, et al. Xoring elephants: novel erasure codes for big data.[8]  J. Blomer, M. Kalfane, R. Karp, M. Karpinski, M. Luby, and D. Zuckerman, An XOR-Based Erasure-Resilient Coding Scheme.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="RS Code" scheme="https://hejtao.netlify.com/tags/RS-Code/"/>
    
      <category term="Golang" scheme="https://hejtao.netlify.com/tags/Golang/"/>
    
      <category term="长文" scheme="https://hejtao.netlify.com/tags/%E9%95%BF%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Golang编程基础</title>
    <link href="https://hejtao.netlify.com/2018/08/20/2018-8-20/"/>
    <id>https://hejtao.netlify.com/2018/08/20/2018-8-20/</id>
    <published>2018-08-20T05:59:10.000Z</published>
    <updated>2019-11-11T19:59:33.203Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><div class="toc"><!-- toc --><ul><li><a href="#zai-ubuntu-an-zhuang">在Ubuntu安装:</a></li><li><a href="#shu-ju-lei-xing">数据类型:</a><ul><li><a href="#ji-ben-lei-xing">基本类型：</a></li><li><a href="#ju-ji-lei-xing-aggregate-types">聚集类型 (aggregate types)：</a><ul><li><a href="#shu-zu">数组</a></li><li><a href="#jie-gou">结构</a></li></ul></li><li><a href="#yin-yong-lei-xing">引用类型</a><ul><li><a href="#zhi-zhen">指针</a></li><li><a href="#qie-pian-slice">切片（slice）</a></li><li><a href="#zi-dian-map">字典（map）</a></li><li><a href="#han-shu">函数</a></li><li><a href="#tong-dao-channel">通道（channel）</a></li></ul></li><li><a href="#jie-kou-lei-xing-interface">接口类型（interface）：</a></li></ul></li><li><a href="#kong-zhi-liu-for-if-switch-defer-goto">控制流 （for if switch defer goto）：</a></li><li><a href="#chuang-jian-gong-cheng-mu-lu">创建工程目录：</a></li><li><a href="#tips">Tips:</a></li><li><a href="#qi-ta">其他：</a></li><li><a href="#can-kao-zi-liao">参考资料：</a></li></ul><!-- tocstop --></div><h3><span id="zai-ubuntu-an-zhuang">在Ubuntu安装:</span><a href="#zai-ubuntu-an-zhuang" class="header-anchor">#</a></h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">cd</span> ~ </span><br><span class="line">&gt;wget https://dl.google.com/go/go1.11.2.linux-amd64.tar.gz</span><br><span class="line">&gt;tar -C /usr/<span class="built_in">local</span> -xzf go1.11.2.linux-amd64.tar.gz    // 解压到得到的 go 目录，放到 /usr/<span class="built_in">local</span> 目录下</span><br><span class="line">&gt;vim .bashrc    // 写入以下内容</span><br><span class="line"><span class="built_in">export</span> GOPATH=~/hejtao/go_projects</span><br><span class="line"><span class="built_in">export</span> GOROOT=/usr/<span class="built_in">local</span>/go</span><br><span class="line"><span class="built_in">export</span> GOBIN=<span class="variable">$GOROOT</span>/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOBIN</span></span><br><span class="line">&gt;<span class="built_in">source</span> .bashrc</span><br></pre></td></tr></table></figure><h3><span id="shu-ju-lei-xing">数据类型:</span><a href="#shu-ju-lei-xing" class="header-anchor">#</a></h3><p><img src="https://upload-images.jianshu.io/upload_images/1863961-07626fa602c42064.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""></p><h4><span id="ji-ben-lei-xing">基本类型：</span><a href="#ji-ben-lei-xing" class="header-anchor">#</a></h4><ul><li>数值<ul><li>整型：<code>int</code>； <code>int8</code>； <code>int16</code>；  <code>int32</code>(<code>rune</code>，<code>Unicode</code>)；  <code>int64</code>； <code>uint</code>； <code>uint8</code>(<code>byte</code>)； <code>uint16</code>； <code>uint32</code>； <code>uint64</code>； <code>uintptr</code><code>int</code>, <code>uint</code>, <code>uintptr</code> 在 32 位系统上是 32 位，在 64位 系统上是 64位</li><li>浮点型：<code>float32</code>； <code>float64</code></li><li>复数型：<code>complex64</code>； <code>complex128</code></li></ul></li><li>字符串：使用双引号 <code>&quot;a&quot;</code></li><li>布尔: <code>true</code>； <code>false</code></li><li>常量：三种基本类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">  kb = <span class="number">1024</span></span><br><span class="line">  e = <span class="number">2.71828182845904523536028747135266249775724709369995957496696763</span></span><br><span class="line">  F = <span class="literal">false</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>if</code>语句中，若检验条件为<code>i &gt;= 0</code>，则<code>i</code> 的类型不宜为 <code>uint</code> 型（<code>uint</code> 数据始终 &gt;= 0）。尽管内置函数 <code>len()</code> 返回值是非负整数，但它际返回 <code>int</code> 型，</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">medals := []<span class="keyword">string</span>&#123;<span class="string">"gold"</span>, <span class="string">"silver"</span>, <span class="string">"bronze"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(medals)<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--&#123;</span><br><span class="line">  fmt.Println(medals[i]) <span class="comment">// "bronze", "silver", "gold"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本类型与操作符构成表达式</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-f1c19a4e5f60b7af.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt=""></p><ul><li>取余 <code>%</code> 只用于整型；余数与被除数符号相同，<code>5%3=2</code>； <code>-5%3=-2</code></li><li><code>5.0/4=1.25</code>；<code>5/4.0=1.25</code>；<code>5/4=1</code></li><li><code>&amp;&amp;</code> 若左边的表达式结果为 <code>false</code>，不检验右边的表达式；<code>&amp;</code> 始终检验两边的表达式</li><li>与或<code>^</code> ; 一元前缀<code>^</code></li></ul><h4><span id="ju-ji-lei-xing-aggregate-types">聚集类型 (aggregate types)：</span><a href="#ju-ji-lei-xing-aggregate-types" class="header-anchor">#</a></h4><h5><span id="shu-zu">数组</span><a href="#shu-zu" class="header-anchor">#</a></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">r := [...]<span class="keyword">int</span>&#123;<span class="number">99</span>: <span class="number">1</span>&#125;    <span class="comment">// 索引为99的元素，r[99]， 等于 1，其他默认 0</span></span><br><span class="line"></span><br><span class="line">p := <span class="built_in">new</span>([<span class="number">10</span>]<span class="keyword">int</span>)    <span class="comment">// 将生成的数组的指针赋给 p, 为 *[10]int 类型</span></span><br><span class="line">p[<span class="number">0</span>]=<span class="number">1</span>    <span class="comment">// 给 p 指向的数组的索引为0的元素赋值 1</span></span><br></pre></td></tr></table></figure><p>数组的长度也是数组类型的一部分，因此 <code>[3]int</code> 和 <code>[4]int</code> 是不同类型的数组，不能进行比较或赋值。</p><h5><span id="jie-gou">结构</span><a href="#jie-gou" class="header-anchor">#</a></h5><p>（1）结构的字段（field）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;      <span class="comment">// 定义 person 类型</span></span><br><span class="line">    gender <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    student := person&#123;&#125;</span><br><span class="line">    student.age = <span class="number">16</span></span><br><span class="line">    student.gender = <span class="string">"male"</span></span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    student := person&#123;</span><br><span class="line">       gender : <span class="string">"male"</span>, </span><br><span class="line">        age : <span class="number">16</span>,    <span class="comment">//逗号不能省</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    student := person&#123;<span class="string">"male"</span>, <span class="number">16</span>&#125;</span><br><span class="line"></span><br><span class="line">    teacher := &amp;person&#123;    <span class="comment">//取指针</span></span><br><span class="line">      gender : <span class="string">"female"</span>, </span><br><span class="line">       age : <span class="number">30</span>,    </span><br><span class="line">    &#125;</span><br><span class="line">    teacher.age = <span class="number">36</span>    <span class="comment">//指针 teacher 仍然可以进行点操作</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>指针也可以进行点操作。</p></blockquote><p>匿名结构，字段匿名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">student := <span class="keyword">struct</span>&#123;      <span class="comment">// 匿名结构</span></span><br><span class="line">    gender : <span class="keyword">string</span></span><br><span class="line">    age : <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">    gender : <span class="string">"male"</span>,</span><br><span class="line">    age : <span class="string">"17"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;      </span><br><span class="line">    <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照顺序初始化</span></span><br><span class="line">student := person&#123;<span class="string">"male"</span>, <span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure><p>结构嵌套，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;      </span><br><span class="line">    gender <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    parents <span class="keyword">struct</span>&#123;      <span class="comment">//  嵌套一个匿名结构</span></span><br><span class="line">        dad, mom : <span class="keyword">string</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span>&#123;</span><br><span class="line">    state, city <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person2 <span class="keyword">struct</span>&#123;      </span><br><span class="line">    gender <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    address    <span class="comment">// 嵌套你一个结构address</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    student := person&#123;gender : <span class="string">"female"</span>, age : <span class="number">10</span>&#125;</span><br><span class="line">    student.parents.dad = <span class="string">"Tom"</span></span><br><span class="line">    student.parents.mom = <span class="string">"Lily"</span>     </span><br><span class="line">    </span><br><span class="line">    student2 := person2&#123;gender:<span class="string">"female"</span>, age:<span class="number">10</span>, address : address&#123;county:<span class="string">"LA"</span> state:<span class="string">"California"</span>&#125;  &#125; </span><br><span class="line">    student2.address.state = <span class="string">"Massachusetts"</span>    <span class="comment">// or</span></span><br><span class="line">    student2.state = <span class="string">"Massachusetts"</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）结构的方法（method）函数与方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Distance</span>(<span class="params">p, q Point</span>) <span class="title">float64</span></span> &#123;<span class="comment">//函数</span></span><br><span class="line"><span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">p Point</span>) <span class="title">Distance</span>(<span class="params">q Point</span>) <span class="title">float64</span></span> &#123;<span class="comment">// 方法，在函数名前增加一个形参（receiver） 类似于Java的this 和python的 self，</span></span><br><span class="line"><span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)             <span class="comment">// 接收者的名称通常取它的类型名称的第一个字母</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line">fmt.Println(Distance(p, q))<span class="comment">// 打印 5， 调用函数</span></span><br><span class="line">fmt.Println(p.Distance(q))<span class="comment">// 调用方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要使用方法对值（value of type T，相对于方法来讲就是实参，argument） 的字段进行修改时，使用接收者为指针的方法或者叫指针方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">p *Point</span>) <span class="title">ScaleBy</span>(<span class="params">factor <span class="keyword">float64</span></span>)</span> &#123;      <span class="comment">// 接收者参数p的类型是指针类型</span></span><br><span class="line">    p.X *= factor      <span class="comment">// p在这里是指针，等价于 (*p).X</span></span><br><span class="line">    p.Y *= factor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同一个 struct 的方法和字段占据相同的命名空间（name space），因此两者的名称不能重复；指针方法看作高权限方法。</p></blockquote><p>对方法的调用, 值（实参） 和 接收者（形参）类型要相同</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;.Distance(q)     <span class="comment">// Point  Point</span></span><br><span class="line">pptr.ScaleBy(<span class="number">2</span>)       <span class="comment">// *Point  *Point</span></span><br><span class="line"></span><br><span class="line">pptr.Distance(q)     <span class="comment">// 隐含 (*pptr)</span></span><br><span class="line">p.ScaleBy(<span class="number">2</span>)     <span class="comment">// 隐含 (&amp;p)</span></span><br><span class="line"></span><br><span class="line">             Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;.ScaleBy(<span class="number">2</span>)    <span class="comment">//错误！！！</span></span><br><span class="line">(&amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;).ScaleBy(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>不仅仅是 <code>struct</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> INT <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">var</span> a INT</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">a.Print()    <span class="comment">// 打印 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">a *INT</span>) <span class="title">Print</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">*a = <span class="number">2</span></span><br><span class="line">fmt.Println(*a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>方法是与命名类型(named type)相关联的函数。</p></blockquote><h4><span id="yin-yong-lei-xing">引用类型</span><a href="#yin-yong-lei-xing" class="header-anchor">#</a></h4><h5><span id="zhi-zhen">指针</span><a href="#zhi-zhen" class="header-anchor">#</a></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">i := <span class="number">20</span></span><br><span class="line">p = &amp;i</span><br><span class="line">*p = <span class="number">10</span>    <span class="comment">// i 的值为 10</span></span><br></pre></td></tr></table></figure><h5><span id="qie-pian-slice">切片（slice）</span><a href="#qie-pian-slice" class="header-anchor">#</a></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span>    <span class="comment">// 声明切片 s</span></span><br><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">s = a[:<span class="number">2</span>]    <span class="comment">// [1, 2]， len(s)等于2，cap(s)等于5</span></span><br><span class="line">s = a[<span class="number">0</span>:<span class="number">1</span>]    <span class="comment">// [1]，len(s)等于1，cap(s)等于5</span></span><br><span class="line">s = a[<span class="number">3</span>:]    <span class="comment">// [4, 5]，len(s)等于2，cap(s)等于2</span></span><br><span class="line"></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">4</span>)    <span class="comment">//make([]type, len, cap) ，切片长度为2，底层数组的长度为4</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>)    <span class="comment">// s 的地址不变</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>)    <span class="comment">// 生成新的数组，地址改变，容量翻倍，也就是cap(s)等于4*2=8</span></span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(s1, s2)    <span class="comment">//把 s2 复制到 s1，s1 为 [4, 5, 3]</span></span><br><span class="line"></span><br><span class="line">s1 = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">copy</span>(s2, s1)    <span class="comment">// s2 为 [1, 2]</span></span><br></pre></td></tr></table></figure><blockquote><p>切片的本质是对底层数组的引用；切片的容量（cap）是切片的始索引到底层数组的末索引的长度。</p></blockquote><h5><span id="zi-dian-map">字典（map）</span><a href="#zi-dian-map" class="header-anchor">#</a></h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>    <span class="comment">// key int 型；value string 型</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">m[<span class="number">0</span>] = <span class="string">"OK"</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="number">0</span>)    <span class="comment">// 删除 m 中键为0的键值对</span></span><br></pre></td></tr></table></figure><p>嵌套，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)    <span class="comment">// value  map型</span></span><br><span class="line">m[<span class="number">1</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">m[<span class="number">1</span>][<span class="number">2</span>] = <span class="string">"YES"</span></span><br></pre></td></tr></table></figure><h5><span id="han-shu">函数</span><a href="#han-shu" class="header-anchor">#</a></h5><p><code>func main(int, []string) int</code>means， function main takes an int and a slice of strings and returns an int函数作为类型，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span>(<span class="params"><span class="keyword">func</span>(<span class="keyword">int</span>,<span class="keyword">int</span></span>) <span class="title">int</span>, <span class="title">int</span>) <span class="title">func</span>(<span class="params"><span class="keyword">int</span>, <span class="keyword">int</span></span>) <span class="title">int</span></span></span><br></pre></td></tr></table></figure><p>不定长变参，闭包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  var_args(<span class="number">1</span>)    </span><br><span class="line">  var_args(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)    </span><br><span class="line"></span><br><span class="line">  f := closure(<span class="number">10</span>)</span><br><span class="line">  fmt.Println(f(<span class="number">1</span>))   </span><br><span class="line">  fmt.Println(f(<span class="number">2</span>))    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">var_args</span>(<span class="params">args ...<span class="keyword">int</span></span>)</span>&#123;</span><br><span class="line">  fmt.Println(args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closure</span>(<span class="params">x <span class="keyword">int</span></span>) <span class="title">func</span>(<span class="params"><span class="keyword">int</span></span>) <span class="title">int</span></span>&#123;    <span class="comment">// 返回匿名函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">func</span>(<span class="params">y <span class="keyword">int</span></span>) <span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h5><span id="tong-dao-channel">通道（channel）</span><a href="#tong-dao-channel" class="header-anchor">#</a></h5><p>channel 是 goroutine 沟通的桥梁，通过 make 创建，close 关闭</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"I from goroutine !"</span>)</span><br><span class="line">c &lt;- <span class="literal">true</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;-c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>channel 作为函数形参</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> Hello(c)</span><br><span class="line"></span><br><span class="line">&lt;-c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span>(<span class="params">c <span class="keyword">chan</span> <span class="keyword">bool</span></span>)</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello, I from goroutine!"</span>)</span><br><span class="line">c &lt;- <span class="literal">true</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个 goroutine，多个channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(runtime.NumCPU())    <span class="comment">// 开启多核</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;    <span class="comment">// 启动多个 goroutin</span></span><br><span class="line"><span class="keyword">go</span> Decomposition(c, i, <span class="number">100000007</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;    <span class="comment">// 多个 channel 阻塞</span></span><br><span class="line">&lt;-c</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decomposition</span>(<span class="params">c <span class="keyword">chan</span> <span class="keyword">bool</span>, index <span class="keyword">int</span>, n <span class="keyword">int</span></span>)</span> &#123;    <span class="comment">// 质数分解</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> n != i &#123;</span><br><span class="line"><span class="keyword">if</span> n%i == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d*"</span>, i)</span><br><span class="line">n = n / i</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%d: %d\n"</span>, index, n)</span><br><span class="line"></span><br><span class="line">c &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：   </span><br><span class="line"><span class="number">0</span>: <span class="number">100000007</span></span><br><span class="line"><span class="number">2</span>: <span class="number">100000007</span></span><br><span class="line"><span class="number">1</span>: <span class="number">100000007</span></span><br><span class="line"><span class="number">4</span>: <span class="number">100000007</span></span><br><span class="line"><span class="number">3</span>: <span class="number">100000007</span></span><br><span class="line">从输出结果的顺序可以看出 goroutine 并非先启动先执行</span><br></pre></td></tr></table></figure><p>使用同步包来代替 channel</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">5</span>)    <span class="comment">//  添加 5 个 任务（goroutine）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> Decomposition(&amp;wg, i, <span class="number">100000007</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()    <span class="comment">// 等到任务数减到 0 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decomposition</span>(<span class="params">wg *sync.WaitGroup, m <span class="keyword">int</span>, n <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> n != i &#123;</span><br><span class="line"><span class="keyword">if</span> n%i == <span class="number">0</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%d*"</span>, i)</span><br><span class="line">n = n / i</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%d: %d\n"</span>, m, n)</span><br><span class="line"></span><br><span class="line">wg.Done()    <span class="comment">// 任务数减 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">0</span>: <span class="number">100000007</span></span><br><span class="line"><span class="number">2</span>: <span class="number">100000007</span></span><br><span class="line"><span class="number">4</span>: <span class="number">100000007</span></span><br><span class="line"><span class="number">1</span>: <span class="number">100000007</span></span><br><span class="line"><span class="number">3</span>: <span class="number">100000007</span></span><br></pre></td></tr></table></figure><p><code>selec{}</code>语句，如果有多个case 读取数据，select会随机选择一个case执行，其他不执行；如果没有case读取数据，就执行default；如果没有case读取数据，且没有default，select将阻塞，直到某个case可以执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">c1, c2, block := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;    <span class="comment">// 按随机顺序处理多个 case</span></span><br><span class="line"><span class="keyword">case</span> message, open := &lt;-c1:</span><br><span class="line"><span class="keyword">if</span> !open &#123;    <span class="comment">// 如果通道 c1 关闭，则跳出无限循环</span></span><br><span class="line">block &lt;- <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"A message from main by c1:"</span>, message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> message, open := &lt;-c2:</span><br><span class="line"><span class="keyword">if</span> !open &#123;    <span class="comment">// 如果通道 c2 关闭，则跳出无限循环</span></span><br><span class="line">block &lt;- <span class="literal">true</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"A message from main by c2:"</span>, message)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">c1 &lt;- <span class="number">10</span></span><br><span class="line">c2 &lt;- <span class="string">"hello"</span></span><br><span class="line">c1 &lt;- <span class="number">20</span></span><br><span class="line">c2 &lt;- <span class="string">"world"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(c1)    <span class="comment">// 关闭通道 c1</span></span><br><span class="line"></span><br><span class="line">&lt;-block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">A message from main by c1: <span class="number">10</span></span><br><span class="line">A message from main by c2: hello</span><br><span class="line">A message from main by c1: <span class="number">20</span></span><br><span class="line">A message from main by c2: world</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">2000000</span> * time.Microsecond):</span><br><span class="line">fmt.Println(<span class="string">"2 seconds"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1999999</span> * time.Microsecond):</span><br><span class="line">fmt.Println(<span class="string">"1.999999 seconds"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1.999999</span> seconds</span><br></pre></td></tr></table></figure><h4><span id="jie-kou-lei-xing-interface">接口类型（interface）：</span><a href="#jie-kou-lei-xing-interface" class="header-anchor">#</a></h4><p>（1）接口代表某些方法的集合</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> game <span class="keyword">interface</span> &#123;</span><br><span class="line">Strike_of_Kings() <span class="keyword">int</span></span><br><span class="line">Battle_Grounds() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> contact <span class="keyword">interface</span> &#123;</span><br><span class="line">Wechat()</span><br><span class="line">QQ()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> smartphone <span class="keyword">interface</span>&#123;    <span class="comment">// 接口嵌套，</span></span><br><span class="line">    game</span><br><span class="line">    contact</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iphone <span class="keyword">struct</span> &#123;    </span><br><span class="line">version <span class="keyword">string</span></span><br><span class="line">price   <span class="keyword">float32</span></span><br><span class="line">user    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">iph iphone</span>) <span class="title">Wechat</span>(<span class="params"></span>)</span> &#123;    </span><br><span class="line">fmt.Println(<span class="string">"I installed wechat on my iphone"</span>, iph.version)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">iph *iphone</span>) <span class="title">QQ</span>(<span class="params"></span>)</span> &#123;    </span><br><span class="line">fmt.Println(<span class="string">"I installed wechat on my iphone"</span>, iph.version)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// iphone 不满足 contact 接口</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">iph iphone</span>) <span class="title">Battle_Grounds</span>(<span class="params"></span>) <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"There are 4 teammates at most in the Battle Grounds."</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">iph iphone</span>) <span class="title">Strike_of_Kings</span>(<span class="params"></span>) <span class="title">int</span></span> &#123;    </span><br><span class="line">fmt.Println(<span class="string">"There are 5 teammates at most in the Strike of Kings."</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// iphone 满足 game 接口</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">iph *iphone</span>) <span class="title">New_Version</span>(<span class="params">version <span class="keyword">string</span></span>)</span> &#123;</span><br><span class="line">iph.version = version</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">all_round_game</span>(<span class="params">game</span>)</span> &#123;      <span class="comment">// 接口作为形参</span></span><br><span class="line">fmt.Println(<span class="string">"Both Strike of_Kings and Battle Grounds have installed."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">my_phone := iphone&#123;<span class="string">"X"</span>, <span class="number">8316</span>, <span class="string">"Xiaohe"</span>&#125;</span><br><span class="line">my_phone.Wechat()</span><br><span class="line">    fmt.Println(my_phone.Battle_Grounds())</span><br><span class="line"></span><br><span class="line">all_round_game(my_phone)    <span class="comment">// my_phone 符合 game 接口，可作为该函数的实参</span></span><br><span class="line"><span class="keyword">var</span> _ game = iphone   <span class="comment">// 确保 iphone 实现了接口game </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）任何类型都满足空接口；空接口<code>interface{}</code>作为形参可以接受任何类型的实参</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">m[<span class="number">1</span>] = <span class="string">"a"</span></span><br><span class="line">m[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">m[<span class="number">3</span>] = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">print_map(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print_map</span>(<span class="params">m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">interface</span>&#123;&#125;</span>)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(k, <span class="string">":"</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span> : a</span><br><span class="line"><span class="number">2</span> : <span class="number">2</span></span><br><span class="line"><span class="number">3</span> : <span class="literal">false</span></span><br></pre></td></tr></table></figure><blockquote><p><code>[]string</code> 和 <code>[]interface{}</code> 是不同的类型；接口是一种抽象类型，可理解为是将所有具体类型按照方法集进行再分类；指针方法集包含非指针方法集。</p></blockquote><p>（3）接口值（interface value）包含 类型 （接口的动态类型）和 类型值 （接口的动态值） 两个部分，仅当两者均为<code>nil</code> 时，接口才为<code>nil</code><img src="https://upload-images.jianshu.io/upload_images/1863961-48d541dd9a4ab443.JPG?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="The zero value for an interface has both its type and value components set to nil">（4）反射 （reflection）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> iphone <span class="keyword">struct</span> &#123;</span><br><span class="line">version <span class="keyword">string</span></span><br><span class="line">price   <span class="keyword">int</span></span><br><span class="line">user    <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> (<span class="params">iph iphone</span>) <span class="title">Wechat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"I installed wechat on my iphone"</span>, iph.version)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">my_phone := iphone&#123;<span class="string">"X"</span>, <span class="number">8316</span>, <span class="string">"Xiaohe"</span>&#125;</span><br><span class="line">Info(my_phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Info</span>(<span class="params">itf <span class="keyword">interface</span>&#123;&#125;</span>)</span> &#123;</span><br><span class="line">t := reflect.TypeOf(itf)</span><br><span class="line">fmt.Println(t)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">fmt.Println(t.Field(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"___________________"</span>)</span><br><span class="line"></span><br><span class="line">v := reflect.ValueOf(itf)</span><br><span class="line">fmt.Println(v)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumField(); i++ &#123;</span><br><span class="line">fmt.Println(v.Field(i))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">main.iphone</span><br><span class="line">&#123;version main <span class="keyword">string</span>  <span class="number">0</span> [<span class="number">0</span>] <span class="literal">false</span>&#125;</span><br><span class="line">&#123;price main <span class="keyword">int</span>  <span class="number">16</span> [<span class="number">1</span>] <span class="literal">false</span>&#125;</span><br><span class="line">&#123;user main <span class="keyword">string</span>  <span class="number">24</span> [<span class="number">2</span>] <span class="literal">false</span>&#125;</span><br><span class="line">___________________</span><br><span class="line">&#123;X <span class="number">8316</span> Xiaohe&#125;</span><br><span class="line">X</span><br><span class="line"><span class="number">8316</span></span><br><span class="line">Xiaohe</span><br></pre></td></tr></table></figure><h3><span id="kong-zhi-liu-for-if-switch-defer-goto">控制流 （for if switch defer goto）：</span><a href="#kong-zhi-liu-for-if-switch-defer-goto" class="header-anchor">#</a></h3><p>（1）<code>for</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (inti statement)；condition；(post statement) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> ; i &lt; <span class="number">10</span>; &#123;    <span class="comment">// 去掉分号</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span>&#123;    <span class="comment">// while 语句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>&#123;    <span class="comment">// 无限循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）<code>if</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (init statement)；condition &#123;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (init statement)；condition &#123;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）<code>switch</code>：</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (init statement)；some value &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>：</span><br><span class="line">    <span class="keyword">case</span> f()：</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>：</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> 布尔表达式<span class="number">1</span>：</span><br><span class="line">    <span class="keyword">case</span> 布尔表达式<span class="number">2</span>：</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>：</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦符合条件自动终止，若希望继续检验下面的case，使用 <code>fallthrough</code> 语句。（4）<code>defer</code>：</p><ul><li>defer 后必须跟函数引用</li><li>defer 语句被检验后，延迟函数获得变量的拷贝</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;    <span class="comment">// defer 语句打印0</span></span><br></pre></td></tr></table></figure><ul><li>defer 语句被检验后，延迟匿名函数获得变量的地址</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span>(<span class="params"></span>) (<span class="params">i <span class="keyword">int</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123; i++ &#125;()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>    <span class="comment">// 将1 赋给 i</span></span><br><span class="line">&#125;    <span class="comment">// 返回 2。利用 defer 语句修改外围函数的命名返回值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">c</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        fmt.Print(i)</span><br><span class="line">  &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;  <span class="comment">// 打印 333</span></span><br></pre></td></tr></table></figure><ul><li>defer 语句被检验后，延迟函数的引用被推入堆栈，当外围函数返回后，按照后进先出的顺序被调用（即使外围函数发生错误，如 panic，延迟函数仍然会被调用）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">d</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> fmt.Print(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    <span class="comment">// 打印 3210</span></span><br></pre></td></tr></table></figure><p>更多细节如，<code>panic</code>， <code>recover</code>（只能用在延迟函数中） 参考 <a href="https://blog.golang.org/defer-panic-and-recover" target="_blank" rel="noopener">defer blog</a>。</p><p>（5）<code>goto</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">LABEL:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">break</span> LABEL    <span class="comment">// 跳出与LABEL同级的循环，即跳出无限循环</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LABEL:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> LABEL</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LABEL:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> LABEL    <span class="comment">// 将再次进入无限循环</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通常<code>标签</code>放到 <code>goto</code> 的后面。</p></blockquote><h3><span id="chuang-jian-gong-cheng-mu-lu">创建工程目录：</span><a href="#chuang-jian-gong-cheng-mu-lu" class="header-anchor">#</a></h3><p>Go工程中共有三个部分：</p><ul><li>src：存放go源码文件</li><li>pkg：存放编译后的包文件</li><li>bin：存放编译后的可执行文件</li></ul><blockquote><p>**注意：**src目录需要自己创建，pkg和bin编译时会自动创建。</p></blockquote><p>步骤：</p><ol><li>新建工程目录，my_project，并在该目录下创建 src目录；</li><li>把my_project 添加到 GOPATH，GOPATH=/home/user/...;my_project（可以同时添加多个路径目录，Linux下用冒号:隔开，window下分号;隔开）;</li><li>在 src 下创建my_pkg 和 my_cmd;</li><li>包文件放入到 my_pkg 中，比如 test.go</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> my_pkg</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  fmt.Println(<span class="string">"Hello,world!"</span>)</span><br><span class="line">  fmt.Println(<span class="string">"You used a function defined in my_package!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在命令行src目录，执行 <code>go install my_pkg</code> 将创建 pkg 目录并声成 my_pkg.a 文件。</p><ol start="5"><li>my_cmd 中放入 package main，比如 hello_world.go</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">  <span class="string">"my_pkg"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  my_pkg.Test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在命令行src目录，执行 <code>go install my_cmd</code> 将创建 bin 目录并生成可执行文件成 hello_world.exe 文件。</p><blockquote><p>目录结构：src/$\quad$ my_pkg/$\qquad$ test.go$\quad$ my_cmd/$\qquad$ hello_world.go</p></blockquote><h3><span id="tips">Tips:</span><a href="#tips" class="header-anchor">#</a></h3><p>import 包A的时候，会自动调用包A的init()函数（i字母小写）。如果该包A又import了别的包B，会优先调用包B的init()函数，最后才调用main包的init()函数。一个包的init()函数可以定义多个，每个都会被调用，调用的顺序按文件名排序。同一个文件也可以定义多个init函数。</p><h3><span id="qi-ta">其他：</span><a href="#qi-ta" class="header-anchor">#</a></h3><ul><li><code>fmt.printf</code> verbs：<code>%x %b</code>：16进制，2进制显示；<code>%t</code>：显示 bool 结果；<code>%T</code>：显示值的类型；<code>%v</code>：显示值；<code>%p</code>：显示地址；<code>\n</code>：换行</li><li>Sublime text 3上一个编辑处: alt+-下一个编辑处: alt+shift+-</li><li>GoSublime：GoSublime快捷键列表：ctrl+.+. (连击 .)查看声明：ctrl+.+h代码跳转：ctrl+shift+左键package control：ctrl+shift+p</li><li>Goland：退回上一次光标位置：ctrl+win+alt+左键</li></ul><h3><span id="can-kao-zi-liao">参考资料：</span><a href="#can-kao-zi-liao" class="header-anchor">#</a></h3><p>[1] 无闻;<a href="https://study.163.com/course/introduction.htm?courseId=306002" target="_blank" rel="noopener">Go编程基础系列视频</a>.[2] Alan A.A. Donovan; Brain W. Kernighan; The Go Programming Language; 2015.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://hejtao.netlify.com/tags/Golang/"/>
    
      <category term="长文" scheme="https://hejtao.netlify.com/tags/%E9%95%BF%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>本地项目上传到 Github 仓库、Git开发命令</title>
    <link href="https://hejtao.netlify.com/2018/07/04/2018-7-4/"/>
    <id>https://hejtao.netlify.com/2018/07/04/2018-7-4/</id>
    <published>2018-07-04T11:35:11.000Z</published>
    <updated>2020-03-11T13:47:05.878Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><div class="toc"><!-- toc --><ul><li><a href="#sheng-cheng-ben-di-ban-ben-ku-git-wen-jian-jia">生成本地版本库 （.git 文件夹）</a></li><li><a href="#chuang-jian-ssh-key">创建 SSH key</a></li><li><a href="#chuang-jian-github-cang-ku">创建 GitHub 仓库</a></li><li><a href="#shang-chuan-dao-github-cang-ku">上传到 GitHub 仓库</a></li><li><a href="#ben-di-xiu-gai-gen-xin-dao-github-cang-ku">本地修改跟新到 GitHub 仓库</a></li></ul><!-- tocstop --></div><h3><span id="sheng-cheng-ben-di-ban-ben-ku-git-wen-jian-jia">生成本地版本库 （.git 文件夹）</span><a href="#sheng-cheng-ben-di-ban-ben-ku-git-wen-jian-jia" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"..."</span></span><br></pre></td></tr></table></figure><p>操作如下，<br><img src="https://upload-images.jianshu.io/upload_images/1863961-32ad650b5e4944d8.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/650" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-4716f9712379e68f.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/650" alt=""></p><h3><span id="chuang-jian-ssh-key">创建 SSH key</span><a href="#chuang-jian-ssh-key" class="header-anchor">#</a></h3><ul><li>查看 c盘 用户目录是否包含 .ssh 目录。如果包含，打开 id_rsa.pub 文件并复制里面的内容（密钥）<br><img src="https://upload-images.jianshu.io/upload_images/1863961-645677c3a3ec906e.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/650" alt=""><br></li><li>如果不包含 .ssh 目录（上述操作会报错），通过如下命令创建</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"your email address"</span></span><br></pre></td></tr></table></figure><p>其中 C 为大写。然后按照前面的方式复制密钥。</p><ul><li>将密钥添加到 GitHub<br><img src="https://upload-images.jianshu.io/upload_images/1863961-fd4c50b7021715b1.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/650" alt=" "><br><img src="https://upload-images.jianshu.io/upload_images/1863961-fe525f53b369e5cb.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/650" alt=" "><br><img src="https://upload-images.jianshu.io/upload_images/1863961-a77e329b14352980.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/650" alt=" "></li></ul><h3><span id="chuang-jian-github-cang-ku">创建 GitHub 仓库</span><a href="#chuang-jian-github-cang-ku" class="header-anchor">#</a></h3><br>![](https://upload-images.jianshu.io/upload_images/1863961-d05408b0cfc2e198.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/650)<br>![](https://upload-images.jianshu.io/upload_images/1863961-f7edb952c890e069.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/650)<h3><span id="shang-chuan-dao-github-cang-ku">上传到 GitHub 仓库</span><a href="#shang-chuan-dao-github-cang-ku" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:jiangtaohe/test.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1863961-8e43cefe8d940184.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/650" alt=""></p><h3><span id="ben-di-xiu-gai-gen-xin-dao-github-cang-ku">本地修改跟新到 GitHub 仓库</span><a href="#ben-di-xiu-gai-gen-xin-dao-github-cang-ku" class="header-anchor">#</a></h3><p>若本地已经关联到仓库，git remote add origin 命令行去掉。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:jiangtaohe/test.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"..."</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add file</span><br></pre></td></tr></table></figure><p>file的修改添加到暂存区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit file -m <span class="string">"备注信息"</span></span><br></pre></td></tr></table></figure><p>创建新的版本库，并将file在暂存区中的修改添加到新的版本库中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>将工作区和暂存区的修改装箱后回到版本库初始状态(相当于撤销所有修改)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p>将 <code>git stash</code>装箱的修改倒出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></table></figure><p>撤销file工作区的修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout --ours (--theirs) file</span><br><span class="line">git add file</span><br></pre></td></tr></table></figure><p>file发生merge冲突时，完全采取本方(他方)的修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin dev:local_dev</span><br></pre></td></tr></table></figure><p>获取远程分支dev的代码，并在本地创建本地分支local_dev</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin dev</span><br></pre></td></tr></table></figure><p>拉取远程分支dev与当前分支和并(merge)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id(前4位数)</span><br></pre></td></tr></table></figure><p>切换到某个版本库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch branch_name</span><br></pre></td></tr></table></figure><p>新建分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d branch_name</span><br></pre></td></tr></table></figure><p>删除分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge branch_name</span><br></pre></td></tr></table></figure><p>合并分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>打印远程仓库名称和地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">set</span>-url --add origin git@gitlab.com:jiangtaohe/test.git</span><br></pre></td></tr></table></figure><p>增加一个远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached a.txt</span><br></pre></td></tr></table></figure><p>git不再跟踪a.txt, 但文件仍保留</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -f a.txt</span><br></pre></td></tr></table></figure><p>git不再跟踪a.txt, 同时文件被删除</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Git" scheme="https://hejtao.netlify.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>阅历</title>
    <link href="https://hejtao.netlify.com/2018/07/01/2018-7-1/"/>
    <id>https://hejtao.netlify.com/2018/07/01/2018-7-1/</id>
    <published>2018-07-01T05:54:12.000Z</published>
    <updated>2019-11-11T19:59:33.203Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><p>有时人的成长在不知不觉中发生，且不论是生理上的还是心智上的。比如人的身高的变化，对于旁人看来是很大的改变，但对于当事人可能是相当无感的（除非你刻意的去测量，并画出折线图来，很少人会这么做吧）。与前者相比，心智的 变化更加隐蔽，你甚至都不好记录数据作出图表来，但并非一无所知，有些是可以从生活中窥见端倪。<br>少年时期的我非常讨厌吃苦瓜。你可能已经脑补出我第一次吃苦瓜时候的表情了。</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-957f2582e5306a85.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>“是人吃的吗？”，当然没有说出口，但我当时就那么想的。让我惊奇的是母亲竟吃得津津有味 (＃°Д°)  好像我吃了一口假的苦瓜。转念一想，既然这玩意儿都叫苦瓜了，那是必苦无疑了。那时的我品不来苦瓜的味道，自然理解不了母亲的有滋有味了。后来偶尔遇到苦瓜也会吃上一小片，“浅尝辄止”，毕竟还是那个味儿啊，干嘛亏待自己。直到上了大学后才有了改变。<br>话说我在大学吃了几年食堂，喜欢吃的都吃得腻了。某天心血来潮，要不来盘炒苦瓜吧。我突然发现这玩意儿不那么苦了，甚至感到别有一番风味。原以为跟苦瓜品种有关，所以后来回外婆家时，我特意让外婆做了道炒苦瓜，吃起来也是不那么苦。我意识到“物是人已非”，苦瓜还是年少时的苦瓜，而我却不一样了。这种变化当然有生理上的，但更多的是心智上的，而后者是自己的阅历在不断增长的结果。有些事情阅历够了自然就会了。</p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-9b10c729b2816844.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="坂东玉三郎在《牡丹亭》中扮演的杜丽娘"></p><br>类似的还有对戏曲的理解。以前的我根本就看不了戏曲的，无感啊。随着年龄的增长，我对戏曲的态度也发生改变，虽然谈不上热爱，但多少也能品到其中的一些韵味。尤其是京剧，不愧为国粹，尽管没看过一个完整的剧目，也叫不出多少剧目的名字来，当我被表演者的一颦一簇、一唱一打所牵动的时候，我知道那就是好的戏曲，了不起的艺术！]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="随想" scheme="https://hejtao.netlify.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>独憩</title>
    <link href="https://hejtao.netlify.com/2018/06/19/2018-6-19/"/>
    <id>https://hejtao.netlify.com/2018/06/19/2018-6-19/</id>
    <published>2018-06-19T15:23:51.000Z</published>
    <updated>2019-11-11T19:59:33.202Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><p>有时候我真地喜欢安静，独自一人，不被打扰，做一些没有意义的事情。<br></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-e2c1ff0d4ed6d93e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""><br></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-f7690317383e9115.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""><br></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-62efa82f3f0a7690.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""><br></p><p><img src="https://upload-images.jianshu.io/upload_images/1863961-8db994a2183f0427.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt=""><br></p><p>当下简单地唯水，笔，布而已。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="书法" scheme="https://hejtao.netlify.com/tags/%E4%B9%A6%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>运动与冥想</title>
    <link href="https://hejtao.netlify.com/2018/06/14/2018-6-14/"/>
    <id>https://hejtao.netlify.com/2018/06/14/2018-6-14/</id>
    <published>2018-06-14T12:56:23.000Z</published>
    <updated>2019-11-11T19:59:33.202Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><p>近来又把跑步纳入日常。跑着跑着，跑出了一点心得，今以记之，算是对自己坚持锻炼的勉励。<br>一开始，我是跟着小伙伴一起跑来着，然后有几次自己跑。回想运动时候的状态，我发现自己跑运动地更充分，锻炼的效果也更好。据说跑步半个小时是一种很好的锻炼方式，前提是要保质保量。保质就要求全程保持在跑的状态，你可以跑快点或者慢点，但不要是 walking 。保量就是最少跑半个小时，当然你也可以按照路程（多少圈跑道）来计。值得注意的是，这个保质保量因人而异，你需要给自己设立合理的目标且不能够轻易就可达成。<br>专注于跑步有利于目标的达成。这也解释了为什么独自跑步的效果更好（与小伙伴相互鼓励当然也挺好），因为不用刻意去协调别人，你可以更快找到自己的节奏。当你持续地专注于自己的身体和感觉时，你可以体会到控制与活力，而维持标准动作可以加深这种体会。因此，不妨把跑步看作一次冥想训练，专注于自我，体会积极的力量也接受脑涨腿乏感觉，但不要让疲劳占据上风，否则你将动作变形，愈感举步维艰。<br>避免外部干扰因素有助于专注，比如握着手机，携带狗狗等尽量避免。<br>最后需要强调的是注意安全。当身体出现不适的时候，千万不要勉强。前两些天就有公众号报道某男子跑步过程中摔倒了两次仍要坚持，最终导致猝亡的杯具。还有上文提到独自运动有助于专注，但还是避免去人少的地方活动，尤其是女同学。学校的操场是绝佳的场所，因为有其他的同学还可以减少孤独感，对自己的坚持是很有帮助的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="随想" scheme="https://hejtao.netlify.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>多宝塔碑精选</title>
    <link href="https://hejtao.netlify.com/2018/06/10/2018-6-10/"/>
    <id>https://hejtao.netlify.com/2018/06/10/2018-6-10/</id>
    <published>2018-06-09T16:00:00.000Z</published>
    <updated>2019-11-11T19:59:33.202Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><meta name="referrer" content="no-referrer"><p>《多宝塔碑》精选三十七字。来源于搜狐“书法思考”，今藏以时习之。</p><h4><span id="heng-shu-san-wang-shi-ban-zhong">横、竖：(三、王、十、半、中)</span><a href="#heng-shu-san-wang-shi-ban-zhong" class="header-anchor">#</a></h4><p><img src="https://upload-images.jianshu.io/upload_images/1863961-fd42718c0a299083.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-4c1effead6120728.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-336f4dd557020eb4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-628d5d654e373a56.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-288f14358d1a4c63.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br></p><h4><span id="pie-na-da-shou-you-nian-ru">撇、捺：(大、手、又、年、入)</span><a href="#pie-na-da-shou-you-nian-ru" class="header-anchor">#</a></h4><p><img src="https://upload-images.jianshu.io/upload_images/1863961-a30469c7962a5558.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-107def9ce572f49a.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-ee8c1121fa3f592b.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-cdaa9fd9128afb46.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-c1785e6ab500cc9e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br></p><h4><span id="dian-xin-han-fu-bing-shang-xiao-yu-qi-gan">点：(心、涵、浮、并、尚、小、於、其、感)</span><a href="#dian-xin-han-fu-bing-shang-xiao-yu-qi-gan" class="header-anchor">#</a></h4><p><img src="https://upload-images.jianshu.io/upload_images/1863961-6b5a2f643c434662.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-eebc76a56376dacf.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-56845155b67f1729.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-15395e032a580d63.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-bce55f1474f1d73d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-5322fe5638885601.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-f1aec2afb515c077.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-abf0ee92c1c18314.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-9d81be126c2247be.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br></p><h4><span id="gou-tiao-zong-qiu-guan-biao-jian-xian-shi-yi">钩、挑：(宗、求、观、表、见、咸、食、以)</span><a href="#gou-tiao-zong-qiu-guan-biao-jian-xian-shi-yi" class="header-anchor">#</a></h4><p><img src="https://upload-images.jianshu.io/upload_images/1863961-07b36ef484f1cf16.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-a59190a6d0f9d9e7.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-24038d4638101588.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-7953ea4a4189c4b0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-32b6e4330997a09d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-3b809c47ed74ceca.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-e7b453d37c1e69c2.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-994e4901b7bc2c56.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br></p><h4><span id="zhe-zi-ming-liao-shan-ya-yi-mu-wai-nu">折：(自、名、了、山、牙、矣、母、外、女)</span><a href="#zhe-zi-ming-liao-shan-ya-yi-mu-wai-nu" class="header-anchor">#</a></h4><p><img src="https://upload-images.jianshu.io/upload_images/1863961-90bc923c63fe4459.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-43b34a046df0e9dd.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-94f5fe9db9983d3a.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-fddb276bcc8db19a.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-22d5c7ed19c5bd93.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-888cc4c4373cd182.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-811cc6bb2382e9b7.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-d6760cf1ac098d38.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1863961-5ab612b0240ea685.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="书法" scheme="https://hejtao.netlify.com/tags/%E4%B9%A6%E6%B3%95/"/>
    
  </entry>
  
</feed>
